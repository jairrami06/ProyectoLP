Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AS
    ASSERT
    ASYNC
    AWAIT
    BREAK
    CASE
    CATCH
    CLASS
    CONTINUE
    COVARIANT
    DEFAULT
    DEFERRED
    DO
    DOLLARSIGN
    DOUBLE_COLON
    ENUM
    EXPORT
    EXTENDS
    EXTENSION
    EXTERNAL
    FACTORY
    FINALLY
    FUNCTION
    GET
    HIDE
    IMPLEMENTS
    IMPORT
    INTERFACE
    IS
    LATE
    LIBRARY
    MIXIN
    MODULE
    NEW
    NULL
    NUM
    NUMERAL
    OBJECT
    ON
    OPERATOR
    PART
    RETHROW
    SET
    SHOW
    STATIC
    SUPER
    SWITCH
    SYNC
    THROW
    TRY
    TYPEDEF
    WITH
    YIELD

Grammar

Rule 0     S' -> program
Rule 1     program -> statement_list
Rule 2     statement_list -> statement
Rule 3     statement_list -> statement_list statement
Rule 4     statement -> print
Rule 5     statement -> data_input
Rule 6     statement -> set
Rule 7     statement -> map
Rule 8     statement -> constructor
Rule 9     statement -> control_structures
Rule 10    statement -> function
Rule 11    statement -> list_definition
Rule 12    statement -> variable_definition
Rule 13    statement -> variable_usage
Rule 14    statement -> call_function
Rule 15    statement -> return
Rule 16    statement -> COMMENT_MULTI
Rule 17    statement -> COMMENT_SINGLE
Rule 18    statement -> SEMICOLON
Rule 19    return -> RETURN expression SEMICOLON
Rule 20    control_structures -> control_structures_if_else
Rule 21    control_structures -> control_structures_for
Rule 22    control_structures -> control_structures_while
Rule 23    variable_usage -> ID SEMICOLON
Rule 24    variable_usage -> ID ASSIGN value SEMICOLON
Rule 25    call_function -> ID LPAREN argument_list RPAREN
Rule 26    call_function -> ID LPAREN RPAREN
Rule 27    data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
Rule 28    data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
Rule 29    length -> call_list DOT LENGTH
Rule 30    length -> TEXT DOT LENGTH
Rule 31    length -> ID DOT LENGTH
Rule 32    argument_list -> expression
Rule 33    argument_list -> argument_list COMMA expression
Rule 34    function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
Rule 35    function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
Rule 36    function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
Rule 37    function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
Rule 38    function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET
Rule 39    function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
Rule 40    variable_definition -> type ID ASSIGN expression SEMICOLON
Rule 41    variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON
Rule 42    variable_definition -> VAR ID ASSIGN expression SEMICOLON
Rule 43    print -> PRINT LPAREN RPAREN SEMICOLON
Rule 44    print -> PRINT LPAREN print_options RPAREN SEMICOLON
Rule 45    print_options -> expression
Rule 46    print_options -> length
Rule 47    print_options -> call_function
Rule 48    expression -> operations
Rule 49    operations -> operation
Rule 50    operations -> operation operand operations
Rule 51    operation -> operand operator operand
Rule 52    operand -> NUMBER
Rule 53    operand -> DOUBLE
Rule 54    operator -> PLUS
Rule 55    operator -> MINUS
Rule 56    operator -> TIMES
Rule 57    operator -> DIVIDE
Rule 58    expression -> conditions
Rule 59    expression -> value
Rule 60    control_structures_if_else -> if_block
Rule 61    control_structures_if_else -> if_block else_if_blocks
Rule 62    control_structures_if_else -> if_block else_if_blocks else_block
Rule 63    control_structures_if_else -> if_block else_block
Rule 64    if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
Rule 65    else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
Rule 66    else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
Rule 67    else_block -> ELSE LBRACKET statement_list RBRACKET
Rule 68    conditions -> condition
Rule 69    conditions -> condition AND conditions
Rule 70    conditions -> condition OR conditions
Rule 71    condition -> value comparator value
Rule 72    condition -> NOT condition
Rule 73    comparator -> GREATER
Rule 74    comparator -> LESS
Rule 75    comparator -> EQUALS
Rule 76    comparator -> GREATER_EQUAL
Rule 77    comparator -> LESS_EQUAL
Rule 78    comparator -> NOT_EQUALS
Rule 79    parameter_list -> parameter
Rule 80    parameter_list -> parameter_list COMMA parameter
Rule 81    parameter -> type ID
Rule 82    parameter -> REQUIRED type ID
Rule 83    call_list -> LSBRACKET value_list RSBRACKET
Rule 84    list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
Rule 85    value_list -> value
Rule 86    value_list -> value COMMA value_list
Rule 87    type -> INT
Rule 88    type -> DOUBLE
Rule 89    type -> STRING
Rule 90    type -> BOOL
Rule 91    value -> NUMBER
Rule 92    value -> NDOUBLE
Rule 93    value -> TEXT
Rule 94    value -> ID
Rule 95    value -> TRUE
Rule 96    value -> FALSE
Rule 97    set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
Rule 98    set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
Rule 99    set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
Rule 100   for_classic_initialization -> INT ID ASSIGN NUMBER
Rule 101   for_classic_initialization -> DOUBLE ID ASSIGN NDOUBLE
Rule 102   for_classic_conditions -> conditions
Rule 103   for_classic_changes -> ID comparator value
Rule 104   for_classic_changes -> ID INCREMENT
Rule 105   for_classic_changes -> ID DECREMENT
Rule 106   for_classic_changes -> ID comparator value COMMA for_classic_changes
Rule 107   for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON for_classic_changes
Rule 108   for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
Rule 109   for_in_parenthesis_content -> FINAL ID IN ID
Rule 110   for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
Rule 111   for_each_parenthesis_parenthesis_content -> COLON ID
Rule 112   for_each_parenthesis_parenthesis_content -> COLON ID COMMA for_each_parenthesis_parenthesis_content
Rule 113   for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID
Rule 114   for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
Rule 115   control_structures_for -> for_classic
Rule 116   control_structures_for -> for_in
Rule 117   control_structures_for -> for_each
Rule 118   constructor_parenthesis_content -> THIS DOT ID
Rule 119   constructor_parenthesis_content -> THIS DOT ID COMMA constructor_parenthesis_content
Rule 120   constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
Rule 121   function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
Rule 122   control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET
Rule 123   map -> map_declaration map_assignment
Rule 124   map_declaration -> MAP LESS key_type COMMA type GREATER ID ASSIGN
Rule 125   map_assignment -> LBRACKET map_contents RBRACKET
Rule 126   map_contents -> map_content
Rule 127   map_contents -> map_content COMMA map_contents
Rule 128   map_content -> key_value COLON value
Rule 129   key_value -> TEXT
Rule 130   key_type -> STRING

Terminals, with rules where they appear

ABSTRACT             : 
AND                  : 69
AS                   : 
ASSERT               : 
ASSIGN               : 24 27 28 40 41 42 84 97 98 99 100 101 121 124
ASYNC                : 
AWAIT                : 
BOOL                 : 90
BREAK                : 
CASE                 : 
CATCH                : 
CLASS                : 
COLON                : 111 112 128
COMMA                : 33 80 86 106 112 119 124 127
COMMENT_MULTI        : 16
COMMENT_SINGLE       : 17
CONST                : 99
CONTINUE             : 
COVARIANT            : 
DECREMENT            : 105
DEFAULT              : 
DEFERRED             : 
DIVIDE               : 57
DO                   : 
DOLLARSIGN           : 
DOT                  : 27 28 29 30 31 118 119
DOUBLE               : 53 88 101
DOUBLE_COLON         : 
DYNAMIC              : 41
ELSE                 : 65 66 67
ENUM                 : 
EQUALS               : 75
EXPORT               : 
EXTENDS              : 
EXTENSION            : 
EXTERNAL             : 
FACTORY              : 
FALSE                : 96
FINAL                : 99 109 113
FINALLY              : 
FOR                  : 108 110 114
FUNCTION             : 
GET                  : 
GREATER              : 73 84 98 121 124
GREATER_EQUAL        : 76
HIDE                 : 
ID                   : 23 24 25 26 27 28 31 34 35 36 37 38 39 40 41 42 81 82 84 94 97 98 99 100 101 103 104 105 106 109 109 111 112 113 113 118 119 120 121 124
IF                   : 64 65 66
IMPLEMENTS           : 
IMPORT               : 
IN                   : 109 113
INCREMENT            : 104
INT                  : 87 100
INTERFACE            : 
IS                   : 
LATE                 : 
LBRACKET             : 34 35 36 37 38 39 64 65 66 67 97 98 99 108 110 114 122 125
LENGTH               : 29 30 31
LESS                 : 74 84 98 124
LESS_EQUAL           : 77
LIBRARY              : 
LIST                 : 84
LPAREN               : 25 26 27 28 34 35 36 37 38 39 43 44 64 65 66 108 110 113 114 120 121 122
LSBRACKET            : 83 84
MAP                  : 124
MINUS                : 55
MIXIN                : 
MODULE               : 
NDOUBLE              : 92 101
NEW                  : 
NOT                  : 72
NOT_EQUALS           : 78
NULL                 : 
NUM                  : 
NUMBER               : 52 91 100
NUMERAL              : 
OBJECT               : 
ON                   : 
OPERATOR             : 
OR                   : 70
PART                 : 
PLUS                 : 54
PRINT                : 43 44
QUESTION             : 28
RBRACKET             : 34 35 36 37 38 39 64 65 66 67 97 98 99 108 110 114 122 125
READLINESYNC         : 27 28
REQUIRED             : 82
RETHROW              : 
RETURN               : 19
RPAREN               : 25 26 27 28 34 35 36 37 38 39 43 44 64 65 66 108 110 113 114 120 121
RSBRACKET            : 83 84
SEMICOLON            : 18 19 23 24 27 28 40 41 42 43 44 84 97 98 99 107 107 120
SET                  : 
SHOW                 : 
STATIC               : 
STDIN                : 27 28
STRING               : 27 28 89 98 130
SUPER                : 
SWITCH               : 
SYNC                 : 
TEXT                 : 30 93 129
THIS                 : 118 119
THROW                : 
TIMES                : 56
TRUE                 : 95
TRY                  : 
TYPEDEF              : 
VAR                  : 42 97 98
VOID                 : 35 37 38 39
WHILE                : 122
WITH                 : 
YIELD                : 
error                : 

Nonterminals, with rules where they appear

argument_list        : 25 33
call_function        : 14 47
call_list            : 29
comparator           : 71 103 106
condition            : 68 69 70 72
conditions           : 58 64 65 66 69 70 102 122
constructor          : 8
constructor_parenthesis_content : 119 120
control_structures   : 9
control_structures_for : 21
control_structures_if_else : 20
control_structures_while : 22
data_input           : 5
else_block           : 62 63
else_if_blocks       : 61 62 66
expression           : 19 32 33 40 41 42 45 121
for_classic          : 115
for_classic_changes  : 106 107
for_classic_conditions : 107
for_classic_initialization : 107
for_classic_parenthesis_content : 108
for_each             : 117
for_each_parenthesis_content : 114
for_each_parenthesis_parenthesis_content : 112 113
for_in               : 116
for_in_parenthesis_content : 110
function             : 10
if_block             : 60 61 62 63
key_type             : 124
key_value            : 128
length               : 46
list_definition      : 11
map                  : 7
map_assignment       : 123
map_content          : 126 127
map_contents         : 125 127
map_declaration      : 123
operand              : 50 51 51
operation            : 49 50
operations           : 48 50
operator             : 51
parameter            : 79 80
parameter_list       : 34 35 39 80 121
print                : 4
print_options        : 44
program              : 0
return               : 15
set                  : 6
statement            : 2 3
statement_list       : 1 3 34 35 36 37 64 65 66 67 108 110 114 122
type                 : 34 36 40 81 82 84 121 124
value                : 24 59 71 71 85 86 103 106 128
value_list           : 83 84 86 97 99
variable_definition  : 12
variable_usage       : 13

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement_list
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (97) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (98) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (99) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (123) map -> . map_declaration map_assignment
    (120) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (121) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (84) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN value SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (124) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (60) control_structures_if_else -> . if_block
    (61) control_structures_if_else -> . if_block else_if_blocks
    (62) control_structures_if_else -> . if_block else_if_blocks else_block
    (63) control_structures_if_else -> . if_block else_block
    (115) control_structures_for -> . for_classic
    (116) control_structures_for -> . for_in
    (117) control_structures_for -> . for_each
    (122) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (64) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (108) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (110) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (114) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    program                        shift and go to state 1
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 1

    (0) S' -> program .



state 2

    (1) program -> statement_list .
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (97) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (98) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (99) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (123) map -> . map_declaration map_assignment
    (120) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (121) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (84) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN value SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (124) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (60) control_structures_if_else -> . if_block
    (61) control_structures_if_else -> . if_block else_if_blocks
    (62) control_structures_if_else -> . if_block else_if_blocks else_block
    (63) control_structures_if_else -> . if_block else_block
    (115) control_structures_for -> . for_classic
    (116) control_structures_for -> . for_in
    (117) control_structures_for -> . for_each
    (122) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (64) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (108) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (110) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (114) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    $end            reduce using rule 1 (program -> statement_list .)
    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement                      shift and go to state 44
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 3

    (2) statement_list -> statement .

    COMMENT_MULTI   reduce using rule 2 (statement_list -> statement .)
    COMMENT_SINGLE  reduce using rule 2 (statement_list -> statement .)
    SEMICOLON       reduce using rule 2 (statement_list -> statement .)
    PRINT           reduce using rule 2 (statement_list -> statement .)
    STRING          reduce using rule 2 (statement_list -> statement .)
    VAR             reduce using rule 2 (statement_list -> statement .)
    FINAL           reduce using rule 2 (statement_list -> statement .)
    ID              reduce using rule 2 (statement_list -> statement .)
    VOID            reduce using rule 2 (statement_list -> statement .)
    LIST            reduce using rule 2 (statement_list -> statement .)
    DYNAMIC         reduce using rule 2 (statement_list -> statement .)
    RETURN          reduce using rule 2 (statement_list -> statement .)
    MAP             reduce using rule 2 (statement_list -> statement .)
    WHILE           reduce using rule 2 (statement_list -> statement .)
    INT             reduce using rule 2 (statement_list -> statement .)
    DOUBLE          reduce using rule 2 (statement_list -> statement .)
    BOOL            reduce using rule 2 (statement_list -> statement .)
    IF              reduce using rule 2 (statement_list -> statement .)
    FOR             reduce using rule 2 (statement_list -> statement .)
    $end            reduce using rule 2 (statement_list -> statement .)
    RBRACKET        reduce using rule 2 (statement_list -> statement .)


state 4

    (4) statement -> print .

    COMMENT_MULTI   reduce using rule 4 (statement -> print .)
    COMMENT_SINGLE  reduce using rule 4 (statement -> print .)
    SEMICOLON       reduce using rule 4 (statement -> print .)
    PRINT           reduce using rule 4 (statement -> print .)
    STRING          reduce using rule 4 (statement -> print .)
    VAR             reduce using rule 4 (statement -> print .)
    FINAL           reduce using rule 4 (statement -> print .)
    ID              reduce using rule 4 (statement -> print .)
    VOID            reduce using rule 4 (statement -> print .)
    LIST            reduce using rule 4 (statement -> print .)
    DYNAMIC         reduce using rule 4 (statement -> print .)
    RETURN          reduce using rule 4 (statement -> print .)
    MAP             reduce using rule 4 (statement -> print .)
    WHILE           reduce using rule 4 (statement -> print .)
    INT             reduce using rule 4 (statement -> print .)
    DOUBLE          reduce using rule 4 (statement -> print .)
    BOOL            reduce using rule 4 (statement -> print .)
    IF              reduce using rule 4 (statement -> print .)
    FOR             reduce using rule 4 (statement -> print .)
    $end            reduce using rule 4 (statement -> print .)
    RBRACKET        reduce using rule 4 (statement -> print .)


state 5

    (5) statement -> data_input .

    COMMENT_MULTI   reduce using rule 5 (statement -> data_input .)
    COMMENT_SINGLE  reduce using rule 5 (statement -> data_input .)
    SEMICOLON       reduce using rule 5 (statement -> data_input .)
    PRINT           reduce using rule 5 (statement -> data_input .)
    STRING          reduce using rule 5 (statement -> data_input .)
    VAR             reduce using rule 5 (statement -> data_input .)
    FINAL           reduce using rule 5 (statement -> data_input .)
    ID              reduce using rule 5 (statement -> data_input .)
    VOID            reduce using rule 5 (statement -> data_input .)
    LIST            reduce using rule 5 (statement -> data_input .)
    DYNAMIC         reduce using rule 5 (statement -> data_input .)
    RETURN          reduce using rule 5 (statement -> data_input .)
    MAP             reduce using rule 5 (statement -> data_input .)
    WHILE           reduce using rule 5 (statement -> data_input .)
    INT             reduce using rule 5 (statement -> data_input .)
    DOUBLE          reduce using rule 5 (statement -> data_input .)
    BOOL            reduce using rule 5 (statement -> data_input .)
    IF              reduce using rule 5 (statement -> data_input .)
    FOR             reduce using rule 5 (statement -> data_input .)
    $end            reduce using rule 5 (statement -> data_input .)
    RBRACKET        reduce using rule 5 (statement -> data_input .)


state 6

    (6) statement -> set .

    COMMENT_MULTI   reduce using rule 6 (statement -> set .)
    COMMENT_SINGLE  reduce using rule 6 (statement -> set .)
    SEMICOLON       reduce using rule 6 (statement -> set .)
    PRINT           reduce using rule 6 (statement -> set .)
    STRING          reduce using rule 6 (statement -> set .)
    VAR             reduce using rule 6 (statement -> set .)
    FINAL           reduce using rule 6 (statement -> set .)
    ID              reduce using rule 6 (statement -> set .)
    VOID            reduce using rule 6 (statement -> set .)
    LIST            reduce using rule 6 (statement -> set .)
    DYNAMIC         reduce using rule 6 (statement -> set .)
    RETURN          reduce using rule 6 (statement -> set .)
    MAP             reduce using rule 6 (statement -> set .)
    WHILE           reduce using rule 6 (statement -> set .)
    INT             reduce using rule 6 (statement -> set .)
    DOUBLE          reduce using rule 6 (statement -> set .)
    BOOL            reduce using rule 6 (statement -> set .)
    IF              reduce using rule 6 (statement -> set .)
    FOR             reduce using rule 6 (statement -> set .)
    $end            reduce using rule 6 (statement -> set .)
    RBRACKET        reduce using rule 6 (statement -> set .)


state 7

    (7) statement -> map .

    COMMENT_MULTI   reduce using rule 7 (statement -> map .)
    COMMENT_SINGLE  reduce using rule 7 (statement -> map .)
    SEMICOLON       reduce using rule 7 (statement -> map .)
    PRINT           reduce using rule 7 (statement -> map .)
    STRING          reduce using rule 7 (statement -> map .)
    VAR             reduce using rule 7 (statement -> map .)
    FINAL           reduce using rule 7 (statement -> map .)
    ID              reduce using rule 7 (statement -> map .)
    VOID            reduce using rule 7 (statement -> map .)
    LIST            reduce using rule 7 (statement -> map .)
    DYNAMIC         reduce using rule 7 (statement -> map .)
    RETURN          reduce using rule 7 (statement -> map .)
    MAP             reduce using rule 7 (statement -> map .)
    WHILE           reduce using rule 7 (statement -> map .)
    INT             reduce using rule 7 (statement -> map .)
    DOUBLE          reduce using rule 7 (statement -> map .)
    BOOL            reduce using rule 7 (statement -> map .)
    IF              reduce using rule 7 (statement -> map .)
    FOR             reduce using rule 7 (statement -> map .)
    $end            reduce using rule 7 (statement -> map .)
    RBRACKET        reduce using rule 7 (statement -> map .)


state 8

    (8) statement -> constructor .

    COMMENT_MULTI   reduce using rule 8 (statement -> constructor .)
    COMMENT_SINGLE  reduce using rule 8 (statement -> constructor .)
    SEMICOLON       reduce using rule 8 (statement -> constructor .)
    PRINT           reduce using rule 8 (statement -> constructor .)
    STRING          reduce using rule 8 (statement -> constructor .)
    VAR             reduce using rule 8 (statement -> constructor .)
    FINAL           reduce using rule 8 (statement -> constructor .)
    ID              reduce using rule 8 (statement -> constructor .)
    VOID            reduce using rule 8 (statement -> constructor .)
    LIST            reduce using rule 8 (statement -> constructor .)
    DYNAMIC         reduce using rule 8 (statement -> constructor .)
    RETURN          reduce using rule 8 (statement -> constructor .)
    MAP             reduce using rule 8 (statement -> constructor .)
    WHILE           reduce using rule 8 (statement -> constructor .)
    INT             reduce using rule 8 (statement -> constructor .)
    DOUBLE          reduce using rule 8 (statement -> constructor .)
    BOOL            reduce using rule 8 (statement -> constructor .)
    IF              reduce using rule 8 (statement -> constructor .)
    FOR             reduce using rule 8 (statement -> constructor .)
    $end            reduce using rule 8 (statement -> constructor .)
    RBRACKET        reduce using rule 8 (statement -> constructor .)


state 9

    (9) statement -> control_structures .

    COMMENT_MULTI   reduce using rule 9 (statement -> control_structures .)
    COMMENT_SINGLE  reduce using rule 9 (statement -> control_structures .)
    SEMICOLON       reduce using rule 9 (statement -> control_structures .)
    PRINT           reduce using rule 9 (statement -> control_structures .)
    STRING          reduce using rule 9 (statement -> control_structures .)
    VAR             reduce using rule 9 (statement -> control_structures .)
    FINAL           reduce using rule 9 (statement -> control_structures .)
    ID              reduce using rule 9 (statement -> control_structures .)
    VOID            reduce using rule 9 (statement -> control_structures .)
    LIST            reduce using rule 9 (statement -> control_structures .)
    DYNAMIC         reduce using rule 9 (statement -> control_structures .)
    RETURN          reduce using rule 9 (statement -> control_structures .)
    MAP             reduce using rule 9 (statement -> control_structures .)
    WHILE           reduce using rule 9 (statement -> control_structures .)
    INT             reduce using rule 9 (statement -> control_structures .)
    DOUBLE          reduce using rule 9 (statement -> control_structures .)
    BOOL            reduce using rule 9 (statement -> control_structures .)
    IF              reduce using rule 9 (statement -> control_structures .)
    FOR             reduce using rule 9 (statement -> control_structures .)
    $end            reduce using rule 9 (statement -> control_structures .)
    RBRACKET        reduce using rule 9 (statement -> control_structures .)


state 10

    (10) statement -> function .

    COMMENT_MULTI   reduce using rule 10 (statement -> function .)
    COMMENT_SINGLE  reduce using rule 10 (statement -> function .)
    SEMICOLON       reduce using rule 10 (statement -> function .)
    PRINT           reduce using rule 10 (statement -> function .)
    STRING          reduce using rule 10 (statement -> function .)
    VAR             reduce using rule 10 (statement -> function .)
    FINAL           reduce using rule 10 (statement -> function .)
    ID              reduce using rule 10 (statement -> function .)
    VOID            reduce using rule 10 (statement -> function .)
    LIST            reduce using rule 10 (statement -> function .)
    DYNAMIC         reduce using rule 10 (statement -> function .)
    RETURN          reduce using rule 10 (statement -> function .)
    MAP             reduce using rule 10 (statement -> function .)
    WHILE           reduce using rule 10 (statement -> function .)
    INT             reduce using rule 10 (statement -> function .)
    DOUBLE          reduce using rule 10 (statement -> function .)
    BOOL            reduce using rule 10 (statement -> function .)
    IF              reduce using rule 10 (statement -> function .)
    FOR             reduce using rule 10 (statement -> function .)
    $end            reduce using rule 10 (statement -> function .)
    RBRACKET        reduce using rule 10 (statement -> function .)


state 11

    (11) statement -> list_definition .

    COMMENT_MULTI   reduce using rule 11 (statement -> list_definition .)
    COMMENT_SINGLE  reduce using rule 11 (statement -> list_definition .)
    SEMICOLON       reduce using rule 11 (statement -> list_definition .)
    PRINT           reduce using rule 11 (statement -> list_definition .)
    STRING          reduce using rule 11 (statement -> list_definition .)
    VAR             reduce using rule 11 (statement -> list_definition .)
    FINAL           reduce using rule 11 (statement -> list_definition .)
    ID              reduce using rule 11 (statement -> list_definition .)
    VOID            reduce using rule 11 (statement -> list_definition .)
    LIST            reduce using rule 11 (statement -> list_definition .)
    DYNAMIC         reduce using rule 11 (statement -> list_definition .)
    RETURN          reduce using rule 11 (statement -> list_definition .)
    MAP             reduce using rule 11 (statement -> list_definition .)
    WHILE           reduce using rule 11 (statement -> list_definition .)
    INT             reduce using rule 11 (statement -> list_definition .)
    DOUBLE          reduce using rule 11 (statement -> list_definition .)
    BOOL            reduce using rule 11 (statement -> list_definition .)
    IF              reduce using rule 11 (statement -> list_definition .)
    FOR             reduce using rule 11 (statement -> list_definition .)
    $end            reduce using rule 11 (statement -> list_definition .)
    RBRACKET        reduce using rule 11 (statement -> list_definition .)


state 12

    (12) statement -> variable_definition .

    COMMENT_MULTI   reduce using rule 12 (statement -> variable_definition .)
    COMMENT_SINGLE  reduce using rule 12 (statement -> variable_definition .)
    SEMICOLON       reduce using rule 12 (statement -> variable_definition .)
    PRINT           reduce using rule 12 (statement -> variable_definition .)
    STRING          reduce using rule 12 (statement -> variable_definition .)
    VAR             reduce using rule 12 (statement -> variable_definition .)
    FINAL           reduce using rule 12 (statement -> variable_definition .)
    ID              reduce using rule 12 (statement -> variable_definition .)
    VOID            reduce using rule 12 (statement -> variable_definition .)
    LIST            reduce using rule 12 (statement -> variable_definition .)
    DYNAMIC         reduce using rule 12 (statement -> variable_definition .)
    RETURN          reduce using rule 12 (statement -> variable_definition .)
    MAP             reduce using rule 12 (statement -> variable_definition .)
    WHILE           reduce using rule 12 (statement -> variable_definition .)
    INT             reduce using rule 12 (statement -> variable_definition .)
    DOUBLE          reduce using rule 12 (statement -> variable_definition .)
    BOOL            reduce using rule 12 (statement -> variable_definition .)
    IF              reduce using rule 12 (statement -> variable_definition .)
    FOR             reduce using rule 12 (statement -> variable_definition .)
    $end            reduce using rule 12 (statement -> variable_definition .)
    RBRACKET        reduce using rule 12 (statement -> variable_definition .)


state 13

    (13) statement -> variable_usage .

    COMMENT_MULTI   reduce using rule 13 (statement -> variable_usage .)
    COMMENT_SINGLE  reduce using rule 13 (statement -> variable_usage .)
    SEMICOLON       reduce using rule 13 (statement -> variable_usage .)
    PRINT           reduce using rule 13 (statement -> variable_usage .)
    STRING          reduce using rule 13 (statement -> variable_usage .)
    VAR             reduce using rule 13 (statement -> variable_usage .)
    FINAL           reduce using rule 13 (statement -> variable_usage .)
    ID              reduce using rule 13 (statement -> variable_usage .)
    VOID            reduce using rule 13 (statement -> variable_usage .)
    LIST            reduce using rule 13 (statement -> variable_usage .)
    DYNAMIC         reduce using rule 13 (statement -> variable_usage .)
    RETURN          reduce using rule 13 (statement -> variable_usage .)
    MAP             reduce using rule 13 (statement -> variable_usage .)
    WHILE           reduce using rule 13 (statement -> variable_usage .)
    INT             reduce using rule 13 (statement -> variable_usage .)
    DOUBLE          reduce using rule 13 (statement -> variable_usage .)
    BOOL            reduce using rule 13 (statement -> variable_usage .)
    IF              reduce using rule 13 (statement -> variable_usage .)
    FOR             reduce using rule 13 (statement -> variable_usage .)
    $end            reduce using rule 13 (statement -> variable_usage .)
    RBRACKET        reduce using rule 13 (statement -> variable_usage .)


state 14

    (14) statement -> call_function .

    COMMENT_MULTI   reduce using rule 14 (statement -> call_function .)
    COMMENT_SINGLE  reduce using rule 14 (statement -> call_function .)
    SEMICOLON       reduce using rule 14 (statement -> call_function .)
    PRINT           reduce using rule 14 (statement -> call_function .)
    STRING          reduce using rule 14 (statement -> call_function .)
    VAR             reduce using rule 14 (statement -> call_function .)
    FINAL           reduce using rule 14 (statement -> call_function .)
    ID              reduce using rule 14 (statement -> call_function .)
    VOID            reduce using rule 14 (statement -> call_function .)
    LIST            reduce using rule 14 (statement -> call_function .)
    DYNAMIC         reduce using rule 14 (statement -> call_function .)
    RETURN          reduce using rule 14 (statement -> call_function .)
    MAP             reduce using rule 14 (statement -> call_function .)
    WHILE           reduce using rule 14 (statement -> call_function .)
    INT             reduce using rule 14 (statement -> call_function .)
    DOUBLE          reduce using rule 14 (statement -> call_function .)
    BOOL            reduce using rule 14 (statement -> call_function .)
    IF              reduce using rule 14 (statement -> call_function .)
    FOR             reduce using rule 14 (statement -> call_function .)
    $end            reduce using rule 14 (statement -> call_function .)
    RBRACKET        reduce using rule 14 (statement -> call_function .)


state 15

    (15) statement -> return .

    COMMENT_MULTI   reduce using rule 15 (statement -> return .)
    COMMENT_SINGLE  reduce using rule 15 (statement -> return .)
    SEMICOLON       reduce using rule 15 (statement -> return .)
    PRINT           reduce using rule 15 (statement -> return .)
    STRING          reduce using rule 15 (statement -> return .)
    VAR             reduce using rule 15 (statement -> return .)
    FINAL           reduce using rule 15 (statement -> return .)
    ID              reduce using rule 15 (statement -> return .)
    VOID            reduce using rule 15 (statement -> return .)
    LIST            reduce using rule 15 (statement -> return .)
    DYNAMIC         reduce using rule 15 (statement -> return .)
    RETURN          reduce using rule 15 (statement -> return .)
    MAP             reduce using rule 15 (statement -> return .)
    WHILE           reduce using rule 15 (statement -> return .)
    INT             reduce using rule 15 (statement -> return .)
    DOUBLE          reduce using rule 15 (statement -> return .)
    BOOL            reduce using rule 15 (statement -> return .)
    IF              reduce using rule 15 (statement -> return .)
    FOR             reduce using rule 15 (statement -> return .)
    $end            reduce using rule 15 (statement -> return .)
    RBRACKET        reduce using rule 15 (statement -> return .)


state 16

    (16) statement -> COMMENT_MULTI .

    COMMENT_MULTI   reduce using rule 16 (statement -> COMMENT_MULTI .)
    COMMENT_SINGLE  reduce using rule 16 (statement -> COMMENT_MULTI .)
    SEMICOLON       reduce using rule 16 (statement -> COMMENT_MULTI .)
    PRINT           reduce using rule 16 (statement -> COMMENT_MULTI .)
    STRING          reduce using rule 16 (statement -> COMMENT_MULTI .)
    VAR             reduce using rule 16 (statement -> COMMENT_MULTI .)
    FINAL           reduce using rule 16 (statement -> COMMENT_MULTI .)
    ID              reduce using rule 16 (statement -> COMMENT_MULTI .)
    VOID            reduce using rule 16 (statement -> COMMENT_MULTI .)
    LIST            reduce using rule 16 (statement -> COMMENT_MULTI .)
    DYNAMIC         reduce using rule 16 (statement -> COMMENT_MULTI .)
    RETURN          reduce using rule 16 (statement -> COMMENT_MULTI .)
    MAP             reduce using rule 16 (statement -> COMMENT_MULTI .)
    WHILE           reduce using rule 16 (statement -> COMMENT_MULTI .)
    INT             reduce using rule 16 (statement -> COMMENT_MULTI .)
    DOUBLE          reduce using rule 16 (statement -> COMMENT_MULTI .)
    BOOL            reduce using rule 16 (statement -> COMMENT_MULTI .)
    IF              reduce using rule 16 (statement -> COMMENT_MULTI .)
    FOR             reduce using rule 16 (statement -> COMMENT_MULTI .)
    $end            reduce using rule 16 (statement -> COMMENT_MULTI .)
    RBRACKET        reduce using rule 16 (statement -> COMMENT_MULTI .)


state 17

    (17) statement -> COMMENT_SINGLE .

    COMMENT_MULTI   reduce using rule 17 (statement -> COMMENT_SINGLE .)
    COMMENT_SINGLE  reduce using rule 17 (statement -> COMMENT_SINGLE .)
    SEMICOLON       reduce using rule 17 (statement -> COMMENT_SINGLE .)
    PRINT           reduce using rule 17 (statement -> COMMENT_SINGLE .)
    STRING          reduce using rule 17 (statement -> COMMENT_SINGLE .)
    VAR             reduce using rule 17 (statement -> COMMENT_SINGLE .)
    FINAL           reduce using rule 17 (statement -> COMMENT_SINGLE .)
    ID              reduce using rule 17 (statement -> COMMENT_SINGLE .)
    VOID            reduce using rule 17 (statement -> COMMENT_SINGLE .)
    LIST            reduce using rule 17 (statement -> COMMENT_SINGLE .)
    DYNAMIC         reduce using rule 17 (statement -> COMMENT_SINGLE .)
    RETURN          reduce using rule 17 (statement -> COMMENT_SINGLE .)
    MAP             reduce using rule 17 (statement -> COMMENT_SINGLE .)
    WHILE           reduce using rule 17 (statement -> COMMENT_SINGLE .)
    INT             reduce using rule 17 (statement -> COMMENT_SINGLE .)
    DOUBLE          reduce using rule 17 (statement -> COMMENT_SINGLE .)
    BOOL            reduce using rule 17 (statement -> COMMENT_SINGLE .)
    IF              reduce using rule 17 (statement -> COMMENT_SINGLE .)
    FOR             reduce using rule 17 (statement -> COMMENT_SINGLE .)
    $end            reduce using rule 17 (statement -> COMMENT_SINGLE .)
    RBRACKET        reduce using rule 17 (statement -> COMMENT_SINGLE .)


state 18

    (18) statement -> SEMICOLON .

    COMMENT_MULTI   reduce using rule 18 (statement -> SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 18 (statement -> SEMICOLON .)
    SEMICOLON       reduce using rule 18 (statement -> SEMICOLON .)
    PRINT           reduce using rule 18 (statement -> SEMICOLON .)
    STRING          reduce using rule 18 (statement -> SEMICOLON .)
    VAR             reduce using rule 18 (statement -> SEMICOLON .)
    FINAL           reduce using rule 18 (statement -> SEMICOLON .)
    ID              reduce using rule 18 (statement -> SEMICOLON .)
    VOID            reduce using rule 18 (statement -> SEMICOLON .)
    LIST            reduce using rule 18 (statement -> SEMICOLON .)
    DYNAMIC         reduce using rule 18 (statement -> SEMICOLON .)
    RETURN          reduce using rule 18 (statement -> SEMICOLON .)
    MAP             reduce using rule 18 (statement -> SEMICOLON .)
    WHILE           reduce using rule 18 (statement -> SEMICOLON .)
    INT             reduce using rule 18 (statement -> SEMICOLON .)
    DOUBLE          reduce using rule 18 (statement -> SEMICOLON .)
    BOOL            reduce using rule 18 (statement -> SEMICOLON .)
    IF              reduce using rule 18 (statement -> SEMICOLON .)
    FOR             reduce using rule 18 (statement -> SEMICOLON .)
    $end            reduce using rule 18 (statement -> SEMICOLON .)
    RBRACKET        reduce using rule 18 (statement -> SEMICOLON .)


state 19

    (43) print -> PRINT . LPAREN RPAREN SEMICOLON
    (44) print -> PRINT . LPAREN print_options RPAREN SEMICOLON

    LPAREN          shift and go to state 45


state 20

    (27) data_input -> STRING . ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> STRING . QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (89) type -> STRING .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 46
    QUESTION        shift and go to state 47

  ! ID              [ reduce using rule 89 (type -> STRING .) ]


state 21

    (120) constructor -> ID . LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (23) variable_usage -> ID . SEMICOLON
    (24) variable_usage -> ID . ASSIGN value SEMICOLON
    (25) call_function -> ID . LPAREN argument_list RPAREN
    (26) call_function -> ID . LPAREN RPAREN

    LPAREN          shift and go to state 48
    SEMICOLON       shift and go to state 49
    ASSIGN          shift and go to state 50


state 22

    (97) set -> VAR . ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (98) set -> VAR . ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (42) variable_definition -> VAR . ID ASSIGN expression SEMICOLON

    ID              shift and go to state 51


state 23

    (99) set -> FINAL . ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON

    ID              shift and go to state 52


state 24

    (123) map -> map_declaration . map_assignment
    (125) map_assignment -> . LBRACKET map_contents RBRACKET

    LBRACKET        shift and go to state 54

    map_assignment                 shift and go to state 53

state 25

    (20) control_structures -> control_structures_if_else .

    COMMENT_MULTI   reduce using rule 20 (control_structures -> control_structures_if_else .)
    COMMENT_SINGLE  reduce using rule 20 (control_structures -> control_structures_if_else .)
    SEMICOLON       reduce using rule 20 (control_structures -> control_structures_if_else .)
    PRINT           reduce using rule 20 (control_structures -> control_structures_if_else .)
    STRING          reduce using rule 20 (control_structures -> control_structures_if_else .)
    VAR             reduce using rule 20 (control_structures -> control_structures_if_else .)
    FINAL           reduce using rule 20 (control_structures -> control_structures_if_else .)
    ID              reduce using rule 20 (control_structures -> control_structures_if_else .)
    VOID            reduce using rule 20 (control_structures -> control_structures_if_else .)
    LIST            reduce using rule 20 (control_structures -> control_structures_if_else .)
    DYNAMIC         reduce using rule 20 (control_structures -> control_structures_if_else .)
    RETURN          reduce using rule 20 (control_structures -> control_structures_if_else .)
    MAP             reduce using rule 20 (control_structures -> control_structures_if_else .)
    WHILE           reduce using rule 20 (control_structures -> control_structures_if_else .)
    INT             reduce using rule 20 (control_structures -> control_structures_if_else .)
    DOUBLE          reduce using rule 20 (control_structures -> control_structures_if_else .)
    BOOL            reduce using rule 20 (control_structures -> control_structures_if_else .)
    IF              reduce using rule 20 (control_structures -> control_structures_if_else .)
    FOR             reduce using rule 20 (control_structures -> control_structures_if_else .)
    $end            reduce using rule 20 (control_structures -> control_structures_if_else .)
    RBRACKET        reduce using rule 20 (control_structures -> control_structures_if_else .)


state 26

    (21) control_structures -> control_structures_for .

    COMMENT_MULTI   reduce using rule 21 (control_structures -> control_structures_for .)
    COMMENT_SINGLE  reduce using rule 21 (control_structures -> control_structures_for .)
    SEMICOLON       reduce using rule 21 (control_structures -> control_structures_for .)
    PRINT           reduce using rule 21 (control_structures -> control_structures_for .)
    STRING          reduce using rule 21 (control_structures -> control_structures_for .)
    VAR             reduce using rule 21 (control_structures -> control_structures_for .)
    FINAL           reduce using rule 21 (control_structures -> control_structures_for .)
    ID              reduce using rule 21 (control_structures -> control_structures_for .)
    VOID            reduce using rule 21 (control_structures -> control_structures_for .)
    LIST            reduce using rule 21 (control_structures -> control_structures_for .)
    DYNAMIC         reduce using rule 21 (control_structures -> control_structures_for .)
    RETURN          reduce using rule 21 (control_structures -> control_structures_for .)
    MAP             reduce using rule 21 (control_structures -> control_structures_for .)
    WHILE           reduce using rule 21 (control_structures -> control_structures_for .)
    INT             reduce using rule 21 (control_structures -> control_structures_for .)
    DOUBLE          reduce using rule 21 (control_structures -> control_structures_for .)
    BOOL            reduce using rule 21 (control_structures -> control_structures_for .)
    IF              reduce using rule 21 (control_structures -> control_structures_for .)
    FOR             reduce using rule 21 (control_structures -> control_structures_for .)
    $end            reduce using rule 21 (control_structures -> control_structures_for .)
    RBRACKET        reduce using rule 21 (control_structures -> control_structures_for .)


state 27

    (22) control_structures -> control_structures_while .

    COMMENT_MULTI   reduce using rule 22 (control_structures -> control_structures_while .)
    COMMENT_SINGLE  reduce using rule 22 (control_structures -> control_structures_while .)
    SEMICOLON       reduce using rule 22 (control_structures -> control_structures_while .)
    PRINT           reduce using rule 22 (control_structures -> control_structures_while .)
    STRING          reduce using rule 22 (control_structures -> control_structures_while .)
    VAR             reduce using rule 22 (control_structures -> control_structures_while .)
    FINAL           reduce using rule 22 (control_structures -> control_structures_while .)
    ID              reduce using rule 22 (control_structures -> control_structures_while .)
    VOID            reduce using rule 22 (control_structures -> control_structures_while .)
    LIST            reduce using rule 22 (control_structures -> control_structures_while .)
    DYNAMIC         reduce using rule 22 (control_structures -> control_structures_while .)
    RETURN          reduce using rule 22 (control_structures -> control_structures_while .)
    MAP             reduce using rule 22 (control_structures -> control_structures_while .)
    WHILE           reduce using rule 22 (control_structures -> control_structures_while .)
    INT             reduce using rule 22 (control_structures -> control_structures_while .)
    DOUBLE          reduce using rule 22 (control_structures -> control_structures_while .)
    BOOL            reduce using rule 22 (control_structures -> control_structures_while .)
    IF              reduce using rule 22 (control_structures -> control_structures_while .)
    FOR             reduce using rule 22 (control_structures -> control_structures_while .)
    $end            reduce using rule 22 (control_structures -> control_structures_while .)
    RBRACKET        reduce using rule 22 (control_structures -> control_structures_while .)


state 28

    (34) function -> type . ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> type . ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (121) function -> type . ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (40) variable_definition -> type . ID ASSIGN expression SEMICOLON

    ID              shift and go to state 55


state 29

    (35) function -> VOID . ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (37) function -> VOID . ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> VOID . ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> VOID . ID LPAREN parameter_list RPAREN LBRACKET RBRACKET

    ID              shift and go to state 56


state 30

    (84) list_definition -> LIST . LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON

    LESS            shift and go to state 57


state 31

    (41) variable_definition -> DYNAMIC . ID ASSIGN expression SEMICOLON

    ID              shift and go to state 58


state 32

    (19) return -> RETURN . expression SEMICOLON
    (48) expression -> . operations
    (58) expression -> . conditions
    (59) expression -> . value
    (49) operations -> . operation
    (50) operations -> . operation operand operations
    (68) conditions -> . condition
    (69) conditions -> . condition AND conditions
    (70) conditions -> . condition OR conditions
    (91) value -> . NUMBER
    (92) value -> . NDOUBLE
    (93) value -> . TEXT
    (94) value -> . ID
    (95) value -> . TRUE
    (96) value -> . FALSE
    (51) operation -> . operand operator operand
    (71) condition -> . value comparator value
    (72) condition -> . NOT condition
    (52) operand -> . NUMBER
    (53) operand -> . DOUBLE

    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 68
    ID              shift and go to state 69
    TRUE            shift and go to state 70
    FALSE           shift and go to state 71
    NOT             shift and go to state 72
    DOUBLE          shift and go to state 73

    expression                     shift and go to state 59
    operations                     shift and go to state 60
    conditions                     shift and go to state 61
    value                          shift and go to state 62
    operation                      shift and go to state 63
    operand                        shift and go to state 64
    condition                      shift and go to state 65

state 33

    (124) map_declaration -> MAP . LESS key_type COMMA type GREATER ID ASSIGN

    LESS            shift and go to state 74


state 34

    (60) control_structures_if_else -> if_block .
    (61) control_structures_if_else -> if_block . else_if_blocks
    (62) control_structures_if_else -> if_block . else_if_blocks else_block
    (63) control_structures_if_else -> if_block . else_block
    (65) else_if_blocks -> . ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (66) else_if_blocks -> . else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (67) else_block -> . ELSE LBRACKET statement_list RBRACKET

    COMMENT_MULTI   reduce using rule 60 (control_structures_if_else -> if_block .)
    COMMENT_SINGLE  reduce using rule 60 (control_structures_if_else -> if_block .)
    SEMICOLON       reduce using rule 60 (control_structures_if_else -> if_block .)
    PRINT           reduce using rule 60 (control_structures_if_else -> if_block .)
    STRING          reduce using rule 60 (control_structures_if_else -> if_block .)
    VAR             reduce using rule 60 (control_structures_if_else -> if_block .)
    FINAL           reduce using rule 60 (control_structures_if_else -> if_block .)
    ID              reduce using rule 60 (control_structures_if_else -> if_block .)
    VOID            reduce using rule 60 (control_structures_if_else -> if_block .)
    LIST            reduce using rule 60 (control_structures_if_else -> if_block .)
    DYNAMIC         reduce using rule 60 (control_structures_if_else -> if_block .)
    RETURN          reduce using rule 60 (control_structures_if_else -> if_block .)
    MAP             reduce using rule 60 (control_structures_if_else -> if_block .)
    WHILE           reduce using rule 60 (control_structures_if_else -> if_block .)
    INT             reduce using rule 60 (control_structures_if_else -> if_block .)
    DOUBLE          reduce using rule 60 (control_structures_if_else -> if_block .)
    BOOL            reduce using rule 60 (control_structures_if_else -> if_block .)
    IF              reduce using rule 60 (control_structures_if_else -> if_block .)
    FOR             reduce using rule 60 (control_structures_if_else -> if_block .)
    $end            reduce using rule 60 (control_structures_if_else -> if_block .)
    RBRACKET        reduce using rule 60 (control_structures_if_else -> if_block .)
    ELSE            shift and go to state 77

    else_if_blocks                 shift and go to state 75
    else_block                     shift and go to state 76

state 35

    (115) control_structures_for -> for_classic .

    COMMENT_MULTI   reduce using rule 115 (control_structures_for -> for_classic .)
    COMMENT_SINGLE  reduce using rule 115 (control_structures_for -> for_classic .)
    SEMICOLON       reduce using rule 115 (control_structures_for -> for_classic .)
    PRINT           reduce using rule 115 (control_structures_for -> for_classic .)
    STRING          reduce using rule 115 (control_structures_for -> for_classic .)
    VAR             reduce using rule 115 (control_structures_for -> for_classic .)
    FINAL           reduce using rule 115 (control_structures_for -> for_classic .)
    ID              reduce using rule 115 (control_structures_for -> for_classic .)
    VOID            reduce using rule 115 (control_structures_for -> for_classic .)
    LIST            reduce using rule 115 (control_structures_for -> for_classic .)
    DYNAMIC         reduce using rule 115 (control_structures_for -> for_classic .)
    RETURN          reduce using rule 115 (control_structures_for -> for_classic .)
    MAP             reduce using rule 115 (control_structures_for -> for_classic .)
    WHILE           reduce using rule 115 (control_structures_for -> for_classic .)
    INT             reduce using rule 115 (control_structures_for -> for_classic .)
    DOUBLE          reduce using rule 115 (control_structures_for -> for_classic .)
    BOOL            reduce using rule 115 (control_structures_for -> for_classic .)
    IF              reduce using rule 115 (control_structures_for -> for_classic .)
    FOR             reduce using rule 115 (control_structures_for -> for_classic .)
    $end            reduce using rule 115 (control_structures_for -> for_classic .)
    RBRACKET        reduce using rule 115 (control_structures_for -> for_classic .)


state 36

    (116) control_structures_for -> for_in .

    COMMENT_MULTI   reduce using rule 116 (control_structures_for -> for_in .)
    COMMENT_SINGLE  reduce using rule 116 (control_structures_for -> for_in .)
    SEMICOLON       reduce using rule 116 (control_structures_for -> for_in .)
    PRINT           reduce using rule 116 (control_structures_for -> for_in .)
    STRING          reduce using rule 116 (control_structures_for -> for_in .)
    VAR             reduce using rule 116 (control_structures_for -> for_in .)
    FINAL           reduce using rule 116 (control_structures_for -> for_in .)
    ID              reduce using rule 116 (control_structures_for -> for_in .)
    VOID            reduce using rule 116 (control_structures_for -> for_in .)
    LIST            reduce using rule 116 (control_structures_for -> for_in .)
    DYNAMIC         reduce using rule 116 (control_structures_for -> for_in .)
    RETURN          reduce using rule 116 (control_structures_for -> for_in .)
    MAP             reduce using rule 116 (control_structures_for -> for_in .)
    WHILE           reduce using rule 116 (control_structures_for -> for_in .)
    INT             reduce using rule 116 (control_structures_for -> for_in .)
    DOUBLE          reduce using rule 116 (control_structures_for -> for_in .)
    BOOL            reduce using rule 116 (control_structures_for -> for_in .)
    IF              reduce using rule 116 (control_structures_for -> for_in .)
    FOR             reduce using rule 116 (control_structures_for -> for_in .)
    $end            reduce using rule 116 (control_structures_for -> for_in .)
    RBRACKET        reduce using rule 116 (control_structures_for -> for_in .)


state 37

    (117) control_structures_for -> for_each .

    COMMENT_MULTI   reduce using rule 117 (control_structures_for -> for_each .)
    COMMENT_SINGLE  reduce using rule 117 (control_structures_for -> for_each .)
    SEMICOLON       reduce using rule 117 (control_structures_for -> for_each .)
    PRINT           reduce using rule 117 (control_structures_for -> for_each .)
    STRING          reduce using rule 117 (control_structures_for -> for_each .)
    VAR             reduce using rule 117 (control_structures_for -> for_each .)
    FINAL           reduce using rule 117 (control_structures_for -> for_each .)
    ID              reduce using rule 117 (control_structures_for -> for_each .)
    VOID            reduce using rule 117 (control_structures_for -> for_each .)
    LIST            reduce using rule 117 (control_structures_for -> for_each .)
    DYNAMIC         reduce using rule 117 (control_structures_for -> for_each .)
    RETURN          reduce using rule 117 (control_structures_for -> for_each .)
    MAP             reduce using rule 117 (control_structures_for -> for_each .)
    WHILE           reduce using rule 117 (control_structures_for -> for_each .)
    INT             reduce using rule 117 (control_structures_for -> for_each .)
    DOUBLE          reduce using rule 117 (control_structures_for -> for_each .)
    BOOL            reduce using rule 117 (control_structures_for -> for_each .)
    IF              reduce using rule 117 (control_structures_for -> for_each .)
    FOR             reduce using rule 117 (control_structures_for -> for_each .)
    $end            reduce using rule 117 (control_structures_for -> for_each .)
    RBRACKET        reduce using rule 117 (control_structures_for -> for_each .)


state 38

    (122) control_structures_while -> WHILE . LPAREN conditions LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 78


state 39

    (87) type -> INT .

    ID              reduce using rule 87 (type -> INT .)
    GREATER         reduce using rule 87 (type -> INT .)


state 40

    (88) type -> DOUBLE .

    ID              reduce using rule 88 (type -> DOUBLE .)
    GREATER         reduce using rule 88 (type -> DOUBLE .)


state 41

    (90) type -> BOOL .

    ID              reduce using rule 90 (type -> BOOL .)
    GREATER         reduce using rule 90 (type -> BOOL .)


state 42

    (64) if_block -> IF . LPAREN conditions RPAREN LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 79


state 43

    (108) for_classic -> FOR . LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (110) for_in -> FOR . LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (114) for_each -> FOR . LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 80


state 44

    (3) statement_list -> statement_list statement .

    COMMENT_MULTI   reduce using rule 3 (statement_list -> statement_list statement .)
    COMMENT_SINGLE  reduce using rule 3 (statement_list -> statement_list statement .)
    SEMICOLON       reduce using rule 3 (statement_list -> statement_list statement .)
    PRINT           reduce using rule 3 (statement_list -> statement_list statement .)
    STRING          reduce using rule 3 (statement_list -> statement_list statement .)
    VAR             reduce using rule 3 (statement_list -> statement_list statement .)
    FINAL           reduce using rule 3 (statement_list -> statement_list statement .)
    ID              reduce using rule 3 (statement_list -> statement_list statement .)
    VOID            reduce using rule 3 (statement_list -> statement_list statement .)
    LIST            reduce using rule 3 (statement_list -> statement_list statement .)
    DYNAMIC         reduce using rule 3 (statement_list -> statement_list statement .)
    RETURN          reduce using rule 3 (statement_list -> statement_list statement .)
    MAP             reduce using rule 3 (statement_list -> statement_list statement .)
    WHILE           reduce using rule 3 (statement_list -> statement_list statement .)
    INT             reduce using rule 3 (statement_list -> statement_list statement .)
    DOUBLE          reduce using rule 3 (statement_list -> statement_list statement .)
    BOOL            reduce using rule 3 (statement_list -> statement_list statement .)
    IF              reduce using rule 3 (statement_list -> statement_list statement .)
    FOR             reduce using rule 3 (statement_list -> statement_list statement .)
    $end            reduce using rule 3 (statement_list -> statement_list statement .)
    RBRACKET        reduce using rule 3 (statement_list -> statement_list statement .)


state 45

    (43) print -> PRINT LPAREN . RPAREN SEMICOLON
    (44) print -> PRINT LPAREN . print_options RPAREN SEMICOLON
    (45) print_options -> . expression
    (46) print_options -> . length
    (47) print_options -> . call_function
    (48) expression -> . operations
    (58) expression -> . conditions
    (59) expression -> . value
    (29) length -> . call_list DOT LENGTH
    (30) length -> . TEXT DOT LENGTH
    (31) length -> . ID DOT LENGTH
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (49) operations -> . operation
    (50) operations -> . operation operand operations
    (68) conditions -> . condition
    (69) conditions -> . condition AND conditions
    (70) conditions -> . condition OR conditions
    (91) value -> . NUMBER
    (92) value -> . NDOUBLE
    (93) value -> . TEXT
    (94) value -> . ID
    (95) value -> . TRUE
    (96) value -> . FALSE
    (83) call_list -> . LSBRACKET value_list RSBRACKET
    (51) operation -> . operand operator operand
    (71) condition -> . value comparator value
    (72) condition -> . NOT condition
    (52) operand -> . NUMBER
    (53) operand -> . DOUBLE

    RPAREN          shift and go to state 81
    TEXT            shift and go to state 87
    ID              shift and go to state 88
    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TRUE            shift and go to state 70
    FALSE           shift and go to state 71
    LSBRACKET       shift and go to state 89
    NOT             shift and go to state 72
    DOUBLE          shift and go to state 73

    print_options                  shift and go to state 82
    expression                     shift and go to state 83
    length                         shift and go to state 84
    call_function                  shift and go to state 85
    operations                     shift and go to state 60
    conditions                     shift and go to state 61
    value                          shift and go to state 62
    call_list                      shift and go to state 86
    operation                      shift and go to state 63
    operand                        shift and go to state 64
    condition                      shift and go to state 65

state 46

    (27) data_input -> STRING ID . ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    ASSIGN          shift and go to state 90


state 47

    (28) data_input -> STRING QUESTION . ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    ID              shift and go to state 91


state 48

    (120) constructor -> ID LPAREN . constructor_parenthesis_content RPAREN SEMICOLON
    (25) call_function -> ID LPAREN . argument_list RPAREN
    (26) call_function -> ID LPAREN . RPAREN
    (118) constructor_parenthesis_content -> . THIS DOT ID
    (119) constructor_parenthesis_content -> . THIS DOT ID COMMA constructor_parenthesis_content
    (32) argument_list -> . expression
    (33) argument_list -> . argument_list COMMA expression
    (48) expression -> . operations
    (58) expression -> . conditions
    (59) expression -> . value
    (49) operations -> . operation
    (50) operations -> . operation operand operations
    (68) conditions -> . condition
    (69) conditions -> . condition AND conditions
    (70) conditions -> . condition OR conditions
    (91) value -> . NUMBER
    (92) value -> . NDOUBLE
    (93) value -> . TEXT
    (94) value -> . ID
    (95) value -> . TRUE
    (96) value -> . FALSE
    (51) operation -> . operand operator operand
    (71) condition -> . value comparator value
    (72) condition -> . NOT condition
    (52) operand -> . NUMBER
    (53) operand -> . DOUBLE

    RPAREN          shift and go to state 93
    THIS            shift and go to state 95
    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 68
    ID              shift and go to state 69
    TRUE            shift and go to state 70
    FALSE           shift and go to state 71
    NOT             shift and go to state 72
    DOUBLE          shift and go to state 73

    constructor_parenthesis_content shift and go to state 92
    argument_list                  shift and go to state 94
    expression                     shift and go to state 96
    operations                     shift and go to state 60
    conditions                     shift and go to state 61
    value                          shift and go to state 62
    operation                      shift and go to state 63
    operand                        shift and go to state 64
    condition                      shift and go to state 65

state 49

    (23) variable_usage -> ID SEMICOLON .

    COMMENT_MULTI   reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    SEMICOLON       reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    PRINT           reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    STRING          reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    VAR             reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    FINAL           reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    ID              reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    VOID            reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    LIST            reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    DYNAMIC         reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    RETURN          reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    MAP             reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    WHILE           reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    INT             reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    DOUBLE          reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    BOOL            reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    IF              reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    FOR             reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    $end            reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    RBRACKET        reduce using rule 23 (variable_usage -> ID SEMICOLON .)


state 50

    (24) variable_usage -> ID ASSIGN . value SEMICOLON
    (91) value -> . NUMBER
    (92) value -> . NDOUBLE
    (93) value -> . TEXT
    (94) value -> . ID
    (95) value -> . TRUE
    (96) value -> . FALSE

    NUMBER          shift and go to state 98
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 68
    ID              shift and go to state 69
    TRUE            shift and go to state 70
    FALSE           shift and go to state 71

    value                          shift and go to state 97

state 51

    (97) set -> VAR ID . ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (98) set -> VAR ID . ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (42) variable_definition -> VAR ID . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 99


state 52

    (99) set -> FINAL ID . ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON

    ASSIGN          shift and go to state 100


state 53

    (123) map -> map_declaration map_assignment .

    COMMENT_MULTI   reduce using rule 123 (map -> map_declaration map_assignment .)
    COMMENT_SINGLE  reduce using rule 123 (map -> map_declaration map_assignment .)
    SEMICOLON       reduce using rule 123 (map -> map_declaration map_assignment .)
    PRINT           reduce using rule 123 (map -> map_declaration map_assignment .)
    STRING          reduce using rule 123 (map -> map_declaration map_assignment .)
    VAR             reduce using rule 123 (map -> map_declaration map_assignment .)
    FINAL           reduce using rule 123 (map -> map_declaration map_assignment .)
    ID              reduce using rule 123 (map -> map_declaration map_assignment .)
    VOID            reduce using rule 123 (map -> map_declaration map_assignment .)
    LIST            reduce using rule 123 (map -> map_declaration map_assignment .)
    DYNAMIC         reduce using rule 123 (map -> map_declaration map_assignment .)
    RETURN          reduce using rule 123 (map -> map_declaration map_assignment .)
    MAP             reduce using rule 123 (map -> map_declaration map_assignment .)
    WHILE           reduce using rule 123 (map -> map_declaration map_assignment .)
    INT             reduce using rule 123 (map -> map_declaration map_assignment .)
    DOUBLE          reduce using rule 123 (map -> map_declaration map_assignment .)
    BOOL            reduce using rule 123 (map -> map_declaration map_assignment .)
    IF              reduce using rule 123 (map -> map_declaration map_assignment .)
    FOR             reduce using rule 123 (map -> map_declaration map_assignment .)
    $end            reduce using rule 123 (map -> map_declaration map_assignment .)
    RBRACKET        reduce using rule 123 (map -> map_declaration map_assignment .)


state 54

    (125) map_assignment -> LBRACKET . map_contents RBRACKET
    (126) map_contents -> . map_content
    (127) map_contents -> . map_content COMMA map_contents
    (128) map_content -> . key_value COLON value
    (129) key_value -> . TEXT

    TEXT            shift and go to state 104

    map_contents                   shift and go to state 101
    map_content                    shift and go to state 102
    key_value                      shift and go to state 103

state 55

    (34) function -> type ID . LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> type ID . LPAREN RPAREN LBRACKET statement_list RBRACKET
    (121) function -> type ID . LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (40) variable_definition -> type ID . ASSIGN expression SEMICOLON

    LPAREN          shift and go to state 105
    ASSIGN          shift and go to state 106


state 56

    (35) function -> VOID ID . LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (37) function -> VOID ID . LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> VOID ID . LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> VOID ID . LPAREN parameter_list RPAREN LBRACKET RBRACKET

    LPAREN          shift and go to state 107


state 57

    (84) list_definition -> LIST LESS . type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL

    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 109
    BOOL            shift and go to state 41

    type                           shift and go to state 108

state 58

    (41) variable_definition -> DYNAMIC ID . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 110


state 59

    (19) return -> RETURN expression . SEMICOLON

    SEMICOLON       shift and go to state 111


state 60

    (48) expression -> operations .

    SEMICOLON       reduce using rule 48 (expression -> operations .)
    RPAREN          reduce using rule 48 (expression -> operations .)
    COMMA           reduce using rule 48 (expression -> operations .)
    COMMENT_MULTI   reduce using rule 48 (expression -> operations .)
    COMMENT_SINGLE  reduce using rule 48 (expression -> operations .)
    PRINT           reduce using rule 48 (expression -> operations .)
    STRING          reduce using rule 48 (expression -> operations .)
    VAR             reduce using rule 48 (expression -> operations .)
    FINAL           reduce using rule 48 (expression -> operations .)
    ID              reduce using rule 48 (expression -> operations .)
    VOID            reduce using rule 48 (expression -> operations .)
    LIST            reduce using rule 48 (expression -> operations .)
    DYNAMIC         reduce using rule 48 (expression -> operations .)
    RETURN          reduce using rule 48 (expression -> operations .)
    MAP             reduce using rule 48 (expression -> operations .)
    WHILE           reduce using rule 48 (expression -> operations .)
    INT             reduce using rule 48 (expression -> operations .)
    DOUBLE          reduce using rule 48 (expression -> operations .)
    BOOL            reduce using rule 48 (expression -> operations .)
    IF              reduce using rule 48 (expression -> operations .)
    FOR             reduce using rule 48 (expression -> operations .)
    $end            reduce using rule 48 (expression -> operations .)
    RBRACKET        reduce using rule 48 (expression -> operations .)


state 61

    (58) expression -> conditions .

    SEMICOLON       reduce using rule 58 (expression -> conditions .)
    RPAREN          reduce using rule 58 (expression -> conditions .)
    COMMA           reduce using rule 58 (expression -> conditions .)
    COMMENT_MULTI   reduce using rule 58 (expression -> conditions .)
    COMMENT_SINGLE  reduce using rule 58 (expression -> conditions .)
    PRINT           reduce using rule 58 (expression -> conditions .)
    STRING          reduce using rule 58 (expression -> conditions .)
    VAR             reduce using rule 58 (expression -> conditions .)
    FINAL           reduce using rule 58 (expression -> conditions .)
    ID              reduce using rule 58 (expression -> conditions .)
    VOID            reduce using rule 58 (expression -> conditions .)
    LIST            reduce using rule 58 (expression -> conditions .)
    DYNAMIC         reduce using rule 58 (expression -> conditions .)
    RETURN          reduce using rule 58 (expression -> conditions .)
    MAP             reduce using rule 58 (expression -> conditions .)
    WHILE           reduce using rule 58 (expression -> conditions .)
    INT             reduce using rule 58 (expression -> conditions .)
    DOUBLE          reduce using rule 58 (expression -> conditions .)
    BOOL            reduce using rule 58 (expression -> conditions .)
    IF              reduce using rule 58 (expression -> conditions .)
    FOR             reduce using rule 58 (expression -> conditions .)
    $end            reduce using rule 58 (expression -> conditions .)
    RBRACKET        reduce using rule 58 (expression -> conditions .)


state 62

    (59) expression -> value .
    (71) condition -> value . comparator value
    (73) comparator -> . GREATER
    (74) comparator -> . LESS
    (75) comparator -> . EQUALS
    (76) comparator -> . GREATER_EQUAL
    (77) comparator -> . LESS_EQUAL
    (78) comparator -> . NOT_EQUALS

    SEMICOLON       reduce using rule 59 (expression -> value .)
    RPAREN          reduce using rule 59 (expression -> value .)
    COMMA           reduce using rule 59 (expression -> value .)
    COMMENT_MULTI   reduce using rule 59 (expression -> value .)
    COMMENT_SINGLE  reduce using rule 59 (expression -> value .)
    PRINT           reduce using rule 59 (expression -> value .)
    STRING          reduce using rule 59 (expression -> value .)
    VAR             reduce using rule 59 (expression -> value .)
    FINAL           reduce using rule 59 (expression -> value .)
    ID              reduce using rule 59 (expression -> value .)
    VOID            reduce using rule 59 (expression -> value .)
    LIST            reduce using rule 59 (expression -> value .)
    DYNAMIC         reduce using rule 59 (expression -> value .)
    RETURN          reduce using rule 59 (expression -> value .)
    MAP             reduce using rule 59 (expression -> value .)
    WHILE           reduce using rule 59 (expression -> value .)
    INT             reduce using rule 59 (expression -> value .)
    DOUBLE          reduce using rule 59 (expression -> value .)
    BOOL            reduce using rule 59 (expression -> value .)
    IF              reduce using rule 59 (expression -> value .)
    FOR             reduce using rule 59 (expression -> value .)
    $end            reduce using rule 59 (expression -> value .)
    RBRACKET        reduce using rule 59 (expression -> value .)
    GREATER         shift and go to state 113
    LESS            shift and go to state 114
    EQUALS          shift and go to state 115
    GREATER_EQUAL   shift and go to state 116
    LESS_EQUAL      shift and go to state 117
    NOT_EQUALS      shift and go to state 118

    comparator                     shift and go to state 112

state 63

    (49) operations -> operation .
    (50) operations -> operation . operand operations
    (52) operand -> . NUMBER
    (53) operand -> . DOUBLE

  ! shift/reduce conflict for DOUBLE resolved as shift
    SEMICOLON       reduce using rule 49 (operations -> operation .)
    RPAREN          reduce using rule 49 (operations -> operation .)
    COMMA           reduce using rule 49 (operations -> operation .)
    COMMENT_MULTI   reduce using rule 49 (operations -> operation .)
    COMMENT_SINGLE  reduce using rule 49 (operations -> operation .)
    PRINT           reduce using rule 49 (operations -> operation .)
    STRING          reduce using rule 49 (operations -> operation .)
    VAR             reduce using rule 49 (operations -> operation .)
    FINAL           reduce using rule 49 (operations -> operation .)
    ID              reduce using rule 49 (operations -> operation .)
    VOID            reduce using rule 49 (operations -> operation .)
    LIST            reduce using rule 49 (operations -> operation .)
    DYNAMIC         reduce using rule 49 (operations -> operation .)
    RETURN          reduce using rule 49 (operations -> operation .)
    MAP             reduce using rule 49 (operations -> operation .)
    WHILE           reduce using rule 49 (operations -> operation .)
    INT             reduce using rule 49 (operations -> operation .)
    BOOL            reduce using rule 49 (operations -> operation .)
    IF              reduce using rule 49 (operations -> operation .)
    FOR             reduce using rule 49 (operations -> operation .)
    $end            reduce using rule 49 (operations -> operation .)
    RBRACKET        reduce using rule 49 (operations -> operation .)
    NUMBER          shift and go to state 120
    DOUBLE          shift and go to state 73

  ! DOUBLE          [ reduce using rule 49 (operations -> operation .) ]

    operand                        shift and go to state 119

state 64

    (51) operation -> operand . operator operand
    (54) operator -> . PLUS
    (55) operator -> . MINUS
    (56) operator -> . TIMES
    (57) operator -> . DIVIDE

    PLUS            shift and go to state 122
    MINUS           shift and go to state 123
    TIMES           shift and go to state 124
    DIVIDE          shift and go to state 125

    operator                       shift and go to state 121

state 65

    (68) conditions -> condition .
    (69) conditions -> condition . AND conditions
    (70) conditions -> condition . OR conditions

    SEMICOLON       reduce using rule 68 (conditions -> condition .)
    RPAREN          reduce using rule 68 (conditions -> condition .)
    COMMA           reduce using rule 68 (conditions -> condition .)
    LBRACKET        reduce using rule 68 (conditions -> condition .)
    COMMENT_MULTI   reduce using rule 68 (conditions -> condition .)
    COMMENT_SINGLE  reduce using rule 68 (conditions -> condition .)
    PRINT           reduce using rule 68 (conditions -> condition .)
    STRING          reduce using rule 68 (conditions -> condition .)
    VAR             reduce using rule 68 (conditions -> condition .)
    FINAL           reduce using rule 68 (conditions -> condition .)
    ID              reduce using rule 68 (conditions -> condition .)
    VOID            reduce using rule 68 (conditions -> condition .)
    LIST            reduce using rule 68 (conditions -> condition .)
    DYNAMIC         reduce using rule 68 (conditions -> condition .)
    RETURN          reduce using rule 68 (conditions -> condition .)
    MAP             reduce using rule 68 (conditions -> condition .)
    WHILE           reduce using rule 68 (conditions -> condition .)
    INT             reduce using rule 68 (conditions -> condition .)
    DOUBLE          reduce using rule 68 (conditions -> condition .)
    BOOL            reduce using rule 68 (conditions -> condition .)
    IF              reduce using rule 68 (conditions -> condition .)
    FOR             reduce using rule 68 (conditions -> condition .)
    $end            reduce using rule 68 (conditions -> condition .)
    RBRACKET        reduce using rule 68 (conditions -> condition .)
    AND             shift and go to state 126
    OR              shift and go to state 127


state 66

    (91) value -> NUMBER .
    (52) operand -> NUMBER .

    GREATER         reduce using rule 91 (value -> NUMBER .)
    LESS            reduce using rule 91 (value -> NUMBER .)
    EQUALS          reduce using rule 91 (value -> NUMBER .)
    GREATER_EQUAL   reduce using rule 91 (value -> NUMBER .)
    LESS_EQUAL      reduce using rule 91 (value -> NUMBER .)
    NOT_EQUALS      reduce using rule 91 (value -> NUMBER .)
    SEMICOLON       reduce using rule 91 (value -> NUMBER .)
    RPAREN          reduce using rule 91 (value -> NUMBER .)
    COMMA           reduce using rule 91 (value -> NUMBER .)
    COMMENT_MULTI   reduce using rule 91 (value -> NUMBER .)
    COMMENT_SINGLE  reduce using rule 91 (value -> NUMBER .)
    PRINT           reduce using rule 91 (value -> NUMBER .)
    STRING          reduce using rule 91 (value -> NUMBER .)
    VAR             reduce using rule 91 (value -> NUMBER .)
    FINAL           reduce using rule 91 (value -> NUMBER .)
    ID              reduce using rule 91 (value -> NUMBER .)
    VOID            reduce using rule 91 (value -> NUMBER .)
    LIST            reduce using rule 91 (value -> NUMBER .)
    DYNAMIC         reduce using rule 91 (value -> NUMBER .)
    RETURN          reduce using rule 91 (value -> NUMBER .)
    MAP             reduce using rule 91 (value -> NUMBER .)
    WHILE           reduce using rule 91 (value -> NUMBER .)
    INT             reduce using rule 91 (value -> NUMBER .)
    DOUBLE          reduce using rule 91 (value -> NUMBER .)
    BOOL            reduce using rule 91 (value -> NUMBER .)
    IF              reduce using rule 91 (value -> NUMBER .)
    FOR             reduce using rule 91 (value -> NUMBER .)
    $end            reduce using rule 91 (value -> NUMBER .)
    RBRACKET        reduce using rule 91 (value -> NUMBER .)
    PLUS            reduce using rule 52 (operand -> NUMBER .)
    MINUS           reduce using rule 52 (operand -> NUMBER .)
    TIMES           reduce using rule 52 (operand -> NUMBER .)
    DIVIDE          reduce using rule 52 (operand -> NUMBER .)


state 67

    (92) value -> NDOUBLE .

    GREATER         reduce using rule 92 (value -> NDOUBLE .)
    LESS            reduce using rule 92 (value -> NDOUBLE .)
    EQUALS          reduce using rule 92 (value -> NDOUBLE .)
    GREATER_EQUAL   reduce using rule 92 (value -> NDOUBLE .)
    LESS_EQUAL      reduce using rule 92 (value -> NDOUBLE .)
    NOT_EQUALS      reduce using rule 92 (value -> NDOUBLE .)
    SEMICOLON       reduce using rule 92 (value -> NDOUBLE .)
    RPAREN          reduce using rule 92 (value -> NDOUBLE .)
    COMMA           reduce using rule 92 (value -> NDOUBLE .)
    RSBRACKET       reduce using rule 92 (value -> NDOUBLE .)
    AND             reduce using rule 92 (value -> NDOUBLE .)
    OR              reduce using rule 92 (value -> NDOUBLE .)
    LBRACKET        reduce using rule 92 (value -> NDOUBLE .)
    COMMENT_MULTI   reduce using rule 92 (value -> NDOUBLE .)
    COMMENT_SINGLE  reduce using rule 92 (value -> NDOUBLE .)
    PRINT           reduce using rule 92 (value -> NDOUBLE .)
    STRING          reduce using rule 92 (value -> NDOUBLE .)
    VAR             reduce using rule 92 (value -> NDOUBLE .)
    FINAL           reduce using rule 92 (value -> NDOUBLE .)
    ID              reduce using rule 92 (value -> NDOUBLE .)
    VOID            reduce using rule 92 (value -> NDOUBLE .)
    LIST            reduce using rule 92 (value -> NDOUBLE .)
    DYNAMIC         reduce using rule 92 (value -> NDOUBLE .)
    RETURN          reduce using rule 92 (value -> NDOUBLE .)
    MAP             reduce using rule 92 (value -> NDOUBLE .)
    WHILE           reduce using rule 92 (value -> NDOUBLE .)
    INT             reduce using rule 92 (value -> NDOUBLE .)
    DOUBLE          reduce using rule 92 (value -> NDOUBLE .)
    BOOL            reduce using rule 92 (value -> NDOUBLE .)
    IF              reduce using rule 92 (value -> NDOUBLE .)
    FOR             reduce using rule 92 (value -> NDOUBLE .)
    $end            reduce using rule 92 (value -> NDOUBLE .)
    RBRACKET        reduce using rule 92 (value -> NDOUBLE .)


state 68

    (93) value -> TEXT .

    GREATER         reduce using rule 93 (value -> TEXT .)
    LESS            reduce using rule 93 (value -> TEXT .)
    EQUALS          reduce using rule 93 (value -> TEXT .)
    GREATER_EQUAL   reduce using rule 93 (value -> TEXT .)
    LESS_EQUAL      reduce using rule 93 (value -> TEXT .)
    NOT_EQUALS      reduce using rule 93 (value -> TEXT .)
    SEMICOLON       reduce using rule 93 (value -> TEXT .)
    RPAREN          reduce using rule 93 (value -> TEXT .)
    COMMA           reduce using rule 93 (value -> TEXT .)
    RSBRACKET       reduce using rule 93 (value -> TEXT .)
    AND             reduce using rule 93 (value -> TEXT .)
    OR              reduce using rule 93 (value -> TEXT .)
    LBRACKET        reduce using rule 93 (value -> TEXT .)
    COMMENT_MULTI   reduce using rule 93 (value -> TEXT .)
    COMMENT_SINGLE  reduce using rule 93 (value -> TEXT .)
    PRINT           reduce using rule 93 (value -> TEXT .)
    STRING          reduce using rule 93 (value -> TEXT .)
    VAR             reduce using rule 93 (value -> TEXT .)
    FINAL           reduce using rule 93 (value -> TEXT .)
    ID              reduce using rule 93 (value -> TEXT .)
    VOID            reduce using rule 93 (value -> TEXT .)
    LIST            reduce using rule 93 (value -> TEXT .)
    DYNAMIC         reduce using rule 93 (value -> TEXT .)
    RETURN          reduce using rule 93 (value -> TEXT .)
    MAP             reduce using rule 93 (value -> TEXT .)
    WHILE           reduce using rule 93 (value -> TEXT .)
    INT             reduce using rule 93 (value -> TEXT .)
    DOUBLE          reduce using rule 93 (value -> TEXT .)
    BOOL            reduce using rule 93 (value -> TEXT .)
    IF              reduce using rule 93 (value -> TEXT .)
    FOR             reduce using rule 93 (value -> TEXT .)
    $end            reduce using rule 93 (value -> TEXT .)
    RBRACKET        reduce using rule 93 (value -> TEXT .)


state 69

    (94) value -> ID .

    GREATER         reduce using rule 94 (value -> ID .)
    LESS            reduce using rule 94 (value -> ID .)
    EQUALS          reduce using rule 94 (value -> ID .)
    GREATER_EQUAL   reduce using rule 94 (value -> ID .)
    LESS_EQUAL      reduce using rule 94 (value -> ID .)
    NOT_EQUALS      reduce using rule 94 (value -> ID .)
    SEMICOLON       reduce using rule 94 (value -> ID .)
    RPAREN          reduce using rule 94 (value -> ID .)
    COMMA           reduce using rule 94 (value -> ID .)
    RSBRACKET       reduce using rule 94 (value -> ID .)
    AND             reduce using rule 94 (value -> ID .)
    OR              reduce using rule 94 (value -> ID .)
    LBRACKET        reduce using rule 94 (value -> ID .)
    COMMENT_MULTI   reduce using rule 94 (value -> ID .)
    COMMENT_SINGLE  reduce using rule 94 (value -> ID .)
    PRINT           reduce using rule 94 (value -> ID .)
    STRING          reduce using rule 94 (value -> ID .)
    VAR             reduce using rule 94 (value -> ID .)
    FINAL           reduce using rule 94 (value -> ID .)
    ID              reduce using rule 94 (value -> ID .)
    VOID            reduce using rule 94 (value -> ID .)
    LIST            reduce using rule 94 (value -> ID .)
    DYNAMIC         reduce using rule 94 (value -> ID .)
    RETURN          reduce using rule 94 (value -> ID .)
    MAP             reduce using rule 94 (value -> ID .)
    WHILE           reduce using rule 94 (value -> ID .)
    INT             reduce using rule 94 (value -> ID .)
    DOUBLE          reduce using rule 94 (value -> ID .)
    BOOL            reduce using rule 94 (value -> ID .)
    IF              reduce using rule 94 (value -> ID .)
    FOR             reduce using rule 94 (value -> ID .)
    $end            reduce using rule 94 (value -> ID .)
    RBRACKET        reduce using rule 94 (value -> ID .)


state 70

    (95) value -> TRUE .

    GREATER         reduce using rule 95 (value -> TRUE .)
    LESS            reduce using rule 95 (value -> TRUE .)
    EQUALS          reduce using rule 95 (value -> TRUE .)
    GREATER_EQUAL   reduce using rule 95 (value -> TRUE .)
    LESS_EQUAL      reduce using rule 95 (value -> TRUE .)
    NOT_EQUALS      reduce using rule 95 (value -> TRUE .)
    SEMICOLON       reduce using rule 95 (value -> TRUE .)
    RPAREN          reduce using rule 95 (value -> TRUE .)
    COMMA           reduce using rule 95 (value -> TRUE .)
    RSBRACKET       reduce using rule 95 (value -> TRUE .)
    AND             reduce using rule 95 (value -> TRUE .)
    OR              reduce using rule 95 (value -> TRUE .)
    LBRACKET        reduce using rule 95 (value -> TRUE .)
    COMMENT_MULTI   reduce using rule 95 (value -> TRUE .)
    COMMENT_SINGLE  reduce using rule 95 (value -> TRUE .)
    PRINT           reduce using rule 95 (value -> TRUE .)
    STRING          reduce using rule 95 (value -> TRUE .)
    VAR             reduce using rule 95 (value -> TRUE .)
    FINAL           reduce using rule 95 (value -> TRUE .)
    ID              reduce using rule 95 (value -> TRUE .)
    VOID            reduce using rule 95 (value -> TRUE .)
    LIST            reduce using rule 95 (value -> TRUE .)
    DYNAMIC         reduce using rule 95 (value -> TRUE .)
    RETURN          reduce using rule 95 (value -> TRUE .)
    MAP             reduce using rule 95 (value -> TRUE .)
    WHILE           reduce using rule 95 (value -> TRUE .)
    INT             reduce using rule 95 (value -> TRUE .)
    DOUBLE          reduce using rule 95 (value -> TRUE .)
    BOOL            reduce using rule 95 (value -> TRUE .)
    IF              reduce using rule 95 (value -> TRUE .)
    FOR             reduce using rule 95 (value -> TRUE .)
    $end            reduce using rule 95 (value -> TRUE .)
    RBRACKET        reduce using rule 95 (value -> TRUE .)


state 71

    (96) value -> FALSE .

    GREATER         reduce using rule 96 (value -> FALSE .)
    LESS            reduce using rule 96 (value -> FALSE .)
    EQUALS          reduce using rule 96 (value -> FALSE .)
    GREATER_EQUAL   reduce using rule 96 (value -> FALSE .)
    LESS_EQUAL      reduce using rule 96 (value -> FALSE .)
    NOT_EQUALS      reduce using rule 96 (value -> FALSE .)
    SEMICOLON       reduce using rule 96 (value -> FALSE .)
    RPAREN          reduce using rule 96 (value -> FALSE .)
    COMMA           reduce using rule 96 (value -> FALSE .)
    RSBRACKET       reduce using rule 96 (value -> FALSE .)
    AND             reduce using rule 96 (value -> FALSE .)
    OR              reduce using rule 96 (value -> FALSE .)
    LBRACKET        reduce using rule 96 (value -> FALSE .)
    COMMENT_MULTI   reduce using rule 96 (value -> FALSE .)
    COMMENT_SINGLE  reduce using rule 96 (value -> FALSE .)
    PRINT           reduce using rule 96 (value -> FALSE .)
    STRING          reduce using rule 96 (value -> FALSE .)
    VAR             reduce using rule 96 (value -> FALSE .)
    FINAL           reduce using rule 96 (value -> FALSE .)
    ID              reduce using rule 96 (value -> FALSE .)
    VOID            reduce using rule 96 (value -> FALSE .)
    LIST            reduce using rule 96 (value -> FALSE .)
    DYNAMIC         reduce using rule 96 (value -> FALSE .)
    RETURN          reduce using rule 96 (value -> FALSE .)
    MAP             reduce using rule 96 (value -> FALSE .)
    WHILE           reduce using rule 96 (value -> FALSE .)
    INT             reduce using rule 96 (value -> FALSE .)
    DOUBLE          reduce using rule 96 (value -> FALSE .)
    BOOL            reduce using rule 96 (value -> FALSE .)
    IF              reduce using rule 96 (value -> FALSE .)
    FOR             reduce using rule 96 (value -> FALSE .)
    $end            reduce using rule 96 (value -> FALSE .)
    RBRACKET        reduce using rule 96 (value -> FALSE .)


state 72

    (72) condition -> NOT . condition
    (71) condition -> . value comparator value
    (72) condition -> . NOT condition
    (91) value -> . NUMBER
    (92) value -> . NDOUBLE
    (93) value -> . TEXT
    (94) value -> . ID
    (95) value -> . TRUE
    (96) value -> . FALSE

    NOT             shift and go to state 72
    NUMBER          shift and go to state 98
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 68
    ID              shift and go to state 69
    TRUE            shift and go to state 70
    FALSE           shift and go to state 71

    condition                      shift and go to state 128
    value                          shift and go to state 129

state 73

    (53) operand -> DOUBLE .

    PLUS            reduce using rule 53 (operand -> DOUBLE .)
    MINUS           reduce using rule 53 (operand -> DOUBLE .)
    TIMES           reduce using rule 53 (operand -> DOUBLE .)
    DIVIDE          reduce using rule 53 (operand -> DOUBLE .)
    NUMBER          reduce using rule 53 (operand -> DOUBLE .)
    DOUBLE          reduce using rule 53 (operand -> DOUBLE .)
    SEMICOLON       reduce using rule 53 (operand -> DOUBLE .)
    RPAREN          reduce using rule 53 (operand -> DOUBLE .)
    COMMA           reduce using rule 53 (operand -> DOUBLE .)
    COMMENT_MULTI   reduce using rule 53 (operand -> DOUBLE .)
    COMMENT_SINGLE  reduce using rule 53 (operand -> DOUBLE .)
    PRINT           reduce using rule 53 (operand -> DOUBLE .)
    STRING          reduce using rule 53 (operand -> DOUBLE .)
    VAR             reduce using rule 53 (operand -> DOUBLE .)
    FINAL           reduce using rule 53 (operand -> DOUBLE .)
    ID              reduce using rule 53 (operand -> DOUBLE .)
    VOID            reduce using rule 53 (operand -> DOUBLE .)
    LIST            reduce using rule 53 (operand -> DOUBLE .)
    DYNAMIC         reduce using rule 53 (operand -> DOUBLE .)
    RETURN          reduce using rule 53 (operand -> DOUBLE .)
    MAP             reduce using rule 53 (operand -> DOUBLE .)
    WHILE           reduce using rule 53 (operand -> DOUBLE .)
    INT             reduce using rule 53 (operand -> DOUBLE .)
    BOOL            reduce using rule 53 (operand -> DOUBLE .)
    IF              reduce using rule 53 (operand -> DOUBLE .)
    FOR             reduce using rule 53 (operand -> DOUBLE .)
    $end            reduce using rule 53 (operand -> DOUBLE .)
    RBRACKET        reduce using rule 53 (operand -> DOUBLE .)


state 74

    (124) map_declaration -> MAP LESS . key_type COMMA type GREATER ID ASSIGN
    (130) key_type -> . STRING

    STRING          shift and go to state 131

    key_type                       shift and go to state 130

state 75

    (61) control_structures_if_else -> if_block else_if_blocks .
    (62) control_structures_if_else -> if_block else_if_blocks . else_block
    (66) else_if_blocks -> else_if_blocks . ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (67) else_block -> . ELSE LBRACKET statement_list RBRACKET

    COMMENT_MULTI   reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks .)
    COMMENT_SINGLE  reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks .)
    SEMICOLON       reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks .)
    PRINT           reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks .)
    STRING          reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks .)
    VAR             reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks .)
    FINAL           reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks .)
    ID              reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks .)
    VOID            reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks .)
    LIST            reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks .)
    DYNAMIC         reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks .)
    RETURN          reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks .)
    MAP             reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks .)
    WHILE           reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks .)
    INT             reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks .)
    DOUBLE          reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks .)
    BOOL            reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks .)
    IF              reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks .)
    FOR             reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks .)
    $end            reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks .)
    RBRACKET        reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks .)
    ELSE            shift and go to state 133

    else_block                     shift and go to state 132

state 76

    (63) control_structures_if_else -> if_block else_block .

    COMMENT_MULTI   reduce using rule 63 (control_structures_if_else -> if_block else_block .)
    COMMENT_SINGLE  reduce using rule 63 (control_structures_if_else -> if_block else_block .)
    SEMICOLON       reduce using rule 63 (control_structures_if_else -> if_block else_block .)
    PRINT           reduce using rule 63 (control_structures_if_else -> if_block else_block .)
    STRING          reduce using rule 63 (control_structures_if_else -> if_block else_block .)
    VAR             reduce using rule 63 (control_structures_if_else -> if_block else_block .)
    FINAL           reduce using rule 63 (control_structures_if_else -> if_block else_block .)
    ID              reduce using rule 63 (control_structures_if_else -> if_block else_block .)
    VOID            reduce using rule 63 (control_structures_if_else -> if_block else_block .)
    LIST            reduce using rule 63 (control_structures_if_else -> if_block else_block .)
    DYNAMIC         reduce using rule 63 (control_structures_if_else -> if_block else_block .)
    RETURN          reduce using rule 63 (control_structures_if_else -> if_block else_block .)
    MAP             reduce using rule 63 (control_structures_if_else -> if_block else_block .)
    WHILE           reduce using rule 63 (control_structures_if_else -> if_block else_block .)
    INT             reduce using rule 63 (control_structures_if_else -> if_block else_block .)
    DOUBLE          reduce using rule 63 (control_structures_if_else -> if_block else_block .)
    BOOL            reduce using rule 63 (control_structures_if_else -> if_block else_block .)
    IF              reduce using rule 63 (control_structures_if_else -> if_block else_block .)
    FOR             reduce using rule 63 (control_structures_if_else -> if_block else_block .)
    $end            reduce using rule 63 (control_structures_if_else -> if_block else_block .)
    RBRACKET        reduce using rule 63 (control_structures_if_else -> if_block else_block .)


state 77

    (65) else_if_blocks -> ELSE . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (67) else_block -> ELSE . LBRACKET statement_list RBRACKET

    IF              shift and go to state 134
    LBRACKET        shift and go to state 135


state 78

    (122) control_structures_while -> WHILE LPAREN . conditions LBRACKET statement_list RBRACKET
    (68) conditions -> . condition
    (69) conditions -> . condition AND conditions
    (70) conditions -> . condition OR conditions
    (71) condition -> . value comparator value
    (72) condition -> . NOT condition
    (91) value -> . NUMBER
    (92) value -> . NDOUBLE
    (93) value -> . TEXT
    (94) value -> . ID
    (95) value -> . TRUE
    (96) value -> . FALSE

    NOT             shift and go to state 72
    NUMBER          shift and go to state 98
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 68
    ID              shift and go to state 69
    TRUE            shift and go to state 70
    FALSE           shift and go to state 71

    conditions                     shift and go to state 136
    condition                      shift and go to state 65
    value                          shift and go to state 129

state 79

    (64) if_block -> IF LPAREN . conditions RPAREN LBRACKET statement_list RBRACKET
    (68) conditions -> . condition
    (69) conditions -> . condition AND conditions
    (70) conditions -> . condition OR conditions
    (71) condition -> . value comparator value
    (72) condition -> . NOT condition
    (91) value -> . NUMBER
    (92) value -> . NDOUBLE
    (93) value -> . TEXT
    (94) value -> . ID
    (95) value -> . TRUE
    (96) value -> . FALSE

    NOT             shift and go to state 72
    NUMBER          shift and go to state 98
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 68
    ID              shift and go to state 69
    TRUE            shift and go to state 70
    FALSE           shift and go to state 71

    conditions                     shift and go to state 137
    condition                      shift and go to state 65
    value                          shift and go to state 129

state 80

    (108) for_classic -> FOR LPAREN . for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (110) for_in -> FOR LPAREN . for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (114) for_each -> FOR LPAREN . for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (107) for_classic_parenthesis_content -> . for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON for_classic_changes
    (109) for_in_parenthesis_content -> . FINAL ID IN ID
    (113) for_each_parenthesis_content -> . FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID
    (100) for_classic_initialization -> . INT ID ASSIGN NUMBER
    (101) for_classic_initialization -> . DOUBLE ID ASSIGN NDOUBLE

    FINAL           shift and go to state 142
    INT             shift and go to state 143
    DOUBLE          shift and go to state 144

    for_classic_parenthesis_content shift and go to state 138
    for_in_parenthesis_content     shift and go to state 139
    for_each_parenthesis_content   shift and go to state 140
    for_classic_initialization     shift and go to state 141

state 81

    (43) print -> PRINT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 145


state 82

    (44) print -> PRINT LPAREN print_options . RPAREN SEMICOLON

    RPAREN          shift and go to state 146


state 83

    (45) print_options -> expression .

    RPAREN          reduce using rule 45 (print_options -> expression .)


state 84

    (46) print_options -> length .

    RPAREN          reduce using rule 46 (print_options -> length .)


state 85

    (47) print_options -> call_function .

    RPAREN          reduce using rule 47 (print_options -> call_function .)


state 86

    (29) length -> call_list . DOT LENGTH

    DOT             shift and go to state 147


state 87

    (30) length -> TEXT . DOT LENGTH
    (93) value -> TEXT .

    DOT             shift and go to state 148
    GREATER         reduce using rule 93 (value -> TEXT .)
    LESS            reduce using rule 93 (value -> TEXT .)
    EQUALS          reduce using rule 93 (value -> TEXT .)
    GREATER_EQUAL   reduce using rule 93 (value -> TEXT .)
    LESS_EQUAL      reduce using rule 93 (value -> TEXT .)
    NOT_EQUALS      reduce using rule 93 (value -> TEXT .)
    RPAREN          reduce using rule 93 (value -> TEXT .)


state 88

    (31) length -> ID . DOT LENGTH
    (25) call_function -> ID . LPAREN argument_list RPAREN
    (26) call_function -> ID . LPAREN RPAREN
    (94) value -> ID .

    DOT             shift and go to state 149
    LPAREN          shift and go to state 150
    GREATER         reduce using rule 94 (value -> ID .)
    LESS            reduce using rule 94 (value -> ID .)
    EQUALS          reduce using rule 94 (value -> ID .)
    GREATER_EQUAL   reduce using rule 94 (value -> ID .)
    LESS_EQUAL      reduce using rule 94 (value -> ID .)
    NOT_EQUALS      reduce using rule 94 (value -> ID .)
    RPAREN          reduce using rule 94 (value -> ID .)


state 89

    (83) call_list -> LSBRACKET . value_list RSBRACKET
    (85) value_list -> . value
    (86) value_list -> . value COMMA value_list
    (91) value -> . NUMBER
    (92) value -> . NDOUBLE
    (93) value -> . TEXT
    (94) value -> . ID
    (95) value -> . TRUE
    (96) value -> . FALSE

    NUMBER          shift and go to state 98
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 68
    ID              shift and go to state 69
    TRUE            shift and go to state 70
    FALSE           shift and go to state 71

    value_list                     shift and go to state 151
    value                          shift and go to state 152

state 90

    (27) data_input -> STRING ID ASSIGN . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    STDIN           shift and go to state 153


state 91

    (28) data_input -> STRING QUESTION ID . ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    ASSIGN          shift and go to state 154


state 92

    (120) constructor -> ID LPAREN constructor_parenthesis_content . RPAREN SEMICOLON

    RPAREN          shift and go to state 155


state 93

    (26) call_function -> ID LPAREN RPAREN .

    COMMENT_MULTI   reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    COMMENT_SINGLE  reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    SEMICOLON       reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    PRINT           reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    STRING          reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    VAR             reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    FINAL           reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    ID              reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    VOID            reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    LIST            reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    DYNAMIC         reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    RETURN          reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    MAP             reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    WHILE           reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    INT             reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    DOUBLE          reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    BOOL            reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    IF              reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    FOR             reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    $end            reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    RPAREN          reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    RBRACKET        reduce using rule 26 (call_function -> ID LPAREN RPAREN .)


state 94

    (25) call_function -> ID LPAREN argument_list . RPAREN
    (33) argument_list -> argument_list . COMMA expression

    RPAREN          shift and go to state 156
    COMMA           shift and go to state 157


state 95

    (118) constructor_parenthesis_content -> THIS . DOT ID
    (119) constructor_parenthesis_content -> THIS . DOT ID COMMA constructor_parenthesis_content

    DOT             shift and go to state 158


state 96

    (32) argument_list -> expression .

    RPAREN          reduce using rule 32 (argument_list -> expression .)
    COMMA           reduce using rule 32 (argument_list -> expression .)


state 97

    (24) variable_usage -> ID ASSIGN value . SEMICOLON

    SEMICOLON       shift and go to state 159


state 98

    (91) value -> NUMBER .

    SEMICOLON       reduce using rule 91 (value -> NUMBER .)
    GREATER         reduce using rule 91 (value -> NUMBER .)
    LESS            reduce using rule 91 (value -> NUMBER .)
    EQUALS          reduce using rule 91 (value -> NUMBER .)
    GREATER_EQUAL   reduce using rule 91 (value -> NUMBER .)
    LESS_EQUAL      reduce using rule 91 (value -> NUMBER .)
    NOT_EQUALS      reduce using rule 91 (value -> NUMBER .)
    COMMA           reduce using rule 91 (value -> NUMBER .)
    RSBRACKET       reduce using rule 91 (value -> NUMBER .)
    AND             reduce using rule 91 (value -> NUMBER .)
    OR              reduce using rule 91 (value -> NUMBER .)
    RPAREN          reduce using rule 91 (value -> NUMBER .)
    LBRACKET        reduce using rule 91 (value -> NUMBER .)
    COMMENT_MULTI   reduce using rule 91 (value -> NUMBER .)
    COMMENT_SINGLE  reduce using rule 91 (value -> NUMBER .)
    PRINT           reduce using rule 91 (value -> NUMBER .)
    STRING          reduce using rule 91 (value -> NUMBER .)
    VAR             reduce using rule 91 (value -> NUMBER .)
    FINAL           reduce using rule 91 (value -> NUMBER .)
    ID              reduce using rule 91 (value -> NUMBER .)
    VOID            reduce using rule 91 (value -> NUMBER .)
    LIST            reduce using rule 91 (value -> NUMBER .)
    DYNAMIC         reduce using rule 91 (value -> NUMBER .)
    RETURN          reduce using rule 91 (value -> NUMBER .)
    MAP             reduce using rule 91 (value -> NUMBER .)
    WHILE           reduce using rule 91 (value -> NUMBER .)
    INT             reduce using rule 91 (value -> NUMBER .)
    DOUBLE          reduce using rule 91 (value -> NUMBER .)
    BOOL            reduce using rule 91 (value -> NUMBER .)
    IF              reduce using rule 91 (value -> NUMBER .)
    FOR             reduce using rule 91 (value -> NUMBER .)
    $end            reduce using rule 91 (value -> NUMBER .)
    RBRACKET        reduce using rule 91 (value -> NUMBER .)


state 99

    (97) set -> VAR ID ASSIGN . LBRACKET value_list RBRACKET SEMICOLON
    (98) set -> VAR ID ASSIGN . LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (42) variable_definition -> VAR ID ASSIGN . expression SEMICOLON
    (48) expression -> . operations
    (58) expression -> . conditions
    (59) expression -> . value
    (49) operations -> . operation
    (50) operations -> . operation operand operations
    (68) conditions -> . condition
    (69) conditions -> . condition AND conditions
    (70) conditions -> . condition OR conditions
    (91) value -> . NUMBER
    (92) value -> . NDOUBLE
    (93) value -> . TEXT
    (94) value -> . ID
    (95) value -> . TRUE
    (96) value -> . FALSE
    (51) operation -> . operand operator operand
    (71) condition -> . value comparator value
    (72) condition -> . NOT condition
    (52) operand -> . NUMBER
    (53) operand -> . DOUBLE

    LBRACKET        shift and go to state 160
    LESS            shift and go to state 161
    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 68
    ID              shift and go to state 69
    TRUE            shift and go to state 70
    FALSE           shift and go to state 71
    NOT             shift and go to state 72
    DOUBLE          shift and go to state 73

    expression                     shift and go to state 162
    operations                     shift and go to state 60
    conditions                     shift and go to state 61
    value                          shift and go to state 62
    operation                      shift and go to state 63
    operand                        shift and go to state 64
    condition                      shift and go to state 65

state 100

    (99) set -> FINAL ID ASSIGN . CONST LBRACKET value_list RBRACKET SEMICOLON

    CONST           shift and go to state 163


state 101

    (125) map_assignment -> LBRACKET map_contents . RBRACKET

    RBRACKET        shift and go to state 164


state 102

    (126) map_contents -> map_content .
    (127) map_contents -> map_content . COMMA map_contents

    RBRACKET        reduce using rule 126 (map_contents -> map_content .)
    COMMA           shift and go to state 165


state 103

    (128) map_content -> key_value . COLON value

    COLON           shift and go to state 166


state 104

    (129) key_value -> TEXT .

    COLON           reduce using rule 129 (key_value -> TEXT .)


state 105

    (34) function -> type ID LPAREN . parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> type ID LPAREN . RPAREN LBRACKET statement_list RBRACKET
    (121) function -> type ID LPAREN . parameter_list RPAREN ASSIGN GREATER expression
    (79) parameter_list -> . parameter
    (80) parameter_list -> . parameter_list COMMA parameter
    (81) parameter -> . type ID
    (82) parameter -> . REQUIRED type ID
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL

    RPAREN          shift and go to state 169
    REQUIRED        shift and go to state 171
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 109
    BOOL            shift and go to state 41

    type                           shift and go to state 167
    parameter_list                 shift and go to state 168
    parameter                      shift and go to state 170

state 106

    (40) variable_definition -> type ID ASSIGN . expression SEMICOLON
    (48) expression -> . operations
    (58) expression -> . conditions
    (59) expression -> . value
    (49) operations -> . operation
    (50) operations -> . operation operand operations
    (68) conditions -> . condition
    (69) conditions -> . condition AND conditions
    (70) conditions -> . condition OR conditions
    (91) value -> . NUMBER
    (92) value -> . NDOUBLE
    (93) value -> . TEXT
    (94) value -> . ID
    (95) value -> . TRUE
    (96) value -> . FALSE
    (51) operation -> . operand operator operand
    (71) condition -> . value comparator value
    (72) condition -> . NOT condition
    (52) operand -> . NUMBER
    (53) operand -> . DOUBLE

    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 68
    ID              shift and go to state 69
    TRUE            shift and go to state 70
    FALSE           shift and go to state 71
    NOT             shift and go to state 72
    DOUBLE          shift and go to state 73

    expression                     shift and go to state 172
    operations                     shift and go to state 60
    conditions                     shift and go to state 61
    value                          shift and go to state 62
    operation                      shift and go to state 63
    operand                        shift and go to state 64
    condition                      shift and go to state 65

state 107

    (35) function -> VOID ID LPAREN . parameter_list RPAREN LBRACKET statement_list RBRACKET
    (37) function -> VOID ID LPAREN . RPAREN LBRACKET statement_list RBRACKET
    (38) function -> VOID ID LPAREN . RPAREN LBRACKET RBRACKET
    (39) function -> VOID ID LPAREN . parameter_list RPAREN LBRACKET RBRACKET
    (79) parameter_list -> . parameter
    (80) parameter_list -> . parameter_list COMMA parameter
    (81) parameter -> . type ID
    (82) parameter -> . REQUIRED type ID
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL

    RPAREN          shift and go to state 174
    REQUIRED        shift and go to state 171
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 109
    BOOL            shift and go to state 41

    parameter_list                 shift and go to state 173
    parameter                      shift and go to state 170
    type                           shift and go to state 167

state 108

    (84) list_definition -> LIST LESS type . GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON

    GREATER         shift and go to state 175


state 109

    (89) type -> STRING .

    GREATER         reduce using rule 89 (type -> STRING .)
    ID              reduce using rule 89 (type -> STRING .)


state 110

    (41) variable_definition -> DYNAMIC ID ASSIGN . expression SEMICOLON
    (48) expression -> . operations
    (58) expression -> . conditions
    (59) expression -> . value
    (49) operations -> . operation
    (50) operations -> . operation operand operations
    (68) conditions -> . condition
    (69) conditions -> . condition AND conditions
    (70) conditions -> . condition OR conditions
    (91) value -> . NUMBER
    (92) value -> . NDOUBLE
    (93) value -> . TEXT
    (94) value -> . ID
    (95) value -> . TRUE
    (96) value -> . FALSE
    (51) operation -> . operand operator operand
    (71) condition -> . value comparator value
    (72) condition -> . NOT condition
    (52) operand -> . NUMBER
    (53) operand -> . DOUBLE

    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 68
    ID              shift and go to state 69
    TRUE            shift and go to state 70
    FALSE           shift and go to state 71
    NOT             shift and go to state 72
    DOUBLE          shift and go to state 73

    expression                     shift and go to state 176
    operations                     shift and go to state 60
    conditions                     shift and go to state 61
    value                          shift and go to state 62
    operation                      shift and go to state 63
    operand                        shift and go to state 64
    condition                      shift and go to state 65

state 111

    (19) return -> RETURN expression SEMICOLON .

    COMMENT_MULTI   reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    SEMICOLON       reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    PRINT           reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    STRING          reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    VAR             reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    FINAL           reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    ID              reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    VOID            reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    LIST            reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    DYNAMIC         reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    MAP             reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    WHILE           reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    INT             reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    DOUBLE          reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    BOOL            reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    IF              reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    FOR             reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    $end            reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    RBRACKET        reduce using rule 19 (return -> RETURN expression SEMICOLON .)


state 112

    (71) condition -> value comparator . value
    (91) value -> . NUMBER
    (92) value -> . NDOUBLE
    (93) value -> . TEXT
    (94) value -> . ID
    (95) value -> . TRUE
    (96) value -> . FALSE

    NUMBER          shift and go to state 98
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 68
    ID              shift and go to state 69
    TRUE            shift and go to state 70
    FALSE           shift and go to state 71

    value                          shift and go to state 177

state 113

    (73) comparator -> GREATER .

    NUMBER          reduce using rule 73 (comparator -> GREATER .)
    NDOUBLE         reduce using rule 73 (comparator -> GREATER .)
    TEXT            reduce using rule 73 (comparator -> GREATER .)
    ID              reduce using rule 73 (comparator -> GREATER .)
    TRUE            reduce using rule 73 (comparator -> GREATER .)
    FALSE           reduce using rule 73 (comparator -> GREATER .)


state 114

    (74) comparator -> LESS .

    NUMBER          reduce using rule 74 (comparator -> LESS .)
    NDOUBLE         reduce using rule 74 (comparator -> LESS .)
    TEXT            reduce using rule 74 (comparator -> LESS .)
    ID              reduce using rule 74 (comparator -> LESS .)
    TRUE            reduce using rule 74 (comparator -> LESS .)
    FALSE           reduce using rule 74 (comparator -> LESS .)


state 115

    (75) comparator -> EQUALS .

    NUMBER          reduce using rule 75 (comparator -> EQUALS .)
    NDOUBLE         reduce using rule 75 (comparator -> EQUALS .)
    TEXT            reduce using rule 75 (comparator -> EQUALS .)
    ID              reduce using rule 75 (comparator -> EQUALS .)
    TRUE            reduce using rule 75 (comparator -> EQUALS .)
    FALSE           reduce using rule 75 (comparator -> EQUALS .)


state 116

    (76) comparator -> GREATER_EQUAL .

    NUMBER          reduce using rule 76 (comparator -> GREATER_EQUAL .)
    NDOUBLE         reduce using rule 76 (comparator -> GREATER_EQUAL .)
    TEXT            reduce using rule 76 (comparator -> GREATER_EQUAL .)
    ID              reduce using rule 76 (comparator -> GREATER_EQUAL .)
    TRUE            reduce using rule 76 (comparator -> GREATER_EQUAL .)
    FALSE           reduce using rule 76 (comparator -> GREATER_EQUAL .)


state 117

    (77) comparator -> LESS_EQUAL .

    NUMBER          reduce using rule 77 (comparator -> LESS_EQUAL .)
    NDOUBLE         reduce using rule 77 (comparator -> LESS_EQUAL .)
    TEXT            reduce using rule 77 (comparator -> LESS_EQUAL .)
    ID              reduce using rule 77 (comparator -> LESS_EQUAL .)
    TRUE            reduce using rule 77 (comparator -> LESS_EQUAL .)
    FALSE           reduce using rule 77 (comparator -> LESS_EQUAL .)


state 118

    (78) comparator -> NOT_EQUALS .

    NUMBER          reduce using rule 78 (comparator -> NOT_EQUALS .)
    NDOUBLE         reduce using rule 78 (comparator -> NOT_EQUALS .)
    TEXT            reduce using rule 78 (comparator -> NOT_EQUALS .)
    ID              reduce using rule 78 (comparator -> NOT_EQUALS .)
    TRUE            reduce using rule 78 (comparator -> NOT_EQUALS .)
    FALSE           reduce using rule 78 (comparator -> NOT_EQUALS .)


state 119

    (50) operations -> operation operand . operations
    (49) operations -> . operation
    (50) operations -> . operation operand operations
    (51) operation -> . operand operator operand
    (52) operand -> . NUMBER
    (53) operand -> . DOUBLE

    NUMBER          shift and go to state 120
    DOUBLE          shift and go to state 73

    operation                      shift and go to state 63
    operand                        shift and go to state 64
    operations                     shift and go to state 178

state 120

    (52) operand -> NUMBER .

    NUMBER          reduce using rule 52 (operand -> NUMBER .)
    DOUBLE          reduce using rule 52 (operand -> NUMBER .)
    PLUS            reduce using rule 52 (operand -> NUMBER .)
    MINUS           reduce using rule 52 (operand -> NUMBER .)
    TIMES           reduce using rule 52 (operand -> NUMBER .)
    DIVIDE          reduce using rule 52 (operand -> NUMBER .)
    SEMICOLON       reduce using rule 52 (operand -> NUMBER .)
    RPAREN          reduce using rule 52 (operand -> NUMBER .)
    COMMA           reduce using rule 52 (operand -> NUMBER .)
    COMMENT_MULTI   reduce using rule 52 (operand -> NUMBER .)
    COMMENT_SINGLE  reduce using rule 52 (operand -> NUMBER .)
    PRINT           reduce using rule 52 (operand -> NUMBER .)
    STRING          reduce using rule 52 (operand -> NUMBER .)
    VAR             reduce using rule 52 (operand -> NUMBER .)
    FINAL           reduce using rule 52 (operand -> NUMBER .)
    ID              reduce using rule 52 (operand -> NUMBER .)
    VOID            reduce using rule 52 (operand -> NUMBER .)
    LIST            reduce using rule 52 (operand -> NUMBER .)
    DYNAMIC         reduce using rule 52 (operand -> NUMBER .)
    RETURN          reduce using rule 52 (operand -> NUMBER .)
    MAP             reduce using rule 52 (operand -> NUMBER .)
    WHILE           reduce using rule 52 (operand -> NUMBER .)
    INT             reduce using rule 52 (operand -> NUMBER .)
    BOOL            reduce using rule 52 (operand -> NUMBER .)
    IF              reduce using rule 52 (operand -> NUMBER .)
    FOR             reduce using rule 52 (operand -> NUMBER .)
    $end            reduce using rule 52 (operand -> NUMBER .)
    RBRACKET        reduce using rule 52 (operand -> NUMBER .)


state 121

    (51) operation -> operand operator . operand
    (52) operand -> . NUMBER
    (53) operand -> . DOUBLE

    NUMBER          shift and go to state 120
    DOUBLE          shift and go to state 73

    operand                        shift and go to state 179

state 122

    (54) operator -> PLUS .

    NUMBER          reduce using rule 54 (operator -> PLUS .)
    DOUBLE          reduce using rule 54 (operator -> PLUS .)


state 123

    (55) operator -> MINUS .

    NUMBER          reduce using rule 55 (operator -> MINUS .)
    DOUBLE          reduce using rule 55 (operator -> MINUS .)


state 124

    (56) operator -> TIMES .

    NUMBER          reduce using rule 56 (operator -> TIMES .)
    DOUBLE          reduce using rule 56 (operator -> TIMES .)


state 125

    (57) operator -> DIVIDE .

    NUMBER          reduce using rule 57 (operator -> DIVIDE .)
    DOUBLE          reduce using rule 57 (operator -> DIVIDE .)


state 126

    (69) conditions -> condition AND . conditions
    (68) conditions -> . condition
    (69) conditions -> . condition AND conditions
    (70) conditions -> . condition OR conditions
    (71) condition -> . value comparator value
    (72) condition -> . NOT condition
    (91) value -> . NUMBER
    (92) value -> . NDOUBLE
    (93) value -> . TEXT
    (94) value -> . ID
    (95) value -> . TRUE
    (96) value -> . FALSE

    NOT             shift and go to state 72
    NUMBER          shift and go to state 98
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 68
    ID              shift and go to state 69
    TRUE            shift and go to state 70
    FALSE           shift and go to state 71

    condition                      shift and go to state 65
    conditions                     shift and go to state 180
    value                          shift and go to state 129

state 127

    (70) conditions -> condition OR . conditions
    (68) conditions -> . condition
    (69) conditions -> . condition AND conditions
    (70) conditions -> . condition OR conditions
    (71) condition -> . value comparator value
    (72) condition -> . NOT condition
    (91) value -> . NUMBER
    (92) value -> . NDOUBLE
    (93) value -> . TEXT
    (94) value -> . ID
    (95) value -> . TRUE
    (96) value -> . FALSE

    NOT             shift and go to state 72
    NUMBER          shift and go to state 98
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 68
    ID              shift and go to state 69
    TRUE            shift and go to state 70
    FALSE           shift and go to state 71

    condition                      shift and go to state 65
    conditions                     shift and go to state 181
    value                          shift and go to state 129

state 128

    (72) condition -> NOT condition .

    AND             reduce using rule 72 (condition -> NOT condition .)
    OR              reduce using rule 72 (condition -> NOT condition .)
    SEMICOLON       reduce using rule 72 (condition -> NOT condition .)
    RPAREN          reduce using rule 72 (condition -> NOT condition .)
    COMMA           reduce using rule 72 (condition -> NOT condition .)
    LBRACKET        reduce using rule 72 (condition -> NOT condition .)
    COMMENT_MULTI   reduce using rule 72 (condition -> NOT condition .)
    COMMENT_SINGLE  reduce using rule 72 (condition -> NOT condition .)
    PRINT           reduce using rule 72 (condition -> NOT condition .)
    STRING          reduce using rule 72 (condition -> NOT condition .)
    VAR             reduce using rule 72 (condition -> NOT condition .)
    FINAL           reduce using rule 72 (condition -> NOT condition .)
    ID              reduce using rule 72 (condition -> NOT condition .)
    VOID            reduce using rule 72 (condition -> NOT condition .)
    LIST            reduce using rule 72 (condition -> NOT condition .)
    DYNAMIC         reduce using rule 72 (condition -> NOT condition .)
    RETURN          reduce using rule 72 (condition -> NOT condition .)
    MAP             reduce using rule 72 (condition -> NOT condition .)
    WHILE           reduce using rule 72 (condition -> NOT condition .)
    INT             reduce using rule 72 (condition -> NOT condition .)
    DOUBLE          reduce using rule 72 (condition -> NOT condition .)
    BOOL            reduce using rule 72 (condition -> NOT condition .)
    IF              reduce using rule 72 (condition -> NOT condition .)
    FOR             reduce using rule 72 (condition -> NOT condition .)
    $end            reduce using rule 72 (condition -> NOT condition .)
    RBRACKET        reduce using rule 72 (condition -> NOT condition .)


state 129

    (71) condition -> value . comparator value
    (73) comparator -> . GREATER
    (74) comparator -> . LESS
    (75) comparator -> . EQUALS
    (76) comparator -> . GREATER_EQUAL
    (77) comparator -> . LESS_EQUAL
    (78) comparator -> . NOT_EQUALS

    GREATER         shift and go to state 113
    LESS            shift and go to state 114
    EQUALS          shift and go to state 115
    GREATER_EQUAL   shift and go to state 116
    LESS_EQUAL      shift and go to state 117
    NOT_EQUALS      shift and go to state 118

    comparator                     shift and go to state 112

state 130

    (124) map_declaration -> MAP LESS key_type . COMMA type GREATER ID ASSIGN

    COMMA           shift and go to state 182


state 131

    (130) key_type -> STRING .

    COMMA           reduce using rule 130 (key_type -> STRING .)


state 132

    (62) control_structures_if_else -> if_block else_if_blocks else_block .

    COMMENT_MULTI   reduce using rule 62 (control_structures_if_else -> if_block else_if_blocks else_block .)
    COMMENT_SINGLE  reduce using rule 62 (control_structures_if_else -> if_block else_if_blocks else_block .)
    SEMICOLON       reduce using rule 62 (control_structures_if_else -> if_block else_if_blocks else_block .)
    PRINT           reduce using rule 62 (control_structures_if_else -> if_block else_if_blocks else_block .)
    STRING          reduce using rule 62 (control_structures_if_else -> if_block else_if_blocks else_block .)
    VAR             reduce using rule 62 (control_structures_if_else -> if_block else_if_blocks else_block .)
    FINAL           reduce using rule 62 (control_structures_if_else -> if_block else_if_blocks else_block .)
    ID              reduce using rule 62 (control_structures_if_else -> if_block else_if_blocks else_block .)
    VOID            reduce using rule 62 (control_structures_if_else -> if_block else_if_blocks else_block .)
    LIST            reduce using rule 62 (control_structures_if_else -> if_block else_if_blocks else_block .)
    DYNAMIC         reduce using rule 62 (control_structures_if_else -> if_block else_if_blocks else_block .)
    RETURN          reduce using rule 62 (control_structures_if_else -> if_block else_if_blocks else_block .)
    MAP             reduce using rule 62 (control_structures_if_else -> if_block else_if_blocks else_block .)
    WHILE           reduce using rule 62 (control_structures_if_else -> if_block else_if_blocks else_block .)
    INT             reduce using rule 62 (control_structures_if_else -> if_block else_if_blocks else_block .)
    DOUBLE          reduce using rule 62 (control_structures_if_else -> if_block else_if_blocks else_block .)
    BOOL            reduce using rule 62 (control_structures_if_else -> if_block else_if_blocks else_block .)
    IF              reduce using rule 62 (control_structures_if_else -> if_block else_if_blocks else_block .)
    FOR             reduce using rule 62 (control_structures_if_else -> if_block else_if_blocks else_block .)
    $end            reduce using rule 62 (control_structures_if_else -> if_block else_if_blocks else_block .)
    RBRACKET        reduce using rule 62 (control_structures_if_else -> if_block else_if_blocks else_block .)


state 133

    (66) else_if_blocks -> else_if_blocks ELSE . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (67) else_block -> ELSE . LBRACKET statement_list RBRACKET

    IF              shift and go to state 183
    LBRACKET        shift and go to state 135


state 134

    (65) else_if_blocks -> ELSE IF . LPAREN conditions RPAREN LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 184


state 135

    (67) else_block -> ELSE LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (97) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (98) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (99) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (123) map -> . map_declaration map_assignment
    (120) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (121) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (84) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN value SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (124) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (60) control_structures_if_else -> . if_block
    (61) control_structures_if_else -> . if_block else_if_blocks
    (62) control_structures_if_else -> . if_block else_if_blocks else_block
    (63) control_structures_if_else -> . if_block else_block
    (115) control_structures_for -> . for_classic
    (116) control_structures_for -> . for_in
    (117) control_structures_for -> . for_each
    (122) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (64) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (108) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (110) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (114) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement_list                 shift and go to state 185
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 136

    (122) control_structures_while -> WHILE LPAREN conditions . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 186


state 137

    (64) if_block -> IF LPAREN conditions . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 187


state 138

    (108) for_classic -> FOR LPAREN for_classic_parenthesis_content . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 188


state 139

    (110) for_in -> FOR LPAREN for_in_parenthesis_content . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 189


state 140

    (114) for_each -> FOR LPAREN for_each_parenthesis_content . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 190


state 141

    (107) for_classic_parenthesis_content -> for_classic_initialization . SEMICOLON for_classic_conditions SEMICOLON for_classic_changes

    SEMICOLON       shift and go to state 191


state 142

    (109) for_in_parenthesis_content -> FINAL . ID IN ID
    (113) for_each_parenthesis_content -> FINAL . ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID

    ID              shift and go to state 192


state 143

    (100) for_classic_initialization -> INT . ID ASSIGN NUMBER

    ID              shift and go to state 193


state 144

    (101) for_classic_initialization -> DOUBLE . ID ASSIGN NDOUBLE

    ID              shift and go to state 194


state 145

    (43) print -> PRINT LPAREN RPAREN SEMICOLON .

    COMMENT_MULTI   reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    RETURN          reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)


state 146

    (44) print -> PRINT LPAREN print_options RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 195


state 147

    (29) length -> call_list DOT . LENGTH

    LENGTH          shift and go to state 196


state 148

    (30) length -> TEXT DOT . LENGTH

    LENGTH          shift and go to state 197


state 149

    (31) length -> ID DOT . LENGTH

    LENGTH          shift and go to state 198


state 150

    (25) call_function -> ID LPAREN . argument_list RPAREN
    (26) call_function -> ID LPAREN . RPAREN
    (32) argument_list -> . expression
    (33) argument_list -> . argument_list COMMA expression
    (48) expression -> . operations
    (58) expression -> . conditions
    (59) expression -> . value
    (49) operations -> . operation
    (50) operations -> . operation operand operations
    (68) conditions -> . condition
    (69) conditions -> . condition AND conditions
    (70) conditions -> . condition OR conditions
    (91) value -> . NUMBER
    (92) value -> . NDOUBLE
    (93) value -> . TEXT
    (94) value -> . ID
    (95) value -> . TRUE
    (96) value -> . FALSE
    (51) operation -> . operand operator operand
    (71) condition -> . value comparator value
    (72) condition -> . NOT condition
    (52) operand -> . NUMBER
    (53) operand -> . DOUBLE

    RPAREN          shift and go to state 93
    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 68
    ID              shift and go to state 69
    TRUE            shift and go to state 70
    FALSE           shift and go to state 71
    NOT             shift and go to state 72
    DOUBLE          shift and go to state 73

    argument_list                  shift and go to state 94
    expression                     shift and go to state 96
    operations                     shift and go to state 60
    conditions                     shift and go to state 61
    value                          shift and go to state 62
    operation                      shift and go to state 63
    operand                        shift and go to state 64
    condition                      shift and go to state 65

state 151

    (83) call_list -> LSBRACKET value_list . RSBRACKET

    RSBRACKET       shift and go to state 199


state 152

    (85) value_list -> value .
    (86) value_list -> value . COMMA value_list

    RSBRACKET       reduce using rule 85 (value_list -> value .)
    RBRACKET        reduce using rule 85 (value_list -> value .)
    COMMA           shift and go to state 200


state 153

    (27) data_input -> STRING ID ASSIGN STDIN . DOT READLINESYNC LPAREN RPAREN SEMICOLON

    DOT             shift and go to state 201


state 154

    (28) data_input -> STRING QUESTION ID ASSIGN . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    STDIN           shift and go to state 202


state 155

    (120) constructor -> ID LPAREN constructor_parenthesis_content RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 203


state 156

    (25) call_function -> ID LPAREN argument_list RPAREN .

    COMMENT_MULTI   reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    COMMENT_SINGLE  reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    SEMICOLON       reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    PRINT           reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    STRING          reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    VAR             reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    FINAL           reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    ID              reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    VOID            reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    LIST            reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    DYNAMIC         reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    RETURN          reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    MAP             reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    WHILE           reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    INT             reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    DOUBLE          reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    BOOL            reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    IF              reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    FOR             reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    $end            reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    RPAREN          reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    RBRACKET        reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)


state 157

    (33) argument_list -> argument_list COMMA . expression
    (48) expression -> . operations
    (58) expression -> . conditions
    (59) expression -> . value
    (49) operations -> . operation
    (50) operations -> . operation operand operations
    (68) conditions -> . condition
    (69) conditions -> . condition AND conditions
    (70) conditions -> . condition OR conditions
    (91) value -> . NUMBER
    (92) value -> . NDOUBLE
    (93) value -> . TEXT
    (94) value -> . ID
    (95) value -> . TRUE
    (96) value -> . FALSE
    (51) operation -> . operand operator operand
    (71) condition -> . value comparator value
    (72) condition -> . NOT condition
    (52) operand -> . NUMBER
    (53) operand -> . DOUBLE

    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 68
    ID              shift and go to state 69
    TRUE            shift and go to state 70
    FALSE           shift and go to state 71
    NOT             shift and go to state 72
    DOUBLE          shift and go to state 73

    expression                     shift and go to state 204
    operations                     shift and go to state 60
    conditions                     shift and go to state 61
    value                          shift and go to state 62
    operation                      shift and go to state 63
    operand                        shift and go to state 64
    condition                      shift and go to state 65

state 158

    (118) constructor_parenthesis_content -> THIS DOT . ID
    (119) constructor_parenthesis_content -> THIS DOT . ID COMMA constructor_parenthesis_content

    ID              shift and go to state 205


state 159

    (24) variable_usage -> ID ASSIGN value SEMICOLON .

    COMMENT_MULTI   reduce using rule 24 (variable_usage -> ID ASSIGN value SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 24 (variable_usage -> ID ASSIGN value SEMICOLON .)
    SEMICOLON       reduce using rule 24 (variable_usage -> ID ASSIGN value SEMICOLON .)
    PRINT           reduce using rule 24 (variable_usage -> ID ASSIGN value SEMICOLON .)
    STRING          reduce using rule 24 (variable_usage -> ID ASSIGN value SEMICOLON .)
    VAR             reduce using rule 24 (variable_usage -> ID ASSIGN value SEMICOLON .)
    FINAL           reduce using rule 24 (variable_usage -> ID ASSIGN value SEMICOLON .)
    ID              reduce using rule 24 (variable_usage -> ID ASSIGN value SEMICOLON .)
    VOID            reduce using rule 24 (variable_usage -> ID ASSIGN value SEMICOLON .)
    LIST            reduce using rule 24 (variable_usage -> ID ASSIGN value SEMICOLON .)
    DYNAMIC         reduce using rule 24 (variable_usage -> ID ASSIGN value SEMICOLON .)
    RETURN          reduce using rule 24 (variable_usage -> ID ASSIGN value SEMICOLON .)
    MAP             reduce using rule 24 (variable_usage -> ID ASSIGN value SEMICOLON .)
    WHILE           reduce using rule 24 (variable_usage -> ID ASSIGN value SEMICOLON .)
    INT             reduce using rule 24 (variable_usage -> ID ASSIGN value SEMICOLON .)
    DOUBLE          reduce using rule 24 (variable_usage -> ID ASSIGN value SEMICOLON .)
    BOOL            reduce using rule 24 (variable_usage -> ID ASSIGN value SEMICOLON .)
    IF              reduce using rule 24 (variable_usage -> ID ASSIGN value SEMICOLON .)
    FOR             reduce using rule 24 (variable_usage -> ID ASSIGN value SEMICOLON .)
    $end            reduce using rule 24 (variable_usage -> ID ASSIGN value SEMICOLON .)
    RBRACKET        reduce using rule 24 (variable_usage -> ID ASSIGN value SEMICOLON .)


state 160

    (97) set -> VAR ID ASSIGN LBRACKET . value_list RBRACKET SEMICOLON
    (85) value_list -> . value
    (86) value_list -> . value COMMA value_list
    (91) value -> . NUMBER
    (92) value -> . NDOUBLE
    (93) value -> . TEXT
    (94) value -> . ID
    (95) value -> . TRUE
    (96) value -> . FALSE

    NUMBER          shift and go to state 98
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 68
    ID              shift and go to state 69
    TRUE            shift and go to state 70
    FALSE           shift and go to state 71

    value_list                     shift and go to state 206
    value                          shift and go to state 152

state 161

    (98) set -> VAR ID ASSIGN LESS . STRING GREATER LBRACKET RBRACKET SEMICOLON

    STRING          shift and go to state 207


state 162

    (42) variable_definition -> VAR ID ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 208


state 163

    (99) set -> FINAL ID ASSIGN CONST . LBRACKET value_list RBRACKET SEMICOLON

    LBRACKET        shift and go to state 209


state 164

    (125) map_assignment -> LBRACKET map_contents RBRACKET .

    COMMENT_MULTI   reduce using rule 125 (map_assignment -> LBRACKET map_contents RBRACKET .)
    COMMENT_SINGLE  reduce using rule 125 (map_assignment -> LBRACKET map_contents RBRACKET .)
    SEMICOLON       reduce using rule 125 (map_assignment -> LBRACKET map_contents RBRACKET .)
    PRINT           reduce using rule 125 (map_assignment -> LBRACKET map_contents RBRACKET .)
    STRING          reduce using rule 125 (map_assignment -> LBRACKET map_contents RBRACKET .)
    VAR             reduce using rule 125 (map_assignment -> LBRACKET map_contents RBRACKET .)
    FINAL           reduce using rule 125 (map_assignment -> LBRACKET map_contents RBRACKET .)
    ID              reduce using rule 125 (map_assignment -> LBRACKET map_contents RBRACKET .)
    VOID            reduce using rule 125 (map_assignment -> LBRACKET map_contents RBRACKET .)
    LIST            reduce using rule 125 (map_assignment -> LBRACKET map_contents RBRACKET .)
    DYNAMIC         reduce using rule 125 (map_assignment -> LBRACKET map_contents RBRACKET .)
    RETURN          reduce using rule 125 (map_assignment -> LBRACKET map_contents RBRACKET .)
    MAP             reduce using rule 125 (map_assignment -> LBRACKET map_contents RBRACKET .)
    WHILE           reduce using rule 125 (map_assignment -> LBRACKET map_contents RBRACKET .)
    INT             reduce using rule 125 (map_assignment -> LBRACKET map_contents RBRACKET .)
    DOUBLE          reduce using rule 125 (map_assignment -> LBRACKET map_contents RBRACKET .)
    BOOL            reduce using rule 125 (map_assignment -> LBRACKET map_contents RBRACKET .)
    IF              reduce using rule 125 (map_assignment -> LBRACKET map_contents RBRACKET .)
    FOR             reduce using rule 125 (map_assignment -> LBRACKET map_contents RBRACKET .)
    $end            reduce using rule 125 (map_assignment -> LBRACKET map_contents RBRACKET .)
    RBRACKET        reduce using rule 125 (map_assignment -> LBRACKET map_contents RBRACKET .)


state 165

    (127) map_contents -> map_content COMMA . map_contents
    (126) map_contents -> . map_content
    (127) map_contents -> . map_content COMMA map_contents
    (128) map_content -> . key_value COLON value
    (129) key_value -> . TEXT

    TEXT            shift and go to state 104

    map_content                    shift and go to state 102
    map_contents                   shift and go to state 210
    key_value                      shift and go to state 103

state 166

    (128) map_content -> key_value COLON . value
    (91) value -> . NUMBER
    (92) value -> . NDOUBLE
    (93) value -> . TEXT
    (94) value -> . ID
    (95) value -> . TRUE
    (96) value -> . FALSE

    NUMBER          shift and go to state 98
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 68
    ID              shift and go to state 69
    TRUE            shift and go to state 70
    FALSE           shift and go to state 71

    value                          shift and go to state 211

state 167

    (81) parameter -> type . ID

    ID              shift and go to state 212


state 168

    (34) function -> type ID LPAREN parameter_list . RPAREN LBRACKET statement_list RBRACKET
    (121) function -> type ID LPAREN parameter_list . RPAREN ASSIGN GREATER expression
    (80) parameter_list -> parameter_list . COMMA parameter

    RPAREN          shift and go to state 213
    COMMA           shift and go to state 214


state 169

    (36) function -> type ID LPAREN RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 215


state 170

    (79) parameter_list -> parameter .

    RPAREN          reduce using rule 79 (parameter_list -> parameter .)
    COMMA           reduce using rule 79 (parameter_list -> parameter .)


state 171

    (82) parameter -> REQUIRED . type ID
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL

    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 109
    BOOL            shift and go to state 41

    type                           shift and go to state 216

state 172

    (40) variable_definition -> type ID ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 217


state 173

    (35) function -> VOID ID LPAREN parameter_list . RPAREN LBRACKET statement_list RBRACKET
    (39) function -> VOID ID LPAREN parameter_list . RPAREN LBRACKET RBRACKET
    (80) parameter_list -> parameter_list . COMMA parameter

    RPAREN          shift and go to state 218
    COMMA           shift and go to state 214


state 174

    (37) function -> VOID ID LPAREN RPAREN . LBRACKET statement_list RBRACKET
    (38) function -> VOID ID LPAREN RPAREN . LBRACKET RBRACKET

    LBRACKET        shift and go to state 219


state 175

    (84) list_definition -> LIST LESS type GREATER . ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON

    ID              shift and go to state 220


state 176

    (41) variable_definition -> DYNAMIC ID ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 221


state 177

    (71) condition -> value comparator value .

    AND             reduce using rule 71 (condition -> value comparator value .)
    OR              reduce using rule 71 (condition -> value comparator value .)
    SEMICOLON       reduce using rule 71 (condition -> value comparator value .)
    RPAREN          reduce using rule 71 (condition -> value comparator value .)
    COMMA           reduce using rule 71 (condition -> value comparator value .)
    LBRACKET        reduce using rule 71 (condition -> value comparator value .)
    COMMENT_MULTI   reduce using rule 71 (condition -> value comparator value .)
    COMMENT_SINGLE  reduce using rule 71 (condition -> value comparator value .)
    PRINT           reduce using rule 71 (condition -> value comparator value .)
    STRING          reduce using rule 71 (condition -> value comparator value .)
    VAR             reduce using rule 71 (condition -> value comparator value .)
    FINAL           reduce using rule 71 (condition -> value comparator value .)
    ID              reduce using rule 71 (condition -> value comparator value .)
    VOID            reduce using rule 71 (condition -> value comparator value .)
    LIST            reduce using rule 71 (condition -> value comparator value .)
    DYNAMIC         reduce using rule 71 (condition -> value comparator value .)
    RETURN          reduce using rule 71 (condition -> value comparator value .)
    MAP             reduce using rule 71 (condition -> value comparator value .)
    WHILE           reduce using rule 71 (condition -> value comparator value .)
    INT             reduce using rule 71 (condition -> value comparator value .)
    DOUBLE          reduce using rule 71 (condition -> value comparator value .)
    BOOL            reduce using rule 71 (condition -> value comparator value .)
    IF              reduce using rule 71 (condition -> value comparator value .)
    FOR             reduce using rule 71 (condition -> value comparator value .)
    $end            reduce using rule 71 (condition -> value comparator value .)
    RBRACKET        reduce using rule 71 (condition -> value comparator value .)


state 178

    (50) operations -> operation operand operations .

    SEMICOLON       reduce using rule 50 (operations -> operation operand operations .)
    RPAREN          reduce using rule 50 (operations -> operation operand operations .)
    COMMA           reduce using rule 50 (operations -> operation operand operations .)
    COMMENT_MULTI   reduce using rule 50 (operations -> operation operand operations .)
    COMMENT_SINGLE  reduce using rule 50 (operations -> operation operand operations .)
    PRINT           reduce using rule 50 (operations -> operation operand operations .)
    STRING          reduce using rule 50 (operations -> operation operand operations .)
    VAR             reduce using rule 50 (operations -> operation operand operations .)
    FINAL           reduce using rule 50 (operations -> operation operand operations .)
    ID              reduce using rule 50 (operations -> operation operand operations .)
    VOID            reduce using rule 50 (operations -> operation operand operations .)
    LIST            reduce using rule 50 (operations -> operation operand operations .)
    DYNAMIC         reduce using rule 50 (operations -> operation operand operations .)
    RETURN          reduce using rule 50 (operations -> operation operand operations .)
    MAP             reduce using rule 50 (operations -> operation operand operations .)
    WHILE           reduce using rule 50 (operations -> operation operand operations .)
    INT             reduce using rule 50 (operations -> operation operand operations .)
    DOUBLE          reduce using rule 50 (operations -> operation operand operations .)
    BOOL            reduce using rule 50 (operations -> operation operand operations .)
    IF              reduce using rule 50 (operations -> operation operand operations .)
    FOR             reduce using rule 50 (operations -> operation operand operations .)
    $end            reduce using rule 50 (operations -> operation operand operations .)
    RBRACKET        reduce using rule 50 (operations -> operation operand operations .)


state 179

    (51) operation -> operand operator operand .

    NUMBER          reduce using rule 51 (operation -> operand operator operand .)
    DOUBLE          reduce using rule 51 (operation -> operand operator operand .)
    SEMICOLON       reduce using rule 51 (operation -> operand operator operand .)
    RPAREN          reduce using rule 51 (operation -> operand operator operand .)
    COMMA           reduce using rule 51 (operation -> operand operator operand .)
    COMMENT_MULTI   reduce using rule 51 (operation -> operand operator operand .)
    COMMENT_SINGLE  reduce using rule 51 (operation -> operand operator operand .)
    PRINT           reduce using rule 51 (operation -> operand operator operand .)
    STRING          reduce using rule 51 (operation -> operand operator operand .)
    VAR             reduce using rule 51 (operation -> operand operator operand .)
    FINAL           reduce using rule 51 (operation -> operand operator operand .)
    ID              reduce using rule 51 (operation -> operand operator operand .)
    VOID            reduce using rule 51 (operation -> operand operator operand .)
    LIST            reduce using rule 51 (operation -> operand operator operand .)
    DYNAMIC         reduce using rule 51 (operation -> operand operator operand .)
    RETURN          reduce using rule 51 (operation -> operand operator operand .)
    MAP             reduce using rule 51 (operation -> operand operator operand .)
    WHILE           reduce using rule 51 (operation -> operand operator operand .)
    INT             reduce using rule 51 (operation -> operand operator operand .)
    BOOL            reduce using rule 51 (operation -> operand operator operand .)
    IF              reduce using rule 51 (operation -> operand operator operand .)
    FOR             reduce using rule 51 (operation -> operand operator operand .)
    $end            reduce using rule 51 (operation -> operand operator operand .)
    RBRACKET        reduce using rule 51 (operation -> operand operator operand .)


state 180

    (69) conditions -> condition AND conditions .

    SEMICOLON       reduce using rule 69 (conditions -> condition AND conditions .)
    RPAREN          reduce using rule 69 (conditions -> condition AND conditions .)
    COMMA           reduce using rule 69 (conditions -> condition AND conditions .)
    LBRACKET        reduce using rule 69 (conditions -> condition AND conditions .)
    COMMENT_MULTI   reduce using rule 69 (conditions -> condition AND conditions .)
    COMMENT_SINGLE  reduce using rule 69 (conditions -> condition AND conditions .)
    PRINT           reduce using rule 69 (conditions -> condition AND conditions .)
    STRING          reduce using rule 69 (conditions -> condition AND conditions .)
    VAR             reduce using rule 69 (conditions -> condition AND conditions .)
    FINAL           reduce using rule 69 (conditions -> condition AND conditions .)
    ID              reduce using rule 69 (conditions -> condition AND conditions .)
    VOID            reduce using rule 69 (conditions -> condition AND conditions .)
    LIST            reduce using rule 69 (conditions -> condition AND conditions .)
    DYNAMIC         reduce using rule 69 (conditions -> condition AND conditions .)
    RETURN          reduce using rule 69 (conditions -> condition AND conditions .)
    MAP             reduce using rule 69 (conditions -> condition AND conditions .)
    WHILE           reduce using rule 69 (conditions -> condition AND conditions .)
    INT             reduce using rule 69 (conditions -> condition AND conditions .)
    DOUBLE          reduce using rule 69 (conditions -> condition AND conditions .)
    BOOL            reduce using rule 69 (conditions -> condition AND conditions .)
    IF              reduce using rule 69 (conditions -> condition AND conditions .)
    FOR             reduce using rule 69 (conditions -> condition AND conditions .)
    $end            reduce using rule 69 (conditions -> condition AND conditions .)
    RBRACKET        reduce using rule 69 (conditions -> condition AND conditions .)


state 181

    (70) conditions -> condition OR conditions .

    SEMICOLON       reduce using rule 70 (conditions -> condition OR conditions .)
    RPAREN          reduce using rule 70 (conditions -> condition OR conditions .)
    COMMA           reduce using rule 70 (conditions -> condition OR conditions .)
    LBRACKET        reduce using rule 70 (conditions -> condition OR conditions .)
    COMMENT_MULTI   reduce using rule 70 (conditions -> condition OR conditions .)
    COMMENT_SINGLE  reduce using rule 70 (conditions -> condition OR conditions .)
    PRINT           reduce using rule 70 (conditions -> condition OR conditions .)
    STRING          reduce using rule 70 (conditions -> condition OR conditions .)
    VAR             reduce using rule 70 (conditions -> condition OR conditions .)
    FINAL           reduce using rule 70 (conditions -> condition OR conditions .)
    ID              reduce using rule 70 (conditions -> condition OR conditions .)
    VOID            reduce using rule 70 (conditions -> condition OR conditions .)
    LIST            reduce using rule 70 (conditions -> condition OR conditions .)
    DYNAMIC         reduce using rule 70 (conditions -> condition OR conditions .)
    RETURN          reduce using rule 70 (conditions -> condition OR conditions .)
    MAP             reduce using rule 70 (conditions -> condition OR conditions .)
    WHILE           reduce using rule 70 (conditions -> condition OR conditions .)
    INT             reduce using rule 70 (conditions -> condition OR conditions .)
    DOUBLE          reduce using rule 70 (conditions -> condition OR conditions .)
    BOOL            reduce using rule 70 (conditions -> condition OR conditions .)
    IF              reduce using rule 70 (conditions -> condition OR conditions .)
    FOR             reduce using rule 70 (conditions -> condition OR conditions .)
    $end            reduce using rule 70 (conditions -> condition OR conditions .)
    RBRACKET        reduce using rule 70 (conditions -> condition OR conditions .)


state 182

    (124) map_declaration -> MAP LESS key_type COMMA . type GREATER ID ASSIGN
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL

    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 109
    BOOL            shift and go to state 41

    type                           shift and go to state 222

state 183

    (66) else_if_blocks -> else_if_blocks ELSE IF . LPAREN conditions RPAREN LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 223


state 184

    (65) else_if_blocks -> ELSE IF LPAREN . conditions RPAREN LBRACKET statement_list RBRACKET
    (68) conditions -> . condition
    (69) conditions -> . condition AND conditions
    (70) conditions -> . condition OR conditions
    (71) condition -> . value comparator value
    (72) condition -> . NOT condition
    (91) value -> . NUMBER
    (92) value -> . NDOUBLE
    (93) value -> . TEXT
    (94) value -> . ID
    (95) value -> . TRUE
    (96) value -> . FALSE

    NOT             shift and go to state 72
    NUMBER          shift and go to state 98
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 68
    ID              shift and go to state 69
    TRUE            shift and go to state 70
    FALSE           shift and go to state 71

    conditions                     shift and go to state 224
    condition                      shift and go to state 65
    value                          shift and go to state 129

state 185

    (67) else_block -> ELSE LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (97) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (98) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (99) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (123) map -> . map_declaration map_assignment
    (120) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (121) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (84) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN value SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (124) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (60) control_structures_if_else -> . if_block
    (61) control_structures_if_else -> . if_block else_if_blocks
    (62) control_structures_if_else -> . if_block else_if_blocks else_block
    (63) control_structures_if_else -> . if_block else_block
    (115) control_structures_for -> . for_classic
    (116) control_structures_for -> . for_in
    (117) control_structures_for -> . for_each
    (122) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (64) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (108) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (110) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (114) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 225
    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement                      shift and go to state 44
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 186

    (122) control_structures_while -> WHILE LPAREN conditions LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (97) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (98) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (99) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (123) map -> . map_declaration map_assignment
    (120) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (121) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (84) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN value SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (124) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (60) control_structures_if_else -> . if_block
    (61) control_structures_if_else -> . if_block else_if_blocks
    (62) control_structures_if_else -> . if_block else_if_blocks else_block
    (63) control_structures_if_else -> . if_block else_block
    (115) control_structures_for -> . for_classic
    (116) control_structures_for -> . for_in
    (117) control_structures_for -> . for_each
    (122) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (64) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (108) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (110) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (114) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement_list                 shift and go to state 226
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 187

    (64) if_block -> IF LPAREN conditions RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 227


state 188

    (108) for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 228


state 189

    (110) for_in -> FOR LPAREN for_in_parenthesis_content RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 229


state 190

    (114) for_each -> FOR LPAREN for_each_parenthesis_content RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 230


state 191

    (107) for_classic_parenthesis_content -> for_classic_initialization SEMICOLON . for_classic_conditions SEMICOLON for_classic_changes
    (102) for_classic_conditions -> . conditions
    (68) conditions -> . condition
    (69) conditions -> . condition AND conditions
    (70) conditions -> . condition OR conditions
    (71) condition -> . value comparator value
    (72) condition -> . NOT condition
    (91) value -> . NUMBER
    (92) value -> . NDOUBLE
    (93) value -> . TEXT
    (94) value -> . ID
    (95) value -> . TRUE
    (96) value -> . FALSE

    NOT             shift and go to state 72
    NUMBER          shift and go to state 98
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 68
    ID              shift and go to state 69
    TRUE            shift and go to state 70
    FALSE           shift and go to state 71

    for_classic_conditions         shift and go to state 231
    conditions                     shift and go to state 232
    condition                      shift and go to state 65
    value                          shift and go to state 129

state 192

    (109) for_in_parenthesis_content -> FINAL ID . IN ID
    (113) for_each_parenthesis_content -> FINAL ID . LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID

    IN              shift and go to state 233
    LPAREN          shift and go to state 234


state 193

    (100) for_classic_initialization -> INT ID . ASSIGN NUMBER

    ASSIGN          shift and go to state 235


state 194

    (101) for_classic_initialization -> DOUBLE ID . ASSIGN NDOUBLE

    ASSIGN          shift and go to state 236


state 195

    (44) print -> PRINT LPAREN print_options RPAREN SEMICOLON .

    COMMENT_MULTI   reduce using rule 44 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 44 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 44 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    PRINT           reduce using rule 44 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    STRING          reduce using rule 44 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    VAR             reduce using rule 44 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    FINAL           reduce using rule 44 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    ID              reduce using rule 44 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    VOID            reduce using rule 44 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    LIST            reduce using rule 44 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 44 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    RETURN          reduce using rule 44 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    MAP             reduce using rule 44 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    WHILE           reduce using rule 44 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    INT             reduce using rule 44 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 44 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    BOOL            reduce using rule 44 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    IF              reduce using rule 44 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    FOR             reduce using rule 44 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    $end            reduce using rule 44 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 44 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)


state 196

    (29) length -> call_list DOT LENGTH .

    RPAREN          reduce using rule 29 (length -> call_list DOT LENGTH .)


state 197

    (30) length -> TEXT DOT LENGTH .

    RPAREN          reduce using rule 30 (length -> TEXT DOT LENGTH .)


state 198

    (31) length -> ID DOT LENGTH .

    RPAREN          reduce using rule 31 (length -> ID DOT LENGTH .)


state 199

    (83) call_list -> LSBRACKET value_list RSBRACKET .

    DOT             reduce using rule 83 (call_list -> LSBRACKET value_list RSBRACKET .)


state 200

    (86) value_list -> value COMMA . value_list
    (85) value_list -> . value
    (86) value_list -> . value COMMA value_list
    (91) value -> . NUMBER
    (92) value -> . NDOUBLE
    (93) value -> . TEXT
    (94) value -> . ID
    (95) value -> . TRUE
    (96) value -> . FALSE

    NUMBER          shift and go to state 98
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 68
    ID              shift and go to state 69
    TRUE            shift and go to state 70
    FALSE           shift and go to state 71

    value                          shift and go to state 152
    value_list                     shift and go to state 237

state 201

    (27) data_input -> STRING ID ASSIGN STDIN DOT . READLINESYNC LPAREN RPAREN SEMICOLON

    READLINESYNC    shift and go to state 238


state 202

    (28) data_input -> STRING QUESTION ID ASSIGN STDIN . DOT READLINESYNC LPAREN RPAREN SEMICOLON

    DOT             shift and go to state 239


state 203

    (120) constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .

    COMMENT_MULTI   reduce using rule 120 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 120 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 120 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    PRINT           reduce using rule 120 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    STRING          reduce using rule 120 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    VAR             reduce using rule 120 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    FINAL           reduce using rule 120 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    ID              reduce using rule 120 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    VOID            reduce using rule 120 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    LIST            reduce using rule 120 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 120 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    RETURN          reduce using rule 120 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    MAP             reduce using rule 120 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    WHILE           reduce using rule 120 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    INT             reduce using rule 120 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 120 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    BOOL            reduce using rule 120 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    IF              reduce using rule 120 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    FOR             reduce using rule 120 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    $end            reduce using rule 120 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 120 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)


state 204

    (33) argument_list -> argument_list COMMA expression .

    RPAREN          reduce using rule 33 (argument_list -> argument_list COMMA expression .)
    COMMA           reduce using rule 33 (argument_list -> argument_list COMMA expression .)


state 205

    (118) constructor_parenthesis_content -> THIS DOT ID .
    (119) constructor_parenthesis_content -> THIS DOT ID . COMMA constructor_parenthesis_content

    RPAREN          reduce using rule 118 (constructor_parenthesis_content -> THIS DOT ID .)
    COMMA           shift and go to state 240


state 206

    (97) set -> VAR ID ASSIGN LBRACKET value_list . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 241


state 207

    (98) set -> VAR ID ASSIGN LESS STRING . GREATER LBRACKET RBRACKET SEMICOLON

    GREATER         shift and go to state 242


state 208

    (42) variable_definition -> VAR ID ASSIGN expression SEMICOLON .

    COMMENT_MULTI   reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    DYNAMIC         reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    RETURN          reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    RBRACKET        reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)


state 209

    (99) set -> FINAL ID ASSIGN CONST LBRACKET . value_list RBRACKET SEMICOLON
    (85) value_list -> . value
    (86) value_list -> . value COMMA value_list
    (91) value -> . NUMBER
    (92) value -> . NDOUBLE
    (93) value -> . TEXT
    (94) value -> . ID
    (95) value -> . TRUE
    (96) value -> . FALSE

    NUMBER          shift and go to state 98
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 68
    ID              shift and go to state 69
    TRUE            shift and go to state 70
    FALSE           shift and go to state 71

    value_list                     shift and go to state 243
    value                          shift and go to state 152

state 210

    (127) map_contents -> map_content COMMA map_contents .

    RBRACKET        reduce using rule 127 (map_contents -> map_content COMMA map_contents .)


state 211

    (128) map_content -> key_value COLON value .

    COMMA           reduce using rule 128 (map_content -> key_value COLON value .)
    RBRACKET        reduce using rule 128 (map_content -> key_value COLON value .)


state 212

    (81) parameter -> type ID .

    RPAREN          reduce using rule 81 (parameter -> type ID .)
    COMMA           reduce using rule 81 (parameter -> type ID .)


state 213

    (34) function -> type ID LPAREN parameter_list RPAREN . LBRACKET statement_list RBRACKET
    (121) function -> type ID LPAREN parameter_list RPAREN . ASSIGN GREATER expression

    LBRACKET        shift and go to state 244
    ASSIGN          shift and go to state 245


state 214

    (80) parameter_list -> parameter_list COMMA . parameter
    (81) parameter -> . type ID
    (82) parameter -> . REQUIRED type ID
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL

    REQUIRED        shift and go to state 171
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 109
    BOOL            shift and go to state 41

    parameter                      shift and go to state 246
    type                           shift and go to state 167

state 215

    (36) function -> type ID LPAREN RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (97) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (98) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (99) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (123) map -> . map_declaration map_assignment
    (120) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (121) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (84) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN value SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (124) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (60) control_structures_if_else -> . if_block
    (61) control_structures_if_else -> . if_block else_if_blocks
    (62) control_structures_if_else -> . if_block else_if_blocks else_block
    (63) control_structures_if_else -> . if_block else_block
    (115) control_structures_for -> . for_classic
    (116) control_structures_for -> . for_in
    (117) control_structures_for -> . for_each
    (122) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (64) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (108) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (110) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (114) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    type                           shift and go to state 28
    statement_list                 shift and go to state 247
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 216

    (82) parameter -> REQUIRED type . ID

    ID              shift and go to state 248


state 217

    (40) variable_definition -> type ID ASSIGN expression SEMICOLON .

    COMMENT_MULTI   reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    DYNAMIC         reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    RETURN          reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    RBRACKET        reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)


state 218

    (35) function -> VOID ID LPAREN parameter_list RPAREN . LBRACKET statement_list RBRACKET
    (39) function -> VOID ID LPAREN parameter_list RPAREN . LBRACKET RBRACKET

    LBRACKET        shift and go to state 249


state 219

    (37) function -> VOID ID LPAREN RPAREN LBRACKET . statement_list RBRACKET
    (38) function -> VOID ID LPAREN RPAREN LBRACKET . RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (97) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (98) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (99) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (123) map -> . map_declaration map_assignment
    (120) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (121) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (84) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN value SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (124) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (60) control_structures_if_else -> . if_block
    (61) control_structures_if_else -> . if_block else_if_blocks
    (62) control_structures_if_else -> . if_block else_if_blocks else_block
    (63) control_structures_if_else -> . if_block else_block
    (115) control_structures_for -> . for_classic
    (116) control_structures_for -> . for_in
    (117) control_structures_for -> . for_each
    (122) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (64) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (108) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (110) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (114) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 251
    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement_list                 shift and go to state 250
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 220

    (84) list_definition -> LIST LESS type GREATER ID . ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON

    ASSIGN          shift and go to state 252


state 221

    (41) variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .

    COMMENT_MULTI   reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    DYNAMIC         reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    RETURN          reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    RBRACKET        reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)


state 222

    (124) map_declaration -> MAP LESS key_type COMMA type . GREATER ID ASSIGN

    GREATER         shift and go to state 253


state 223

    (66) else_if_blocks -> else_if_blocks ELSE IF LPAREN . conditions RPAREN LBRACKET statement_list RBRACKET
    (68) conditions -> . condition
    (69) conditions -> . condition AND conditions
    (70) conditions -> . condition OR conditions
    (71) condition -> . value comparator value
    (72) condition -> . NOT condition
    (91) value -> . NUMBER
    (92) value -> . NDOUBLE
    (93) value -> . TEXT
    (94) value -> . ID
    (95) value -> . TRUE
    (96) value -> . FALSE

    NOT             shift and go to state 72
    NUMBER          shift and go to state 98
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 68
    ID              shift and go to state 69
    TRUE            shift and go to state 70
    FALSE           shift and go to state 71

    conditions                     shift and go to state 254
    condition                      shift and go to state 65
    value                          shift and go to state 129

state 224

    (65) else_if_blocks -> ELSE IF LPAREN conditions . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 255


state 225

    (67) else_block -> ELSE LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 67 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 67 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 67 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 67 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 67 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 67 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 67 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 67 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 67 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 67 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 67 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    RETURN          reduce using rule 67 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 67 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 67 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 67 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 67 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 67 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 67 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 67 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 67 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 67 (else_block -> ELSE LBRACKET statement_list RBRACKET .)


state 226

    (122) control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (97) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (98) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (99) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (123) map -> . map_declaration map_assignment
    (120) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (121) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (84) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN value SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (124) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (60) control_structures_if_else -> . if_block
    (61) control_structures_if_else -> . if_block else_if_blocks
    (62) control_structures_if_else -> . if_block else_if_blocks else_block
    (63) control_structures_if_else -> . if_block else_block
    (115) control_structures_for -> . for_classic
    (116) control_structures_for -> . for_in
    (117) control_structures_for -> . for_each
    (122) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (64) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (108) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (110) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (114) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 256
    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement                      shift and go to state 44
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 227

    (64) if_block -> IF LPAREN conditions RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (97) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (98) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (99) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (123) map -> . map_declaration map_assignment
    (120) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (121) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (84) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN value SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (124) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (60) control_structures_if_else -> . if_block
    (61) control_structures_if_else -> . if_block else_if_blocks
    (62) control_structures_if_else -> . if_block else_if_blocks else_block
    (63) control_structures_if_else -> . if_block else_block
    (115) control_structures_for -> . for_classic
    (116) control_structures_for -> . for_in
    (117) control_structures_for -> . for_each
    (122) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (64) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (108) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (110) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (114) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement_list                 shift and go to state 257
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 228

    (108) for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (97) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (98) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (99) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (123) map -> . map_declaration map_assignment
    (120) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (121) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (84) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN value SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (124) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (60) control_structures_if_else -> . if_block
    (61) control_structures_if_else -> . if_block else_if_blocks
    (62) control_structures_if_else -> . if_block else_if_blocks else_block
    (63) control_structures_if_else -> . if_block else_block
    (115) control_structures_for -> . for_classic
    (116) control_structures_for -> . for_in
    (117) control_structures_for -> . for_each
    (122) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (64) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (108) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (110) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (114) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement_list                 shift and go to state 258
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 229

    (110) for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (97) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (98) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (99) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (123) map -> . map_declaration map_assignment
    (120) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (121) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (84) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN value SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (124) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (60) control_structures_if_else -> . if_block
    (61) control_structures_if_else -> . if_block else_if_blocks
    (62) control_structures_if_else -> . if_block else_if_blocks else_block
    (63) control_structures_if_else -> . if_block else_block
    (115) control_structures_for -> . for_classic
    (116) control_structures_for -> . for_in
    (117) control_structures_for -> . for_each
    (122) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (64) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (108) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (110) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (114) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement_list                 shift and go to state 259
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 230

    (114) for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (97) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (98) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (99) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (123) map -> . map_declaration map_assignment
    (120) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (121) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (84) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN value SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (124) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (60) control_structures_if_else -> . if_block
    (61) control_structures_if_else -> . if_block else_if_blocks
    (62) control_structures_if_else -> . if_block else_if_blocks else_block
    (63) control_structures_if_else -> . if_block else_block
    (115) control_structures_for -> . for_classic
    (116) control_structures_for -> . for_in
    (117) control_structures_for -> . for_each
    (122) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (64) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (108) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (110) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (114) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement_list                 shift and go to state 260
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 231

    (107) for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions . SEMICOLON for_classic_changes

    SEMICOLON       shift and go to state 261


state 232

    (102) for_classic_conditions -> conditions .

    SEMICOLON       reduce using rule 102 (for_classic_conditions -> conditions .)


state 233

    (109) for_in_parenthesis_content -> FINAL ID IN . ID

    ID              shift and go to state 262


state 234

    (113) for_each_parenthesis_content -> FINAL ID LPAREN . for_each_parenthesis_parenthesis_content RPAREN IN ID
    (111) for_each_parenthesis_parenthesis_content -> . COLON ID
    (112) for_each_parenthesis_parenthesis_content -> . COLON ID COMMA for_each_parenthesis_parenthesis_content

    COLON           shift and go to state 264

    for_each_parenthesis_parenthesis_content shift and go to state 263

state 235

    (100) for_classic_initialization -> INT ID ASSIGN . NUMBER

    NUMBER          shift and go to state 265


state 236

    (101) for_classic_initialization -> DOUBLE ID ASSIGN . NDOUBLE

    NDOUBLE         shift and go to state 266


state 237

    (86) value_list -> value COMMA value_list .

    RSBRACKET       reduce using rule 86 (value_list -> value COMMA value_list .)
    RBRACKET        reduce using rule 86 (value_list -> value COMMA value_list .)


state 238

    (27) data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 267


state 239

    (28) data_input -> STRING QUESTION ID ASSIGN STDIN DOT . READLINESYNC LPAREN RPAREN SEMICOLON

    READLINESYNC    shift and go to state 268


state 240

    (119) constructor_parenthesis_content -> THIS DOT ID COMMA . constructor_parenthesis_content
    (118) constructor_parenthesis_content -> . THIS DOT ID
    (119) constructor_parenthesis_content -> . THIS DOT ID COMMA constructor_parenthesis_content

    THIS            shift and go to state 95

    constructor_parenthesis_content shift and go to state 269

state 241

    (97) set -> VAR ID ASSIGN LBRACKET value_list RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 270


state 242

    (98) set -> VAR ID ASSIGN LESS STRING GREATER . LBRACKET RBRACKET SEMICOLON

    LBRACKET        shift and go to state 271


state 243

    (99) set -> FINAL ID ASSIGN CONST LBRACKET value_list . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 272


state 244

    (34) function -> type ID LPAREN parameter_list RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (97) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (98) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (99) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (123) map -> . map_declaration map_assignment
    (120) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (121) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (84) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN value SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (124) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (60) control_structures_if_else -> . if_block
    (61) control_structures_if_else -> . if_block else_if_blocks
    (62) control_structures_if_else -> . if_block else_if_blocks else_block
    (63) control_structures_if_else -> . if_block else_block
    (115) control_structures_for -> . for_classic
    (116) control_structures_for -> . for_in
    (117) control_structures_for -> . for_each
    (122) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (64) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (108) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (110) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (114) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    type                           shift and go to state 28
    statement_list                 shift and go to state 273
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 245

    (121) function -> type ID LPAREN parameter_list RPAREN ASSIGN . GREATER expression

    GREATER         shift and go to state 274


state 246

    (80) parameter_list -> parameter_list COMMA parameter .

    RPAREN          reduce using rule 80 (parameter_list -> parameter_list COMMA parameter .)
    COMMA           reduce using rule 80 (parameter_list -> parameter_list COMMA parameter .)


state 247

    (36) function -> type ID LPAREN RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (97) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (98) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (99) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (123) map -> . map_declaration map_assignment
    (120) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (121) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (84) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN value SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (124) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (60) control_structures_if_else -> . if_block
    (61) control_structures_if_else -> . if_block else_if_blocks
    (62) control_structures_if_else -> . if_block else_if_blocks else_block
    (63) control_structures_if_else -> . if_block else_block
    (115) control_structures_for -> . for_classic
    (116) control_structures_for -> . for_in
    (117) control_structures_for -> . for_each
    (122) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (64) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (108) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (110) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (114) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 275
    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    type                           shift and go to state 28
    statement                      shift and go to state 44
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 248

    (82) parameter -> REQUIRED type ID .

    RPAREN          reduce using rule 82 (parameter -> REQUIRED type ID .)
    COMMA           reduce using rule 82 (parameter -> REQUIRED type ID .)


state 249

    (35) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET . statement_list RBRACKET
    (39) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET . RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (97) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (98) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (99) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (123) map -> . map_declaration map_assignment
    (120) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (121) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (84) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN value SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (124) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (60) control_structures_if_else -> . if_block
    (61) control_structures_if_else -> . if_block else_if_blocks
    (62) control_structures_if_else -> . if_block else_if_blocks else_block
    (63) control_structures_if_else -> . if_block else_block
    (115) control_structures_for -> . for_classic
    (116) control_structures_for -> . for_in
    (117) control_structures_for -> . for_each
    (122) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (64) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (108) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (110) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (114) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 277
    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement_list                 shift and go to state 276
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 250

    (37) function -> VOID ID LPAREN RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (97) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (98) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (99) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (123) map -> . map_declaration map_assignment
    (120) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (121) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (84) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN value SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (124) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (60) control_structures_if_else -> . if_block
    (61) control_structures_if_else -> . if_block else_if_blocks
    (62) control_structures_if_else -> . if_block else_if_blocks else_block
    (63) control_structures_if_else -> . if_block else_block
    (115) control_structures_for -> . for_classic
    (116) control_structures_for -> . for_in
    (117) control_structures_for -> . for_each
    (122) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (64) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (108) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (110) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (114) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 278
    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement                      shift and go to state 44
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 251

    (38) function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .

    COMMENT_MULTI   reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    COMMENT_SINGLE  reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    SEMICOLON       reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    PRINT           reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    STRING          reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    VAR             reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    FINAL           reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    ID              reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    VOID            reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    LIST            reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    DYNAMIC         reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    RETURN          reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    MAP             reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    WHILE           reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    INT             reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    DOUBLE          reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    BOOL            reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    IF              reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    FOR             reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    $end            reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)


state 252

    (84) list_definition -> LIST LESS type GREATER ID ASSIGN . LSBRACKET value_list RSBRACKET SEMICOLON

    LSBRACKET       shift and go to state 279


state 253

    (124) map_declaration -> MAP LESS key_type COMMA type GREATER . ID ASSIGN

    ID              shift and go to state 280


state 254

    (66) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 281


state 255

    (65) else_if_blocks -> ELSE IF LPAREN conditions RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 282


state 256

    (122) control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 122 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 122 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 122 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 122 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 122 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 122 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 122 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 122 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 122 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 122 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 122 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    RETURN          reduce using rule 122 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 122 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 122 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 122 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 122 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 122 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 122 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 122 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 122 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 122 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)


state 257

    (64) if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (97) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (98) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (99) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (123) map -> . map_declaration map_assignment
    (120) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (121) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (84) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN value SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (124) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (60) control_structures_if_else -> . if_block
    (61) control_structures_if_else -> . if_block else_if_blocks
    (62) control_structures_if_else -> . if_block else_if_blocks else_block
    (63) control_structures_if_else -> . if_block else_block
    (115) control_structures_for -> . for_classic
    (116) control_structures_for -> . for_in
    (117) control_structures_for -> . for_each
    (122) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (64) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (108) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (110) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (114) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 283
    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement                      shift and go to state 44
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 258

    (108) for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (97) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (98) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (99) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (123) map -> . map_declaration map_assignment
    (120) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (121) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (84) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN value SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (124) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (60) control_structures_if_else -> . if_block
    (61) control_structures_if_else -> . if_block else_if_blocks
    (62) control_structures_if_else -> . if_block else_if_blocks else_block
    (63) control_structures_if_else -> . if_block else_block
    (115) control_structures_for -> . for_classic
    (116) control_structures_for -> . for_in
    (117) control_structures_for -> . for_each
    (122) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (64) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (108) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (110) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (114) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 284
    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement                      shift and go to state 44
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 259

    (110) for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (97) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (98) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (99) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (123) map -> . map_declaration map_assignment
    (120) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (121) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (84) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN value SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (124) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (60) control_structures_if_else -> . if_block
    (61) control_structures_if_else -> . if_block else_if_blocks
    (62) control_structures_if_else -> . if_block else_if_blocks else_block
    (63) control_structures_if_else -> . if_block else_block
    (115) control_structures_for -> . for_classic
    (116) control_structures_for -> . for_in
    (117) control_structures_for -> . for_each
    (122) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (64) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (108) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (110) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (114) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 285
    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement                      shift and go to state 44
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 260

    (114) for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (97) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (98) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (99) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (123) map -> . map_declaration map_assignment
    (120) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (121) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (84) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN value SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (124) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (60) control_structures_if_else -> . if_block
    (61) control_structures_if_else -> . if_block else_if_blocks
    (62) control_structures_if_else -> . if_block else_if_blocks else_block
    (63) control_structures_if_else -> . if_block else_block
    (115) control_structures_for -> . for_classic
    (116) control_structures_for -> . for_in
    (117) control_structures_for -> . for_each
    (122) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (64) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (108) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (110) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (114) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 286
    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement                      shift and go to state 44
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 261

    (107) for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON . for_classic_changes
    (103) for_classic_changes -> . ID comparator value
    (104) for_classic_changes -> . ID INCREMENT
    (105) for_classic_changes -> . ID DECREMENT
    (106) for_classic_changes -> . ID comparator value COMMA for_classic_changes

    ID              shift and go to state 288

    for_classic_changes            shift and go to state 287

state 262

    (109) for_in_parenthesis_content -> FINAL ID IN ID .

    RPAREN          reduce using rule 109 (for_in_parenthesis_content -> FINAL ID IN ID .)


state 263

    (113) for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content . RPAREN IN ID

    RPAREN          shift and go to state 289


state 264

    (111) for_each_parenthesis_parenthesis_content -> COLON . ID
    (112) for_each_parenthesis_parenthesis_content -> COLON . ID COMMA for_each_parenthesis_parenthesis_content

    ID              shift and go to state 290


state 265

    (100) for_classic_initialization -> INT ID ASSIGN NUMBER .

    SEMICOLON       reduce using rule 100 (for_classic_initialization -> INT ID ASSIGN NUMBER .)


state 266

    (101) for_classic_initialization -> DOUBLE ID ASSIGN NDOUBLE .

    SEMICOLON       reduce using rule 101 (for_classic_initialization -> DOUBLE ID ASSIGN NDOUBLE .)


state 267

    (27) data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 291


state 268

    (28) data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 292


state 269

    (119) constructor_parenthesis_content -> THIS DOT ID COMMA constructor_parenthesis_content .

    RPAREN          reduce using rule 119 (constructor_parenthesis_content -> THIS DOT ID COMMA constructor_parenthesis_content .)


state 270

    (97) set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .

    COMMENT_MULTI   reduce using rule 97 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 97 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    SEMICOLON       reduce using rule 97 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    PRINT           reduce using rule 97 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    STRING          reduce using rule 97 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    VAR             reduce using rule 97 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    FINAL           reduce using rule 97 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    ID              reduce using rule 97 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    VOID            reduce using rule 97 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    LIST            reduce using rule 97 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 97 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    RETURN          reduce using rule 97 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    MAP             reduce using rule 97 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    WHILE           reduce using rule 97 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    INT             reduce using rule 97 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 97 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    BOOL            reduce using rule 97 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    IF              reduce using rule 97 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    FOR             reduce using rule 97 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    $end            reduce using rule 97 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    RBRACKET        reduce using rule 97 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)


state 271

    (98) set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 293


state 272

    (99) set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 294


state 273

    (34) function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (97) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (98) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (99) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (123) map -> . map_declaration map_assignment
    (120) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (121) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (84) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN value SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (124) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (60) control_structures_if_else -> . if_block
    (61) control_structures_if_else -> . if_block else_if_blocks
    (62) control_structures_if_else -> . if_block else_if_blocks else_block
    (63) control_structures_if_else -> . if_block else_block
    (115) control_structures_for -> . for_classic
    (116) control_structures_for -> . for_in
    (117) control_structures_for -> . for_each
    (122) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (64) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (108) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (110) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (114) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 295
    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    type                           shift and go to state 28
    statement                      shift and go to state 44
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 274

    (121) function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER . expression
    (48) expression -> . operations
    (58) expression -> . conditions
    (59) expression -> . value
    (49) operations -> . operation
    (50) operations -> . operation operand operations
    (68) conditions -> . condition
    (69) conditions -> . condition AND conditions
    (70) conditions -> . condition OR conditions
    (91) value -> . NUMBER
    (92) value -> . NDOUBLE
    (93) value -> . TEXT
    (94) value -> . ID
    (95) value -> . TRUE
    (96) value -> . FALSE
    (51) operation -> . operand operator operand
    (71) condition -> . value comparator value
    (72) condition -> . NOT condition
    (52) operand -> . NUMBER
    (53) operand -> . DOUBLE

    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 68
    ID              shift and go to state 69
    TRUE            shift and go to state 70
    FALSE           shift and go to state 71
    NOT             shift and go to state 72
    DOUBLE          shift and go to state 73

    expression                     shift and go to state 296
    operations                     shift and go to state 60
    conditions                     shift and go to state 61
    value                          shift and go to state 62
    operation                      shift and go to state 63
    operand                        shift and go to state 64
    condition                      shift and go to state 65

state 275

    (36) function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    RETURN          reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)


state 276

    (35) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (97) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (98) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (99) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (123) map -> . map_declaration map_assignment
    (120) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (121) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (84) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN value SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (124) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (60) control_structures_if_else -> . if_block
    (61) control_structures_if_else -> . if_block else_if_blocks
    (62) control_structures_if_else -> . if_block else_if_blocks else_block
    (63) control_structures_if_else -> . if_block else_block
    (115) control_structures_for -> . for_classic
    (116) control_structures_for -> . for_in
    (117) control_structures_for -> . for_each
    (122) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (64) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (108) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (110) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (114) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 297
    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement                      shift and go to state 44
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 277

    (39) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .

    COMMENT_MULTI   reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    COMMENT_SINGLE  reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    SEMICOLON       reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    PRINT           reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    STRING          reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    VAR             reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    FINAL           reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    ID              reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    VOID            reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    LIST            reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    DYNAMIC         reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    RETURN          reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    MAP             reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    WHILE           reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    INT             reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    DOUBLE          reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    BOOL            reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    IF              reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    FOR             reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    $end            reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)


state 278

    (37) function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    RETURN          reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)


state 279

    (84) list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET . value_list RSBRACKET SEMICOLON
    (85) value_list -> . value
    (86) value_list -> . value COMMA value_list
    (91) value -> . NUMBER
    (92) value -> . NDOUBLE
    (93) value -> . TEXT
    (94) value -> . ID
    (95) value -> . TRUE
    (96) value -> . FALSE

    NUMBER          shift and go to state 98
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 68
    ID              shift and go to state 69
    TRUE            shift and go to state 70
    FALSE           shift and go to state 71

    value_list                     shift and go to state 298
    value                          shift and go to state 152

state 280

    (124) map_declaration -> MAP LESS key_type COMMA type GREATER ID . ASSIGN

    ASSIGN          shift and go to state 299


state 281

    (66) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 300


state 282

    (65) else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (97) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (98) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (99) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (123) map -> . map_declaration map_assignment
    (120) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (121) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (84) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN value SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (124) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (60) control_structures_if_else -> . if_block
    (61) control_structures_if_else -> . if_block else_if_blocks
    (62) control_structures_if_else -> . if_block else_if_blocks else_block
    (63) control_structures_if_else -> . if_block else_block
    (115) control_structures_for -> . for_classic
    (116) control_structures_for -> . for_in
    (117) control_structures_for -> . for_each
    (122) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (64) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (108) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (110) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (114) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement_list                 shift and go to state 301
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 283

    (64) if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .

    ELSE            reduce using rule 64 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_MULTI   reduce using rule 64 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 64 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 64 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 64 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 64 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 64 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 64 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 64 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 64 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 64 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 64 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    RETURN          reduce using rule 64 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 64 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 64 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 64 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 64 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 64 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 64 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 64 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 64 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 64 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)


state 284

    (108) for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 108 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 108 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 108 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 108 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 108 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 108 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 108 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 108 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 108 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 108 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 108 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    RETURN          reduce using rule 108 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 108 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 108 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 108 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 108 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 108 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 108 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 108 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 108 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 108 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)


state 285

    (110) for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 110 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 110 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 110 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 110 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 110 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 110 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 110 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 110 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 110 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 110 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 110 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    RETURN          reduce using rule 110 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 110 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 110 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 110 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 110 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 110 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 110 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 110 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 110 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 110 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)


state 286

    (114) for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 114 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 114 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 114 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 114 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 114 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 114 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 114 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 114 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 114 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 114 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 114 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    RETURN          reduce using rule 114 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 114 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 114 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 114 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 114 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 114 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 114 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 114 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 114 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 114 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)


state 287

    (107) for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON for_classic_changes .

    RPAREN          reduce using rule 107 (for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON for_classic_changes .)


state 288

    (103) for_classic_changes -> ID . comparator value
    (104) for_classic_changes -> ID . INCREMENT
    (105) for_classic_changes -> ID . DECREMENT
    (106) for_classic_changes -> ID . comparator value COMMA for_classic_changes
    (73) comparator -> . GREATER
    (74) comparator -> . LESS
    (75) comparator -> . EQUALS
    (76) comparator -> . GREATER_EQUAL
    (77) comparator -> . LESS_EQUAL
    (78) comparator -> . NOT_EQUALS

    INCREMENT       shift and go to state 303
    DECREMENT       shift and go to state 304
    GREATER         shift and go to state 113
    LESS            shift and go to state 114
    EQUALS          shift and go to state 115
    GREATER_EQUAL   shift and go to state 116
    LESS_EQUAL      shift and go to state 117
    NOT_EQUALS      shift and go to state 118

    comparator                     shift and go to state 302

state 289

    (113) for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN . IN ID

    IN              shift and go to state 305


state 290

    (111) for_each_parenthesis_parenthesis_content -> COLON ID .
    (112) for_each_parenthesis_parenthesis_content -> COLON ID . COMMA for_each_parenthesis_parenthesis_content

    RPAREN          reduce using rule 111 (for_each_parenthesis_parenthesis_content -> COLON ID .)
    COMMA           shift and go to state 306


state 291

    (27) data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 307


state 292

    (28) data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 308


state 293

    (98) set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 309


state 294

    (99) set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .

    COMMENT_MULTI   reduce using rule 99 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 99 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    SEMICOLON       reduce using rule 99 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    PRINT           reduce using rule 99 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    STRING          reduce using rule 99 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    VAR             reduce using rule 99 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    FINAL           reduce using rule 99 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    ID              reduce using rule 99 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    VOID            reduce using rule 99 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    LIST            reduce using rule 99 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 99 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    RETURN          reduce using rule 99 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    MAP             reduce using rule 99 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    WHILE           reduce using rule 99 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    INT             reduce using rule 99 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 99 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    BOOL            reduce using rule 99 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    IF              reduce using rule 99 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    FOR             reduce using rule 99 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    $end            reduce using rule 99 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    RBRACKET        reduce using rule 99 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)


state 295

    (34) function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    RETURN          reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)


state 296

    (121) function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .

    COMMENT_MULTI   reduce using rule 121 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    COMMENT_SINGLE  reduce using rule 121 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    SEMICOLON       reduce using rule 121 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    PRINT           reduce using rule 121 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    STRING          reduce using rule 121 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    VAR             reduce using rule 121 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    FINAL           reduce using rule 121 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    ID              reduce using rule 121 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    VOID            reduce using rule 121 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    LIST            reduce using rule 121 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    DYNAMIC         reduce using rule 121 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    RETURN          reduce using rule 121 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    MAP             reduce using rule 121 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    WHILE           reduce using rule 121 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    INT             reduce using rule 121 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    DOUBLE          reduce using rule 121 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    BOOL            reduce using rule 121 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    IF              reduce using rule 121 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    FOR             reduce using rule 121 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    $end            reduce using rule 121 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    RBRACKET        reduce using rule 121 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)


state 297

    (35) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    RETURN          reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)


state 298

    (84) list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list . RSBRACKET SEMICOLON

    RSBRACKET       shift and go to state 310


state 299

    (124) map_declaration -> MAP LESS key_type COMMA type GREATER ID ASSIGN .

    LBRACKET        reduce using rule 124 (map_declaration -> MAP LESS key_type COMMA type GREATER ID ASSIGN .)


state 300

    (66) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (97) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (98) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (99) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (123) map -> . map_declaration map_assignment
    (120) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (121) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (84) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN value SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (124) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (60) control_structures_if_else -> . if_block
    (61) control_structures_if_else -> . if_block else_if_blocks
    (62) control_structures_if_else -> . if_block else_if_blocks else_block
    (63) control_structures_if_else -> . if_block else_block
    (115) control_structures_for -> . for_classic
    (116) control_structures_for -> . for_in
    (117) control_structures_for -> . for_each
    (122) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (64) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (108) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (110) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (114) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement_list                 shift and go to state 311
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 301

    (65) else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (97) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (98) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (99) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (123) map -> . map_declaration map_assignment
    (120) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (121) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (84) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN value SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (124) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (60) control_structures_if_else -> . if_block
    (61) control_structures_if_else -> . if_block else_if_blocks
    (62) control_structures_if_else -> . if_block else_if_blocks else_block
    (63) control_structures_if_else -> . if_block else_block
    (115) control_structures_for -> . for_classic
    (116) control_structures_for -> . for_in
    (117) control_structures_for -> . for_each
    (122) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (64) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (108) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (110) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (114) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 312
    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement                      shift and go to state 44
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 302

    (103) for_classic_changes -> ID comparator . value
    (106) for_classic_changes -> ID comparator . value COMMA for_classic_changes
    (91) value -> . NUMBER
    (92) value -> . NDOUBLE
    (93) value -> . TEXT
    (94) value -> . ID
    (95) value -> . TRUE
    (96) value -> . FALSE

    NUMBER          shift and go to state 98
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 68
    ID              shift and go to state 69
    TRUE            shift and go to state 70
    FALSE           shift and go to state 71

    value                          shift and go to state 313

state 303

    (104) for_classic_changes -> ID INCREMENT .

    RPAREN          reduce using rule 104 (for_classic_changes -> ID INCREMENT .)


state 304

    (105) for_classic_changes -> ID DECREMENT .

    RPAREN          reduce using rule 105 (for_classic_changes -> ID DECREMENT .)


state 305

    (113) for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN . ID

    ID              shift and go to state 314


state 306

    (112) for_each_parenthesis_parenthesis_content -> COLON ID COMMA . for_each_parenthesis_parenthesis_content
    (111) for_each_parenthesis_parenthesis_content -> . COLON ID
    (112) for_each_parenthesis_parenthesis_content -> . COLON ID COMMA for_each_parenthesis_parenthesis_content

    COLON           shift and go to state 264

    for_each_parenthesis_parenthesis_content shift and go to state 315

state 307

    (27) data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .

    COMMENT_MULTI   reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    RETURN          reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)


state 308

    (28) data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 316


state 309

    (98) set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .

    COMMENT_MULTI   reduce using rule 98 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 98 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    SEMICOLON       reduce using rule 98 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    PRINT           reduce using rule 98 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    STRING          reduce using rule 98 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    VAR             reduce using rule 98 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    FINAL           reduce using rule 98 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    ID              reduce using rule 98 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    VOID            reduce using rule 98 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    LIST            reduce using rule 98 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 98 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    RETURN          reduce using rule 98 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    MAP             reduce using rule 98 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    WHILE           reduce using rule 98 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    INT             reduce using rule 98 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 98 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    BOOL            reduce using rule 98 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    IF              reduce using rule 98 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    FOR             reduce using rule 98 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    $end            reduce using rule 98 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    RBRACKET        reduce using rule 98 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)


state 310

    (84) list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 317


state 311

    (66) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (97) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (98) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (99) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (123) map -> . map_declaration map_assignment
    (120) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (121) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (84) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN value SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (124) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (60) control_structures_if_else -> . if_block
    (61) control_structures_if_else -> . if_block else_if_blocks
    (62) control_structures_if_else -> . if_block else_if_blocks else_block
    (63) control_structures_if_else -> . if_block else_block
    (115) control_structures_for -> . for_classic
    (116) control_structures_for -> . for_in
    (117) control_structures_for -> . for_each
    (122) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (64) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (108) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (110) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (114) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 318
    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement                      shift and go to state 44
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 312

    (65) else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .

    ELSE            reduce using rule 65 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_MULTI   reduce using rule 65 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 65 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 65 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 65 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 65 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 65 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 65 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 65 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 65 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 65 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 65 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    RETURN          reduce using rule 65 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 65 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 65 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 65 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 65 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 65 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 65 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 65 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 65 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 65 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)


state 313

    (103) for_classic_changes -> ID comparator value .
    (106) for_classic_changes -> ID comparator value . COMMA for_classic_changes

    RPAREN          reduce using rule 103 (for_classic_changes -> ID comparator value .)
    COMMA           shift and go to state 319


state 314

    (113) for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID .

    RPAREN          reduce using rule 113 (for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID .)


state 315

    (112) for_each_parenthesis_parenthesis_content -> COLON ID COMMA for_each_parenthesis_parenthesis_content .

    RPAREN          reduce using rule 112 (for_each_parenthesis_parenthesis_content -> COLON ID COMMA for_each_parenthesis_parenthesis_content .)


state 316

    (28) data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .

    COMMENT_MULTI   reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    RETURN          reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)


state 317

    (84) list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .

    COMMENT_MULTI   reduce using rule 84 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 84 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    SEMICOLON       reduce using rule 84 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    PRINT           reduce using rule 84 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    STRING          reduce using rule 84 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    VAR             reduce using rule 84 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    FINAL           reduce using rule 84 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    ID              reduce using rule 84 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    VOID            reduce using rule 84 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    LIST            reduce using rule 84 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 84 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    RETURN          reduce using rule 84 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    MAP             reduce using rule 84 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    WHILE           reduce using rule 84 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    INT             reduce using rule 84 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 84 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    BOOL            reduce using rule 84 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    IF              reduce using rule 84 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    FOR             reduce using rule 84 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    $end            reduce using rule 84 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    RBRACKET        reduce using rule 84 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)


state 318

    (66) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .

    ELSE            reduce using rule 66 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_MULTI   reduce using rule 66 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 66 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 66 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 66 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 66 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 66 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 66 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 66 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 66 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 66 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 66 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    RETURN          reduce using rule 66 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 66 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 66 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 66 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 66 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 66 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 66 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 66 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 66 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 66 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)


state 319

    (106) for_classic_changes -> ID comparator value COMMA . for_classic_changes
    (103) for_classic_changes -> . ID comparator value
    (104) for_classic_changes -> . ID INCREMENT
    (105) for_classic_changes -> . ID DECREMENT
    (106) for_classic_changes -> . ID comparator value COMMA for_classic_changes

    ID              shift and go to state 288

    for_classic_changes            shift and go to state 320

state 320

    (106) for_classic_changes -> ID comparator value COMMA for_classic_changes .

    RPAREN          reduce using rule 106 (for_classic_changes -> ID comparator value COMMA for_classic_changes .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 20 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 63 resolved as shift
