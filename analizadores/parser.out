Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AS
    ASSERT
    ASYNC
    AWAIT
    BREAK
    CASE
    CATCH
    CLASS
    CONTINUE
    COVARIANT
    DEFAULT
    DEFERRED
    DO
    DOLLARSIGN
    DOUBLE_COLON
    ENUM
    EXPORT
    EXTENDS
    EXTENSION
    EXTERNAL
    FACTORY
    FINALLY
    FUNCTION
    GET
    HIDE
    IMPLEMENTS
    IMPORT
    INTERFACE
    IS
    LATE
    LIBRARY
    MIXIN
    MODULE
    NEW
    NULL
    NUM
    NUMERAL
    OBJECT
    ON
    OPERATOR
    PART
    RETHROW
    SET
    SHOW
    STATIC
    SUPER
    SWITCH
    SYNC
    THROW
    TRY
    TYPEDEF
    WITH
    YIELD

Grammar

Rule 0     S' -> program
Rule 1     program -> statement_list
Rule 2     statement_list -> statement
Rule 3     statement_list -> statement_list statement
Rule 4     statement -> print
Rule 5     statement -> data_input
Rule 6     statement -> set
Rule 7     statement -> map
Rule 8     statement -> constructor
Rule 9     statement -> control_structures
Rule 10    statement -> function
Rule 11    statement -> list_definition
Rule 12    statement -> variable_definition
Rule 13    statement -> variable_usage
Rule 14    statement -> call_function
Rule 15    statement -> return
Rule 16    statement -> COMMENT_MULTI
Rule 17    statement -> COMMENT_SINGLE
Rule 18    statement -> SEMICOLON
Rule 19    return -> RETURN expression SEMICOLON
Rule 20    control_structures -> control_structures_if_else
Rule 21    control_structures -> control_structures_for
Rule 22    control_structures -> control_structures_while
Rule 23    variable_usage -> ID SEMICOLON
Rule 24    variable_usage -> ID ASSIGN expression SEMICOLON
Rule 25    call_function -> ID LPAREN argument_list RPAREN
Rule 26    call_function -> ID LPAREN RPAREN
Rule 27    data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
Rule 28    data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
Rule 29    length -> call_list DOT LENGTH
Rule 30    length -> TEXT DOT LENGTH
Rule 31    length -> ID DOT LENGTH
Rule 32    argument_list -> expression
Rule 33    argument_list -> argument_list COMMA expression
Rule 34    function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
Rule 35    function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
Rule 36    function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
Rule 37    function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
Rule 38    function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET
Rule 39    function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
Rule 40    variable_definition -> type ID ASSIGN expression SEMICOLON
Rule 41    variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON
Rule 42    variable_definition -> VAR ID ASSIGN expression SEMICOLON
Rule 43    print -> PRINT LPAREN RPAREN SEMICOLON
Rule 44    print -> PRINT LPAREN expression RPAREN SEMICOLON
Rule 45    expression -> operations
Rule 46    expression -> conditions
Rule 47    expression -> length
Rule 48    expression -> call_function
Rule 49    operations -> operand
Rule 50    operations -> operand operator operations
Rule 51    operand -> NUMBER
Rule 52    operand -> NDOUBLE
Rule 53    operand -> ID
Rule 54    operator -> PLUS
Rule 55    operator -> MINUS
Rule 56    operator -> TIMES
Rule 57    operator -> DIVIDE
Rule 58    operator -> INT_DIVIDE
Rule 59    control_structures_if_else -> if_block
Rule 60    control_structures_if_else -> if_block else_if_blocks
Rule 61    control_structures_if_else -> if_block else_if_blocks else_block
Rule 62    control_structures_if_else -> if_block else_block
Rule 63    if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
Rule 64    else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
Rule 65    else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
Rule 66    else_block -> ELSE LBRACKET statement_list RBRACKET
Rule 67    conditions -> condition
Rule 68    conditions -> condition AND conditions
Rule 69    conditions -> condition OR conditions
Rule 70    condition -> value comparator value
Rule 71    condition -> NOT value
Rule 72    comparator -> GREATER
Rule 73    comparator -> LESS
Rule 74    comparator -> EQUALS
Rule 75    comparator -> GREATER_EQUAL
Rule 76    comparator -> LESS_EQUAL
Rule 77    comparator -> NOT_EQUALS
Rule 78    parameter_list -> parameter
Rule 79    parameter_list -> parameter_list COMMA parameter
Rule 80    parameter -> type ID
Rule 81    parameter -> REQUIRED type ID
Rule 82    call_list -> LSBRACKET value_list RSBRACKET
Rule 83    list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
Rule 84    value_list -> value
Rule 85    value_list -> value COMMA value_list
Rule 86    type -> INT
Rule 87    type -> DOUBLE
Rule 88    type -> STRING
Rule 89    type -> BOOL
Rule 90    value -> operand
Rule 91    value -> TEXT
Rule 92    value -> TRUE
Rule 93    value -> FALSE
Rule 94    set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
Rule 95    set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
Rule 96    set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
Rule 97    for_classic_initialization -> INT ID ASSIGN NUMBER
Rule 98    for_classic_initialization -> DOUBLE ID ASSIGN NDOUBLE
Rule 99    for_classic_conditions -> conditions
Rule 100   for_classic_changes -> ID comparator value
Rule 101   for_classic_changes -> ID INCREMENT
Rule 102   for_classic_changes -> ID DECREMENT
Rule 103   for_classic_changes -> ID comparator value COMMA for_classic_changes
Rule 104   for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON for_classic_changes
Rule 105   for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
Rule 106   for_in_parenthesis_content -> FINAL ID IN ID
Rule 107   for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
Rule 108   for_each_parenthesis_parenthesis_content -> COLON ID
Rule 109   for_each_parenthesis_parenthesis_content -> COLON ID COMMA for_each_parenthesis_parenthesis_content
Rule 110   for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID
Rule 111   for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
Rule 112   control_structures_for -> for_classic
Rule 113   control_structures_for -> for_in
Rule 114   control_structures_for -> for_each
Rule 115   constructor_parenthesis_content -> THIS DOT ID
Rule 116   constructor_parenthesis_content -> THIS DOT ID COMMA constructor_parenthesis_content
Rule 117   constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
Rule 118   function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
Rule 119   control_structures_while -> WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
Rule 120   map -> map_declaration map_assignment
Rule 121   map_declaration -> MAP LESS key_type COMMA type GREATER ID ASSIGN
Rule 122   map_assignment -> LBRACKET map_contents RBRACKET
Rule 123   map_contents -> map_content
Rule 124   map_contents -> map_content COMMA map_contents
Rule 125   map_content -> key_value COLON value
Rule 126   key_value -> TEXT
Rule 127   key_type -> STRING

Terminals, with rules where they appear

ABSTRACT             : 
AND                  : 68
AS                   : 
ASSERT               : 
ASSIGN               : 24 27 28 40 41 42 83 94 95 96 97 98 118 121
ASYNC                : 
AWAIT                : 
BOOL                 : 89
BREAK                : 
CASE                 : 
CATCH                : 
CLASS                : 
COLON                : 108 109 125
COMMA                : 33 79 85 103 109 116 121 124
COMMENT_MULTI        : 16
COMMENT_SINGLE       : 17
CONST                : 96
CONTINUE             : 
COVARIANT            : 
DECREMENT            : 102
DEFAULT              : 
DEFERRED             : 
DIVIDE               : 57
DO                   : 
DOLLARSIGN           : 
DOT                  : 27 28 29 30 31 115 116
DOUBLE               : 87 98
DOUBLE_COLON         : 
DYNAMIC              : 41
ELSE                 : 64 65 66
ENUM                 : 
EQUALS               : 74
EXPORT               : 
EXTENDS              : 
EXTENSION            : 
EXTERNAL             : 
FACTORY              : 
FALSE                : 93
FINAL                : 96 106 110
FINALLY              : 
FOR                  : 105 107 111
FUNCTION             : 
GET                  : 
GREATER              : 72 83 95 118 121
GREATER_EQUAL        : 75
HIDE                 : 
ID                   : 23 24 25 26 27 28 31 34 35 36 37 38 39 40 41 42 53 80 81 83 94 95 96 97 98 100 101 102 103 106 106 108 109 110 110 115 116 117 118 121
IF                   : 63 64 65
IMPLEMENTS           : 
IMPORT               : 
IN                   : 106 110
INCREMENT            : 101
INT                  : 86 97
INTERFACE            : 
INT_DIVIDE           : 58
IS                   : 
LATE                 : 
LBRACKET             : 34 35 36 37 38 39 63 64 65 66 94 95 96 105 107 111 119 122
LENGTH               : 29 30 31
LESS                 : 73 83 95 121
LESS_EQUAL           : 76
LIBRARY              : 
LIST                 : 83
LPAREN               : 25 26 27 28 34 35 36 37 38 39 43 44 63 64 65 105 107 110 111 117 118 119
LSBRACKET            : 82 83
MAP                  : 121
MINUS                : 55
MIXIN                : 
MODULE               : 
NDOUBLE              : 52 98
NEW                  : 
NOT                  : 71
NOT_EQUALS           : 77
NULL                 : 
NUM                  : 
NUMBER               : 51 97
NUMERAL              : 
OBJECT               : 
ON                   : 
OPERATOR             : 
OR                   : 69
PART                 : 
PLUS                 : 54
PRINT                : 43 44
QUESTION             : 28
RBRACKET             : 34 35 36 37 38 39 63 64 65 66 94 95 96 105 107 111 119 122
READLINESYNC         : 27 28
REQUIRED             : 81
RETHROW              : 
RETURN               : 19
RPAREN               : 25 26 27 28 34 35 36 37 38 39 43 44 63 64 65 105 107 110 111 117 118 119
RSBRACKET            : 82 83
SEMICOLON            : 18 19 23 24 27 28 40 41 42 43 44 83 94 95 96 104 104 117
SET                  : 
SHOW                 : 
STATIC               : 
STDIN                : 27 28
STRING               : 27 28 88 95 127
SUPER                : 
SWITCH               : 
SYNC                 : 
TEXT                 : 30 91 126
THIS                 : 115 116
THROW                : 
TIMES                : 56
TRUE                 : 92
TRY                  : 
TYPEDEF              : 
VAR                  : 42 94 95
VOID                 : 35 37 38 39
WHILE                : 119
WITH                 : 
YIELD                : 
error                : 

Nonterminals, with rules where they appear

argument_list        : 25 33
call_function        : 14 48
call_list            : 29
comparator           : 70 100 103
condition            : 67 68 69
conditions           : 46 63 64 65 68 69 99 119
constructor          : 8
constructor_parenthesis_content : 116 117
control_structures   : 9
control_structures_for : 21
control_structures_if_else : 20
control_structures_while : 22
data_input           : 5
else_block           : 61 62
else_if_blocks       : 60 61 65
expression           : 19 24 32 33 40 41 42 44 118
for_classic          : 112
for_classic_changes  : 103 104
for_classic_conditions : 104
for_classic_initialization : 104
for_classic_parenthesis_content : 105
for_each             : 114
for_each_parenthesis_content : 111
for_each_parenthesis_parenthesis_content : 109 110
for_in               : 113
for_in_parenthesis_content : 107
function             : 10
if_block             : 59 60 61 62
key_type             : 121
key_value            : 125
length               : 47
list_definition      : 11
map                  : 7
map_assignment       : 120
map_content          : 123 124
map_contents         : 122 124
map_declaration      : 120
operand              : 49 50 90
operations           : 45 50
operator             : 50
parameter            : 78 79
parameter_list       : 34 35 39 79 118
print                : 4
program              : 0
return               : 15
set                  : 6
statement            : 2 3
statement_list       : 1 3 34 35 36 37 63 64 65 66 105 107 111 119
type                 : 34 36 40 80 81 83 118 121
value                : 70 70 71 84 85 100 103 125
value_list           : 82 83 85 94 96
variable_definition  : 12
variable_usage       : 13

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement_list
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (94) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (95) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (96) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (120) map -> . map_declaration map_assignment
    (117) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (118) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN expression SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (121) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (59) control_structures_if_else -> . if_block
    (60) control_structures_if_else -> . if_block else_if_blocks
    (61) control_structures_if_else -> . if_block else_if_blocks else_block
    (62) control_structures_if_else -> . if_block else_block
    (112) control_structures_for -> . for_classic
    (113) control_structures_for -> . for_in
    (114) control_structures_for -> . for_each
    (119) control_structures_while -> . WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (86) type -> . INT
    (87) type -> . DOUBLE
    (88) type -> . STRING
    (89) type -> . BOOL
    (63) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (105) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (107) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (111) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    program                        shift and go to state 1
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 1

    (0) S' -> program .



state 2

    (1) program -> statement_list .
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (94) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (95) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (96) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (120) map -> . map_declaration map_assignment
    (117) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (118) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN expression SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (121) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (59) control_structures_if_else -> . if_block
    (60) control_structures_if_else -> . if_block else_if_blocks
    (61) control_structures_if_else -> . if_block else_if_blocks else_block
    (62) control_structures_if_else -> . if_block else_block
    (112) control_structures_for -> . for_classic
    (113) control_structures_for -> . for_in
    (114) control_structures_for -> . for_each
    (119) control_structures_while -> . WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (86) type -> . INT
    (87) type -> . DOUBLE
    (88) type -> . STRING
    (89) type -> . BOOL
    (63) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (105) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (107) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (111) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    $end            reduce using rule 1 (program -> statement_list .)
    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement                      shift and go to state 44
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 3

    (2) statement_list -> statement .

    COMMENT_MULTI   reduce using rule 2 (statement_list -> statement .)
    COMMENT_SINGLE  reduce using rule 2 (statement_list -> statement .)
    SEMICOLON       reduce using rule 2 (statement_list -> statement .)
    PRINT           reduce using rule 2 (statement_list -> statement .)
    STRING          reduce using rule 2 (statement_list -> statement .)
    VAR             reduce using rule 2 (statement_list -> statement .)
    FINAL           reduce using rule 2 (statement_list -> statement .)
    ID              reduce using rule 2 (statement_list -> statement .)
    VOID            reduce using rule 2 (statement_list -> statement .)
    LIST            reduce using rule 2 (statement_list -> statement .)
    DYNAMIC         reduce using rule 2 (statement_list -> statement .)
    RETURN          reduce using rule 2 (statement_list -> statement .)
    MAP             reduce using rule 2 (statement_list -> statement .)
    WHILE           reduce using rule 2 (statement_list -> statement .)
    INT             reduce using rule 2 (statement_list -> statement .)
    DOUBLE          reduce using rule 2 (statement_list -> statement .)
    BOOL            reduce using rule 2 (statement_list -> statement .)
    IF              reduce using rule 2 (statement_list -> statement .)
    FOR             reduce using rule 2 (statement_list -> statement .)
    $end            reduce using rule 2 (statement_list -> statement .)
    RBRACKET        reduce using rule 2 (statement_list -> statement .)


state 4

    (4) statement -> print .

    COMMENT_MULTI   reduce using rule 4 (statement -> print .)
    COMMENT_SINGLE  reduce using rule 4 (statement -> print .)
    SEMICOLON       reduce using rule 4 (statement -> print .)
    PRINT           reduce using rule 4 (statement -> print .)
    STRING          reduce using rule 4 (statement -> print .)
    VAR             reduce using rule 4 (statement -> print .)
    FINAL           reduce using rule 4 (statement -> print .)
    ID              reduce using rule 4 (statement -> print .)
    VOID            reduce using rule 4 (statement -> print .)
    LIST            reduce using rule 4 (statement -> print .)
    DYNAMIC         reduce using rule 4 (statement -> print .)
    RETURN          reduce using rule 4 (statement -> print .)
    MAP             reduce using rule 4 (statement -> print .)
    WHILE           reduce using rule 4 (statement -> print .)
    INT             reduce using rule 4 (statement -> print .)
    DOUBLE          reduce using rule 4 (statement -> print .)
    BOOL            reduce using rule 4 (statement -> print .)
    IF              reduce using rule 4 (statement -> print .)
    FOR             reduce using rule 4 (statement -> print .)
    $end            reduce using rule 4 (statement -> print .)
    RBRACKET        reduce using rule 4 (statement -> print .)


state 5

    (5) statement -> data_input .

    COMMENT_MULTI   reduce using rule 5 (statement -> data_input .)
    COMMENT_SINGLE  reduce using rule 5 (statement -> data_input .)
    SEMICOLON       reduce using rule 5 (statement -> data_input .)
    PRINT           reduce using rule 5 (statement -> data_input .)
    STRING          reduce using rule 5 (statement -> data_input .)
    VAR             reduce using rule 5 (statement -> data_input .)
    FINAL           reduce using rule 5 (statement -> data_input .)
    ID              reduce using rule 5 (statement -> data_input .)
    VOID            reduce using rule 5 (statement -> data_input .)
    LIST            reduce using rule 5 (statement -> data_input .)
    DYNAMIC         reduce using rule 5 (statement -> data_input .)
    RETURN          reduce using rule 5 (statement -> data_input .)
    MAP             reduce using rule 5 (statement -> data_input .)
    WHILE           reduce using rule 5 (statement -> data_input .)
    INT             reduce using rule 5 (statement -> data_input .)
    DOUBLE          reduce using rule 5 (statement -> data_input .)
    BOOL            reduce using rule 5 (statement -> data_input .)
    IF              reduce using rule 5 (statement -> data_input .)
    FOR             reduce using rule 5 (statement -> data_input .)
    $end            reduce using rule 5 (statement -> data_input .)
    RBRACKET        reduce using rule 5 (statement -> data_input .)


state 6

    (6) statement -> set .

    COMMENT_MULTI   reduce using rule 6 (statement -> set .)
    COMMENT_SINGLE  reduce using rule 6 (statement -> set .)
    SEMICOLON       reduce using rule 6 (statement -> set .)
    PRINT           reduce using rule 6 (statement -> set .)
    STRING          reduce using rule 6 (statement -> set .)
    VAR             reduce using rule 6 (statement -> set .)
    FINAL           reduce using rule 6 (statement -> set .)
    ID              reduce using rule 6 (statement -> set .)
    VOID            reduce using rule 6 (statement -> set .)
    LIST            reduce using rule 6 (statement -> set .)
    DYNAMIC         reduce using rule 6 (statement -> set .)
    RETURN          reduce using rule 6 (statement -> set .)
    MAP             reduce using rule 6 (statement -> set .)
    WHILE           reduce using rule 6 (statement -> set .)
    INT             reduce using rule 6 (statement -> set .)
    DOUBLE          reduce using rule 6 (statement -> set .)
    BOOL            reduce using rule 6 (statement -> set .)
    IF              reduce using rule 6 (statement -> set .)
    FOR             reduce using rule 6 (statement -> set .)
    $end            reduce using rule 6 (statement -> set .)
    RBRACKET        reduce using rule 6 (statement -> set .)


state 7

    (7) statement -> map .

    COMMENT_MULTI   reduce using rule 7 (statement -> map .)
    COMMENT_SINGLE  reduce using rule 7 (statement -> map .)
    SEMICOLON       reduce using rule 7 (statement -> map .)
    PRINT           reduce using rule 7 (statement -> map .)
    STRING          reduce using rule 7 (statement -> map .)
    VAR             reduce using rule 7 (statement -> map .)
    FINAL           reduce using rule 7 (statement -> map .)
    ID              reduce using rule 7 (statement -> map .)
    VOID            reduce using rule 7 (statement -> map .)
    LIST            reduce using rule 7 (statement -> map .)
    DYNAMIC         reduce using rule 7 (statement -> map .)
    RETURN          reduce using rule 7 (statement -> map .)
    MAP             reduce using rule 7 (statement -> map .)
    WHILE           reduce using rule 7 (statement -> map .)
    INT             reduce using rule 7 (statement -> map .)
    DOUBLE          reduce using rule 7 (statement -> map .)
    BOOL            reduce using rule 7 (statement -> map .)
    IF              reduce using rule 7 (statement -> map .)
    FOR             reduce using rule 7 (statement -> map .)
    $end            reduce using rule 7 (statement -> map .)
    RBRACKET        reduce using rule 7 (statement -> map .)


state 8

    (8) statement -> constructor .

    COMMENT_MULTI   reduce using rule 8 (statement -> constructor .)
    COMMENT_SINGLE  reduce using rule 8 (statement -> constructor .)
    SEMICOLON       reduce using rule 8 (statement -> constructor .)
    PRINT           reduce using rule 8 (statement -> constructor .)
    STRING          reduce using rule 8 (statement -> constructor .)
    VAR             reduce using rule 8 (statement -> constructor .)
    FINAL           reduce using rule 8 (statement -> constructor .)
    ID              reduce using rule 8 (statement -> constructor .)
    VOID            reduce using rule 8 (statement -> constructor .)
    LIST            reduce using rule 8 (statement -> constructor .)
    DYNAMIC         reduce using rule 8 (statement -> constructor .)
    RETURN          reduce using rule 8 (statement -> constructor .)
    MAP             reduce using rule 8 (statement -> constructor .)
    WHILE           reduce using rule 8 (statement -> constructor .)
    INT             reduce using rule 8 (statement -> constructor .)
    DOUBLE          reduce using rule 8 (statement -> constructor .)
    BOOL            reduce using rule 8 (statement -> constructor .)
    IF              reduce using rule 8 (statement -> constructor .)
    FOR             reduce using rule 8 (statement -> constructor .)
    $end            reduce using rule 8 (statement -> constructor .)
    RBRACKET        reduce using rule 8 (statement -> constructor .)


state 9

    (9) statement -> control_structures .

    COMMENT_MULTI   reduce using rule 9 (statement -> control_structures .)
    COMMENT_SINGLE  reduce using rule 9 (statement -> control_structures .)
    SEMICOLON       reduce using rule 9 (statement -> control_structures .)
    PRINT           reduce using rule 9 (statement -> control_structures .)
    STRING          reduce using rule 9 (statement -> control_structures .)
    VAR             reduce using rule 9 (statement -> control_structures .)
    FINAL           reduce using rule 9 (statement -> control_structures .)
    ID              reduce using rule 9 (statement -> control_structures .)
    VOID            reduce using rule 9 (statement -> control_structures .)
    LIST            reduce using rule 9 (statement -> control_structures .)
    DYNAMIC         reduce using rule 9 (statement -> control_structures .)
    RETURN          reduce using rule 9 (statement -> control_structures .)
    MAP             reduce using rule 9 (statement -> control_structures .)
    WHILE           reduce using rule 9 (statement -> control_structures .)
    INT             reduce using rule 9 (statement -> control_structures .)
    DOUBLE          reduce using rule 9 (statement -> control_structures .)
    BOOL            reduce using rule 9 (statement -> control_structures .)
    IF              reduce using rule 9 (statement -> control_structures .)
    FOR             reduce using rule 9 (statement -> control_structures .)
    $end            reduce using rule 9 (statement -> control_structures .)
    RBRACKET        reduce using rule 9 (statement -> control_structures .)


state 10

    (10) statement -> function .

    COMMENT_MULTI   reduce using rule 10 (statement -> function .)
    COMMENT_SINGLE  reduce using rule 10 (statement -> function .)
    SEMICOLON       reduce using rule 10 (statement -> function .)
    PRINT           reduce using rule 10 (statement -> function .)
    STRING          reduce using rule 10 (statement -> function .)
    VAR             reduce using rule 10 (statement -> function .)
    FINAL           reduce using rule 10 (statement -> function .)
    ID              reduce using rule 10 (statement -> function .)
    VOID            reduce using rule 10 (statement -> function .)
    LIST            reduce using rule 10 (statement -> function .)
    DYNAMIC         reduce using rule 10 (statement -> function .)
    RETURN          reduce using rule 10 (statement -> function .)
    MAP             reduce using rule 10 (statement -> function .)
    WHILE           reduce using rule 10 (statement -> function .)
    INT             reduce using rule 10 (statement -> function .)
    DOUBLE          reduce using rule 10 (statement -> function .)
    BOOL            reduce using rule 10 (statement -> function .)
    IF              reduce using rule 10 (statement -> function .)
    FOR             reduce using rule 10 (statement -> function .)
    $end            reduce using rule 10 (statement -> function .)
    RBRACKET        reduce using rule 10 (statement -> function .)


state 11

    (11) statement -> list_definition .

    COMMENT_MULTI   reduce using rule 11 (statement -> list_definition .)
    COMMENT_SINGLE  reduce using rule 11 (statement -> list_definition .)
    SEMICOLON       reduce using rule 11 (statement -> list_definition .)
    PRINT           reduce using rule 11 (statement -> list_definition .)
    STRING          reduce using rule 11 (statement -> list_definition .)
    VAR             reduce using rule 11 (statement -> list_definition .)
    FINAL           reduce using rule 11 (statement -> list_definition .)
    ID              reduce using rule 11 (statement -> list_definition .)
    VOID            reduce using rule 11 (statement -> list_definition .)
    LIST            reduce using rule 11 (statement -> list_definition .)
    DYNAMIC         reduce using rule 11 (statement -> list_definition .)
    RETURN          reduce using rule 11 (statement -> list_definition .)
    MAP             reduce using rule 11 (statement -> list_definition .)
    WHILE           reduce using rule 11 (statement -> list_definition .)
    INT             reduce using rule 11 (statement -> list_definition .)
    DOUBLE          reduce using rule 11 (statement -> list_definition .)
    BOOL            reduce using rule 11 (statement -> list_definition .)
    IF              reduce using rule 11 (statement -> list_definition .)
    FOR             reduce using rule 11 (statement -> list_definition .)
    $end            reduce using rule 11 (statement -> list_definition .)
    RBRACKET        reduce using rule 11 (statement -> list_definition .)


state 12

    (12) statement -> variable_definition .

    COMMENT_MULTI   reduce using rule 12 (statement -> variable_definition .)
    COMMENT_SINGLE  reduce using rule 12 (statement -> variable_definition .)
    SEMICOLON       reduce using rule 12 (statement -> variable_definition .)
    PRINT           reduce using rule 12 (statement -> variable_definition .)
    STRING          reduce using rule 12 (statement -> variable_definition .)
    VAR             reduce using rule 12 (statement -> variable_definition .)
    FINAL           reduce using rule 12 (statement -> variable_definition .)
    ID              reduce using rule 12 (statement -> variable_definition .)
    VOID            reduce using rule 12 (statement -> variable_definition .)
    LIST            reduce using rule 12 (statement -> variable_definition .)
    DYNAMIC         reduce using rule 12 (statement -> variable_definition .)
    RETURN          reduce using rule 12 (statement -> variable_definition .)
    MAP             reduce using rule 12 (statement -> variable_definition .)
    WHILE           reduce using rule 12 (statement -> variable_definition .)
    INT             reduce using rule 12 (statement -> variable_definition .)
    DOUBLE          reduce using rule 12 (statement -> variable_definition .)
    BOOL            reduce using rule 12 (statement -> variable_definition .)
    IF              reduce using rule 12 (statement -> variable_definition .)
    FOR             reduce using rule 12 (statement -> variable_definition .)
    $end            reduce using rule 12 (statement -> variable_definition .)
    RBRACKET        reduce using rule 12 (statement -> variable_definition .)


state 13

    (13) statement -> variable_usage .

    COMMENT_MULTI   reduce using rule 13 (statement -> variable_usage .)
    COMMENT_SINGLE  reduce using rule 13 (statement -> variable_usage .)
    SEMICOLON       reduce using rule 13 (statement -> variable_usage .)
    PRINT           reduce using rule 13 (statement -> variable_usage .)
    STRING          reduce using rule 13 (statement -> variable_usage .)
    VAR             reduce using rule 13 (statement -> variable_usage .)
    FINAL           reduce using rule 13 (statement -> variable_usage .)
    ID              reduce using rule 13 (statement -> variable_usage .)
    VOID            reduce using rule 13 (statement -> variable_usage .)
    LIST            reduce using rule 13 (statement -> variable_usage .)
    DYNAMIC         reduce using rule 13 (statement -> variable_usage .)
    RETURN          reduce using rule 13 (statement -> variable_usage .)
    MAP             reduce using rule 13 (statement -> variable_usage .)
    WHILE           reduce using rule 13 (statement -> variable_usage .)
    INT             reduce using rule 13 (statement -> variable_usage .)
    DOUBLE          reduce using rule 13 (statement -> variable_usage .)
    BOOL            reduce using rule 13 (statement -> variable_usage .)
    IF              reduce using rule 13 (statement -> variable_usage .)
    FOR             reduce using rule 13 (statement -> variable_usage .)
    $end            reduce using rule 13 (statement -> variable_usage .)
    RBRACKET        reduce using rule 13 (statement -> variable_usage .)


state 14

    (14) statement -> call_function .

    COMMENT_MULTI   reduce using rule 14 (statement -> call_function .)
    COMMENT_SINGLE  reduce using rule 14 (statement -> call_function .)
    SEMICOLON       reduce using rule 14 (statement -> call_function .)
    PRINT           reduce using rule 14 (statement -> call_function .)
    STRING          reduce using rule 14 (statement -> call_function .)
    VAR             reduce using rule 14 (statement -> call_function .)
    FINAL           reduce using rule 14 (statement -> call_function .)
    ID              reduce using rule 14 (statement -> call_function .)
    VOID            reduce using rule 14 (statement -> call_function .)
    LIST            reduce using rule 14 (statement -> call_function .)
    DYNAMIC         reduce using rule 14 (statement -> call_function .)
    RETURN          reduce using rule 14 (statement -> call_function .)
    MAP             reduce using rule 14 (statement -> call_function .)
    WHILE           reduce using rule 14 (statement -> call_function .)
    INT             reduce using rule 14 (statement -> call_function .)
    DOUBLE          reduce using rule 14 (statement -> call_function .)
    BOOL            reduce using rule 14 (statement -> call_function .)
    IF              reduce using rule 14 (statement -> call_function .)
    FOR             reduce using rule 14 (statement -> call_function .)
    $end            reduce using rule 14 (statement -> call_function .)
    RBRACKET        reduce using rule 14 (statement -> call_function .)


state 15

    (15) statement -> return .

    COMMENT_MULTI   reduce using rule 15 (statement -> return .)
    COMMENT_SINGLE  reduce using rule 15 (statement -> return .)
    SEMICOLON       reduce using rule 15 (statement -> return .)
    PRINT           reduce using rule 15 (statement -> return .)
    STRING          reduce using rule 15 (statement -> return .)
    VAR             reduce using rule 15 (statement -> return .)
    FINAL           reduce using rule 15 (statement -> return .)
    ID              reduce using rule 15 (statement -> return .)
    VOID            reduce using rule 15 (statement -> return .)
    LIST            reduce using rule 15 (statement -> return .)
    DYNAMIC         reduce using rule 15 (statement -> return .)
    RETURN          reduce using rule 15 (statement -> return .)
    MAP             reduce using rule 15 (statement -> return .)
    WHILE           reduce using rule 15 (statement -> return .)
    INT             reduce using rule 15 (statement -> return .)
    DOUBLE          reduce using rule 15 (statement -> return .)
    BOOL            reduce using rule 15 (statement -> return .)
    IF              reduce using rule 15 (statement -> return .)
    FOR             reduce using rule 15 (statement -> return .)
    $end            reduce using rule 15 (statement -> return .)
    RBRACKET        reduce using rule 15 (statement -> return .)


state 16

    (16) statement -> COMMENT_MULTI .

    COMMENT_MULTI   reduce using rule 16 (statement -> COMMENT_MULTI .)
    COMMENT_SINGLE  reduce using rule 16 (statement -> COMMENT_MULTI .)
    SEMICOLON       reduce using rule 16 (statement -> COMMENT_MULTI .)
    PRINT           reduce using rule 16 (statement -> COMMENT_MULTI .)
    STRING          reduce using rule 16 (statement -> COMMENT_MULTI .)
    VAR             reduce using rule 16 (statement -> COMMENT_MULTI .)
    FINAL           reduce using rule 16 (statement -> COMMENT_MULTI .)
    ID              reduce using rule 16 (statement -> COMMENT_MULTI .)
    VOID            reduce using rule 16 (statement -> COMMENT_MULTI .)
    LIST            reduce using rule 16 (statement -> COMMENT_MULTI .)
    DYNAMIC         reduce using rule 16 (statement -> COMMENT_MULTI .)
    RETURN          reduce using rule 16 (statement -> COMMENT_MULTI .)
    MAP             reduce using rule 16 (statement -> COMMENT_MULTI .)
    WHILE           reduce using rule 16 (statement -> COMMENT_MULTI .)
    INT             reduce using rule 16 (statement -> COMMENT_MULTI .)
    DOUBLE          reduce using rule 16 (statement -> COMMENT_MULTI .)
    BOOL            reduce using rule 16 (statement -> COMMENT_MULTI .)
    IF              reduce using rule 16 (statement -> COMMENT_MULTI .)
    FOR             reduce using rule 16 (statement -> COMMENT_MULTI .)
    $end            reduce using rule 16 (statement -> COMMENT_MULTI .)
    RBRACKET        reduce using rule 16 (statement -> COMMENT_MULTI .)


state 17

    (17) statement -> COMMENT_SINGLE .

    COMMENT_MULTI   reduce using rule 17 (statement -> COMMENT_SINGLE .)
    COMMENT_SINGLE  reduce using rule 17 (statement -> COMMENT_SINGLE .)
    SEMICOLON       reduce using rule 17 (statement -> COMMENT_SINGLE .)
    PRINT           reduce using rule 17 (statement -> COMMENT_SINGLE .)
    STRING          reduce using rule 17 (statement -> COMMENT_SINGLE .)
    VAR             reduce using rule 17 (statement -> COMMENT_SINGLE .)
    FINAL           reduce using rule 17 (statement -> COMMENT_SINGLE .)
    ID              reduce using rule 17 (statement -> COMMENT_SINGLE .)
    VOID            reduce using rule 17 (statement -> COMMENT_SINGLE .)
    LIST            reduce using rule 17 (statement -> COMMENT_SINGLE .)
    DYNAMIC         reduce using rule 17 (statement -> COMMENT_SINGLE .)
    RETURN          reduce using rule 17 (statement -> COMMENT_SINGLE .)
    MAP             reduce using rule 17 (statement -> COMMENT_SINGLE .)
    WHILE           reduce using rule 17 (statement -> COMMENT_SINGLE .)
    INT             reduce using rule 17 (statement -> COMMENT_SINGLE .)
    DOUBLE          reduce using rule 17 (statement -> COMMENT_SINGLE .)
    BOOL            reduce using rule 17 (statement -> COMMENT_SINGLE .)
    IF              reduce using rule 17 (statement -> COMMENT_SINGLE .)
    FOR             reduce using rule 17 (statement -> COMMENT_SINGLE .)
    $end            reduce using rule 17 (statement -> COMMENT_SINGLE .)
    RBRACKET        reduce using rule 17 (statement -> COMMENT_SINGLE .)


state 18

    (18) statement -> SEMICOLON .

    COMMENT_MULTI   reduce using rule 18 (statement -> SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 18 (statement -> SEMICOLON .)
    SEMICOLON       reduce using rule 18 (statement -> SEMICOLON .)
    PRINT           reduce using rule 18 (statement -> SEMICOLON .)
    STRING          reduce using rule 18 (statement -> SEMICOLON .)
    VAR             reduce using rule 18 (statement -> SEMICOLON .)
    FINAL           reduce using rule 18 (statement -> SEMICOLON .)
    ID              reduce using rule 18 (statement -> SEMICOLON .)
    VOID            reduce using rule 18 (statement -> SEMICOLON .)
    LIST            reduce using rule 18 (statement -> SEMICOLON .)
    DYNAMIC         reduce using rule 18 (statement -> SEMICOLON .)
    RETURN          reduce using rule 18 (statement -> SEMICOLON .)
    MAP             reduce using rule 18 (statement -> SEMICOLON .)
    WHILE           reduce using rule 18 (statement -> SEMICOLON .)
    INT             reduce using rule 18 (statement -> SEMICOLON .)
    DOUBLE          reduce using rule 18 (statement -> SEMICOLON .)
    BOOL            reduce using rule 18 (statement -> SEMICOLON .)
    IF              reduce using rule 18 (statement -> SEMICOLON .)
    FOR             reduce using rule 18 (statement -> SEMICOLON .)
    $end            reduce using rule 18 (statement -> SEMICOLON .)
    RBRACKET        reduce using rule 18 (statement -> SEMICOLON .)


state 19

    (43) print -> PRINT . LPAREN RPAREN SEMICOLON
    (44) print -> PRINT . LPAREN expression RPAREN SEMICOLON

    LPAREN          shift and go to state 45


state 20

    (27) data_input -> STRING . ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> STRING . QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (88) type -> STRING .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 46
    QUESTION        shift and go to state 47

  ! ID              [ reduce using rule 88 (type -> STRING .) ]


state 21

    (117) constructor -> ID . LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (23) variable_usage -> ID . SEMICOLON
    (24) variable_usage -> ID . ASSIGN expression SEMICOLON
    (25) call_function -> ID . LPAREN argument_list RPAREN
    (26) call_function -> ID . LPAREN RPAREN

    LPAREN          shift and go to state 48
    SEMICOLON       shift and go to state 49
    ASSIGN          shift and go to state 50


state 22

    (94) set -> VAR . ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (95) set -> VAR . ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (42) variable_definition -> VAR . ID ASSIGN expression SEMICOLON

    ID              shift and go to state 51


state 23

    (96) set -> FINAL . ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON

    ID              shift and go to state 52


state 24

    (120) map -> map_declaration . map_assignment
    (122) map_assignment -> . LBRACKET map_contents RBRACKET

    LBRACKET        shift and go to state 54

    map_assignment                 shift and go to state 53

state 25

    (20) control_structures -> control_structures_if_else .

    COMMENT_MULTI   reduce using rule 20 (control_structures -> control_structures_if_else .)
    COMMENT_SINGLE  reduce using rule 20 (control_structures -> control_structures_if_else .)
    SEMICOLON       reduce using rule 20 (control_structures -> control_structures_if_else .)
    PRINT           reduce using rule 20 (control_structures -> control_structures_if_else .)
    STRING          reduce using rule 20 (control_structures -> control_structures_if_else .)
    VAR             reduce using rule 20 (control_structures -> control_structures_if_else .)
    FINAL           reduce using rule 20 (control_structures -> control_structures_if_else .)
    ID              reduce using rule 20 (control_structures -> control_structures_if_else .)
    VOID            reduce using rule 20 (control_structures -> control_structures_if_else .)
    LIST            reduce using rule 20 (control_structures -> control_structures_if_else .)
    DYNAMIC         reduce using rule 20 (control_structures -> control_structures_if_else .)
    RETURN          reduce using rule 20 (control_structures -> control_structures_if_else .)
    MAP             reduce using rule 20 (control_structures -> control_structures_if_else .)
    WHILE           reduce using rule 20 (control_structures -> control_structures_if_else .)
    INT             reduce using rule 20 (control_structures -> control_structures_if_else .)
    DOUBLE          reduce using rule 20 (control_structures -> control_structures_if_else .)
    BOOL            reduce using rule 20 (control_structures -> control_structures_if_else .)
    IF              reduce using rule 20 (control_structures -> control_structures_if_else .)
    FOR             reduce using rule 20 (control_structures -> control_structures_if_else .)
    $end            reduce using rule 20 (control_structures -> control_structures_if_else .)
    RBRACKET        reduce using rule 20 (control_structures -> control_structures_if_else .)


state 26

    (21) control_structures -> control_structures_for .

    COMMENT_MULTI   reduce using rule 21 (control_structures -> control_structures_for .)
    COMMENT_SINGLE  reduce using rule 21 (control_structures -> control_structures_for .)
    SEMICOLON       reduce using rule 21 (control_structures -> control_structures_for .)
    PRINT           reduce using rule 21 (control_structures -> control_structures_for .)
    STRING          reduce using rule 21 (control_structures -> control_structures_for .)
    VAR             reduce using rule 21 (control_structures -> control_structures_for .)
    FINAL           reduce using rule 21 (control_structures -> control_structures_for .)
    ID              reduce using rule 21 (control_structures -> control_structures_for .)
    VOID            reduce using rule 21 (control_structures -> control_structures_for .)
    LIST            reduce using rule 21 (control_structures -> control_structures_for .)
    DYNAMIC         reduce using rule 21 (control_structures -> control_structures_for .)
    RETURN          reduce using rule 21 (control_structures -> control_structures_for .)
    MAP             reduce using rule 21 (control_structures -> control_structures_for .)
    WHILE           reduce using rule 21 (control_structures -> control_structures_for .)
    INT             reduce using rule 21 (control_structures -> control_structures_for .)
    DOUBLE          reduce using rule 21 (control_structures -> control_structures_for .)
    BOOL            reduce using rule 21 (control_structures -> control_structures_for .)
    IF              reduce using rule 21 (control_structures -> control_structures_for .)
    FOR             reduce using rule 21 (control_structures -> control_structures_for .)
    $end            reduce using rule 21 (control_structures -> control_structures_for .)
    RBRACKET        reduce using rule 21 (control_structures -> control_structures_for .)


state 27

    (22) control_structures -> control_structures_while .

    COMMENT_MULTI   reduce using rule 22 (control_structures -> control_structures_while .)
    COMMENT_SINGLE  reduce using rule 22 (control_structures -> control_structures_while .)
    SEMICOLON       reduce using rule 22 (control_structures -> control_structures_while .)
    PRINT           reduce using rule 22 (control_structures -> control_structures_while .)
    STRING          reduce using rule 22 (control_structures -> control_structures_while .)
    VAR             reduce using rule 22 (control_structures -> control_structures_while .)
    FINAL           reduce using rule 22 (control_structures -> control_structures_while .)
    ID              reduce using rule 22 (control_structures -> control_structures_while .)
    VOID            reduce using rule 22 (control_structures -> control_structures_while .)
    LIST            reduce using rule 22 (control_structures -> control_structures_while .)
    DYNAMIC         reduce using rule 22 (control_structures -> control_structures_while .)
    RETURN          reduce using rule 22 (control_structures -> control_structures_while .)
    MAP             reduce using rule 22 (control_structures -> control_structures_while .)
    WHILE           reduce using rule 22 (control_structures -> control_structures_while .)
    INT             reduce using rule 22 (control_structures -> control_structures_while .)
    DOUBLE          reduce using rule 22 (control_structures -> control_structures_while .)
    BOOL            reduce using rule 22 (control_structures -> control_structures_while .)
    IF              reduce using rule 22 (control_structures -> control_structures_while .)
    FOR             reduce using rule 22 (control_structures -> control_structures_while .)
    $end            reduce using rule 22 (control_structures -> control_structures_while .)
    RBRACKET        reduce using rule 22 (control_structures -> control_structures_while .)


state 28

    (34) function -> type . ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> type . ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (118) function -> type . ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (40) variable_definition -> type . ID ASSIGN expression SEMICOLON

    ID              shift and go to state 55


state 29

    (35) function -> VOID . ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (37) function -> VOID . ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> VOID . ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> VOID . ID LPAREN parameter_list RPAREN LBRACKET RBRACKET

    ID              shift and go to state 56


state 30

    (83) list_definition -> LIST . LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON

    LESS            shift and go to state 57


state 31

    (41) variable_definition -> DYNAMIC . ID ASSIGN expression SEMICOLON

    ID              shift and go to state 58


state 32

    (19) return -> RETURN . expression SEMICOLON
    (45) expression -> . operations
    (46) expression -> . conditions
    (47) expression -> . length
    (48) expression -> . call_function
    (49) operations -> . operand
    (50) operations -> . operand operator operations
    (67) conditions -> . condition
    (68) conditions -> . condition AND conditions
    (69) conditions -> . condition OR conditions
    (29) length -> . call_list DOT LENGTH
    (30) length -> . TEXT DOT LENGTH
    (31) length -> . ID DOT LENGTH
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (51) operand -> . NUMBER
    (52) operand -> . NDOUBLE
    (53) operand -> . ID
    (70) condition -> . value comparator value
    (71) condition -> . NOT value
    (82) call_list -> . LSBRACKET value_list RSBRACKET
    (90) value -> . operand
    (91) value -> . TEXT
    (92) value -> . TRUE
    (93) value -> . FALSE

    TEXT            shift and go to state 67
    ID              shift and go to state 68
    NUMBER          shift and go to state 69
    NDOUBLE         shift and go to state 70
    NOT             shift and go to state 72
    LSBRACKET       shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 75

    expression                     shift and go to state 59
    operations                     shift and go to state 60
    conditions                     shift and go to state 61
    length                         shift and go to state 62
    call_function                  shift and go to state 63
    operand                        shift and go to state 64
    condition                      shift and go to state 65
    call_list                      shift and go to state 66
    value                          shift and go to state 71

state 33

    (121) map_declaration -> MAP . LESS key_type COMMA type GREATER ID ASSIGN

    LESS            shift and go to state 76


state 34

    (59) control_structures_if_else -> if_block .
    (60) control_structures_if_else -> if_block . else_if_blocks
    (61) control_structures_if_else -> if_block . else_if_blocks else_block
    (62) control_structures_if_else -> if_block . else_block
    (64) else_if_blocks -> . ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (65) else_if_blocks -> . else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (66) else_block -> . ELSE LBRACKET statement_list RBRACKET

    COMMENT_MULTI   reduce using rule 59 (control_structures_if_else -> if_block .)
    COMMENT_SINGLE  reduce using rule 59 (control_structures_if_else -> if_block .)
    SEMICOLON       reduce using rule 59 (control_structures_if_else -> if_block .)
    PRINT           reduce using rule 59 (control_structures_if_else -> if_block .)
    STRING          reduce using rule 59 (control_structures_if_else -> if_block .)
    VAR             reduce using rule 59 (control_structures_if_else -> if_block .)
    FINAL           reduce using rule 59 (control_structures_if_else -> if_block .)
    ID              reduce using rule 59 (control_structures_if_else -> if_block .)
    VOID            reduce using rule 59 (control_structures_if_else -> if_block .)
    LIST            reduce using rule 59 (control_structures_if_else -> if_block .)
    DYNAMIC         reduce using rule 59 (control_structures_if_else -> if_block .)
    RETURN          reduce using rule 59 (control_structures_if_else -> if_block .)
    MAP             reduce using rule 59 (control_structures_if_else -> if_block .)
    WHILE           reduce using rule 59 (control_structures_if_else -> if_block .)
    INT             reduce using rule 59 (control_structures_if_else -> if_block .)
    DOUBLE          reduce using rule 59 (control_structures_if_else -> if_block .)
    BOOL            reduce using rule 59 (control_structures_if_else -> if_block .)
    IF              reduce using rule 59 (control_structures_if_else -> if_block .)
    FOR             reduce using rule 59 (control_structures_if_else -> if_block .)
    $end            reduce using rule 59 (control_structures_if_else -> if_block .)
    RBRACKET        reduce using rule 59 (control_structures_if_else -> if_block .)
    ELSE            shift and go to state 79

    else_if_blocks                 shift and go to state 77
    else_block                     shift and go to state 78

state 35

    (112) control_structures_for -> for_classic .

    COMMENT_MULTI   reduce using rule 112 (control_structures_for -> for_classic .)
    COMMENT_SINGLE  reduce using rule 112 (control_structures_for -> for_classic .)
    SEMICOLON       reduce using rule 112 (control_structures_for -> for_classic .)
    PRINT           reduce using rule 112 (control_structures_for -> for_classic .)
    STRING          reduce using rule 112 (control_structures_for -> for_classic .)
    VAR             reduce using rule 112 (control_structures_for -> for_classic .)
    FINAL           reduce using rule 112 (control_structures_for -> for_classic .)
    ID              reduce using rule 112 (control_structures_for -> for_classic .)
    VOID            reduce using rule 112 (control_structures_for -> for_classic .)
    LIST            reduce using rule 112 (control_structures_for -> for_classic .)
    DYNAMIC         reduce using rule 112 (control_structures_for -> for_classic .)
    RETURN          reduce using rule 112 (control_structures_for -> for_classic .)
    MAP             reduce using rule 112 (control_structures_for -> for_classic .)
    WHILE           reduce using rule 112 (control_structures_for -> for_classic .)
    INT             reduce using rule 112 (control_structures_for -> for_classic .)
    DOUBLE          reduce using rule 112 (control_structures_for -> for_classic .)
    BOOL            reduce using rule 112 (control_structures_for -> for_classic .)
    IF              reduce using rule 112 (control_structures_for -> for_classic .)
    FOR             reduce using rule 112 (control_structures_for -> for_classic .)
    $end            reduce using rule 112 (control_structures_for -> for_classic .)
    RBRACKET        reduce using rule 112 (control_structures_for -> for_classic .)


state 36

    (113) control_structures_for -> for_in .

    COMMENT_MULTI   reduce using rule 113 (control_structures_for -> for_in .)
    COMMENT_SINGLE  reduce using rule 113 (control_structures_for -> for_in .)
    SEMICOLON       reduce using rule 113 (control_structures_for -> for_in .)
    PRINT           reduce using rule 113 (control_structures_for -> for_in .)
    STRING          reduce using rule 113 (control_structures_for -> for_in .)
    VAR             reduce using rule 113 (control_structures_for -> for_in .)
    FINAL           reduce using rule 113 (control_structures_for -> for_in .)
    ID              reduce using rule 113 (control_structures_for -> for_in .)
    VOID            reduce using rule 113 (control_structures_for -> for_in .)
    LIST            reduce using rule 113 (control_structures_for -> for_in .)
    DYNAMIC         reduce using rule 113 (control_structures_for -> for_in .)
    RETURN          reduce using rule 113 (control_structures_for -> for_in .)
    MAP             reduce using rule 113 (control_structures_for -> for_in .)
    WHILE           reduce using rule 113 (control_structures_for -> for_in .)
    INT             reduce using rule 113 (control_structures_for -> for_in .)
    DOUBLE          reduce using rule 113 (control_structures_for -> for_in .)
    BOOL            reduce using rule 113 (control_structures_for -> for_in .)
    IF              reduce using rule 113 (control_structures_for -> for_in .)
    FOR             reduce using rule 113 (control_structures_for -> for_in .)
    $end            reduce using rule 113 (control_structures_for -> for_in .)
    RBRACKET        reduce using rule 113 (control_structures_for -> for_in .)


state 37

    (114) control_structures_for -> for_each .

    COMMENT_MULTI   reduce using rule 114 (control_structures_for -> for_each .)
    COMMENT_SINGLE  reduce using rule 114 (control_structures_for -> for_each .)
    SEMICOLON       reduce using rule 114 (control_structures_for -> for_each .)
    PRINT           reduce using rule 114 (control_structures_for -> for_each .)
    STRING          reduce using rule 114 (control_structures_for -> for_each .)
    VAR             reduce using rule 114 (control_structures_for -> for_each .)
    FINAL           reduce using rule 114 (control_structures_for -> for_each .)
    ID              reduce using rule 114 (control_structures_for -> for_each .)
    VOID            reduce using rule 114 (control_structures_for -> for_each .)
    LIST            reduce using rule 114 (control_structures_for -> for_each .)
    DYNAMIC         reduce using rule 114 (control_structures_for -> for_each .)
    RETURN          reduce using rule 114 (control_structures_for -> for_each .)
    MAP             reduce using rule 114 (control_structures_for -> for_each .)
    WHILE           reduce using rule 114 (control_structures_for -> for_each .)
    INT             reduce using rule 114 (control_structures_for -> for_each .)
    DOUBLE          reduce using rule 114 (control_structures_for -> for_each .)
    BOOL            reduce using rule 114 (control_structures_for -> for_each .)
    IF              reduce using rule 114 (control_structures_for -> for_each .)
    FOR             reduce using rule 114 (control_structures_for -> for_each .)
    $end            reduce using rule 114 (control_structures_for -> for_each .)
    RBRACKET        reduce using rule 114 (control_structures_for -> for_each .)


state 38

    (119) control_structures_while -> WHILE . LPAREN conditions RPAREN LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 80


state 39

    (86) type -> INT .

    ID              reduce using rule 86 (type -> INT .)
    GREATER         reduce using rule 86 (type -> INT .)


state 40

    (87) type -> DOUBLE .

    ID              reduce using rule 87 (type -> DOUBLE .)
    GREATER         reduce using rule 87 (type -> DOUBLE .)


state 41

    (89) type -> BOOL .

    ID              reduce using rule 89 (type -> BOOL .)
    GREATER         reduce using rule 89 (type -> BOOL .)


state 42

    (63) if_block -> IF . LPAREN conditions RPAREN LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 81


state 43

    (105) for_classic -> FOR . LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (107) for_in -> FOR . LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (111) for_each -> FOR . LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 82


state 44

    (3) statement_list -> statement_list statement .

    COMMENT_MULTI   reduce using rule 3 (statement_list -> statement_list statement .)
    COMMENT_SINGLE  reduce using rule 3 (statement_list -> statement_list statement .)
    SEMICOLON       reduce using rule 3 (statement_list -> statement_list statement .)
    PRINT           reduce using rule 3 (statement_list -> statement_list statement .)
    STRING          reduce using rule 3 (statement_list -> statement_list statement .)
    VAR             reduce using rule 3 (statement_list -> statement_list statement .)
    FINAL           reduce using rule 3 (statement_list -> statement_list statement .)
    ID              reduce using rule 3 (statement_list -> statement_list statement .)
    VOID            reduce using rule 3 (statement_list -> statement_list statement .)
    LIST            reduce using rule 3 (statement_list -> statement_list statement .)
    DYNAMIC         reduce using rule 3 (statement_list -> statement_list statement .)
    RETURN          reduce using rule 3 (statement_list -> statement_list statement .)
    MAP             reduce using rule 3 (statement_list -> statement_list statement .)
    WHILE           reduce using rule 3 (statement_list -> statement_list statement .)
    INT             reduce using rule 3 (statement_list -> statement_list statement .)
    DOUBLE          reduce using rule 3 (statement_list -> statement_list statement .)
    BOOL            reduce using rule 3 (statement_list -> statement_list statement .)
    IF              reduce using rule 3 (statement_list -> statement_list statement .)
    FOR             reduce using rule 3 (statement_list -> statement_list statement .)
    $end            reduce using rule 3 (statement_list -> statement_list statement .)
    RBRACKET        reduce using rule 3 (statement_list -> statement_list statement .)


state 45

    (43) print -> PRINT LPAREN . RPAREN SEMICOLON
    (44) print -> PRINT LPAREN . expression RPAREN SEMICOLON
    (45) expression -> . operations
    (46) expression -> . conditions
    (47) expression -> . length
    (48) expression -> . call_function
    (49) operations -> . operand
    (50) operations -> . operand operator operations
    (67) conditions -> . condition
    (68) conditions -> . condition AND conditions
    (69) conditions -> . condition OR conditions
    (29) length -> . call_list DOT LENGTH
    (30) length -> . TEXT DOT LENGTH
    (31) length -> . ID DOT LENGTH
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (51) operand -> . NUMBER
    (52) operand -> . NDOUBLE
    (53) operand -> . ID
    (70) condition -> . value comparator value
    (71) condition -> . NOT value
    (82) call_list -> . LSBRACKET value_list RSBRACKET
    (90) value -> . operand
    (91) value -> . TEXT
    (92) value -> . TRUE
    (93) value -> . FALSE

    RPAREN          shift and go to state 83
    TEXT            shift and go to state 67
    ID              shift and go to state 68
    NUMBER          shift and go to state 69
    NDOUBLE         shift and go to state 70
    NOT             shift and go to state 72
    LSBRACKET       shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 75

    expression                     shift and go to state 84
    operations                     shift and go to state 60
    conditions                     shift and go to state 61
    length                         shift and go to state 62
    call_function                  shift and go to state 63
    operand                        shift and go to state 64
    condition                      shift and go to state 65
    call_list                      shift and go to state 66
    value                          shift and go to state 71

state 46

    (27) data_input -> STRING ID . ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    ASSIGN          shift and go to state 85


state 47

    (28) data_input -> STRING QUESTION . ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    ID              shift and go to state 86


state 48

    (117) constructor -> ID LPAREN . constructor_parenthesis_content RPAREN SEMICOLON
    (25) call_function -> ID LPAREN . argument_list RPAREN
    (26) call_function -> ID LPAREN . RPAREN
    (115) constructor_parenthesis_content -> . THIS DOT ID
    (116) constructor_parenthesis_content -> . THIS DOT ID COMMA constructor_parenthesis_content
    (32) argument_list -> . expression
    (33) argument_list -> . argument_list COMMA expression
    (45) expression -> . operations
    (46) expression -> . conditions
    (47) expression -> . length
    (48) expression -> . call_function
    (49) operations -> . operand
    (50) operations -> . operand operator operations
    (67) conditions -> . condition
    (68) conditions -> . condition AND conditions
    (69) conditions -> . condition OR conditions
    (29) length -> . call_list DOT LENGTH
    (30) length -> . TEXT DOT LENGTH
    (31) length -> . ID DOT LENGTH
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (51) operand -> . NUMBER
    (52) operand -> . NDOUBLE
    (53) operand -> . ID
    (70) condition -> . value comparator value
    (71) condition -> . NOT value
    (82) call_list -> . LSBRACKET value_list RSBRACKET
    (90) value -> . operand
    (91) value -> . TEXT
    (92) value -> . TRUE
    (93) value -> . FALSE

    RPAREN          shift and go to state 88
    THIS            shift and go to state 90
    TEXT            shift and go to state 67
    ID              shift and go to state 68
    NUMBER          shift and go to state 69
    NDOUBLE         shift and go to state 70
    NOT             shift and go to state 72
    LSBRACKET       shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 75

    constructor_parenthesis_content shift and go to state 87
    argument_list                  shift and go to state 89
    expression                     shift and go to state 91
    operations                     shift and go to state 60
    conditions                     shift and go to state 61
    length                         shift and go to state 62
    call_function                  shift and go to state 63
    operand                        shift and go to state 64
    condition                      shift and go to state 65
    call_list                      shift and go to state 66
    value                          shift and go to state 71

state 49

    (23) variable_usage -> ID SEMICOLON .

    COMMENT_MULTI   reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    SEMICOLON       reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    PRINT           reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    STRING          reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    VAR             reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    FINAL           reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    ID              reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    VOID            reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    LIST            reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    DYNAMIC         reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    RETURN          reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    MAP             reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    WHILE           reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    INT             reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    DOUBLE          reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    BOOL            reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    IF              reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    FOR             reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    $end            reduce using rule 23 (variable_usage -> ID SEMICOLON .)
    RBRACKET        reduce using rule 23 (variable_usage -> ID SEMICOLON .)


state 50

    (24) variable_usage -> ID ASSIGN . expression SEMICOLON
    (45) expression -> . operations
    (46) expression -> . conditions
    (47) expression -> . length
    (48) expression -> . call_function
    (49) operations -> . operand
    (50) operations -> . operand operator operations
    (67) conditions -> . condition
    (68) conditions -> . condition AND conditions
    (69) conditions -> . condition OR conditions
    (29) length -> . call_list DOT LENGTH
    (30) length -> . TEXT DOT LENGTH
    (31) length -> . ID DOT LENGTH
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (51) operand -> . NUMBER
    (52) operand -> . NDOUBLE
    (53) operand -> . ID
    (70) condition -> . value comparator value
    (71) condition -> . NOT value
    (82) call_list -> . LSBRACKET value_list RSBRACKET
    (90) value -> . operand
    (91) value -> . TEXT
    (92) value -> . TRUE
    (93) value -> . FALSE

    TEXT            shift and go to state 67
    ID              shift and go to state 68
    NUMBER          shift and go to state 69
    NDOUBLE         shift and go to state 70
    NOT             shift and go to state 72
    LSBRACKET       shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 75

    expression                     shift and go to state 92
    operations                     shift and go to state 60
    conditions                     shift and go to state 61
    length                         shift and go to state 62
    call_function                  shift and go to state 63
    operand                        shift and go to state 64
    condition                      shift and go to state 65
    call_list                      shift and go to state 66
    value                          shift and go to state 71

state 51

    (94) set -> VAR ID . ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (95) set -> VAR ID . ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (42) variable_definition -> VAR ID . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 93


state 52

    (96) set -> FINAL ID . ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON

    ASSIGN          shift and go to state 94


state 53

    (120) map -> map_declaration map_assignment .

    COMMENT_MULTI   reduce using rule 120 (map -> map_declaration map_assignment .)
    COMMENT_SINGLE  reduce using rule 120 (map -> map_declaration map_assignment .)
    SEMICOLON       reduce using rule 120 (map -> map_declaration map_assignment .)
    PRINT           reduce using rule 120 (map -> map_declaration map_assignment .)
    STRING          reduce using rule 120 (map -> map_declaration map_assignment .)
    VAR             reduce using rule 120 (map -> map_declaration map_assignment .)
    FINAL           reduce using rule 120 (map -> map_declaration map_assignment .)
    ID              reduce using rule 120 (map -> map_declaration map_assignment .)
    VOID            reduce using rule 120 (map -> map_declaration map_assignment .)
    LIST            reduce using rule 120 (map -> map_declaration map_assignment .)
    DYNAMIC         reduce using rule 120 (map -> map_declaration map_assignment .)
    RETURN          reduce using rule 120 (map -> map_declaration map_assignment .)
    MAP             reduce using rule 120 (map -> map_declaration map_assignment .)
    WHILE           reduce using rule 120 (map -> map_declaration map_assignment .)
    INT             reduce using rule 120 (map -> map_declaration map_assignment .)
    DOUBLE          reduce using rule 120 (map -> map_declaration map_assignment .)
    BOOL            reduce using rule 120 (map -> map_declaration map_assignment .)
    IF              reduce using rule 120 (map -> map_declaration map_assignment .)
    FOR             reduce using rule 120 (map -> map_declaration map_assignment .)
    $end            reduce using rule 120 (map -> map_declaration map_assignment .)
    RBRACKET        reduce using rule 120 (map -> map_declaration map_assignment .)


state 54

    (122) map_assignment -> LBRACKET . map_contents RBRACKET
    (123) map_contents -> . map_content
    (124) map_contents -> . map_content COMMA map_contents
    (125) map_content -> . key_value COLON value
    (126) key_value -> . TEXT

    TEXT            shift and go to state 98

    map_contents                   shift and go to state 95
    map_content                    shift and go to state 96
    key_value                      shift and go to state 97

state 55

    (34) function -> type ID . LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> type ID . LPAREN RPAREN LBRACKET statement_list RBRACKET
    (118) function -> type ID . LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (40) variable_definition -> type ID . ASSIGN expression SEMICOLON

    LPAREN          shift and go to state 99
    ASSIGN          shift and go to state 100


state 56

    (35) function -> VOID ID . LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (37) function -> VOID ID . LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> VOID ID . LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> VOID ID . LPAREN parameter_list RPAREN LBRACKET RBRACKET

    LPAREN          shift and go to state 101


state 57

    (83) list_definition -> LIST LESS . type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (86) type -> . INT
    (87) type -> . DOUBLE
    (88) type -> . STRING
    (89) type -> . BOOL

    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 103
    BOOL            shift and go to state 41

    type                           shift and go to state 102

state 58

    (41) variable_definition -> DYNAMIC ID . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 104


state 59

    (19) return -> RETURN expression . SEMICOLON

    SEMICOLON       shift and go to state 105


state 60

    (45) expression -> operations .

    SEMICOLON       reduce using rule 45 (expression -> operations .)
    RPAREN          reduce using rule 45 (expression -> operations .)
    COMMA           reduce using rule 45 (expression -> operations .)
    COMMENT_MULTI   reduce using rule 45 (expression -> operations .)
    COMMENT_SINGLE  reduce using rule 45 (expression -> operations .)
    PRINT           reduce using rule 45 (expression -> operations .)
    STRING          reduce using rule 45 (expression -> operations .)
    VAR             reduce using rule 45 (expression -> operations .)
    FINAL           reduce using rule 45 (expression -> operations .)
    ID              reduce using rule 45 (expression -> operations .)
    VOID            reduce using rule 45 (expression -> operations .)
    LIST            reduce using rule 45 (expression -> operations .)
    DYNAMIC         reduce using rule 45 (expression -> operations .)
    RETURN          reduce using rule 45 (expression -> operations .)
    MAP             reduce using rule 45 (expression -> operations .)
    WHILE           reduce using rule 45 (expression -> operations .)
    INT             reduce using rule 45 (expression -> operations .)
    DOUBLE          reduce using rule 45 (expression -> operations .)
    BOOL            reduce using rule 45 (expression -> operations .)
    IF              reduce using rule 45 (expression -> operations .)
    FOR             reduce using rule 45 (expression -> operations .)
    $end            reduce using rule 45 (expression -> operations .)
    RBRACKET        reduce using rule 45 (expression -> operations .)


state 61

    (46) expression -> conditions .

    SEMICOLON       reduce using rule 46 (expression -> conditions .)
    RPAREN          reduce using rule 46 (expression -> conditions .)
    COMMA           reduce using rule 46 (expression -> conditions .)
    COMMENT_MULTI   reduce using rule 46 (expression -> conditions .)
    COMMENT_SINGLE  reduce using rule 46 (expression -> conditions .)
    PRINT           reduce using rule 46 (expression -> conditions .)
    STRING          reduce using rule 46 (expression -> conditions .)
    VAR             reduce using rule 46 (expression -> conditions .)
    FINAL           reduce using rule 46 (expression -> conditions .)
    ID              reduce using rule 46 (expression -> conditions .)
    VOID            reduce using rule 46 (expression -> conditions .)
    LIST            reduce using rule 46 (expression -> conditions .)
    DYNAMIC         reduce using rule 46 (expression -> conditions .)
    RETURN          reduce using rule 46 (expression -> conditions .)
    MAP             reduce using rule 46 (expression -> conditions .)
    WHILE           reduce using rule 46 (expression -> conditions .)
    INT             reduce using rule 46 (expression -> conditions .)
    DOUBLE          reduce using rule 46 (expression -> conditions .)
    BOOL            reduce using rule 46 (expression -> conditions .)
    IF              reduce using rule 46 (expression -> conditions .)
    FOR             reduce using rule 46 (expression -> conditions .)
    $end            reduce using rule 46 (expression -> conditions .)
    RBRACKET        reduce using rule 46 (expression -> conditions .)


state 62

    (47) expression -> length .

    SEMICOLON       reduce using rule 47 (expression -> length .)
    RPAREN          reduce using rule 47 (expression -> length .)
    COMMA           reduce using rule 47 (expression -> length .)
    COMMENT_MULTI   reduce using rule 47 (expression -> length .)
    COMMENT_SINGLE  reduce using rule 47 (expression -> length .)
    PRINT           reduce using rule 47 (expression -> length .)
    STRING          reduce using rule 47 (expression -> length .)
    VAR             reduce using rule 47 (expression -> length .)
    FINAL           reduce using rule 47 (expression -> length .)
    ID              reduce using rule 47 (expression -> length .)
    VOID            reduce using rule 47 (expression -> length .)
    LIST            reduce using rule 47 (expression -> length .)
    DYNAMIC         reduce using rule 47 (expression -> length .)
    RETURN          reduce using rule 47 (expression -> length .)
    MAP             reduce using rule 47 (expression -> length .)
    WHILE           reduce using rule 47 (expression -> length .)
    INT             reduce using rule 47 (expression -> length .)
    DOUBLE          reduce using rule 47 (expression -> length .)
    BOOL            reduce using rule 47 (expression -> length .)
    IF              reduce using rule 47 (expression -> length .)
    FOR             reduce using rule 47 (expression -> length .)
    $end            reduce using rule 47 (expression -> length .)
    RBRACKET        reduce using rule 47 (expression -> length .)


state 63

    (48) expression -> call_function .

    SEMICOLON       reduce using rule 48 (expression -> call_function .)
    RPAREN          reduce using rule 48 (expression -> call_function .)
    COMMA           reduce using rule 48 (expression -> call_function .)
    COMMENT_MULTI   reduce using rule 48 (expression -> call_function .)
    COMMENT_SINGLE  reduce using rule 48 (expression -> call_function .)
    PRINT           reduce using rule 48 (expression -> call_function .)
    STRING          reduce using rule 48 (expression -> call_function .)
    VAR             reduce using rule 48 (expression -> call_function .)
    FINAL           reduce using rule 48 (expression -> call_function .)
    ID              reduce using rule 48 (expression -> call_function .)
    VOID            reduce using rule 48 (expression -> call_function .)
    LIST            reduce using rule 48 (expression -> call_function .)
    DYNAMIC         reduce using rule 48 (expression -> call_function .)
    RETURN          reduce using rule 48 (expression -> call_function .)
    MAP             reduce using rule 48 (expression -> call_function .)
    WHILE           reduce using rule 48 (expression -> call_function .)
    INT             reduce using rule 48 (expression -> call_function .)
    DOUBLE          reduce using rule 48 (expression -> call_function .)
    BOOL            reduce using rule 48 (expression -> call_function .)
    IF              reduce using rule 48 (expression -> call_function .)
    FOR             reduce using rule 48 (expression -> call_function .)
    $end            reduce using rule 48 (expression -> call_function .)
    RBRACKET        reduce using rule 48 (expression -> call_function .)


state 64

    (49) operations -> operand .
    (50) operations -> operand . operator operations
    (90) value -> operand .
    (54) operator -> . PLUS
    (55) operator -> . MINUS
    (56) operator -> . TIMES
    (57) operator -> . DIVIDE
    (58) operator -> . INT_DIVIDE

    SEMICOLON       reduce using rule 49 (operations -> operand .)
    RPAREN          reduce using rule 49 (operations -> operand .)
    COMMA           reduce using rule 49 (operations -> operand .)
    COMMENT_MULTI   reduce using rule 49 (operations -> operand .)
    COMMENT_SINGLE  reduce using rule 49 (operations -> operand .)
    PRINT           reduce using rule 49 (operations -> operand .)
    STRING          reduce using rule 49 (operations -> operand .)
    VAR             reduce using rule 49 (operations -> operand .)
    FINAL           reduce using rule 49 (operations -> operand .)
    ID              reduce using rule 49 (operations -> operand .)
    VOID            reduce using rule 49 (operations -> operand .)
    LIST            reduce using rule 49 (operations -> operand .)
    DYNAMIC         reduce using rule 49 (operations -> operand .)
    RETURN          reduce using rule 49 (operations -> operand .)
    MAP             reduce using rule 49 (operations -> operand .)
    WHILE           reduce using rule 49 (operations -> operand .)
    INT             reduce using rule 49 (operations -> operand .)
    DOUBLE          reduce using rule 49 (operations -> operand .)
    BOOL            reduce using rule 49 (operations -> operand .)
    IF              reduce using rule 49 (operations -> operand .)
    FOR             reduce using rule 49 (operations -> operand .)
    $end            reduce using rule 49 (operations -> operand .)
    RBRACKET        reduce using rule 49 (operations -> operand .)
    GREATER         reduce using rule 90 (value -> operand .)
    LESS            reduce using rule 90 (value -> operand .)
    EQUALS          reduce using rule 90 (value -> operand .)
    GREATER_EQUAL   reduce using rule 90 (value -> operand .)
    LESS_EQUAL      reduce using rule 90 (value -> operand .)
    NOT_EQUALS      reduce using rule 90 (value -> operand .)
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108
    TIMES           shift and go to state 109
    DIVIDE          shift and go to state 110
    INT_DIVIDE      shift and go to state 111

    operator                       shift and go to state 106

state 65

    (67) conditions -> condition .
    (68) conditions -> condition . AND conditions
    (69) conditions -> condition . OR conditions

    SEMICOLON       reduce using rule 67 (conditions -> condition .)
    RPAREN          reduce using rule 67 (conditions -> condition .)
    COMMA           reduce using rule 67 (conditions -> condition .)
    COMMENT_MULTI   reduce using rule 67 (conditions -> condition .)
    COMMENT_SINGLE  reduce using rule 67 (conditions -> condition .)
    PRINT           reduce using rule 67 (conditions -> condition .)
    STRING          reduce using rule 67 (conditions -> condition .)
    VAR             reduce using rule 67 (conditions -> condition .)
    FINAL           reduce using rule 67 (conditions -> condition .)
    ID              reduce using rule 67 (conditions -> condition .)
    VOID            reduce using rule 67 (conditions -> condition .)
    LIST            reduce using rule 67 (conditions -> condition .)
    DYNAMIC         reduce using rule 67 (conditions -> condition .)
    RETURN          reduce using rule 67 (conditions -> condition .)
    MAP             reduce using rule 67 (conditions -> condition .)
    WHILE           reduce using rule 67 (conditions -> condition .)
    INT             reduce using rule 67 (conditions -> condition .)
    DOUBLE          reduce using rule 67 (conditions -> condition .)
    BOOL            reduce using rule 67 (conditions -> condition .)
    IF              reduce using rule 67 (conditions -> condition .)
    FOR             reduce using rule 67 (conditions -> condition .)
    $end            reduce using rule 67 (conditions -> condition .)
    RBRACKET        reduce using rule 67 (conditions -> condition .)
    AND             shift and go to state 112
    OR              shift and go to state 113


state 66

    (29) length -> call_list . DOT LENGTH

    DOT             shift and go to state 114


state 67

    (30) length -> TEXT . DOT LENGTH
    (91) value -> TEXT .

    DOT             shift and go to state 115
    GREATER         reduce using rule 91 (value -> TEXT .)
    LESS            reduce using rule 91 (value -> TEXT .)
    EQUALS          reduce using rule 91 (value -> TEXT .)
    GREATER_EQUAL   reduce using rule 91 (value -> TEXT .)
    LESS_EQUAL      reduce using rule 91 (value -> TEXT .)
    NOT_EQUALS      reduce using rule 91 (value -> TEXT .)


state 68

    (31) length -> ID . DOT LENGTH
    (25) call_function -> ID . LPAREN argument_list RPAREN
    (26) call_function -> ID . LPAREN RPAREN
    (53) operand -> ID .

    DOT             shift and go to state 116
    LPAREN          shift and go to state 117
    PLUS            reduce using rule 53 (operand -> ID .)
    MINUS           reduce using rule 53 (operand -> ID .)
    TIMES           reduce using rule 53 (operand -> ID .)
    DIVIDE          reduce using rule 53 (operand -> ID .)
    INT_DIVIDE      reduce using rule 53 (operand -> ID .)
    SEMICOLON       reduce using rule 53 (operand -> ID .)
    GREATER         reduce using rule 53 (operand -> ID .)
    LESS            reduce using rule 53 (operand -> ID .)
    EQUALS          reduce using rule 53 (operand -> ID .)
    GREATER_EQUAL   reduce using rule 53 (operand -> ID .)
    LESS_EQUAL      reduce using rule 53 (operand -> ID .)
    NOT_EQUALS      reduce using rule 53 (operand -> ID .)
    RPAREN          reduce using rule 53 (operand -> ID .)
    COMMA           reduce using rule 53 (operand -> ID .)
    COMMENT_MULTI   reduce using rule 53 (operand -> ID .)
    COMMENT_SINGLE  reduce using rule 53 (operand -> ID .)
    PRINT           reduce using rule 53 (operand -> ID .)
    STRING          reduce using rule 53 (operand -> ID .)
    VAR             reduce using rule 53 (operand -> ID .)
    FINAL           reduce using rule 53 (operand -> ID .)
    ID              reduce using rule 53 (operand -> ID .)
    VOID            reduce using rule 53 (operand -> ID .)
    LIST            reduce using rule 53 (operand -> ID .)
    DYNAMIC         reduce using rule 53 (operand -> ID .)
    RETURN          reduce using rule 53 (operand -> ID .)
    MAP             reduce using rule 53 (operand -> ID .)
    WHILE           reduce using rule 53 (operand -> ID .)
    INT             reduce using rule 53 (operand -> ID .)
    DOUBLE          reduce using rule 53 (operand -> ID .)
    BOOL            reduce using rule 53 (operand -> ID .)
    IF              reduce using rule 53 (operand -> ID .)
    FOR             reduce using rule 53 (operand -> ID .)
    $end            reduce using rule 53 (operand -> ID .)
    RBRACKET        reduce using rule 53 (operand -> ID .)


state 69

    (51) operand -> NUMBER .

    PLUS            reduce using rule 51 (operand -> NUMBER .)
    MINUS           reduce using rule 51 (operand -> NUMBER .)
    TIMES           reduce using rule 51 (operand -> NUMBER .)
    DIVIDE          reduce using rule 51 (operand -> NUMBER .)
    INT_DIVIDE      reduce using rule 51 (operand -> NUMBER .)
    SEMICOLON       reduce using rule 51 (operand -> NUMBER .)
    GREATER         reduce using rule 51 (operand -> NUMBER .)
    LESS            reduce using rule 51 (operand -> NUMBER .)
    EQUALS          reduce using rule 51 (operand -> NUMBER .)
    GREATER_EQUAL   reduce using rule 51 (operand -> NUMBER .)
    LESS_EQUAL      reduce using rule 51 (operand -> NUMBER .)
    NOT_EQUALS      reduce using rule 51 (operand -> NUMBER .)
    RPAREN          reduce using rule 51 (operand -> NUMBER .)
    COMMA           reduce using rule 51 (operand -> NUMBER .)
    AND             reduce using rule 51 (operand -> NUMBER .)
    OR              reduce using rule 51 (operand -> NUMBER .)
    COMMENT_MULTI   reduce using rule 51 (operand -> NUMBER .)
    COMMENT_SINGLE  reduce using rule 51 (operand -> NUMBER .)
    PRINT           reduce using rule 51 (operand -> NUMBER .)
    STRING          reduce using rule 51 (operand -> NUMBER .)
    VAR             reduce using rule 51 (operand -> NUMBER .)
    FINAL           reduce using rule 51 (operand -> NUMBER .)
    ID              reduce using rule 51 (operand -> NUMBER .)
    VOID            reduce using rule 51 (operand -> NUMBER .)
    LIST            reduce using rule 51 (operand -> NUMBER .)
    DYNAMIC         reduce using rule 51 (operand -> NUMBER .)
    RETURN          reduce using rule 51 (operand -> NUMBER .)
    MAP             reduce using rule 51 (operand -> NUMBER .)
    WHILE           reduce using rule 51 (operand -> NUMBER .)
    INT             reduce using rule 51 (operand -> NUMBER .)
    DOUBLE          reduce using rule 51 (operand -> NUMBER .)
    BOOL            reduce using rule 51 (operand -> NUMBER .)
    IF              reduce using rule 51 (operand -> NUMBER .)
    FOR             reduce using rule 51 (operand -> NUMBER .)
    $end            reduce using rule 51 (operand -> NUMBER .)
    RBRACKET        reduce using rule 51 (operand -> NUMBER .)
    RSBRACKET       reduce using rule 51 (operand -> NUMBER .)


state 70

    (52) operand -> NDOUBLE .

    PLUS            reduce using rule 52 (operand -> NDOUBLE .)
    MINUS           reduce using rule 52 (operand -> NDOUBLE .)
    TIMES           reduce using rule 52 (operand -> NDOUBLE .)
    DIVIDE          reduce using rule 52 (operand -> NDOUBLE .)
    INT_DIVIDE      reduce using rule 52 (operand -> NDOUBLE .)
    SEMICOLON       reduce using rule 52 (operand -> NDOUBLE .)
    GREATER         reduce using rule 52 (operand -> NDOUBLE .)
    LESS            reduce using rule 52 (operand -> NDOUBLE .)
    EQUALS          reduce using rule 52 (operand -> NDOUBLE .)
    GREATER_EQUAL   reduce using rule 52 (operand -> NDOUBLE .)
    LESS_EQUAL      reduce using rule 52 (operand -> NDOUBLE .)
    NOT_EQUALS      reduce using rule 52 (operand -> NDOUBLE .)
    RPAREN          reduce using rule 52 (operand -> NDOUBLE .)
    COMMA           reduce using rule 52 (operand -> NDOUBLE .)
    AND             reduce using rule 52 (operand -> NDOUBLE .)
    OR              reduce using rule 52 (operand -> NDOUBLE .)
    COMMENT_MULTI   reduce using rule 52 (operand -> NDOUBLE .)
    COMMENT_SINGLE  reduce using rule 52 (operand -> NDOUBLE .)
    PRINT           reduce using rule 52 (operand -> NDOUBLE .)
    STRING          reduce using rule 52 (operand -> NDOUBLE .)
    VAR             reduce using rule 52 (operand -> NDOUBLE .)
    FINAL           reduce using rule 52 (operand -> NDOUBLE .)
    ID              reduce using rule 52 (operand -> NDOUBLE .)
    VOID            reduce using rule 52 (operand -> NDOUBLE .)
    LIST            reduce using rule 52 (operand -> NDOUBLE .)
    DYNAMIC         reduce using rule 52 (operand -> NDOUBLE .)
    RETURN          reduce using rule 52 (operand -> NDOUBLE .)
    MAP             reduce using rule 52 (operand -> NDOUBLE .)
    WHILE           reduce using rule 52 (operand -> NDOUBLE .)
    INT             reduce using rule 52 (operand -> NDOUBLE .)
    DOUBLE          reduce using rule 52 (operand -> NDOUBLE .)
    BOOL            reduce using rule 52 (operand -> NDOUBLE .)
    IF              reduce using rule 52 (operand -> NDOUBLE .)
    FOR             reduce using rule 52 (operand -> NDOUBLE .)
    $end            reduce using rule 52 (operand -> NDOUBLE .)
    RBRACKET        reduce using rule 52 (operand -> NDOUBLE .)
    RSBRACKET       reduce using rule 52 (operand -> NDOUBLE .)


state 71

    (70) condition -> value . comparator value
    (72) comparator -> . GREATER
    (73) comparator -> . LESS
    (74) comparator -> . EQUALS
    (75) comparator -> . GREATER_EQUAL
    (76) comparator -> . LESS_EQUAL
    (77) comparator -> . NOT_EQUALS

    GREATER         shift and go to state 119
    LESS            shift and go to state 120
    EQUALS          shift and go to state 121
    GREATER_EQUAL   shift and go to state 122
    LESS_EQUAL      shift and go to state 123
    NOT_EQUALS      shift and go to state 124

    comparator                     shift and go to state 118

state 72

    (71) condition -> NOT . value
    (90) value -> . operand
    (91) value -> . TEXT
    (92) value -> . TRUE
    (93) value -> . FALSE
    (51) operand -> . NUMBER
    (52) operand -> . NDOUBLE
    (53) operand -> . ID

    TEXT            shift and go to state 127
    TRUE            shift and go to state 74
    FALSE           shift and go to state 75
    NUMBER          shift and go to state 69
    NDOUBLE         shift and go to state 70
    ID              shift and go to state 128

    value                          shift and go to state 125
    operand                        shift and go to state 126

state 73

    (82) call_list -> LSBRACKET . value_list RSBRACKET
    (84) value_list -> . value
    (85) value_list -> . value COMMA value_list
    (90) value -> . operand
    (91) value -> . TEXT
    (92) value -> . TRUE
    (93) value -> . FALSE
    (51) operand -> . NUMBER
    (52) operand -> . NDOUBLE
    (53) operand -> . ID

    TEXT            shift and go to state 127
    TRUE            shift and go to state 74
    FALSE           shift and go to state 75
    NUMBER          shift and go to state 69
    NDOUBLE         shift and go to state 70
    ID              shift and go to state 128

    value_list                     shift and go to state 129
    value                          shift and go to state 130
    operand                        shift and go to state 126

state 74

    (92) value -> TRUE .

    GREATER         reduce using rule 92 (value -> TRUE .)
    LESS            reduce using rule 92 (value -> TRUE .)
    EQUALS          reduce using rule 92 (value -> TRUE .)
    GREATER_EQUAL   reduce using rule 92 (value -> TRUE .)
    LESS_EQUAL      reduce using rule 92 (value -> TRUE .)
    NOT_EQUALS      reduce using rule 92 (value -> TRUE .)
    AND             reduce using rule 92 (value -> TRUE .)
    OR              reduce using rule 92 (value -> TRUE .)
    SEMICOLON       reduce using rule 92 (value -> TRUE .)
    RPAREN          reduce using rule 92 (value -> TRUE .)
    COMMA           reduce using rule 92 (value -> TRUE .)
    COMMENT_MULTI   reduce using rule 92 (value -> TRUE .)
    COMMENT_SINGLE  reduce using rule 92 (value -> TRUE .)
    PRINT           reduce using rule 92 (value -> TRUE .)
    STRING          reduce using rule 92 (value -> TRUE .)
    VAR             reduce using rule 92 (value -> TRUE .)
    FINAL           reduce using rule 92 (value -> TRUE .)
    ID              reduce using rule 92 (value -> TRUE .)
    VOID            reduce using rule 92 (value -> TRUE .)
    LIST            reduce using rule 92 (value -> TRUE .)
    DYNAMIC         reduce using rule 92 (value -> TRUE .)
    RETURN          reduce using rule 92 (value -> TRUE .)
    MAP             reduce using rule 92 (value -> TRUE .)
    WHILE           reduce using rule 92 (value -> TRUE .)
    INT             reduce using rule 92 (value -> TRUE .)
    DOUBLE          reduce using rule 92 (value -> TRUE .)
    BOOL            reduce using rule 92 (value -> TRUE .)
    IF              reduce using rule 92 (value -> TRUE .)
    FOR             reduce using rule 92 (value -> TRUE .)
    $end            reduce using rule 92 (value -> TRUE .)
    RBRACKET        reduce using rule 92 (value -> TRUE .)
    RSBRACKET       reduce using rule 92 (value -> TRUE .)


state 75

    (93) value -> FALSE .

    GREATER         reduce using rule 93 (value -> FALSE .)
    LESS            reduce using rule 93 (value -> FALSE .)
    EQUALS          reduce using rule 93 (value -> FALSE .)
    GREATER_EQUAL   reduce using rule 93 (value -> FALSE .)
    LESS_EQUAL      reduce using rule 93 (value -> FALSE .)
    NOT_EQUALS      reduce using rule 93 (value -> FALSE .)
    AND             reduce using rule 93 (value -> FALSE .)
    OR              reduce using rule 93 (value -> FALSE .)
    SEMICOLON       reduce using rule 93 (value -> FALSE .)
    RPAREN          reduce using rule 93 (value -> FALSE .)
    COMMA           reduce using rule 93 (value -> FALSE .)
    COMMENT_MULTI   reduce using rule 93 (value -> FALSE .)
    COMMENT_SINGLE  reduce using rule 93 (value -> FALSE .)
    PRINT           reduce using rule 93 (value -> FALSE .)
    STRING          reduce using rule 93 (value -> FALSE .)
    VAR             reduce using rule 93 (value -> FALSE .)
    FINAL           reduce using rule 93 (value -> FALSE .)
    ID              reduce using rule 93 (value -> FALSE .)
    VOID            reduce using rule 93 (value -> FALSE .)
    LIST            reduce using rule 93 (value -> FALSE .)
    DYNAMIC         reduce using rule 93 (value -> FALSE .)
    RETURN          reduce using rule 93 (value -> FALSE .)
    MAP             reduce using rule 93 (value -> FALSE .)
    WHILE           reduce using rule 93 (value -> FALSE .)
    INT             reduce using rule 93 (value -> FALSE .)
    DOUBLE          reduce using rule 93 (value -> FALSE .)
    BOOL            reduce using rule 93 (value -> FALSE .)
    IF              reduce using rule 93 (value -> FALSE .)
    FOR             reduce using rule 93 (value -> FALSE .)
    $end            reduce using rule 93 (value -> FALSE .)
    RBRACKET        reduce using rule 93 (value -> FALSE .)
    RSBRACKET       reduce using rule 93 (value -> FALSE .)


state 76

    (121) map_declaration -> MAP LESS . key_type COMMA type GREATER ID ASSIGN
    (127) key_type -> . STRING

    STRING          shift and go to state 132

    key_type                       shift and go to state 131

state 77

    (60) control_structures_if_else -> if_block else_if_blocks .
    (61) control_structures_if_else -> if_block else_if_blocks . else_block
    (65) else_if_blocks -> else_if_blocks . ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (66) else_block -> . ELSE LBRACKET statement_list RBRACKET

    COMMENT_MULTI   reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks .)
    COMMENT_SINGLE  reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks .)
    SEMICOLON       reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks .)
    PRINT           reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks .)
    STRING          reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks .)
    VAR             reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks .)
    FINAL           reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks .)
    ID              reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks .)
    VOID            reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks .)
    LIST            reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks .)
    DYNAMIC         reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks .)
    RETURN          reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks .)
    MAP             reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks .)
    WHILE           reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks .)
    INT             reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks .)
    DOUBLE          reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks .)
    BOOL            reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks .)
    IF              reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks .)
    FOR             reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks .)
    $end            reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks .)
    RBRACKET        reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks .)
    ELSE            shift and go to state 134

    else_block                     shift and go to state 133

state 78

    (62) control_structures_if_else -> if_block else_block .

    COMMENT_MULTI   reduce using rule 62 (control_structures_if_else -> if_block else_block .)
    COMMENT_SINGLE  reduce using rule 62 (control_structures_if_else -> if_block else_block .)
    SEMICOLON       reduce using rule 62 (control_structures_if_else -> if_block else_block .)
    PRINT           reduce using rule 62 (control_structures_if_else -> if_block else_block .)
    STRING          reduce using rule 62 (control_structures_if_else -> if_block else_block .)
    VAR             reduce using rule 62 (control_structures_if_else -> if_block else_block .)
    FINAL           reduce using rule 62 (control_structures_if_else -> if_block else_block .)
    ID              reduce using rule 62 (control_structures_if_else -> if_block else_block .)
    VOID            reduce using rule 62 (control_structures_if_else -> if_block else_block .)
    LIST            reduce using rule 62 (control_structures_if_else -> if_block else_block .)
    DYNAMIC         reduce using rule 62 (control_structures_if_else -> if_block else_block .)
    RETURN          reduce using rule 62 (control_structures_if_else -> if_block else_block .)
    MAP             reduce using rule 62 (control_structures_if_else -> if_block else_block .)
    WHILE           reduce using rule 62 (control_structures_if_else -> if_block else_block .)
    INT             reduce using rule 62 (control_structures_if_else -> if_block else_block .)
    DOUBLE          reduce using rule 62 (control_structures_if_else -> if_block else_block .)
    BOOL            reduce using rule 62 (control_structures_if_else -> if_block else_block .)
    IF              reduce using rule 62 (control_structures_if_else -> if_block else_block .)
    FOR             reduce using rule 62 (control_structures_if_else -> if_block else_block .)
    $end            reduce using rule 62 (control_structures_if_else -> if_block else_block .)
    RBRACKET        reduce using rule 62 (control_structures_if_else -> if_block else_block .)


state 79

    (64) else_if_blocks -> ELSE . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (66) else_block -> ELSE . LBRACKET statement_list RBRACKET

    IF              shift and go to state 135
    LBRACKET        shift and go to state 136


state 80

    (119) control_structures_while -> WHILE LPAREN . conditions RPAREN LBRACKET statement_list RBRACKET
    (67) conditions -> . condition
    (68) conditions -> . condition AND conditions
    (69) conditions -> . condition OR conditions
    (70) condition -> . value comparator value
    (71) condition -> . NOT value
    (90) value -> . operand
    (91) value -> . TEXT
    (92) value -> . TRUE
    (93) value -> . FALSE
    (51) operand -> . NUMBER
    (52) operand -> . NDOUBLE
    (53) operand -> . ID

    NOT             shift and go to state 72
    TEXT            shift and go to state 127
    TRUE            shift and go to state 74
    FALSE           shift and go to state 75
    NUMBER          shift and go to state 69
    NDOUBLE         shift and go to state 70
    ID              shift and go to state 128

    conditions                     shift and go to state 137
    condition                      shift and go to state 65
    value                          shift and go to state 71
    operand                        shift and go to state 126

state 81

    (63) if_block -> IF LPAREN . conditions RPAREN LBRACKET statement_list RBRACKET
    (67) conditions -> . condition
    (68) conditions -> . condition AND conditions
    (69) conditions -> . condition OR conditions
    (70) condition -> . value comparator value
    (71) condition -> . NOT value
    (90) value -> . operand
    (91) value -> . TEXT
    (92) value -> . TRUE
    (93) value -> . FALSE
    (51) operand -> . NUMBER
    (52) operand -> . NDOUBLE
    (53) operand -> . ID

    NOT             shift and go to state 72
    TEXT            shift and go to state 127
    TRUE            shift and go to state 74
    FALSE           shift and go to state 75
    NUMBER          shift and go to state 69
    NDOUBLE         shift and go to state 70
    ID              shift and go to state 128

    conditions                     shift and go to state 138
    condition                      shift and go to state 65
    value                          shift and go to state 71
    operand                        shift and go to state 126

state 82

    (105) for_classic -> FOR LPAREN . for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (107) for_in -> FOR LPAREN . for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (111) for_each -> FOR LPAREN . for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (104) for_classic_parenthesis_content -> . for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON for_classic_changes
    (106) for_in_parenthesis_content -> . FINAL ID IN ID
    (110) for_each_parenthesis_content -> . FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID
    (97) for_classic_initialization -> . INT ID ASSIGN NUMBER
    (98) for_classic_initialization -> . DOUBLE ID ASSIGN NDOUBLE

    FINAL           shift and go to state 143
    INT             shift and go to state 144
    DOUBLE          shift and go to state 145

    for_classic_parenthesis_content shift and go to state 139
    for_in_parenthesis_content     shift and go to state 140
    for_each_parenthesis_content   shift and go to state 141
    for_classic_initialization     shift and go to state 142

state 83

    (43) print -> PRINT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 146


state 84

    (44) print -> PRINT LPAREN expression . RPAREN SEMICOLON

    RPAREN          shift and go to state 147


state 85

    (27) data_input -> STRING ID ASSIGN . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    STDIN           shift and go to state 148


state 86

    (28) data_input -> STRING QUESTION ID . ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    ASSIGN          shift and go to state 149


state 87

    (117) constructor -> ID LPAREN constructor_parenthesis_content . RPAREN SEMICOLON

    RPAREN          shift and go to state 150


state 88

    (26) call_function -> ID LPAREN RPAREN .

    COMMENT_MULTI   reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    COMMENT_SINGLE  reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    SEMICOLON       reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    PRINT           reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    STRING          reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    VAR             reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    FINAL           reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    ID              reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    VOID            reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    LIST            reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    DYNAMIC         reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    RETURN          reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    MAP             reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    WHILE           reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    INT             reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    DOUBLE          reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    BOOL            reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    IF              reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    FOR             reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    $end            reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    RPAREN          reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    COMMA           reduce using rule 26 (call_function -> ID LPAREN RPAREN .)
    RBRACKET        reduce using rule 26 (call_function -> ID LPAREN RPAREN .)


state 89

    (25) call_function -> ID LPAREN argument_list . RPAREN
    (33) argument_list -> argument_list . COMMA expression

    RPAREN          shift and go to state 151
    COMMA           shift and go to state 152


state 90

    (115) constructor_parenthesis_content -> THIS . DOT ID
    (116) constructor_parenthesis_content -> THIS . DOT ID COMMA constructor_parenthesis_content

    DOT             shift and go to state 153


state 91

    (32) argument_list -> expression .

    RPAREN          reduce using rule 32 (argument_list -> expression .)
    COMMA           reduce using rule 32 (argument_list -> expression .)


state 92

    (24) variable_usage -> ID ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 154


state 93

    (94) set -> VAR ID ASSIGN . LBRACKET value_list RBRACKET SEMICOLON
    (95) set -> VAR ID ASSIGN . LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (42) variable_definition -> VAR ID ASSIGN . expression SEMICOLON
    (45) expression -> . operations
    (46) expression -> . conditions
    (47) expression -> . length
    (48) expression -> . call_function
    (49) operations -> . operand
    (50) operations -> . operand operator operations
    (67) conditions -> . condition
    (68) conditions -> . condition AND conditions
    (69) conditions -> . condition OR conditions
    (29) length -> . call_list DOT LENGTH
    (30) length -> . TEXT DOT LENGTH
    (31) length -> . ID DOT LENGTH
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (51) operand -> . NUMBER
    (52) operand -> . NDOUBLE
    (53) operand -> . ID
    (70) condition -> . value comparator value
    (71) condition -> . NOT value
    (82) call_list -> . LSBRACKET value_list RSBRACKET
    (90) value -> . operand
    (91) value -> . TEXT
    (92) value -> . TRUE
    (93) value -> . FALSE

    LBRACKET        shift and go to state 155
    LESS            shift and go to state 156
    TEXT            shift and go to state 67
    ID              shift and go to state 68
    NUMBER          shift and go to state 69
    NDOUBLE         shift and go to state 70
    NOT             shift and go to state 72
    LSBRACKET       shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 75

    expression                     shift and go to state 157
    operations                     shift and go to state 60
    conditions                     shift and go to state 61
    length                         shift and go to state 62
    call_function                  shift and go to state 63
    operand                        shift and go to state 64
    condition                      shift and go to state 65
    call_list                      shift and go to state 66
    value                          shift and go to state 71

state 94

    (96) set -> FINAL ID ASSIGN . CONST LBRACKET value_list RBRACKET SEMICOLON

    CONST           shift and go to state 158


state 95

    (122) map_assignment -> LBRACKET map_contents . RBRACKET

    RBRACKET        shift and go to state 159


state 96

    (123) map_contents -> map_content .
    (124) map_contents -> map_content . COMMA map_contents

    RBRACKET        reduce using rule 123 (map_contents -> map_content .)
    COMMA           shift and go to state 160


state 97

    (125) map_content -> key_value . COLON value

    COLON           shift and go to state 161


state 98

    (126) key_value -> TEXT .

    COLON           reduce using rule 126 (key_value -> TEXT .)


state 99

    (34) function -> type ID LPAREN . parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> type ID LPAREN . RPAREN LBRACKET statement_list RBRACKET
    (118) function -> type ID LPAREN . parameter_list RPAREN ASSIGN GREATER expression
    (78) parameter_list -> . parameter
    (79) parameter_list -> . parameter_list COMMA parameter
    (80) parameter -> . type ID
    (81) parameter -> . REQUIRED type ID
    (86) type -> . INT
    (87) type -> . DOUBLE
    (88) type -> . STRING
    (89) type -> . BOOL

    RPAREN          shift and go to state 164
    REQUIRED        shift and go to state 166
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 103
    BOOL            shift and go to state 41

    type                           shift and go to state 162
    parameter_list                 shift and go to state 163
    parameter                      shift and go to state 165

state 100

    (40) variable_definition -> type ID ASSIGN . expression SEMICOLON
    (45) expression -> . operations
    (46) expression -> . conditions
    (47) expression -> . length
    (48) expression -> . call_function
    (49) operations -> . operand
    (50) operations -> . operand operator operations
    (67) conditions -> . condition
    (68) conditions -> . condition AND conditions
    (69) conditions -> . condition OR conditions
    (29) length -> . call_list DOT LENGTH
    (30) length -> . TEXT DOT LENGTH
    (31) length -> . ID DOT LENGTH
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (51) operand -> . NUMBER
    (52) operand -> . NDOUBLE
    (53) operand -> . ID
    (70) condition -> . value comparator value
    (71) condition -> . NOT value
    (82) call_list -> . LSBRACKET value_list RSBRACKET
    (90) value -> . operand
    (91) value -> . TEXT
    (92) value -> . TRUE
    (93) value -> . FALSE

    TEXT            shift and go to state 67
    ID              shift and go to state 68
    NUMBER          shift and go to state 69
    NDOUBLE         shift and go to state 70
    NOT             shift and go to state 72
    LSBRACKET       shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 75

    expression                     shift and go to state 167
    operations                     shift and go to state 60
    conditions                     shift and go to state 61
    length                         shift and go to state 62
    call_function                  shift and go to state 63
    operand                        shift and go to state 64
    condition                      shift and go to state 65
    call_list                      shift and go to state 66
    value                          shift and go to state 71

state 101

    (35) function -> VOID ID LPAREN . parameter_list RPAREN LBRACKET statement_list RBRACKET
    (37) function -> VOID ID LPAREN . RPAREN LBRACKET statement_list RBRACKET
    (38) function -> VOID ID LPAREN . RPAREN LBRACKET RBRACKET
    (39) function -> VOID ID LPAREN . parameter_list RPAREN LBRACKET RBRACKET
    (78) parameter_list -> . parameter
    (79) parameter_list -> . parameter_list COMMA parameter
    (80) parameter -> . type ID
    (81) parameter -> . REQUIRED type ID
    (86) type -> . INT
    (87) type -> . DOUBLE
    (88) type -> . STRING
    (89) type -> . BOOL

    RPAREN          shift and go to state 169
    REQUIRED        shift and go to state 166
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 103
    BOOL            shift and go to state 41

    parameter_list                 shift and go to state 168
    parameter                      shift and go to state 165
    type                           shift and go to state 162

state 102

    (83) list_definition -> LIST LESS type . GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON

    GREATER         shift and go to state 170


state 103

    (88) type -> STRING .

    GREATER         reduce using rule 88 (type -> STRING .)
    ID              reduce using rule 88 (type -> STRING .)


state 104

    (41) variable_definition -> DYNAMIC ID ASSIGN . expression SEMICOLON
    (45) expression -> . operations
    (46) expression -> . conditions
    (47) expression -> . length
    (48) expression -> . call_function
    (49) operations -> . operand
    (50) operations -> . operand operator operations
    (67) conditions -> . condition
    (68) conditions -> . condition AND conditions
    (69) conditions -> . condition OR conditions
    (29) length -> . call_list DOT LENGTH
    (30) length -> . TEXT DOT LENGTH
    (31) length -> . ID DOT LENGTH
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (51) operand -> . NUMBER
    (52) operand -> . NDOUBLE
    (53) operand -> . ID
    (70) condition -> . value comparator value
    (71) condition -> . NOT value
    (82) call_list -> . LSBRACKET value_list RSBRACKET
    (90) value -> . operand
    (91) value -> . TEXT
    (92) value -> . TRUE
    (93) value -> . FALSE

    TEXT            shift and go to state 67
    ID              shift and go to state 68
    NUMBER          shift and go to state 69
    NDOUBLE         shift and go to state 70
    NOT             shift and go to state 72
    LSBRACKET       shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 75

    expression                     shift and go to state 171
    operations                     shift and go to state 60
    conditions                     shift and go to state 61
    length                         shift and go to state 62
    call_function                  shift and go to state 63
    operand                        shift and go to state 64
    condition                      shift and go to state 65
    call_list                      shift and go to state 66
    value                          shift and go to state 71

state 105

    (19) return -> RETURN expression SEMICOLON .

    COMMENT_MULTI   reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    SEMICOLON       reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    PRINT           reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    STRING          reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    VAR             reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    FINAL           reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    ID              reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    VOID            reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    LIST            reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    DYNAMIC         reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    MAP             reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    WHILE           reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    INT             reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    DOUBLE          reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    BOOL            reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    IF              reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    FOR             reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    $end            reduce using rule 19 (return -> RETURN expression SEMICOLON .)
    RBRACKET        reduce using rule 19 (return -> RETURN expression SEMICOLON .)


state 106

    (50) operations -> operand operator . operations
    (49) operations -> . operand
    (50) operations -> . operand operator operations
    (51) operand -> . NUMBER
    (52) operand -> . NDOUBLE
    (53) operand -> . ID

    NUMBER          shift and go to state 69
    NDOUBLE         shift and go to state 70
    ID              shift and go to state 128

    operand                        shift and go to state 172
    operations                     shift and go to state 173

state 107

    (54) operator -> PLUS .

    NUMBER          reduce using rule 54 (operator -> PLUS .)
    NDOUBLE         reduce using rule 54 (operator -> PLUS .)
    ID              reduce using rule 54 (operator -> PLUS .)


state 108

    (55) operator -> MINUS .

    NUMBER          reduce using rule 55 (operator -> MINUS .)
    NDOUBLE         reduce using rule 55 (operator -> MINUS .)
    ID              reduce using rule 55 (operator -> MINUS .)


state 109

    (56) operator -> TIMES .

    NUMBER          reduce using rule 56 (operator -> TIMES .)
    NDOUBLE         reduce using rule 56 (operator -> TIMES .)
    ID              reduce using rule 56 (operator -> TIMES .)


state 110

    (57) operator -> DIVIDE .

    NUMBER          reduce using rule 57 (operator -> DIVIDE .)
    NDOUBLE         reduce using rule 57 (operator -> DIVIDE .)
    ID              reduce using rule 57 (operator -> DIVIDE .)


state 111

    (58) operator -> INT_DIVIDE .

    NUMBER          reduce using rule 58 (operator -> INT_DIVIDE .)
    NDOUBLE         reduce using rule 58 (operator -> INT_DIVIDE .)
    ID              reduce using rule 58 (operator -> INT_DIVIDE .)


state 112

    (68) conditions -> condition AND . conditions
    (67) conditions -> . condition
    (68) conditions -> . condition AND conditions
    (69) conditions -> . condition OR conditions
    (70) condition -> . value comparator value
    (71) condition -> . NOT value
    (90) value -> . operand
    (91) value -> . TEXT
    (92) value -> . TRUE
    (93) value -> . FALSE
    (51) operand -> . NUMBER
    (52) operand -> . NDOUBLE
    (53) operand -> . ID

    NOT             shift and go to state 72
    TEXT            shift and go to state 127
    TRUE            shift and go to state 74
    FALSE           shift and go to state 75
    NUMBER          shift and go to state 69
    NDOUBLE         shift and go to state 70
    ID              shift and go to state 128

    condition                      shift and go to state 65
    conditions                     shift and go to state 174
    value                          shift and go to state 71
    operand                        shift and go to state 126

state 113

    (69) conditions -> condition OR . conditions
    (67) conditions -> . condition
    (68) conditions -> . condition AND conditions
    (69) conditions -> . condition OR conditions
    (70) condition -> . value comparator value
    (71) condition -> . NOT value
    (90) value -> . operand
    (91) value -> . TEXT
    (92) value -> . TRUE
    (93) value -> . FALSE
    (51) operand -> . NUMBER
    (52) operand -> . NDOUBLE
    (53) operand -> . ID

    NOT             shift and go to state 72
    TEXT            shift and go to state 127
    TRUE            shift and go to state 74
    FALSE           shift and go to state 75
    NUMBER          shift and go to state 69
    NDOUBLE         shift and go to state 70
    ID              shift and go to state 128

    condition                      shift and go to state 65
    conditions                     shift and go to state 175
    value                          shift and go to state 71
    operand                        shift and go to state 126

state 114

    (29) length -> call_list DOT . LENGTH

    LENGTH          shift and go to state 176


state 115

    (30) length -> TEXT DOT . LENGTH

    LENGTH          shift and go to state 177


state 116

    (31) length -> ID DOT . LENGTH

    LENGTH          shift and go to state 178


state 117

    (25) call_function -> ID LPAREN . argument_list RPAREN
    (26) call_function -> ID LPAREN . RPAREN
    (32) argument_list -> . expression
    (33) argument_list -> . argument_list COMMA expression
    (45) expression -> . operations
    (46) expression -> . conditions
    (47) expression -> . length
    (48) expression -> . call_function
    (49) operations -> . operand
    (50) operations -> . operand operator operations
    (67) conditions -> . condition
    (68) conditions -> . condition AND conditions
    (69) conditions -> . condition OR conditions
    (29) length -> . call_list DOT LENGTH
    (30) length -> . TEXT DOT LENGTH
    (31) length -> . ID DOT LENGTH
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (51) operand -> . NUMBER
    (52) operand -> . NDOUBLE
    (53) operand -> . ID
    (70) condition -> . value comparator value
    (71) condition -> . NOT value
    (82) call_list -> . LSBRACKET value_list RSBRACKET
    (90) value -> . operand
    (91) value -> . TEXT
    (92) value -> . TRUE
    (93) value -> . FALSE

    RPAREN          shift and go to state 88
    TEXT            shift and go to state 67
    ID              shift and go to state 68
    NUMBER          shift and go to state 69
    NDOUBLE         shift and go to state 70
    NOT             shift and go to state 72
    LSBRACKET       shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 75

    argument_list                  shift and go to state 89
    expression                     shift and go to state 91
    operations                     shift and go to state 60
    conditions                     shift and go to state 61
    length                         shift and go to state 62
    call_function                  shift and go to state 63
    operand                        shift and go to state 64
    condition                      shift and go to state 65
    call_list                      shift and go to state 66
    value                          shift and go to state 71

state 118

    (70) condition -> value comparator . value
    (90) value -> . operand
    (91) value -> . TEXT
    (92) value -> . TRUE
    (93) value -> . FALSE
    (51) operand -> . NUMBER
    (52) operand -> . NDOUBLE
    (53) operand -> . ID

    TEXT            shift and go to state 127
    TRUE            shift and go to state 74
    FALSE           shift and go to state 75
    NUMBER          shift and go to state 69
    NDOUBLE         shift and go to state 70
    ID              shift and go to state 128

    value                          shift and go to state 179
    operand                        shift and go to state 126

state 119

    (72) comparator -> GREATER .

    TEXT            reduce using rule 72 (comparator -> GREATER .)
    TRUE            reduce using rule 72 (comparator -> GREATER .)
    FALSE           reduce using rule 72 (comparator -> GREATER .)
    NUMBER          reduce using rule 72 (comparator -> GREATER .)
    NDOUBLE         reduce using rule 72 (comparator -> GREATER .)
    ID              reduce using rule 72 (comparator -> GREATER .)


state 120

    (73) comparator -> LESS .

    TEXT            reduce using rule 73 (comparator -> LESS .)
    TRUE            reduce using rule 73 (comparator -> LESS .)
    FALSE           reduce using rule 73 (comparator -> LESS .)
    NUMBER          reduce using rule 73 (comparator -> LESS .)
    NDOUBLE         reduce using rule 73 (comparator -> LESS .)
    ID              reduce using rule 73 (comparator -> LESS .)


state 121

    (74) comparator -> EQUALS .

    TEXT            reduce using rule 74 (comparator -> EQUALS .)
    TRUE            reduce using rule 74 (comparator -> EQUALS .)
    FALSE           reduce using rule 74 (comparator -> EQUALS .)
    NUMBER          reduce using rule 74 (comparator -> EQUALS .)
    NDOUBLE         reduce using rule 74 (comparator -> EQUALS .)
    ID              reduce using rule 74 (comparator -> EQUALS .)


state 122

    (75) comparator -> GREATER_EQUAL .

    TEXT            reduce using rule 75 (comparator -> GREATER_EQUAL .)
    TRUE            reduce using rule 75 (comparator -> GREATER_EQUAL .)
    FALSE           reduce using rule 75 (comparator -> GREATER_EQUAL .)
    NUMBER          reduce using rule 75 (comparator -> GREATER_EQUAL .)
    NDOUBLE         reduce using rule 75 (comparator -> GREATER_EQUAL .)
    ID              reduce using rule 75 (comparator -> GREATER_EQUAL .)


state 123

    (76) comparator -> LESS_EQUAL .

    TEXT            reduce using rule 76 (comparator -> LESS_EQUAL .)
    TRUE            reduce using rule 76 (comparator -> LESS_EQUAL .)
    FALSE           reduce using rule 76 (comparator -> LESS_EQUAL .)
    NUMBER          reduce using rule 76 (comparator -> LESS_EQUAL .)
    NDOUBLE         reduce using rule 76 (comparator -> LESS_EQUAL .)
    ID              reduce using rule 76 (comparator -> LESS_EQUAL .)


state 124

    (77) comparator -> NOT_EQUALS .

    TEXT            reduce using rule 77 (comparator -> NOT_EQUALS .)
    TRUE            reduce using rule 77 (comparator -> NOT_EQUALS .)
    FALSE           reduce using rule 77 (comparator -> NOT_EQUALS .)
    NUMBER          reduce using rule 77 (comparator -> NOT_EQUALS .)
    NDOUBLE         reduce using rule 77 (comparator -> NOT_EQUALS .)
    ID              reduce using rule 77 (comparator -> NOT_EQUALS .)


state 125

    (71) condition -> NOT value .

    AND             reduce using rule 71 (condition -> NOT value .)
    OR              reduce using rule 71 (condition -> NOT value .)
    SEMICOLON       reduce using rule 71 (condition -> NOT value .)
    RPAREN          reduce using rule 71 (condition -> NOT value .)
    COMMA           reduce using rule 71 (condition -> NOT value .)
    COMMENT_MULTI   reduce using rule 71 (condition -> NOT value .)
    COMMENT_SINGLE  reduce using rule 71 (condition -> NOT value .)
    PRINT           reduce using rule 71 (condition -> NOT value .)
    STRING          reduce using rule 71 (condition -> NOT value .)
    VAR             reduce using rule 71 (condition -> NOT value .)
    FINAL           reduce using rule 71 (condition -> NOT value .)
    ID              reduce using rule 71 (condition -> NOT value .)
    VOID            reduce using rule 71 (condition -> NOT value .)
    LIST            reduce using rule 71 (condition -> NOT value .)
    DYNAMIC         reduce using rule 71 (condition -> NOT value .)
    RETURN          reduce using rule 71 (condition -> NOT value .)
    MAP             reduce using rule 71 (condition -> NOT value .)
    WHILE           reduce using rule 71 (condition -> NOT value .)
    INT             reduce using rule 71 (condition -> NOT value .)
    DOUBLE          reduce using rule 71 (condition -> NOT value .)
    BOOL            reduce using rule 71 (condition -> NOT value .)
    IF              reduce using rule 71 (condition -> NOT value .)
    FOR             reduce using rule 71 (condition -> NOT value .)
    $end            reduce using rule 71 (condition -> NOT value .)
    RBRACKET        reduce using rule 71 (condition -> NOT value .)


state 126

    (90) value -> operand .

    AND             reduce using rule 90 (value -> operand .)
    OR              reduce using rule 90 (value -> operand .)
    SEMICOLON       reduce using rule 90 (value -> operand .)
    RPAREN          reduce using rule 90 (value -> operand .)
    COMMA           reduce using rule 90 (value -> operand .)
    COMMENT_MULTI   reduce using rule 90 (value -> operand .)
    COMMENT_SINGLE  reduce using rule 90 (value -> operand .)
    PRINT           reduce using rule 90 (value -> operand .)
    STRING          reduce using rule 90 (value -> operand .)
    VAR             reduce using rule 90 (value -> operand .)
    FINAL           reduce using rule 90 (value -> operand .)
    ID              reduce using rule 90 (value -> operand .)
    VOID            reduce using rule 90 (value -> operand .)
    LIST            reduce using rule 90 (value -> operand .)
    DYNAMIC         reduce using rule 90 (value -> operand .)
    RETURN          reduce using rule 90 (value -> operand .)
    MAP             reduce using rule 90 (value -> operand .)
    WHILE           reduce using rule 90 (value -> operand .)
    INT             reduce using rule 90 (value -> operand .)
    DOUBLE          reduce using rule 90 (value -> operand .)
    BOOL            reduce using rule 90 (value -> operand .)
    IF              reduce using rule 90 (value -> operand .)
    FOR             reduce using rule 90 (value -> operand .)
    $end            reduce using rule 90 (value -> operand .)
    RBRACKET        reduce using rule 90 (value -> operand .)
    RSBRACKET       reduce using rule 90 (value -> operand .)
    GREATER         reduce using rule 90 (value -> operand .)
    LESS            reduce using rule 90 (value -> operand .)
    EQUALS          reduce using rule 90 (value -> operand .)
    GREATER_EQUAL   reduce using rule 90 (value -> operand .)
    LESS_EQUAL      reduce using rule 90 (value -> operand .)
    NOT_EQUALS      reduce using rule 90 (value -> operand .)


state 127

    (91) value -> TEXT .

    AND             reduce using rule 91 (value -> TEXT .)
    OR              reduce using rule 91 (value -> TEXT .)
    SEMICOLON       reduce using rule 91 (value -> TEXT .)
    RPAREN          reduce using rule 91 (value -> TEXT .)
    COMMA           reduce using rule 91 (value -> TEXT .)
    COMMENT_MULTI   reduce using rule 91 (value -> TEXT .)
    COMMENT_SINGLE  reduce using rule 91 (value -> TEXT .)
    PRINT           reduce using rule 91 (value -> TEXT .)
    STRING          reduce using rule 91 (value -> TEXT .)
    VAR             reduce using rule 91 (value -> TEXT .)
    FINAL           reduce using rule 91 (value -> TEXT .)
    ID              reduce using rule 91 (value -> TEXT .)
    VOID            reduce using rule 91 (value -> TEXT .)
    LIST            reduce using rule 91 (value -> TEXT .)
    DYNAMIC         reduce using rule 91 (value -> TEXT .)
    RETURN          reduce using rule 91 (value -> TEXT .)
    MAP             reduce using rule 91 (value -> TEXT .)
    WHILE           reduce using rule 91 (value -> TEXT .)
    INT             reduce using rule 91 (value -> TEXT .)
    DOUBLE          reduce using rule 91 (value -> TEXT .)
    BOOL            reduce using rule 91 (value -> TEXT .)
    IF              reduce using rule 91 (value -> TEXT .)
    FOR             reduce using rule 91 (value -> TEXT .)
    $end            reduce using rule 91 (value -> TEXT .)
    RBRACKET        reduce using rule 91 (value -> TEXT .)
    RSBRACKET       reduce using rule 91 (value -> TEXT .)
    GREATER         reduce using rule 91 (value -> TEXT .)
    LESS            reduce using rule 91 (value -> TEXT .)
    EQUALS          reduce using rule 91 (value -> TEXT .)
    GREATER_EQUAL   reduce using rule 91 (value -> TEXT .)
    LESS_EQUAL      reduce using rule 91 (value -> TEXT .)
    NOT_EQUALS      reduce using rule 91 (value -> TEXT .)


state 128

    (53) operand -> ID .

    AND             reduce using rule 53 (operand -> ID .)
    OR              reduce using rule 53 (operand -> ID .)
    SEMICOLON       reduce using rule 53 (operand -> ID .)
    RPAREN          reduce using rule 53 (operand -> ID .)
    COMMA           reduce using rule 53 (operand -> ID .)
    COMMENT_MULTI   reduce using rule 53 (operand -> ID .)
    COMMENT_SINGLE  reduce using rule 53 (operand -> ID .)
    PRINT           reduce using rule 53 (operand -> ID .)
    STRING          reduce using rule 53 (operand -> ID .)
    VAR             reduce using rule 53 (operand -> ID .)
    FINAL           reduce using rule 53 (operand -> ID .)
    ID              reduce using rule 53 (operand -> ID .)
    VOID            reduce using rule 53 (operand -> ID .)
    LIST            reduce using rule 53 (operand -> ID .)
    DYNAMIC         reduce using rule 53 (operand -> ID .)
    RETURN          reduce using rule 53 (operand -> ID .)
    MAP             reduce using rule 53 (operand -> ID .)
    WHILE           reduce using rule 53 (operand -> ID .)
    INT             reduce using rule 53 (operand -> ID .)
    DOUBLE          reduce using rule 53 (operand -> ID .)
    BOOL            reduce using rule 53 (operand -> ID .)
    IF              reduce using rule 53 (operand -> ID .)
    FOR             reduce using rule 53 (operand -> ID .)
    $end            reduce using rule 53 (operand -> ID .)
    RBRACKET        reduce using rule 53 (operand -> ID .)
    RSBRACKET       reduce using rule 53 (operand -> ID .)
    GREATER         reduce using rule 53 (operand -> ID .)
    LESS            reduce using rule 53 (operand -> ID .)
    EQUALS          reduce using rule 53 (operand -> ID .)
    GREATER_EQUAL   reduce using rule 53 (operand -> ID .)
    LESS_EQUAL      reduce using rule 53 (operand -> ID .)
    NOT_EQUALS      reduce using rule 53 (operand -> ID .)
    PLUS            reduce using rule 53 (operand -> ID .)
    MINUS           reduce using rule 53 (operand -> ID .)
    TIMES           reduce using rule 53 (operand -> ID .)
    DIVIDE          reduce using rule 53 (operand -> ID .)
    INT_DIVIDE      reduce using rule 53 (operand -> ID .)


state 129

    (82) call_list -> LSBRACKET value_list . RSBRACKET

    RSBRACKET       shift and go to state 180


state 130

    (84) value_list -> value .
    (85) value_list -> value . COMMA value_list

    RSBRACKET       reduce using rule 84 (value_list -> value .)
    RBRACKET        reduce using rule 84 (value_list -> value .)
    COMMA           shift and go to state 181


state 131

    (121) map_declaration -> MAP LESS key_type . COMMA type GREATER ID ASSIGN

    COMMA           shift and go to state 182


state 132

    (127) key_type -> STRING .

    COMMA           reduce using rule 127 (key_type -> STRING .)


state 133

    (61) control_structures_if_else -> if_block else_if_blocks else_block .

    COMMENT_MULTI   reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks else_block .)
    COMMENT_SINGLE  reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks else_block .)
    SEMICOLON       reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks else_block .)
    PRINT           reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks else_block .)
    STRING          reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks else_block .)
    VAR             reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks else_block .)
    FINAL           reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks else_block .)
    ID              reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks else_block .)
    VOID            reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks else_block .)
    LIST            reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks else_block .)
    DYNAMIC         reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks else_block .)
    RETURN          reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks else_block .)
    MAP             reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks else_block .)
    WHILE           reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks else_block .)
    INT             reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks else_block .)
    DOUBLE          reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks else_block .)
    BOOL            reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks else_block .)
    IF              reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks else_block .)
    FOR             reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks else_block .)
    $end            reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks else_block .)
    RBRACKET        reduce using rule 61 (control_structures_if_else -> if_block else_if_blocks else_block .)


state 134

    (65) else_if_blocks -> else_if_blocks ELSE . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (66) else_block -> ELSE . LBRACKET statement_list RBRACKET

    IF              shift and go to state 183
    LBRACKET        shift and go to state 136


state 135

    (64) else_if_blocks -> ELSE IF . LPAREN conditions RPAREN LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 184


state 136

    (66) else_block -> ELSE LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (94) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (95) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (96) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (120) map -> . map_declaration map_assignment
    (117) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (118) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN expression SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (121) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (59) control_structures_if_else -> . if_block
    (60) control_structures_if_else -> . if_block else_if_blocks
    (61) control_structures_if_else -> . if_block else_if_blocks else_block
    (62) control_structures_if_else -> . if_block else_block
    (112) control_structures_for -> . for_classic
    (113) control_structures_for -> . for_in
    (114) control_structures_for -> . for_each
    (119) control_structures_while -> . WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (86) type -> . INT
    (87) type -> . DOUBLE
    (88) type -> . STRING
    (89) type -> . BOOL
    (63) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (105) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (107) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (111) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement_list                 shift and go to state 185
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 137

    (119) control_structures_while -> WHILE LPAREN conditions . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 186


state 138

    (63) if_block -> IF LPAREN conditions . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 187


state 139

    (105) for_classic -> FOR LPAREN for_classic_parenthesis_content . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 188


state 140

    (107) for_in -> FOR LPAREN for_in_parenthesis_content . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 189


state 141

    (111) for_each -> FOR LPAREN for_each_parenthesis_content . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 190


state 142

    (104) for_classic_parenthesis_content -> for_classic_initialization . SEMICOLON for_classic_conditions SEMICOLON for_classic_changes

    SEMICOLON       shift and go to state 191


state 143

    (106) for_in_parenthesis_content -> FINAL . ID IN ID
    (110) for_each_parenthesis_content -> FINAL . ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID

    ID              shift and go to state 192


state 144

    (97) for_classic_initialization -> INT . ID ASSIGN NUMBER

    ID              shift and go to state 193


state 145

    (98) for_classic_initialization -> DOUBLE . ID ASSIGN NDOUBLE

    ID              shift and go to state 194


state 146

    (43) print -> PRINT LPAREN RPAREN SEMICOLON .

    COMMENT_MULTI   reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    RETURN          reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 43 (print -> PRINT LPAREN RPAREN SEMICOLON .)


state 147

    (44) print -> PRINT LPAREN expression RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 195


state 148

    (27) data_input -> STRING ID ASSIGN STDIN . DOT READLINESYNC LPAREN RPAREN SEMICOLON

    DOT             shift and go to state 196


state 149

    (28) data_input -> STRING QUESTION ID ASSIGN . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    STDIN           shift and go to state 197


state 150

    (117) constructor -> ID LPAREN constructor_parenthesis_content RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 198


state 151

    (25) call_function -> ID LPAREN argument_list RPAREN .

    COMMENT_MULTI   reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    COMMENT_SINGLE  reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    SEMICOLON       reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    PRINT           reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    STRING          reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    VAR             reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    FINAL           reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    ID              reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    VOID            reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    LIST            reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    DYNAMIC         reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    RETURN          reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    MAP             reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    WHILE           reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    INT             reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    DOUBLE          reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    BOOL            reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    IF              reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    FOR             reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    $end            reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    RPAREN          reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    COMMA           reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)
    RBRACKET        reduce using rule 25 (call_function -> ID LPAREN argument_list RPAREN .)


state 152

    (33) argument_list -> argument_list COMMA . expression
    (45) expression -> . operations
    (46) expression -> . conditions
    (47) expression -> . length
    (48) expression -> . call_function
    (49) operations -> . operand
    (50) operations -> . operand operator operations
    (67) conditions -> . condition
    (68) conditions -> . condition AND conditions
    (69) conditions -> . condition OR conditions
    (29) length -> . call_list DOT LENGTH
    (30) length -> . TEXT DOT LENGTH
    (31) length -> . ID DOT LENGTH
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (51) operand -> . NUMBER
    (52) operand -> . NDOUBLE
    (53) operand -> . ID
    (70) condition -> . value comparator value
    (71) condition -> . NOT value
    (82) call_list -> . LSBRACKET value_list RSBRACKET
    (90) value -> . operand
    (91) value -> . TEXT
    (92) value -> . TRUE
    (93) value -> . FALSE

    TEXT            shift and go to state 67
    ID              shift and go to state 68
    NUMBER          shift and go to state 69
    NDOUBLE         shift and go to state 70
    NOT             shift and go to state 72
    LSBRACKET       shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 75

    expression                     shift and go to state 199
    operations                     shift and go to state 60
    conditions                     shift and go to state 61
    length                         shift and go to state 62
    call_function                  shift and go to state 63
    operand                        shift and go to state 64
    condition                      shift and go to state 65
    call_list                      shift and go to state 66
    value                          shift and go to state 71

state 153

    (115) constructor_parenthesis_content -> THIS DOT . ID
    (116) constructor_parenthesis_content -> THIS DOT . ID COMMA constructor_parenthesis_content

    ID              shift and go to state 200


state 154

    (24) variable_usage -> ID ASSIGN expression SEMICOLON .

    COMMENT_MULTI   reduce using rule 24 (variable_usage -> ID ASSIGN expression SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 24 (variable_usage -> ID ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 24 (variable_usage -> ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 24 (variable_usage -> ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 24 (variable_usage -> ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 24 (variable_usage -> ID ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 24 (variable_usage -> ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 24 (variable_usage -> ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 24 (variable_usage -> ID ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 24 (variable_usage -> ID ASSIGN expression SEMICOLON .)
    DYNAMIC         reduce using rule 24 (variable_usage -> ID ASSIGN expression SEMICOLON .)
    RETURN          reduce using rule 24 (variable_usage -> ID ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 24 (variable_usage -> ID ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 24 (variable_usage -> ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 24 (variable_usage -> ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 24 (variable_usage -> ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 24 (variable_usage -> ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 24 (variable_usage -> ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 24 (variable_usage -> ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 24 (variable_usage -> ID ASSIGN expression SEMICOLON .)
    RBRACKET        reduce using rule 24 (variable_usage -> ID ASSIGN expression SEMICOLON .)


state 155

    (94) set -> VAR ID ASSIGN LBRACKET . value_list RBRACKET SEMICOLON
    (84) value_list -> . value
    (85) value_list -> . value COMMA value_list
    (90) value -> . operand
    (91) value -> . TEXT
    (92) value -> . TRUE
    (93) value -> . FALSE
    (51) operand -> . NUMBER
    (52) operand -> . NDOUBLE
    (53) operand -> . ID

    TEXT            shift and go to state 127
    TRUE            shift and go to state 74
    FALSE           shift and go to state 75
    NUMBER          shift and go to state 69
    NDOUBLE         shift and go to state 70
    ID              shift and go to state 128

    value_list                     shift and go to state 201
    value                          shift and go to state 130
    operand                        shift and go to state 126

state 156

    (95) set -> VAR ID ASSIGN LESS . STRING GREATER LBRACKET RBRACKET SEMICOLON

    STRING          shift and go to state 202


state 157

    (42) variable_definition -> VAR ID ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 203


state 158

    (96) set -> FINAL ID ASSIGN CONST . LBRACKET value_list RBRACKET SEMICOLON

    LBRACKET        shift and go to state 204


state 159

    (122) map_assignment -> LBRACKET map_contents RBRACKET .

    COMMENT_MULTI   reduce using rule 122 (map_assignment -> LBRACKET map_contents RBRACKET .)
    COMMENT_SINGLE  reduce using rule 122 (map_assignment -> LBRACKET map_contents RBRACKET .)
    SEMICOLON       reduce using rule 122 (map_assignment -> LBRACKET map_contents RBRACKET .)
    PRINT           reduce using rule 122 (map_assignment -> LBRACKET map_contents RBRACKET .)
    STRING          reduce using rule 122 (map_assignment -> LBRACKET map_contents RBRACKET .)
    VAR             reduce using rule 122 (map_assignment -> LBRACKET map_contents RBRACKET .)
    FINAL           reduce using rule 122 (map_assignment -> LBRACKET map_contents RBRACKET .)
    ID              reduce using rule 122 (map_assignment -> LBRACKET map_contents RBRACKET .)
    VOID            reduce using rule 122 (map_assignment -> LBRACKET map_contents RBRACKET .)
    LIST            reduce using rule 122 (map_assignment -> LBRACKET map_contents RBRACKET .)
    DYNAMIC         reduce using rule 122 (map_assignment -> LBRACKET map_contents RBRACKET .)
    RETURN          reduce using rule 122 (map_assignment -> LBRACKET map_contents RBRACKET .)
    MAP             reduce using rule 122 (map_assignment -> LBRACKET map_contents RBRACKET .)
    WHILE           reduce using rule 122 (map_assignment -> LBRACKET map_contents RBRACKET .)
    INT             reduce using rule 122 (map_assignment -> LBRACKET map_contents RBRACKET .)
    DOUBLE          reduce using rule 122 (map_assignment -> LBRACKET map_contents RBRACKET .)
    BOOL            reduce using rule 122 (map_assignment -> LBRACKET map_contents RBRACKET .)
    IF              reduce using rule 122 (map_assignment -> LBRACKET map_contents RBRACKET .)
    FOR             reduce using rule 122 (map_assignment -> LBRACKET map_contents RBRACKET .)
    $end            reduce using rule 122 (map_assignment -> LBRACKET map_contents RBRACKET .)
    RBRACKET        reduce using rule 122 (map_assignment -> LBRACKET map_contents RBRACKET .)


state 160

    (124) map_contents -> map_content COMMA . map_contents
    (123) map_contents -> . map_content
    (124) map_contents -> . map_content COMMA map_contents
    (125) map_content -> . key_value COLON value
    (126) key_value -> . TEXT

    TEXT            shift and go to state 98

    map_content                    shift and go to state 96
    map_contents                   shift and go to state 205
    key_value                      shift and go to state 97

state 161

    (125) map_content -> key_value COLON . value
    (90) value -> . operand
    (91) value -> . TEXT
    (92) value -> . TRUE
    (93) value -> . FALSE
    (51) operand -> . NUMBER
    (52) operand -> . NDOUBLE
    (53) operand -> . ID

    TEXT            shift and go to state 127
    TRUE            shift and go to state 74
    FALSE           shift and go to state 75
    NUMBER          shift and go to state 69
    NDOUBLE         shift and go to state 70
    ID              shift and go to state 128

    value                          shift and go to state 206
    operand                        shift and go to state 126

state 162

    (80) parameter -> type . ID

    ID              shift and go to state 207


state 163

    (34) function -> type ID LPAREN parameter_list . RPAREN LBRACKET statement_list RBRACKET
    (118) function -> type ID LPAREN parameter_list . RPAREN ASSIGN GREATER expression
    (79) parameter_list -> parameter_list . COMMA parameter

    RPAREN          shift and go to state 208
    COMMA           shift and go to state 209


state 164

    (36) function -> type ID LPAREN RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 210


state 165

    (78) parameter_list -> parameter .

    RPAREN          reduce using rule 78 (parameter_list -> parameter .)
    COMMA           reduce using rule 78 (parameter_list -> parameter .)


state 166

    (81) parameter -> REQUIRED . type ID
    (86) type -> . INT
    (87) type -> . DOUBLE
    (88) type -> . STRING
    (89) type -> . BOOL

    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 103
    BOOL            shift and go to state 41

    type                           shift and go to state 211

state 167

    (40) variable_definition -> type ID ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 212


state 168

    (35) function -> VOID ID LPAREN parameter_list . RPAREN LBRACKET statement_list RBRACKET
    (39) function -> VOID ID LPAREN parameter_list . RPAREN LBRACKET RBRACKET
    (79) parameter_list -> parameter_list . COMMA parameter

    RPAREN          shift and go to state 213
    COMMA           shift and go to state 209


state 169

    (37) function -> VOID ID LPAREN RPAREN . LBRACKET statement_list RBRACKET
    (38) function -> VOID ID LPAREN RPAREN . LBRACKET RBRACKET

    LBRACKET        shift and go to state 214


state 170

    (83) list_definition -> LIST LESS type GREATER . ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON

    ID              shift and go to state 215


state 171

    (41) variable_definition -> DYNAMIC ID ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 216


state 172

    (49) operations -> operand .
    (50) operations -> operand . operator operations
    (54) operator -> . PLUS
    (55) operator -> . MINUS
    (56) operator -> . TIMES
    (57) operator -> . DIVIDE
    (58) operator -> . INT_DIVIDE

    SEMICOLON       reduce using rule 49 (operations -> operand .)
    RPAREN          reduce using rule 49 (operations -> operand .)
    COMMA           reduce using rule 49 (operations -> operand .)
    COMMENT_MULTI   reduce using rule 49 (operations -> operand .)
    COMMENT_SINGLE  reduce using rule 49 (operations -> operand .)
    PRINT           reduce using rule 49 (operations -> operand .)
    STRING          reduce using rule 49 (operations -> operand .)
    VAR             reduce using rule 49 (operations -> operand .)
    FINAL           reduce using rule 49 (operations -> operand .)
    ID              reduce using rule 49 (operations -> operand .)
    VOID            reduce using rule 49 (operations -> operand .)
    LIST            reduce using rule 49 (operations -> operand .)
    DYNAMIC         reduce using rule 49 (operations -> operand .)
    RETURN          reduce using rule 49 (operations -> operand .)
    MAP             reduce using rule 49 (operations -> operand .)
    WHILE           reduce using rule 49 (operations -> operand .)
    INT             reduce using rule 49 (operations -> operand .)
    DOUBLE          reduce using rule 49 (operations -> operand .)
    BOOL            reduce using rule 49 (operations -> operand .)
    IF              reduce using rule 49 (operations -> operand .)
    FOR             reduce using rule 49 (operations -> operand .)
    $end            reduce using rule 49 (operations -> operand .)
    RBRACKET        reduce using rule 49 (operations -> operand .)
    PLUS            shift and go to state 107
    MINUS           shift and go to state 108
    TIMES           shift and go to state 109
    DIVIDE          shift and go to state 110
    INT_DIVIDE      shift and go to state 111

    operator                       shift and go to state 106

state 173

    (50) operations -> operand operator operations .

    SEMICOLON       reduce using rule 50 (operations -> operand operator operations .)
    RPAREN          reduce using rule 50 (operations -> operand operator operations .)
    COMMA           reduce using rule 50 (operations -> operand operator operations .)
    COMMENT_MULTI   reduce using rule 50 (operations -> operand operator operations .)
    COMMENT_SINGLE  reduce using rule 50 (operations -> operand operator operations .)
    PRINT           reduce using rule 50 (operations -> operand operator operations .)
    STRING          reduce using rule 50 (operations -> operand operator operations .)
    VAR             reduce using rule 50 (operations -> operand operator operations .)
    FINAL           reduce using rule 50 (operations -> operand operator operations .)
    ID              reduce using rule 50 (operations -> operand operator operations .)
    VOID            reduce using rule 50 (operations -> operand operator operations .)
    LIST            reduce using rule 50 (operations -> operand operator operations .)
    DYNAMIC         reduce using rule 50 (operations -> operand operator operations .)
    RETURN          reduce using rule 50 (operations -> operand operator operations .)
    MAP             reduce using rule 50 (operations -> operand operator operations .)
    WHILE           reduce using rule 50 (operations -> operand operator operations .)
    INT             reduce using rule 50 (operations -> operand operator operations .)
    DOUBLE          reduce using rule 50 (operations -> operand operator operations .)
    BOOL            reduce using rule 50 (operations -> operand operator operations .)
    IF              reduce using rule 50 (operations -> operand operator operations .)
    FOR             reduce using rule 50 (operations -> operand operator operations .)
    $end            reduce using rule 50 (operations -> operand operator operations .)
    RBRACKET        reduce using rule 50 (operations -> operand operator operations .)


state 174

    (68) conditions -> condition AND conditions .

    SEMICOLON       reduce using rule 68 (conditions -> condition AND conditions .)
    RPAREN          reduce using rule 68 (conditions -> condition AND conditions .)
    COMMA           reduce using rule 68 (conditions -> condition AND conditions .)
    COMMENT_MULTI   reduce using rule 68 (conditions -> condition AND conditions .)
    COMMENT_SINGLE  reduce using rule 68 (conditions -> condition AND conditions .)
    PRINT           reduce using rule 68 (conditions -> condition AND conditions .)
    STRING          reduce using rule 68 (conditions -> condition AND conditions .)
    VAR             reduce using rule 68 (conditions -> condition AND conditions .)
    FINAL           reduce using rule 68 (conditions -> condition AND conditions .)
    ID              reduce using rule 68 (conditions -> condition AND conditions .)
    VOID            reduce using rule 68 (conditions -> condition AND conditions .)
    LIST            reduce using rule 68 (conditions -> condition AND conditions .)
    DYNAMIC         reduce using rule 68 (conditions -> condition AND conditions .)
    RETURN          reduce using rule 68 (conditions -> condition AND conditions .)
    MAP             reduce using rule 68 (conditions -> condition AND conditions .)
    WHILE           reduce using rule 68 (conditions -> condition AND conditions .)
    INT             reduce using rule 68 (conditions -> condition AND conditions .)
    DOUBLE          reduce using rule 68 (conditions -> condition AND conditions .)
    BOOL            reduce using rule 68 (conditions -> condition AND conditions .)
    IF              reduce using rule 68 (conditions -> condition AND conditions .)
    FOR             reduce using rule 68 (conditions -> condition AND conditions .)
    $end            reduce using rule 68 (conditions -> condition AND conditions .)
    RBRACKET        reduce using rule 68 (conditions -> condition AND conditions .)


state 175

    (69) conditions -> condition OR conditions .

    SEMICOLON       reduce using rule 69 (conditions -> condition OR conditions .)
    RPAREN          reduce using rule 69 (conditions -> condition OR conditions .)
    COMMA           reduce using rule 69 (conditions -> condition OR conditions .)
    COMMENT_MULTI   reduce using rule 69 (conditions -> condition OR conditions .)
    COMMENT_SINGLE  reduce using rule 69 (conditions -> condition OR conditions .)
    PRINT           reduce using rule 69 (conditions -> condition OR conditions .)
    STRING          reduce using rule 69 (conditions -> condition OR conditions .)
    VAR             reduce using rule 69 (conditions -> condition OR conditions .)
    FINAL           reduce using rule 69 (conditions -> condition OR conditions .)
    ID              reduce using rule 69 (conditions -> condition OR conditions .)
    VOID            reduce using rule 69 (conditions -> condition OR conditions .)
    LIST            reduce using rule 69 (conditions -> condition OR conditions .)
    DYNAMIC         reduce using rule 69 (conditions -> condition OR conditions .)
    RETURN          reduce using rule 69 (conditions -> condition OR conditions .)
    MAP             reduce using rule 69 (conditions -> condition OR conditions .)
    WHILE           reduce using rule 69 (conditions -> condition OR conditions .)
    INT             reduce using rule 69 (conditions -> condition OR conditions .)
    DOUBLE          reduce using rule 69 (conditions -> condition OR conditions .)
    BOOL            reduce using rule 69 (conditions -> condition OR conditions .)
    IF              reduce using rule 69 (conditions -> condition OR conditions .)
    FOR             reduce using rule 69 (conditions -> condition OR conditions .)
    $end            reduce using rule 69 (conditions -> condition OR conditions .)
    RBRACKET        reduce using rule 69 (conditions -> condition OR conditions .)


state 176

    (29) length -> call_list DOT LENGTH .

    SEMICOLON       reduce using rule 29 (length -> call_list DOT LENGTH .)
    RPAREN          reduce using rule 29 (length -> call_list DOT LENGTH .)
    COMMA           reduce using rule 29 (length -> call_list DOT LENGTH .)
    COMMENT_MULTI   reduce using rule 29 (length -> call_list DOT LENGTH .)
    COMMENT_SINGLE  reduce using rule 29 (length -> call_list DOT LENGTH .)
    PRINT           reduce using rule 29 (length -> call_list DOT LENGTH .)
    STRING          reduce using rule 29 (length -> call_list DOT LENGTH .)
    VAR             reduce using rule 29 (length -> call_list DOT LENGTH .)
    FINAL           reduce using rule 29 (length -> call_list DOT LENGTH .)
    ID              reduce using rule 29 (length -> call_list DOT LENGTH .)
    VOID            reduce using rule 29 (length -> call_list DOT LENGTH .)
    LIST            reduce using rule 29 (length -> call_list DOT LENGTH .)
    DYNAMIC         reduce using rule 29 (length -> call_list DOT LENGTH .)
    RETURN          reduce using rule 29 (length -> call_list DOT LENGTH .)
    MAP             reduce using rule 29 (length -> call_list DOT LENGTH .)
    WHILE           reduce using rule 29 (length -> call_list DOT LENGTH .)
    INT             reduce using rule 29 (length -> call_list DOT LENGTH .)
    DOUBLE          reduce using rule 29 (length -> call_list DOT LENGTH .)
    BOOL            reduce using rule 29 (length -> call_list DOT LENGTH .)
    IF              reduce using rule 29 (length -> call_list DOT LENGTH .)
    FOR             reduce using rule 29 (length -> call_list DOT LENGTH .)
    $end            reduce using rule 29 (length -> call_list DOT LENGTH .)
    RBRACKET        reduce using rule 29 (length -> call_list DOT LENGTH .)


state 177

    (30) length -> TEXT DOT LENGTH .

    SEMICOLON       reduce using rule 30 (length -> TEXT DOT LENGTH .)
    RPAREN          reduce using rule 30 (length -> TEXT DOT LENGTH .)
    COMMA           reduce using rule 30 (length -> TEXT DOT LENGTH .)
    COMMENT_MULTI   reduce using rule 30 (length -> TEXT DOT LENGTH .)
    COMMENT_SINGLE  reduce using rule 30 (length -> TEXT DOT LENGTH .)
    PRINT           reduce using rule 30 (length -> TEXT DOT LENGTH .)
    STRING          reduce using rule 30 (length -> TEXT DOT LENGTH .)
    VAR             reduce using rule 30 (length -> TEXT DOT LENGTH .)
    FINAL           reduce using rule 30 (length -> TEXT DOT LENGTH .)
    ID              reduce using rule 30 (length -> TEXT DOT LENGTH .)
    VOID            reduce using rule 30 (length -> TEXT DOT LENGTH .)
    LIST            reduce using rule 30 (length -> TEXT DOT LENGTH .)
    DYNAMIC         reduce using rule 30 (length -> TEXT DOT LENGTH .)
    RETURN          reduce using rule 30 (length -> TEXT DOT LENGTH .)
    MAP             reduce using rule 30 (length -> TEXT DOT LENGTH .)
    WHILE           reduce using rule 30 (length -> TEXT DOT LENGTH .)
    INT             reduce using rule 30 (length -> TEXT DOT LENGTH .)
    DOUBLE          reduce using rule 30 (length -> TEXT DOT LENGTH .)
    BOOL            reduce using rule 30 (length -> TEXT DOT LENGTH .)
    IF              reduce using rule 30 (length -> TEXT DOT LENGTH .)
    FOR             reduce using rule 30 (length -> TEXT DOT LENGTH .)
    $end            reduce using rule 30 (length -> TEXT DOT LENGTH .)
    RBRACKET        reduce using rule 30 (length -> TEXT DOT LENGTH .)


state 178

    (31) length -> ID DOT LENGTH .

    SEMICOLON       reduce using rule 31 (length -> ID DOT LENGTH .)
    RPAREN          reduce using rule 31 (length -> ID DOT LENGTH .)
    COMMA           reduce using rule 31 (length -> ID DOT LENGTH .)
    COMMENT_MULTI   reduce using rule 31 (length -> ID DOT LENGTH .)
    COMMENT_SINGLE  reduce using rule 31 (length -> ID DOT LENGTH .)
    PRINT           reduce using rule 31 (length -> ID DOT LENGTH .)
    STRING          reduce using rule 31 (length -> ID DOT LENGTH .)
    VAR             reduce using rule 31 (length -> ID DOT LENGTH .)
    FINAL           reduce using rule 31 (length -> ID DOT LENGTH .)
    ID              reduce using rule 31 (length -> ID DOT LENGTH .)
    VOID            reduce using rule 31 (length -> ID DOT LENGTH .)
    LIST            reduce using rule 31 (length -> ID DOT LENGTH .)
    DYNAMIC         reduce using rule 31 (length -> ID DOT LENGTH .)
    RETURN          reduce using rule 31 (length -> ID DOT LENGTH .)
    MAP             reduce using rule 31 (length -> ID DOT LENGTH .)
    WHILE           reduce using rule 31 (length -> ID DOT LENGTH .)
    INT             reduce using rule 31 (length -> ID DOT LENGTH .)
    DOUBLE          reduce using rule 31 (length -> ID DOT LENGTH .)
    BOOL            reduce using rule 31 (length -> ID DOT LENGTH .)
    IF              reduce using rule 31 (length -> ID DOT LENGTH .)
    FOR             reduce using rule 31 (length -> ID DOT LENGTH .)
    $end            reduce using rule 31 (length -> ID DOT LENGTH .)
    RBRACKET        reduce using rule 31 (length -> ID DOT LENGTH .)


state 179

    (70) condition -> value comparator value .

    AND             reduce using rule 70 (condition -> value comparator value .)
    OR              reduce using rule 70 (condition -> value comparator value .)
    SEMICOLON       reduce using rule 70 (condition -> value comparator value .)
    RPAREN          reduce using rule 70 (condition -> value comparator value .)
    COMMA           reduce using rule 70 (condition -> value comparator value .)
    COMMENT_MULTI   reduce using rule 70 (condition -> value comparator value .)
    COMMENT_SINGLE  reduce using rule 70 (condition -> value comparator value .)
    PRINT           reduce using rule 70 (condition -> value comparator value .)
    STRING          reduce using rule 70 (condition -> value comparator value .)
    VAR             reduce using rule 70 (condition -> value comparator value .)
    FINAL           reduce using rule 70 (condition -> value comparator value .)
    ID              reduce using rule 70 (condition -> value comparator value .)
    VOID            reduce using rule 70 (condition -> value comparator value .)
    LIST            reduce using rule 70 (condition -> value comparator value .)
    DYNAMIC         reduce using rule 70 (condition -> value comparator value .)
    RETURN          reduce using rule 70 (condition -> value comparator value .)
    MAP             reduce using rule 70 (condition -> value comparator value .)
    WHILE           reduce using rule 70 (condition -> value comparator value .)
    INT             reduce using rule 70 (condition -> value comparator value .)
    DOUBLE          reduce using rule 70 (condition -> value comparator value .)
    BOOL            reduce using rule 70 (condition -> value comparator value .)
    IF              reduce using rule 70 (condition -> value comparator value .)
    FOR             reduce using rule 70 (condition -> value comparator value .)
    $end            reduce using rule 70 (condition -> value comparator value .)
    RBRACKET        reduce using rule 70 (condition -> value comparator value .)


state 180

    (82) call_list -> LSBRACKET value_list RSBRACKET .

    DOT             reduce using rule 82 (call_list -> LSBRACKET value_list RSBRACKET .)


state 181

    (85) value_list -> value COMMA . value_list
    (84) value_list -> . value
    (85) value_list -> . value COMMA value_list
    (90) value -> . operand
    (91) value -> . TEXT
    (92) value -> . TRUE
    (93) value -> . FALSE
    (51) operand -> . NUMBER
    (52) operand -> . NDOUBLE
    (53) operand -> . ID

    TEXT            shift and go to state 127
    TRUE            shift and go to state 74
    FALSE           shift and go to state 75
    NUMBER          shift and go to state 69
    NDOUBLE         shift and go to state 70
    ID              shift and go to state 128

    value                          shift and go to state 130
    value_list                     shift and go to state 217
    operand                        shift and go to state 126

state 182

    (121) map_declaration -> MAP LESS key_type COMMA . type GREATER ID ASSIGN
    (86) type -> . INT
    (87) type -> . DOUBLE
    (88) type -> . STRING
    (89) type -> . BOOL

    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 103
    BOOL            shift and go to state 41

    type                           shift and go to state 218

state 183

    (65) else_if_blocks -> else_if_blocks ELSE IF . LPAREN conditions RPAREN LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 219


state 184

    (64) else_if_blocks -> ELSE IF LPAREN . conditions RPAREN LBRACKET statement_list RBRACKET
    (67) conditions -> . condition
    (68) conditions -> . condition AND conditions
    (69) conditions -> . condition OR conditions
    (70) condition -> . value comparator value
    (71) condition -> . NOT value
    (90) value -> . operand
    (91) value -> . TEXT
    (92) value -> . TRUE
    (93) value -> . FALSE
    (51) operand -> . NUMBER
    (52) operand -> . NDOUBLE
    (53) operand -> . ID

    NOT             shift and go to state 72
    TEXT            shift and go to state 127
    TRUE            shift and go to state 74
    FALSE           shift and go to state 75
    NUMBER          shift and go to state 69
    NDOUBLE         shift and go to state 70
    ID              shift and go to state 128

    conditions                     shift and go to state 220
    condition                      shift and go to state 65
    value                          shift and go to state 71
    operand                        shift and go to state 126

state 185

    (66) else_block -> ELSE LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (94) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (95) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (96) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (120) map -> . map_declaration map_assignment
    (117) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (118) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN expression SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (121) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (59) control_structures_if_else -> . if_block
    (60) control_structures_if_else -> . if_block else_if_blocks
    (61) control_structures_if_else -> . if_block else_if_blocks else_block
    (62) control_structures_if_else -> . if_block else_block
    (112) control_structures_for -> . for_classic
    (113) control_structures_for -> . for_in
    (114) control_structures_for -> . for_each
    (119) control_structures_while -> . WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (86) type -> . INT
    (87) type -> . DOUBLE
    (88) type -> . STRING
    (89) type -> . BOOL
    (63) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (105) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (107) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (111) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 221
    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement                      shift and go to state 44
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 186

    (119) control_structures_while -> WHILE LPAREN conditions RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 222


state 187

    (63) if_block -> IF LPAREN conditions RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 223


state 188

    (105) for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 224


state 189

    (107) for_in -> FOR LPAREN for_in_parenthesis_content RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 225


state 190

    (111) for_each -> FOR LPAREN for_each_parenthesis_content RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 226


state 191

    (104) for_classic_parenthesis_content -> for_classic_initialization SEMICOLON . for_classic_conditions SEMICOLON for_classic_changes
    (99) for_classic_conditions -> . conditions
    (67) conditions -> . condition
    (68) conditions -> . condition AND conditions
    (69) conditions -> . condition OR conditions
    (70) condition -> . value comparator value
    (71) condition -> . NOT value
    (90) value -> . operand
    (91) value -> . TEXT
    (92) value -> . TRUE
    (93) value -> . FALSE
    (51) operand -> . NUMBER
    (52) operand -> . NDOUBLE
    (53) operand -> . ID

    NOT             shift and go to state 72
    TEXT            shift and go to state 127
    TRUE            shift and go to state 74
    FALSE           shift and go to state 75
    NUMBER          shift and go to state 69
    NDOUBLE         shift and go to state 70
    ID              shift and go to state 128

    for_classic_conditions         shift and go to state 227
    conditions                     shift and go to state 228
    condition                      shift and go to state 65
    value                          shift and go to state 71
    operand                        shift and go to state 126

state 192

    (106) for_in_parenthesis_content -> FINAL ID . IN ID
    (110) for_each_parenthesis_content -> FINAL ID . LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID

    IN              shift and go to state 229
    LPAREN          shift and go to state 230


state 193

    (97) for_classic_initialization -> INT ID . ASSIGN NUMBER

    ASSIGN          shift and go to state 231


state 194

    (98) for_classic_initialization -> DOUBLE ID . ASSIGN NDOUBLE

    ASSIGN          shift and go to state 232


state 195

    (44) print -> PRINT LPAREN expression RPAREN SEMICOLON .

    COMMENT_MULTI   reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    PRINT           reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    STRING          reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    VAR             reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FINAL           reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    ID              reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    VOID            reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LIST            reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    RETURN          reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    MAP             reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    WHILE           reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    INT             reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    BOOL            reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    IF              reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FOR             reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    $end            reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)


state 196

    (27) data_input -> STRING ID ASSIGN STDIN DOT . READLINESYNC LPAREN RPAREN SEMICOLON

    READLINESYNC    shift and go to state 233


state 197

    (28) data_input -> STRING QUESTION ID ASSIGN STDIN . DOT READLINESYNC LPAREN RPAREN SEMICOLON

    DOT             shift and go to state 234


state 198

    (117) constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .

    COMMENT_MULTI   reduce using rule 117 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 117 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 117 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    PRINT           reduce using rule 117 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    STRING          reduce using rule 117 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    VAR             reduce using rule 117 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    FINAL           reduce using rule 117 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    ID              reduce using rule 117 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    VOID            reduce using rule 117 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    LIST            reduce using rule 117 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 117 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    RETURN          reduce using rule 117 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    MAP             reduce using rule 117 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    WHILE           reduce using rule 117 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    INT             reduce using rule 117 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 117 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    BOOL            reduce using rule 117 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    IF              reduce using rule 117 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    FOR             reduce using rule 117 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    $end            reduce using rule 117 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 117 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)


state 199

    (33) argument_list -> argument_list COMMA expression .

    RPAREN          reduce using rule 33 (argument_list -> argument_list COMMA expression .)
    COMMA           reduce using rule 33 (argument_list -> argument_list COMMA expression .)


state 200

    (115) constructor_parenthesis_content -> THIS DOT ID .
    (116) constructor_parenthesis_content -> THIS DOT ID . COMMA constructor_parenthesis_content

    RPAREN          reduce using rule 115 (constructor_parenthesis_content -> THIS DOT ID .)
    COMMA           shift and go to state 235


state 201

    (94) set -> VAR ID ASSIGN LBRACKET value_list . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 236


state 202

    (95) set -> VAR ID ASSIGN LESS STRING . GREATER LBRACKET RBRACKET SEMICOLON

    GREATER         shift and go to state 237


state 203

    (42) variable_definition -> VAR ID ASSIGN expression SEMICOLON .

    COMMENT_MULTI   reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    DYNAMIC         reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    RETURN          reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    RBRACKET        reduce using rule 42 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)


state 204

    (96) set -> FINAL ID ASSIGN CONST LBRACKET . value_list RBRACKET SEMICOLON
    (84) value_list -> . value
    (85) value_list -> . value COMMA value_list
    (90) value -> . operand
    (91) value -> . TEXT
    (92) value -> . TRUE
    (93) value -> . FALSE
    (51) operand -> . NUMBER
    (52) operand -> . NDOUBLE
    (53) operand -> . ID

    TEXT            shift and go to state 127
    TRUE            shift and go to state 74
    FALSE           shift and go to state 75
    NUMBER          shift and go to state 69
    NDOUBLE         shift and go to state 70
    ID              shift and go to state 128

    value_list                     shift and go to state 238
    value                          shift and go to state 130
    operand                        shift and go to state 126

state 205

    (124) map_contents -> map_content COMMA map_contents .

    RBRACKET        reduce using rule 124 (map_contents -> map_content COMMA map_contents .)


state 206

    (125) map_content -> key_value COLON value .

    COMMA           reduce using rule 125 (map_content -> key_value COLON value .)
    RBRACKET        reduce using rule 125 (map_content -> key_value COLON value .)


state 207

    (80) parameter -> type ID .

    RPAREN          reduce using rule 80 (parameter -> type ID .)
    COMMA           reduce using rule 80 (parameter -> type ID .)


state 208

    (34) function -> type ID LPAREN parameter_list RPAREN . LBRACKET statement_list RBRACKET
    (118) function -> type ID LPAREN parameter_list RPAREN . ASSIGN GREATER expression

    LBRACKET        shift and go to state 239
    ASSIGN          shift and go to state 240


state 209

    (79) parameter_list -> parameter_list COMMA . parameter
    (80) parameter -> . type ID
    (81) parameter -> . REQUIRED type ID
    (86) type -> . INT
    (87) type -> . DOUBLE
    (88) type -> . STRING
    (89) type -> . BOOL

    REQUIRED        shift and go to state 166
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    STRING          shift and go to state 103
    BOOL            shift and go to state 41

    parameter                      shift and go to state 241
    type                           shift and go to state 162

state 210

    (36) function -> type ID LPAREN RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (94) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (95) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (96) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (120) map -> . map_declaration map_assignment
    (117) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (118) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN expression SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (121) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (59) control_structures_if_else -> . if_block
    (60) control_structures_if_else -> . if_block else_if_blocks
    (61) control_structures_if_else -> . if_block else_if_blocks else_block
    (62) control_structures_if_else -> . if_block else_block
    (112) control_structures_for -> . for_classic
    (113) control_structures_for -> . for_in
    (114) control_structures_for -> . for_each
    (119) control_structures_while -> . WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (86) type -> . INT
    (87) type -> . DOUBLE
    (88) type -> . STRING
    (89) type -> . BOOL
    (63) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (105) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (107) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (111) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    type                           shift and go to state 28
    statement_list                 shift and go to state 242
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 211

    (81) parameter -> REQUIRED type . ID

    ID              shift and go to state 243


state 212

    (40) variable_definition -> type ID ASSIGN expression SEMICOLON .

    COMMENT_MULTI   reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    DYNAMIC         reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    RETURN          reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    RBRACKET        reduce using rule 40 (variable_definition -> type ID ASSIGN expression SEMICOLON .)


state 213

    (35) function -> VOID ID LPAREN parameter_list RPAREN . LBRACKET statement_list RBRACKET
    (39) function -> VOID ID LPAREN parameter_list RPAREN . LBRACKET RBRACKET

    LBRACKET        shift and go to state 244


state 214

    (37) function -> VOID ID LPAREN RPAREN LBRACKET . statement_list RBRACKET
    (38) function -> VOID ID LPAREN RPAREN LBRACKET . RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (94) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (95) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (96) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (120) map -> . map_declaration map_assignment
    (117) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (118) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN expression SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (121) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (59) control_structures_if_else -> . if_block
    (60) control_structures_if_else -> . if_block else_if_blocks
    (61) control_structures_if_else -> . if_block else_if_blocks else_block
    (62) control_structures_if_else -> . if_block else_block
    (112) control_structures_for -> . for_classic
    (113) control_structures_for -> . for_in
    (114) control_structures_for -> . for_each
    (119) control_structures_while -> . WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (86) type -> . INT
    (87) type -> . DOUBLE
    (88) type -> . STRING
    (89) type -> . BOOL
    (63) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (105) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (107) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (111) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 246
    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement_list                 shift and go to state 245
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 215

    (83) list_definition -> LIST LESS type GREATER ID . ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON

    ASSIGN          shift and go to state 247


state 216

    (41) variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .

    COMMENT_MULTI   reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    DYNAMIC         reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    RETURN          reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    RBRACKET        reduce using rule 41 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)


state 217

    (85) value_list -> value COMMA value_list .

    RSBRACKET       reduce using rule 85 (value_list -> value COMMA value_list .)
    RBRACKET        reduce using rule 85 (value_list -> value COMMA value_list .)


state 218

    (121) map_declaration -> MAP LESS key_type COMMA type . GREATER ID ASSIGN

    GREATER         shift and go to state 248


state 219

    (65) else_if_blocks -> else_if_blocks ELSE IF LPAREN . conditions RPAREN LBRACKET statement_list RBRACKET
    (67) conditions -> . condition
    (68) conditions -> . condition AND conditions
    (69) conditions -> . condition OR conditions
    (70) condition -> . value comparator value
    (71) condition -> . NOT value
    (90) value -> . operand
    (91) value -> . TEXT
    (92) value -> . TRUE
    (93) value -> . FALSE
    (51) operand -> . NUMBER
    (52) operand -> . NDOUBLE
    (53) operand -> . ID

    NOT             shift and go to state 72
    TEXT            shift and go to state 127
    TRUE            shift and go to state 74
    FALSE           shift and go to state 75
    NUMBER          shift and go to state 69
    NDOUBLE         shift and go to state 70
    ID              shift and go to state 128

    conditions                     shift and go to state 249
    condition                      shift and go to state 65
    value                          shift and go to state 71
    operand                        shift and go to state 126

state 220

    (64) else_if_blocks -> ELSE IF LPAREN conditions . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 250


state 221

    (66) else_block -> ELSE LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 66 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 66 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 66 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 66 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 66 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 66 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 66 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 66 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 66 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 66 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 66 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    RETURN          reduce using rule 66 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 66 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 66 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 66 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 66 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 66 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 66 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 66 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 66 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 66 (else_block -> ELSE LBRACKET statement_list RBRACKET .)


state 222

    (119) control_structures_while -> WHILE LPAREN conditions RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (94) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (95) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (96) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (120) map -> . map_declaration map_assignment
    (117) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (118) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN expression SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (121) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (59) control_structures_if_else -> . if_block
    (60) control_structures_if_else -> . if_block else_if_blocks
    (61) control_structures_if_else -> . if_block else_if_blocks else_block
    (62) control_structures_if_else -> . if_block else_block
    (112) control_structures_for -> . for_classic
    (113) control_structures_for -> . for_in
    (114) control_structures_for -> . for_each
    (119) control_structures_while -> . WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (86) type -> . INT
    (87) type -> . DOUBLE
    (88) type -> . STRING
    (89) type -> . BOOL
    (63) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (105) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (107) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (111) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement_list                 shift and go to state 251
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 223

    (63) if_block -> IF LPAREN conditions RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (94) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (95) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (96) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (120) map -> . map_declaration map_assignment
    (117) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (118) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN expression SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (121) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (59) control_structures_if_else -> . if_block
    (60) control_structures_if_else -> . if_block else_if_blocks
    (61) control_structures_if_else -> . if_block else_if_blocks else_block
    (62) control_structures_if_else -> . if_block else_block
    (112) control_structures_for -> . for_classic
    (113) control_structures_for -> . for_in
    (114) control_structures_for -> . for_each
    (119) control_structures_while -> . WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (86) type -> . INT
    (87) type -> . DOUBLE
    (88) type -> . STRING
    (89) type -> . BOOL
    (63) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (105) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (107) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (111) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement_list                 shift and go to state 252
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 224

    (105) for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (94) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (95) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (96) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (120) map -> . map_declaration map_assignment
    (117) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (118) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN expression SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (121) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (59) control_structures_if_else -> . if_block
    (60) control_structures_if_else -> . if_block else_if_blocks
    (61) control_structures_if_else -> . if_block else_if_blocks else_block
    (62) control_structures_if_else -> . if_block else_block
    (112) control_structures_for -> . for_classic
    (113) control_structures_for -> . for_in
    (114) control_structures_for -> . for_each
    (119) control_structures_while -> . WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (86) type -> . INT
    (87) type -> . DOUBLE
    (88) type -> . STRING
    (89) type -> . BOOL
    (63) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (105) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (107) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (111) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement_list                 shift and go to state 253
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 225

    (107) for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (94) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (95) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (96) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (120) map -> . map_declaration map_assignment
    (117) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (118) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN expression SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (121) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (59) control_structures_if_else -> . if_block
    (60) control_structures_if_else -> . if_block else_if_blocks
    (61) control_structures_if_else -> . if_block else_if_blocks else_block
    (62) control_structures_if_else -> . if_block else_block
    (112) control_structures_for -> . for_classic
    (113) control_structures_for -> . for_in
    (114) control_structures_for -> . for_each
    (119) control_structures_while -> . WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (86) type -> . INT
    (87) type -> . DOUBLE
    (88) type -> . STRING
    (89) type -> . BOOL
    (63) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (105) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (107) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (111) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement_list                 shift and go to state 254
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 226

    (111) for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (94) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (95) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (96) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (120) map -> . map_declaration map_assignment
    (117) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (118) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN expression SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (121) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (59) control_structures_if_else -> . if_block
    (60) control_structures_if_else -> . if_block else_if_blocks
    (61) control_structures_if_else -> . if_block else_if_blocks else_block
    (62) control_structures_if_else -> . if_block else_block
    (112) control_structures_for -> . for_classic
    (113) control_structures_for -> . for_in
    (114) control_structures_for -> . for_each
    (119) control_structures_while -> . WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (86) type -> . INT
    (87) type -> . DOUBLE
    (88) type -> . STRING
    (89) type -> . BOOL
    (63) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (105) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (107) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (111) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement_list                 shift and go to state 255
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 227

    (104) for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions . SEMICOLON for_classic_changes

    SEMICOLON       shift and go to state 256


state 228

    (99) for_classic_conditions -> conditions .

    SEMICOLON       reduce using rule 99 (for_classic_conditions -> conditions .)


state 229

    (106) for_in_parenthesis_content -> FINAL ID IN . ID

    ID              shift and go to state 257


state 230

    (110) for_each_parenthesis_content -> FINAL ID LPAREN . for_each_parenthesis_parenthesis_content RPAREN IN ID
    (108) for_each_parenthesis_parenthesis_content -> . COLON ID
    (109) for_each_parenthesis_parenthesis_content -> . COLON ID COMMA for_each_parenthesis_parenthesis_content

    COLON           shift and go to state 259

    for_each_parenthesis_parenthesis_content shift and go to state 258

state 231

    (97) for_classic_initialization -> INT ID ASSIGN . NUMBER

    NUMBER          shift and go to state 260


state 232

    (98) for_classic_initialization -> DOUBLE ID ASSIGN . NDOUBLE

    NDOUBLE         shift and go to state 261


state 233

    (27) data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 262


state 234

    (28) data_input -> STRING QUESTION ID ASSIGN STDIN DOT . READLINESYNC LPAREN RPAREN SEMICOLON

    READLINESYNC    shift and go to state 263


state 235

    (116) constructor_parenthesis_content -> THIS DOT ID COMMA . constructor_parenthesis_content
    (115) constructor_parenthesis_content -> . THIS DOT ID
    (116) constructor_parenthesis_content -> . THIS DOT ID COMMA constructor_parenthesis_content

    THIS            shift and go to state 90

    constructor_parenthesis_content shift and go to state 264

state 236

    (94) set -> VAR ID ASSIGN LBRACKET value_list RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 265


state 237

    (95) set -> VAR ID ASSIGN LESS STRING GREATER . LBRACKET RBRACKET SEMICOLON

    LBRACKET        shift and go to state 266


state 238

    (96) set -> FINAL ID ASSIGN CONST LBRACKET value_list . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 267


state 239

    (34) function -> type ID LPAREN parameter_list RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (94) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (95) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (96) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (120) map -> . map_declaration map_assignment
    (117) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (118) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN expression SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (121) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (59) control_structures_if_else -> . if_block
    (60) control_structures_if_else -> . if_block else_if_blocks
    (61) control_structures_if_else -> . if_block else_if_blocks else_block
    (62) control_structures_if_else -> . if_block else_block
    (112) control_structures_for -> . for_classic
    (113) control_structures_for -> . for_in
    (114) control_structures_for -> . for_each
    (119) control_structures_while -> . WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (86) type -> . INT
    (87) type -> . DOUBLE
    (88) type -> . STRING
    (89) type -> . BOOL
    (63) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (105) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (107) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (111) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    type                           shift and go to state 28
    statement_list                 shift and go to state 268
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 240

    (118) function -> type ID LPAREN parameter_list RPAREN ASSIGN . GREATER expression

    GREATER         shift and go to state 269


state 241

    (79) parameter_list -> parameter_list COMMA parameter .

    RPAREN          reduce using rule 79 (parameter_list -> parameter_list COMMA parameter .)
    COMMA           reduce using rule 79 (parameter_list -> parameter_list COMMA parameter .)


state 242

    (36) function -> type ID LPAREN RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (94) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (95) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (96) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (120) map -> . map_declaration map_assignment
    (117) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (118) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN expression SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (121) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (59) control_structures_if_else -> . if_block
    (60) control_structures_if_else -> . if_block else_if_blocks
    (61) control_structures_if_else -> . if_block else_if_blocks else_block
    (62) control_structures_if_else -> . if_block else_block
    (112) control_structures_for -> . for_classic
    (113) control_structures_for -> . for_in
    (114) control_structures_for -> . for_each
    (119) control_structures_while -> . WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (86) type -> . INT
    (87) type -> . DOUBLE
    (88) type -> . STRING
    (89) type -> . BOOL
    (63) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (105) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (107) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (111) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 270
    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    type                           shift and go to state 28
    statement                      shift and go to state 44
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 243

    (81) parameter -> REQUIRED type ID .

    RPAREN          reduce using rule 81 (parameter -> REQUIRED type ID .)
    COMMA           reduce using rule 81 (parameter -> REQUIRED type ID .)


state 244

    (35) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET . statement_list RBRACKET
    (39) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET . RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (94) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (95) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (96) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (120) map -> . map_declaration map_assignment
    (117) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (118) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN expression SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (121) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (59) control_structures_if_else -> . if_block
    (60) control_structures_if_else -> . if_block else_if_blocks
    (61) control_structures_if_else -> . if_block else_if_blocks else_block
    (62) control_structures_if_else -> . if_block else_block
    (112) control_structures_for -> . for_classic
    (113) control_structures_for -> . for_in
    (114) control_structures_for -> . for_each
    (119) control_structures_while -> . WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (86) type -> . INT
    (87) type -> . DOUBLE
    (88) type -> . STRING
    (89) type -> . BOOL
    (63) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (105) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (107) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (111) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 272
    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement_list                 shift and go to state 271
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 245

    (37) function -> VOID ID LPAREN RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (94) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (95) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (96) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (120) map -> . map_declaration map_assignment
    (117) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (118) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN expression SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (121) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (59) control_structures_if_else -> . if_block
    (60) control_structures_if_else -> . if_block else_if_blocks
    (61) control_structures_if_else -> . if_block else_if_blocks else_block
    (62) control_structures_if_else -> . if_block else_block
    (112) control_structures_for -> . for_classic
    (113) control_structures_for -> . for_in
    (114) control_structures_for -> . for_each
    (119) control_structures_while -> . WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (86) type -> . INT
    (87) type -> . DOUBLE
    (88) type -> . STRING
    (89) type -> . BOOL
    (63) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (105) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (107) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (111) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 273
    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement                      shift and go to state 44
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 246

    (38) function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .

    COMMENT_MULTI   reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    COMMENT_SINGLE  reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    SEMICOLON       reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    PRINT           reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    STRING          reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    VAR             reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    FINAL           reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    ID              reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    VOID            reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    LIST            reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    DYNAMIC         reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    RETURN          reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    MAP             reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    WHILE           reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    INT             reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    DOUBLE          reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    BOOL            reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    IF              reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    FOR             reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    $end            reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 38 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)


state 247

    (83) list_definition -> LIST LESS type GREATER ID ASSIGN . LSBRACKET value_list RSBRACKET SEMICOLON

    LSBRACKET       shift and go to state 274


state 248

    (121) map_declaration -> MAP LESS key_type COMMA type GREATER . ID ASSIGN

    ID              shift and go to state 275


state 249

    (65) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 276


state 250

    (64) else_if_blocks -> ELSE IF LPAREN conditions RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 277


state 251

    (119) control_structures_while -> WHILE LPAREN conditions RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (94) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (95) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (96) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (120) map -> . map_declaration map_assignment
    (117) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (118) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN expression SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (121) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (59) control_structures_if_else -> . if_block
    (60) control_structures_if_else -> . if_block else_if_blocks
    (61) control_structures_if_else -> . if_block else_if_blocks else_block
    (62) control_structures_if_else -> . if_block else_block
    (112) control_structures_for -> . for_classic
    (113) control_structures_for -> . for_in
    (114) control_structures_for -> . for_each
    (119) control_structures_while -> . WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (86) type -> . INT
    (87) type -> . DOUBLE
    (88) type -> . STRING
    (89) type -> . BOOL
    (63) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (105) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (107) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (111) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 278
    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement                      shift and go to state 44
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 252

    (63) if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (94) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (95) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (96) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (120) map -> . map_declaration map_assignment
    (117) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (118) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN expression SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (121) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (59) control_structures_if_else -> . if_block
    (60) control_structures_if_else -> . if_block else_if_blocks
    (61) control_structures_if_else -> . if_block else_if_blocks else_block
    (62) control_structures_if_else -> . if_block else_block
    (112) control_structures_for -> . for_classic
    (113) control_structures_for -> . for_in
    (114) control_structures_for -> . for_each
    (119) control_structures_while -> . WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (86) type -> . INT
    (87) type -> . DOUBLE
    (88) type -> . STRING
    (89) type -> . BOOL
    (63) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (105) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (107) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (111) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 279
    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement                      shift and go to state 44
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 253

    (105) for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (94) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (95) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (96) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (120) map -> . map_declaration map_assignment
    (117) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (118) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN expression SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (121) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (59) control_structures_if_else -> . if_block
    (60) control_structures_if_else -> . if_block else_if_blocks
    (61) control_structures_if_else -> . if_block else_if_blocks else_block
    (62) control_structures_if_else -> . if_block else_block
    (112) control_structures_for -> . for_classic
    (113) control_structures_for -> . for_in
    (114) control_structures_for -> . for_each
    (119) control_structures_while -> . WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (86) type -> . INT
    (87) type -> . DOUBLE
    (88) type -> . STRING
    (89) type -> . BOOL
    (63) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (105) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (107) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (111) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 280
    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement                      shift and go to state 44
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 254

    (107) for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (94) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (95) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (96) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (120) map -> . map_declaration map_assignment
    (117) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (118) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN expression SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (121) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (59) control_structures_if_else -> . if_block
    (60) control_structures_if_else -> . if_block else_if_blocks
    (61) control_structures_if_else -> . if_block else_if_blocks else_block
    (62) control_structures_if_else -> . if_block else_block
    (112) control_structures_for -> . for_classic
    (113) control_structures_for -> . for_in
    (114) control_structures_for -> . for_each
    (119) control_structures_while -> . WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (86) type -> . INT
    (87) type -> . DOUBLE
    (88) type -> . STRING
    (89) type -> . BOOL
    (63) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (105) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (107) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (111) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 281
    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement                      shift and go to state 44
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 255

    (111) for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (94) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (95) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (96) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (120) map -> . map_declaration map_assignment
    (117) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (118) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN expression SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (121) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (59) control_structures_if_else -> . if_block
    (60) control_structures_if_else -> . if_block else_if_blocks
    (61) control_structures_if_else -> . if_block else_if_blocks else_block
    (62) control_structures_if_else -> . if_block else_block
    (112) control_structures_for -> . for_classic
    (113) control_structures_for -> . for_in
    (114) control_structures_for -> . for_each
    (119) control_structures_while -> . WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (86) type -> . INT
    (87) type -> . DOUBLE
    (88) type -> . STRING
    (89) type -> . BOOL
    (63) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (105) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (107) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (111) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 282
    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement                      shift and go to state 44
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 256

    (104) for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON . for_classic_changes
    (100) for_classic_changes -> . ID comparator value
    (101) for_classic_changes -> . ID INCREMENT
    (102) for_classic_changes -> . ID DECREMENT
    (103) for_classic_changes -> . ID comparator value COMMA for_classic_changes

    ID              shift and go to state 284

    for_classic_changes            shift and go to state 283

state 257

    (106) for_in_parenthesis_content -> FINAL ID IN ID .

    RPAREN          reduce using rule 106 (for_in_parenthesis_content -> FINAL ID IN ID .)


state 258

    (110) for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content . RPAREN IN ID

    RPAREN          shift and go to state 285


state 259

    (108) for_each_parenthesis_parenthesis_content -> COLON . ID
    (109) for_each_parenthesis_parenthesis_content -> COLON . ID COMMA for_each_parenthesis_parenthesis_content

    ID              shift and go to state 286


state 260

    (97) for_classic_initialization -> INT ID ASSIGN NUMBER .

    SEMICOLON       reduce using rule 97 (for_classic_initialization -> INT ID ASSIGN NUMBER .)


state 261

    (98) for_classic_initialization -> DOUBLE ID ASSIGN NDOUBLE .

    SEMICOLON       reduce using rule 98 (for_classic_initialization -> DOUBLE ID ASSIGN NDOUBLE .)


state 262

    (27) data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 287


state 263

    (28) data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 288


state 264

    (116) constructor_parenthesis_content -> THIS DOT ID COMMA constructor_parenthesis_content .

    RPAREN          reduce using rule 116 (constructor_parenthesis_content -> THIS DOT ID COMMA constructor_parenthesis_content .)


state 265

    (94) set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .

    COMMENT_MULTI   reduce using rule 94 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 94 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    SEMICOLON       reduce using rule 94 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    PRINT           reduce using rule 94 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    STRING          reduce using rule 94 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    VAR             reduce using rule 94 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    FINAL           reduce using rule 94 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    ID              reduce using rule 94 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    VOID            reduce using rule 94 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    LIST            reduce using rule 94 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 94 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    RETURN          reduce using rule 94 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    MAP             reduce using rule 94 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    WHILE           reduce using rule 94 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    INT             reduce using rule 94 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 94 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    BOOL            reduce using rule 94 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    IF              reduce using rule 94 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    FOR             reduce using rule 94 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    $end            reduce using rule 94 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    RBRACKET        reduce using rule 94 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)


state 266

    (95) set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 289


state 267

    (96) set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 290


state 268

    (34) function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (94) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (95) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (96) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (120) map -> . map_declaration map_assignment
    (117) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (118) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN expression SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (121) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (59) control_structures_if_else -> . if_block
    (60) control_structures_if_else -> . if_block else_if_blocks
    (61) control_structures_if_else -> . if_block else_if_blocks else_block
    (62) control_structures_if_else -> . if_block else_block
    (112) control_structures_for -> . for_classic
    (113) control_structures_for -> . for_in
    (114) control_structures_for -> . for_each
    (119) control_structures_while -> . WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (86) type -> . INT
    (87) type -> . DOUBLE
    (88) type -> . STRING
    (89) type -> . BOOL
    (63) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (105) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (107) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (111) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 291
    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    type                           shift and go to state 28
    statement                      shift and go to state 44
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 269

    (118) function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER . expression
    (45) expression -> . operations
    (46) expression -> . conditions
    (47) expression -> . length
    (48) expression -> . call_function
    (49) operations -> . operand
    (50) operations -> . operand operator operations
    (67) conditions -> . condition
    (68) conditions -> . condition AND conditions
    (69) conditions -> . condition OR conditions
    (29) length -> . call_list DOT LENGTH
    (30) length -> . TEXT DOT LENGTH
    (31) length -> . ID DOT LENGTH
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (51) operand -> . NUMBER
    (52) operand -> . NDOUBLE
    (53) operand -> . ID
    (70) condition -> . value comparator value
    (71) condition -> . NOT value
    (82) call_list -> . LSBRACKET value_list RSBRACKET
    (90) value -> . operand
    (91) value -> . TEXT
    (92) value -> . TRUE
    (93) value -> . FALSE

    TEXT            shift and go to state 67
    ID              shift and go to state 68
    NUMBER          shift and go to state 69
    NDOUBLE         shift and go to state 70
    NOT             shift and go to state 72
    LSBRACKET       shift and go to state 73
    TRUE            shift and go to state 74
    FALSE           shift and go to state 75

    expression                     shift and go to state 292
    operations                     shift and go to state 60
    conditions                     shift and go to state 61
    length                         shift and go to state 62
    call_function                  shift and go to state 63
    operand                        shift and go to state 64
    condition                      shift and go to state 65
    call_list                      shift and go to state 66
    value                          shift and go to state 71

state 270

    (36) function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    RETURN          reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 36 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)


state 271

    (35) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (94) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (95) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (96) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (120) map -> . map_declaration map_assignment
    (117) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (118) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN expression SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (121) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (59) control_structures_if_else -> . if_block
    (60) control_structures_if_else -> . if_block else_if_blocks
    (61) control_structures_if_else -> . if_block else_if_blocks else_block
    (62) control_structures_if_else -> . if_block else_block
    (112) control_structures_for -> . for_classic
    (113) control_structures_for -> . for_in
    (114) control_structures_for -> . for_each
    (119) control_structures_while -> . WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (86) type -> . INT
    (87) type -> . DOUBLE
    (88) type -> . STRING
    (89) type -> . BOOL
    (63) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (105) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (107) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (111) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 293
    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement                      shift and go to state 44
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 272

    (39) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .

    COMMENT_MULTI   reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    COMMENT_SINGLE  reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    SEMICOLON       reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    PRINT           reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    STRING          reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    VAR             reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    FINAL           reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    ID              reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    VOID            reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    LIST            reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    DYNAMIC         reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    RETURN          reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    MAP             reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    WHILE           reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    INT             reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    DOUBLE          reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    BOOL            reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    IF              reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    FOR             reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    $end            reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 39 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)


state 273

    (37) function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    RETURN          reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 37 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)


state 274

    (83) list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET . value_list RSBRACKET SEMICOLON
    (84) value_list -> . value
    (85) value_list -> . value COMMA value_list
    (90) value -> . operand
    (91) value -> . TEXT
    (92) value -> . TRUE
    (93) value -> . FALSE
    (51) operand -> . NUMBER
    (52) operand -> . NDOUBLE
    (53) operand -> . ID

    TEXT            shift and go to state 127
    TRUE            shift and go to state 74
    FALSE           shift and go to state 75
    NUMBER          shift and go to state 69
    NDOUBLE         shift and go to state 70
    ID              shift and go to state 128

    value_list                     shift and go to state 294
    value                          shift and go to state 130
    operand                        shift and go to state 126

state 275

    (121) map_declaration -> MAP LESS key_type COMMA type GREATER ID . ASSIGN

    ASSIGN          shift and go to state 295


state 276

    (65) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 296


state 277

    (64) else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (94) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (95) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (96) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (120) map -> . map_declaration map_assignment
    (117) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (118) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN expression SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (121) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (59) control_structures_if_else -> . if_block
    (60) control_structures_if_else -> . if_block else_if_blocks
    (61) control_structures_if_else -> . if_block else_if_blocks else_block
    (62) control_structures_if_else -> . if_block else_block
    (112) control_structures_for -> . for_classic
    (113) control_structures_for -> . for_in
    (114) control_structures_for -> . for_each
    (119) control_structures_while -> . WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (86) type -> . INT
    (87) type -> . DOUBLE
    (88) type -> . STRING
    (89) type -> . BOOL
    (63) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (105) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (107) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (111) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement_list                 shift and go to state 297
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 278

    (119) control_structures_while -> WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 119 (control_structures_while -> WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 119 (control_structures_while -> WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 119 (control_structures_while -> WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 119 (control_structures_while -> WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 119 (control_structures_while -> WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 119 (control_structures_while -> WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 119 (control_structures_while -> WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 119 (control_structures_while -> WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 119 (control_structures_while -> WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 119 (control_structures_while -> WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 119 (control_structures_while -> WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    RETURN          reduce using rule 119 (control_structures_while -> WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 119 (control_structures_while -> WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 119 (control_structures_while -> WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 119 (control_structures_while -> WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 119 (control_structures_while -> WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 119 (control_structures_while -> WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 119 (control_structures_while -> WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 119 (control_structures_while -> WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 119 (control_structures_while -> WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 119 (control_structures_while -> WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)


state 279

    (63) if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .

    ELSE            reduce using rule 63 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_MULTI   reduce using rule 63 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 63 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 63 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 63 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 63 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 63 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 63 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 63 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 63 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 63 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 63 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    RETURN          reduce using rule 63 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 63 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 63 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 63 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 63 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 63 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 63 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 63 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 63 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 63 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)


state 280

    (105) for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 105 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 105 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 105 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 105 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 105 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 105 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 105 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 105 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 105 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 105 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 105 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    RETURN          reduce using rule 105 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 105 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 105 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 105 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 105 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 105 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 105 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 105 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 105 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 105 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)


state 281

    (107) for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 107 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 107 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 107 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 107 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 107 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 107 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 107 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 107 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 107 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 107 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 107 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    RETURN          reduce using rule 107 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 107 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 107 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 107 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 107 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 107 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 107 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 107 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 107 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 107 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)


state 282

    (111) for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 111 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 111 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 111 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 111 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 111 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 111 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 111 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 111 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 111 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 111 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 111 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    RETURN          reduce using rule 111 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 111 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 111 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 111 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 111 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 111 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 111 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 111 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 111 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 111 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)


state 283

    (104) for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON for_classic_changes .

    RPAREN          reduce using rule 104 (for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON for_classic_changes .)


state 284

    (100) for_classic_changes -> ID . comparator value
    (101) for_classic_changes -> ID . INCREMENT
    (102) for_classic_changes -> ID . DECREMENT
    (103) for_classic_changes -> ID . comparator value COMMA for_classic_changes
    (72) comparator -> . GREATER
    (73) comparator -> . LESS
    (74) comparator -> . EQUALS
    (75) comparator -> . GREATER_EQUAL
    (76) comparator -> . LESS_EQUAL
    (77) comparator -> . NOT_EQUALS

    INCREMENT       shift and go to state 299
    DECREMENT       shift and go to state 300
    GREATER         shift and go to state 119
    LESS            shift and go to state 120
    EQUALS          shift and go to state 121
    GREATER_EQUAL   shift and go to state 122
    LESS_EQUAL      shift and go to state 123
    NOT_EQUALS      shift and go to state 124

    comparator                     shift and go to state 298

state 285

    (110) for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN . IN ID

    IN              shift and go to state 301


state 286

    (108) for_each_parenthesis_parenthesis_content -> COLON ID .
    (109) for_each_parenthesis_parenthesis_content -> COLON ID . COMMA for_each_parenthesis_parenthesis_content

    RPAREN          reduce using rule 108 (for_each_parenthesis_parenthesis_content -> COLON ID .)
    COMMA           shift and go to state 302


state 287

    (27) data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 303


state 288

    (28) data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 304


state 289

    (95) set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 305


state 290

    (96) set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .

    COMMENT_MULTI   reduce using rule 96 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 96 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    SEMICOLON       reduce using rule 96 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    PRINT           reduce using rule 96 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    STRING          reduce using rule 96 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    VAR             reduce using rule 96 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    FINAL           reduce using rule 96 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    ID              reduce using rule 96 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    VOID            reduce using rule 96 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    LIST            reduce using rule 96 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 96 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    RETURN          reduce using rule 96 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    MAP             reduce using rule 96 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    WHILE           reduce using rule 96 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    INT             reduce using rule 96 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 96 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    BOOL            reduce using rule 96 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    IF              reduce using rule 96 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    FOR             reduce using rule 96 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    $end            reduce using rule 96 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    RBRACKET        reduce using rule 96 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)


state 291

    (34) function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    RETURN          reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 34 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)


state 292

    (118) function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .

    COMMENT_MULTI   reduce using rule 118 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    COMMENT_SINGLE  reduce using rule 118 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    SEMICOLON       reduce using rule 118 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    PRINT           reduce using rule 118 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    STRING          reduce using rule 118 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    VAR             reduce using rule 118 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    FINAL           reduce using rule 118 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    ID              reduce using rule 118 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    VOID            reduce using rule 118 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    LIST            reduce using rule 118 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    DYNAMIC         reduce using rule 118 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    RETURN          reduce using rule 118 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    MAP             reduce using rule 118 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    WHILE           reduce using rule 118 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    INT             reduce using rule 118 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    DOUBLE          reduce using rule 118 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    BOOL            reduce using rule 118 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    IF              reduce using rule 118 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    FOR             reduce using rule 118 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    $end            reduce using rule 118 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    RBRACKET        reduce using rule 118 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)


state 293

    (35) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    RETURN          reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 35 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)


state 294

    (83) list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list . RSBRACKET SEMICOLON

    RSBRACKET       shift and go to state 306


state 295

    (121) map_declaration -> MAP LESS key_type COMMA type GREATER ID ASSIGN .

    LBRACKET        reduce using rule 121 (map_declaration -> MAP LESS key_type COMMA type GREATER ID ASSIGN .)


state 296

    (65) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (94) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (95) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (96) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (120) map -> . map_declaration map_assignment
    (117) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (118) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN expression SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (121) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (59) control_structures_if_else -> . if_block
    (60) control_structures_if_else -> . if_block else_if_blocks
    (61) control_structures_if_else -> . if_block else_if_blocks else_block
    (62) control_structures_if_else -> . if_block else_block
    (112) control_structures_for -> . for_classic
    (113) control_structures_for -> . for_in
    (114) control_structures_for -> . for_each
    (119) control_structures_while -> . WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (86) type -> . INT
    (87) type -> . DOUBLE
    (88) type -> . STRING
    (89) type -> . BOOL
    (63) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (105) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (107) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (111) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement_list                 shift and go to state 307
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 297

    (64) else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (94) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (95) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (96) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (120) map -> . map_declaration map_assignment
    (117) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (118) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN expression SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (121) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (59) control_structures_if_else -> . if_block
    (60) control_structures_if_else -> . if_block else_if_blocks
    (61) control_structures_if_else -> . if_block else_if_blocks else_block
    (62) control_structures_if_else -> . if_block else_block
    (112) control_structures_for -> . for_classic
    (113) control_structures_for -> . for_in
    (114) control_structures_for -> . for_each
    (119) control_structures_while -> . WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (86) type -> . INT
    (87) type -> . DOUBLE
    (88) type -> . STRING
    (89) type -> . BOOL
    (63) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (105) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (107) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (111) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 308
    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement                      shift and go to state 44
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 298

    (100) for_classic_changes -> ID comparator . value
    (103) for_classic_changes -> ID comparator . value COMMA for_classic_changes
    (90) value -> . operand
    (91) value -> . TEXT
    (92) value -> . TRUE
    (93) value -> . FALSE
    (51) operand -> . NUMBER
    (52) operand -> . NDOUBLE
    (53) operand -> . ID

    TEXT            shift and go to state 127
    TRUE            shift and go to state 74
    FALSE           shift and go to state 75
    NUMBER          shift and go to state 69
    NDOUBLE         shift and go to state 70
    ID              shift and go to state 128

    value                          shift and go to state 309
    operand                        shift and go to state 126

state 299

    (101) for_classic_changes -> ID INCREMENT .

    RPAREN          reduce using rule 101 (for_classic_changes -> ID INCREMENT .)


state 300

    (102) for_classic_changes -> ID DECREMENT .

    RPAREN          reduce using rule 102 (for_classic_changes -> ID DECREMENT .)


state 301

    (110) for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN . ID

    ID              shift and go to state 310


state 302

    (109) for_each_parenthesis_parenthesis_content -> COLON ID COMMA . for_each_parenthesis_parenthesis_content
    (108) for_each_parenthesis_parenthesis_content -> . COLON ID
    (109) for_each_parenthesis_parenthesis_content -> . COLON ID COMMA for_each_parenthesis_parenthesis_content

    COLON           shift and go to state 259

    for_each_parenthesis_parenthesis_content shift and go to state 311

state 303

    (27) data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .

    COMMENT_MULTI   reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    RETURN          reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 27 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)


state 304

    (28) data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 312


state 305

    (95) set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .

    COMMENT_MULTI   reduce using rule 95 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 95 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    SEMICOLON       reduce using rule 95 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    PRINT           reduce using rule 95 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    STRING          reduce using rule 95 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    VAR             reduce using rule 95 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    FINAL           reduce using rule 95 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    ID              reduce using rule 95 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    VOID            reduce using rule 95 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    LIST            reduce using rule 95 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 95 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    RETURN          reduce using rule 95 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    MAP             reduce using rule 95 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    WHILE           reduce using rule 95 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    INT             reduce using rule 95 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 95 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    BOOL            reduce using rule 95 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    IF              reduce using rule 95 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    FOR             reduce using rule 95 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    $end            reduce using rule 95 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    RBRACKET        reduce using rule 95 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)


state 306

    (83) list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 313


state 307

    (65) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . return
    (16) statement -> . COMMENT_MULTI
    (17) statement -> . COMMENT_SINGLE
    (18) statement -> . SEMICOLON
    (43) print -> . PRINT LPAREN RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (27) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (28) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (94) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (95) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (96) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (120) map -> . map_declaration map_assignment
    (117) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (20) control_structures -> . control_structures_if_else
    (21) control_structures -> . control_structures_for
    (22) control_structures -> . control_structures_while
    (34) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (36) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (37) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (38) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (39) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (118) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (40) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (41) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (42) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (23) variable_usage -> . ID SEMICOLON
    (24) variable_usage -> . ID ASSIGN expression SEMICOLON
    (25) call_function -> . ID LPAREN argument_list RPAREN
    (26) call_function -> . ID LPAREN RPAREN
    (19) return -> . RETURN expression SEMICOLON
    (121) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (59) control_structures_if_else -> . if_block
    (60) control_structures_if_else -> . if_block else_if_blocks
    (61) control_structures_if_else -> . if_block else_if_blocks else_block
    (62) control_structures_if_else -> . if_block else_block
    (112) control_structures_for -> . for_classic
    (113) control_structures_for -> . for_in
    (114) control_structures_for -> . for_each
    (119) control_structures_while -> . WHILE LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (86) type -> . INT
    (87) type -> . DOUBLE
    (88) type -> . STRING
    (89) type -> . BOOL
    (63) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (105) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (107) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (111) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 314
    COMMENT_MULTI   shift and go to state 16
    COMMENT_SINGLE  shift and go to state 17
    SEMICOLON       shift and go to state 18
    PRINT           shift and go to state 19
    STRING          shift and go to state 20
    VAR             shift and go to state 22
    FINAL           shift and go to state 23
    ID              shift and go to state 21
    VOID            shift and go to state 29
    LIST            shift and go to state 30
    DYNAMIC         shift and go to state 31
    RETURN          shift and go to state 32
    MAP             shift and go to state 33
    WHILE           shift and go to state 38
    INT             shift and go to state 39
    DOUBLE          shift and go to state 40
    BOOL            shift and go to state 41
    IF              shift and go to state 42
    FOR             shift and go to state 43

    statement                      shift and go to state 44
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    return                         shift and go to state 15
    map_declaration                shift and go to state 24
    control_structures_if_else     shift and go to state 25
    control_structures_for         shift and go to state 26
    control_structures_while       shift and go to state 27
    type                           shift and go to state 28
    if_block                       shift and go to state 34
    for_classic                    shift and go to state 35
    for_in                         shift and go to state 36
    for_each                       shift and go to state 37

state 308

    (64) else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .

    ELSE            reduce using rule 64 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_MULTI   reduce using rule 64 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 64 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 64 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 64 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 64 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 64 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 64 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 64 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 64 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 64 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 64 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    RETURN          reduce using rule 64 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 64 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 64 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 64 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 64 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 64 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 64 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 64 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 64 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 64 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)


state 309

    (100) for_classic_changes -> ID comparator value .
    (103) for_classic_changes -> ID comparator value . COMMA for_classic_changes

    RPAREN          reduce using rule 100 (for_classic_changes -> ID comparator value .)
    COMMA           shift and go to state 315


state 310

    (110) for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID .

    RPAREN          reduce using rule 110 (for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID .)


state 311

    (109) for_each_parenthesis_parenthesis_content -> COLON ID COMMA for_each_parenthesis_parenthesis_content .

    RPAREN          reduce using rule 109 (for_each_parenthesis_parenthesis_content -> COLON ID COMMA for_each_parenthesis_parenthesis_content .)


state 312

    (28) data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .

    COMMENT_MULTI   reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    RETURN          reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 28 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)


state 313

    (83) list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .

    COMMENT_MULTI   reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    SEMICOLON       reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    PRINT           reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    STRING          reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    VAR             reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    FINAL           reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    ID              reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    VOID            reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    LIST            reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    RETURN          reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    MAP             reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    WHILE           reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    INT             reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    BOOL            reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    IF              reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    FOR             reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    $end            reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    RBRACKET        reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)


state 314

    (65) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .

    ELSE            reduce using rule 65 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_MULTI   reduce using rule 65 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 65 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 65 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 65 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 65 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 65 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 65 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 65 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 65 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 65 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 65 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    RETURN          reduce using rule 65 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 65 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 65 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 65 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 65 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 65 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 65 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 65 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 65 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 65 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)


state 315

    (103) for_classic_changes -> ID comparator value COMMA . for_classic_changes
    (100) for_classic_changes -> . ID comparator value
    (101) for_classic_changes -> . ID INCREMENT
    (102) for_classic_changes -> . ID DECREMENT
    (103) for_classic_changes -> . ID comparator value COMMA for_classic_changes

    ID              shift and go to state 284

    for_classic_changes            shift and go to state 316

state 316

    (103) for_classic_changes -> ID comparator value COMMA for_classic_changes .

    RPAREN          reduce using rule 103 (for_classic_changes -> ID comparator value COMMA for_classic_changes .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 20 resolved as shift
