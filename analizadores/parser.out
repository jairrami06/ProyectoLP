Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AS
    ASSERT
    ASYNC
    AWAIT
    BREAK
    CASE
    CATCH
    CLASS
    CONTINUE
    COVARIANT
    DEFAULT
    DEFERRED
    DO
    DOLLARSIGN
    DOUBLE_COLON
    ENUM
    EXPORT
    EXTENDS
    EXTENSION
    EXTERNAL
    FACTORY
    FINALLY
    FUNCTION
    GET
    HIDE
    IMPLEMENTS
    IMPORT
    INTERFACE
    IS
    LATE
    LIBRARY
    MIXIN
    MODULE
    NEW
    NULL
    NUM
    NUMERAL
    OBJECT
    ON
    OPERATOR
    PART
    RETHROW
    RETURN
    SET
    SHOW
    STATIC
    SUPER
    SWITCH
    SYNC
    THROW
    TRY
    TYPEDEF
    WITH
    YIELD

Grammar

Rule 0     S' -> program
Rule 1     program -> statement_list
Rule 2     statement_list -> statement
Rule 3     statement_list -> statement_list statement
Rule 4     statement -> print
Rule 5     statement -> data_input
Rule 6     statement -> set
Rule 7     statement -> map
Rule 8     statement -> constructor
Rule 9     statement -> control_structures
Rule 10    statement -> function
Rule 11    statement -> list_definition
Rule 12    statement -> variable_definition
Rule 13    statement -> variable_usage
Rule 14    statement -> call_function
Rule 15    statement -> COMMENT_MULTI
Rule 16    statement -> COMMENT_SINGLE
Rule 17    statement -> SEMICOLON
Rule 18    control_structures -> control_structures_if_else
Rule 19    control_structures -> control_structures_for
Rule 20    control_structures -> control_structures_while
Rule 21    variable_usage -> ID SEMICOLON
Rule 22    variable_usage -> ID ASSIGN value SEMICOLON
Rule 23    call_function -> ID LPAREN argument_list RPAREN
Rule 24    call_function -> ID LPAREN RPAREN
Rule 25    data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
Rule 26    data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
Rule 27    length -> call_list DOT LENGTH
Rule 28    length -> TEXT DOT LENGTH
Rule 29    argument_list -> expression
Rule 30    argument_list -> argument_list COMMA expression
Rule 31    function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
Rule 32    function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
Rule 33    function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
Rule 34    function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
Rule 35    function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET
Rule 36    function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
Rule 37    variable_definition -> type ID ASSIGN expression SEMICOLON
Rule 38    variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON
Rule 39    variable_definition -> VAR ID ASSIGN expression SEMICOLON
Rule 40    print -> PRINT LPAREN RPAREN SEMICOLON
Rule 41    print -> PRINT LPAREN print_options RPAREN SEMICOLON
Rule 42    print_options -> interpolated_string
Rule 43    print_options -> expression
Rule 44    print_options -> length
Rule 45    print_options -> call_function
Rule 46    expression -> operations
Rule 47    operations -> operation
Rule 48    operations -> operation operand operations
Rule 49    operation -> operand operator operand
Rule 50    operand -> NUMBER
Rule 51    operand -> DOUBLE
Rule 52    operator -> PLUS
Rule 53    operator -> MINUS
Rule 54    operator -> TIMES
Rule 55    operator -> DIVIDE
Rule 56    expression -> conditions
Rule 57    expression -> value
Rule 58    control_structures_if_else -> if_block
Rule 59    control_structures_if_else -> if_block else_if_blocks
Rule 60    control_structures_if_else -> if_block else_if_blocks else_block
Rule 61    control_structures_if_else -> if_block else_block
Rule 62    if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
Rule 63    else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
Rule 64    else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
Rule 65    else_block -> ELSE LBRACKET statement_list RBRACKET
Rule 66    conditions -> condition
Rule 67    conditions -> condition AND conditions
Rule 68    conditions -> condition OR conditions
Rule 69    condition -> value comparator value
Rule 70    condition -> NOT condition
Rule 71    comparator -> GREATER
Rule 72    comparator -> LESS
Rule 73    comparator -> EQUALS
Rule 74    comparator -> GREATER_EQUAL
Rule 75    comparator -> LESS_EQUAL
Rule 76    comparator -> NOT_EQUALS
Rule 77    parameter_list -> parameter
Rule 78    parameter_list -> parameter_list COMMA parameter
Rule 79    parameter -> type ID
Rule 80    parameter -> REQUIRED type ID
Rule 81    call_list -> LSBRACKET value_list RSBRACKET
Rule 82    list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
Rule 83    value_list -> value
Rule 84    value_list -> value COMMA value_list
Rule 85    interpolated_string -> string_part
Rule 86    interpolated_string -> string_part PLUS interpolated_string
Rule 87    string_part -> TEXT
Rule 88    string_part -> TEXT PLUS value
Rule 89    type -> INT
Rule 90    type -> DOUBLE
Rule 91    type -> STRING
Rule 92    type -> BOOL
Rule 93    type -> LIST
Rule 94    value -> NUMBER
Rule 95    value -> NDOUBLE
Rule 96    value -> TEXT
Rule 97    value -> ID
Rule 98    value -> TRUE
Rule 99    value -> FALSE
Rule 100   set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
Rule 101   set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
Rule 102   set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
Rule 103   for_classic_initialization -> INT ID ASSIGN NUMBER
Rule 104   for_classic_initialization -> DOUBLE ID ASSIGN NDOUBLE
Rule 105   for_classic_conditions -> conditions
Rule 106   for_classic_changes -> ID comparator value
Rule 107   for_classic_changes -> ID INCREMENT
Rule 108   for_classic_changes -> ID DECREMENT
Rule 109   for_classic_changes -> ID comparator value COMMA for_classic_changes
Rule 110   for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON for_classic_changes
Rule 111   for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
Rule 112   for_in_parenthesis_content -> FINAL ID IN ID
Rule 113   for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
Rule 114   for_each_parenthesis_parenthesis_content -> COLON ID
Rule 115   for_each_parenthesis_parenthesis_content -> COLON ID COMMA for_each_parenthesis_parenthesis_content
Rule 116   for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID
Rule 117   for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
Rule 118   control_structures_for -> for_classic
Rule 119   control_structures_for -> for_in
Rule 120   control_structures_for -> for_each
Rule 121   constructor_parenthesis_content -> THIS DOT ID
Rule 122   constructor_parenthesis_content -> THIS DOT ID COMMA constructor_parenthesis_content
Rule 123   constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
Rule 124   function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
Rule 125   control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET
Rule 126   map -> map_declaration map_assignment
Rule 127   map_declaration -> MAP LESS key_type COMMA type GREATER ID ASSIGN
Rule 128   map_assignment -> LBRACKET map_contents RBRACKET
Rule 129   map_contents -> map_content
Rule 130   map_contents -> map_content COMMA map_contents
Rule 131   map_content -> key_value COLON value
Rule 132   key_value -> TEXT
Rule 133   key_type -> STRING

Terminals, with rules where they appear

ABSTRACT             : 
AND                  : 67
AS                   : 
ASSERT               : 
ASSIGN               : 22 25 26 37 38 39 82 100 101 102 103 104 124 127
ASYNC                : 
AWAIT                : 
BOOL                 : 92
BREAK                : 
CASE                 : 
CATCH                : 
CLASS                : 
COLON                : 114 115 131
COMMA                : 30 78 84 109 115 122 127 130
COMMENT_MULTI        : 15
COMMENT_SINGLE       : 16
CONST                : 102
CONTINUE             : 
COVARIANT            : 
DECREMENT            : 108
DEFAULT              : 
DEFERRED             : 
DIVIDE               : 55
DO                   : 
DOLLARSIGN           : 
DOT                  : 25 26 27 28 121 122
DOUBLE               : 51 90 104
DOUBLE_COLON         : 
DYNAMIC              : 38
ELSE                 : 63 64 65
ENUM                 : 
EQUALS               : 73
EXPORT               : 
EXTENDS              : 
EXTENSION            : 
EXTERNAL             : 
FACTORY              : 
FALSE                : 99
FINAL                : 102 112 116
FINALLY              : 
FOR                  : 111 113 117
FUNCTION             : 
GET                  : 
GREATER              : 71 82 101 124 127
GREATER_EQUAL        : 74
HIDE                 : 
ID                   : 21 22 23 24 25 26 31 32 33 34 35 36 37 38 39 79 80 82 97 100 101 102 103 104 106 107 108 109 112 112 114 115 116 116 121 122 123 124 127
IF                   : 62 63 64
IMPLEMENTS           : 
IMPORT               : 
IN                   : 112 116
INCREMENT            : 107
INT                  : 89 103
INTERFACE            : 
IS                   : 
LATE                 : 
LBRACKET             : 31 32 33 34 35 36 62 63 64 65 100 101 102 111 113 117 125 128
LENGTH               : 27 28
LESS                 : 72 82 101 127
LESS_EQUAL           : 75
LIBRARY              : 
LIST                 : 82 93
LPAREN               : 23 24 25 26 31 32 33 34 35 36 40 41 62 63 64 111 113 116 117 123 124 125
LSBRACKET            : 81 82
MAP                  : 127
MINUS                : 53
MIXIN                : 
MODULE               : 
NDOUBLE              : 95 104
NEW                  : 
NOT                  : 70
NOT_EQUALS           : 76
NULL                 : 
NUM                  : 
NUMBER               : 50 94 103
NUMERAL              : 
OBJECT               : 
ON                   : 
OPERATOR             : 
OR                   : 68
PART                 : 
PLUS                 : 52 86 88
PRINT                : 40 41
QUESTION             : 26
RBRACKET             : 31 32 33 34 35 36 62 63 64 65 100 101 102 111 113 117 125 128
READLINESYNC         : 25 26
REQUIRED             : 80
RETHROW              : 
RETURN               : 
RPAREN               : 23 24 25 26 31 32 33 34 35 36 40 41 62 63 64 111 113 116 117 123 124
RSBRACKET            : 81 82
SEMICOLON            : 17 21 22 25 26 37 38 39 40 41 82 100 101 102 110 110 123
SET                  : 
SHOW                 : 
STATIC               : 
STDIN                : 25 26
STRING               : 25 26 91 101 133
SUPER                : 
SWITCH               : 
SYNC                 : 
TEXT                 : 28 87 88 96 132
THIS                 : 121 122
THROW                : 
TIMES                : 54
TRUE                 : 98
TRY                  : 
TYPEDEF              : 
VAR                  : 39 100 101
VOID                 : 32 34 35 36
WHILE                : 125
WITH                 : 
YIELD                : 
error                : 

Nonterminals, with rules where they appear

argument_list        : 23 30
call_function        : 14 45
call_list            : 27
comparator           : 69 106 109
condition            : 66 67 68 70
conditions           : 56 62 63 64 67 68 105 125
constructor          : 8
constructor_parenthesis_content : 122 123
control_structures   : 9
control_structures_for : 19
control_structures_if_else : 18
control_structures_while : 20
data_input           : 5
else_block           : 60 61
else_if_blocks       : 59 60 64
expression           : 29 30 37 38 39 43 124
for_classic          : 118
for_classic_changes  : 109 110
for_classic_conditions : 110
for_classic_initialization : 110
for_classic_parenthesis_content : 111
for_each             : 120
for_each_parenthesis_content : 117
for_each_parenthesis_parenthesis_content : 115 116
for_in               : 119
for_in_parenthesis_content : 113
function             : 10
if_block             : 58 59 60 61
interpolated_string  : 42 86
key_type             : 127
key_value            : 131
length               : 44
list_definition      : 11
map                  : 7
map_assignment       : 126
map_content          : 129 130
map_contents         : 128 130
map_declaration      : 126
operand              : 48 49 49
operation            : 47 48
operations           : 46 48
operator             : 49
parameter            : 77 78
parameter_list       : 31 32 36 78 124
print                : 4
print_options        : 41
program              : 0
set                  : 6
statement            : 2 3
statement_list       : 1 3 31 32 33 34 62 63 64 65 111 113 117 125
string_part          : 85 86
type                 : 31 33 37 79 80 82 124 127
value                : 22 57 69 69 83 84 88 106 109 131
value_list           : 81 82 84 100 102
variable_definition  : 12
variable_usage       : 13

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement_list
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    program                        shift and go to state 1
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 1

    (0) S' -> program .



state 2

    (1) program -> statement_list .
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    $end            reduce using rule 1 (program -> statement_list .)
    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement                      shift and go to state 42
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 3

    (2) statement_list -> statement .

    COMMENT_MULTI   reduce using rule 2 (statement_list -> statement .)
    COMMENT_SINGLE  reduce using rule 2 (statement_list -> statement .)
    SEMICOLON       reduce using rule 2 (statement_list -> statement .)
    PRINT           reduce using rule 2 (statement_list -> statement .)
    STRING          reduce using rule 2 (statement_list -> statement .)
    VAR             reduce using rule 2 (statement_list -> statement .)
    FINAL           reduce using rule 2 (statement_list -> statement .)
    ID              reduce using rule 2 (statement_list -> statement .)
    VOID            reduce using rule 2 (statement_list -> statement .)
    LIST            reduce using rule 2 (statement_list -> statement .)
    DYNAMIC         reduce using rule 2 (statement_list -> statement .)
    MAP             reduce using rule 2 (statement_list -> statement .)
    WHILE           reduce using rule 2 (statement_list -> statement .)
    INT             reduce using rule 2 (statement_list -> statement .)
    DOUBLE          reduce using rule 2 (statement_list -> statement .)
    BOOL            reduce using rule 2 (statement_list -> statement .)
    IF              reduce using rule 2 (statement_list -> statement .)
    FOR             reduce using rule 2 (statement_list -> statement .)
    $end            reduce using rule 2 (statement_list -> statement .)
    RBRACKET        reduce using rule 2 (statement_list -> statement .)


state 4

    (4) statement -> print .

    COMMENT_MULTI   reduce using rule 4 (statement -> print .)
    COMMENT_SINGLE  reduce using rule 4 (statement -> print .)
    SEMICOLON       reduce using rule 4 (statement -> print .)
    PRINT           reduce using rule 4 (statement -> print .)
    STRING          reduce using rule 4 (statement -> print .)
    VAR             reduce using rule 4 (statement -> print .)
    FINAL           reduce using rule 4 (statement -> print .)
    ID              reduce using rule 4 (statement -> print .)
    VOID            reduce using rule 4 (statement -> print .)
    LIST            reduce using rule 4 (statement -> print .)
    DYNAMIC         reduce using rule 4 (statement -> print .)
    MAP             reduce using rule 4 (statement -> print .)
    WHILE           reduce using rule 4 (statement -> print .)
    INT             reduce using rule 4 (statement -> print .)
    DOUBLE          reduce using rule 4 (statement -> print .)
    BOOL            reduce using rule 4 (statement -> print .)
    IF              reduce using rule 4 (statement -> print .)
    FOR             reduce using rule 4 (statement -> print .)
    $end            reduce using rule 4 (statement -> print .)
    RBRACKET        reduce using rule 4 (statement -> print .)


state 5

    (5) statement -> data_input .

    COMMENT_MULTI   reduce using rule 5 (statement -> data_input .)
    COMMENT_SINGLE  reduce using rule 5 (statement -> data_input .)
    SEMICOLON       reduce using rule 5 (statement -> data_input .)
    PRINT           reduce using rule 5 (statement -> data_input .)
    STRING          reduce using rule 5 (statement -> data_input .)
    VAR             reduce using rule 5 (statement -> data_input .)
    FINAL           reduce using rule 5 (statement -> data_input .)
    ID              reduce using rule 5 (statement -> data_input .)
    VOID            reduce using rule 5 (statement -> data_input .)
    LIST            reduce using rule 5 (statement -> data_input .)
    DYNAMIC         reduce using rule 5 (statement -> data_input .)
    MAP             reduce using rule 5 (statement -> data_input .)
    WHILE           reduce using rule 5 (statement -> data_input .)
    INT             reduce using rule 5 (statement -> data_input .)
    DOUBLE          reduce using rule 5 (statement -> data_input .)
    BOOL            reduce using rule 5 (statement -> data_input .)
    IF              reduce using rule 5 (statement -> data_input .)
    FOR             reduce using rule 5 (statement -> data_input .)
    $end            reduce using rule 5 (statement -> data_input .)
    RBRACKET        reduce using rule 5 (statement -> data_input .)


state 6

    (6) statement -> set .

    COMMENT_MULTI   reduce using rule 6 (statement -> set .)
    COMMENT_SINGLE  reduce using rule 6 (statement -> set .)
    SEMICOLON       reduce using rule 6 (statement -> set .)
    PRINT           reduce using rule 6 (statement -> set .)
    STRING          reduce using rule 6 (statement -> set .)
    VAR             reduce using rule 6 (statement -> set .)
    FINAL           reduce using rule 6 (statement -> set .)
    ID              reduce using rule 6 (statement -> set .)
    VOID            reduce using rule 6 (statement -> set .)
    LIST            reduce using rule 6 (statement -> set .)
    DYNAMIC         reduce using rule 6 (statement -> set .)
    MAP             reduce using rule 6 (statement -> set .)
    WHILE           reduce using rule 6 (statement -> set .)
    INT             reduce using rule 6 (statement -> set .)
    DOUBLE          reduce using rule 6 (statement -> set .)
    BOOL            reduce using rule 6 (statement -> set .)
    IF              reduce using rule 6 (statement -> set .)
    FOR             reduce using rule 6 (statement -> set .)
    $end            reduce using rule 6 (statement -> set .)
    RBRACKET        reduce using rule 6 (statement -> set .)


state 7

    (7) statement -> map .

    COMMENT_MULTI   reduce using rule 7 (statement -> map .)
    COMMENT_SINGLE  reduce using rule 7 (statement -> map .)
    SEMICOLON       reduce using rule 7 (statement -> map .)
    PRINT           reduce using rule 7 (statement -> map .)
    STRING          reduce using rule 7 (statement -> map .)
    VAR             reduce using rule 7 (statement -> map .)
    FINAL           reduce using rule 7 (statement -> map .)
    ID              reduce using rule 7 (statement -> map .)
    VOID            reduce using rule 7 (statement -> map .)
    LIST            reduce using rule 7 (statement -> map .)
    DYNAMIC         reduce using rule 7 (statement -> map .)
    MAP             reduce using rule 7 (statement -> map .)
    WHILE           reduce using rule 7 (statement -> map .)
    INT             reduce using rule 7 (statement -> map .)
    DOUBLE          reduce using rule 7 (statement -> map .)
    BOOL            reduce using rule 7 (statement -> map .)
    IF              reduce using rule 7 (statement -> map .)
    FOR             reduce using rule 7 (statement -> map .)
    $end            reduce using rule 7 (statement -> map .)
    RBRACKET        reduce using rule 7 (statement -> map .)


state 8

    (8) statement -> constructor .

    COMMENT_MULTI   reduce using rule 8 (statement -> constructor .)
    COMMENT_SINGLE  reduce using rule 8 (statement -> constructor .)
    SEMICOLON       reduce using rule 8 (statement -> constructor .)
    PRINT           reduce using rule 8 (statement -> constructor .)
    STRING          reduce using rule 8 (statement -> constructor .)
    VAR             reduce using rule 8 (statement -> constructor .)
    FINAL           reduce using rule 8 (statement -> constructor .)
    ID              reduce using rule 8 (statement -> constructor .)
    VOID            reduce using rule 8 (statement -> constructor .)
    LIST            reduce using rule 8 (statement -> constructor .)
    DYNAMIC         reduce using rule 8 (statement -> constructor .)
    MAP             reduce using rule 8 (statement -> constructor .)
    WHILE           reduce using rule 8 (statement -> constructor .)
    INT             reduce using rule 8 (statement -> constructor .)
    DOUBLE          reduce using rule 8 (statement -> constructor .)
    BOOL            reduce using rule 8 (statement -> constructor .)
    IF              reduce using rule 8 (statement -> constructor .)
    FOR             reduce using rule 8 (statement -> constructor .)
    $end            reduce using rule 8 (statement -> constructor .)
    RBRACKET        reduce using rule 8 (statement -> constructor .)


state 9

    (9) statement -> control_structures .

    COMMENT_MULTI   reduce using rule 9 (statement -> control_structures .)
    COMMENT_SINGLE  reduce using rule 9 (statement -> control_structures .)
    SEMICOLON       reduce using rule 9 (statement -> control_structures .)
    PRINT           reduce using rule 9 (statement -> control_structures .)
    STRING          reduce using rule 9 (statement -> control_structures .)
    VAR             reduce using rule 9 (statement -> control_structures .)
    FINAL           reduce using rule 9 (statement -> control_structures .)
    ID              reduce using rule 9 (statement -> control_structures .)
    VOID            reduce using rule 9 (statement -> control_structures .)
    LIST            reduce using rule 9 (statement -> control_structures .)
    DYNAMIC         reduce using rule 9 (statement -> control_structures .)
    MAP             reduce using rule 9 (statement -> control_structures .)
    WHILE           reduce using rule 9 (statement -> control_structures .)
    INT             reduce using rule 9 (statement -> control_structures .)
    DOUBLE          reduce using rule 9 (statement -> control_structures .)
    BOOL            reduce using rule 9 (statement -> control_structures .)
    IF              reduce using rule 9 (statement -> control_structures .)
    FOR             reduce using rule 9 (statement -> control_structures .)
    $end            reduce using rule 9 (statement -> control_structures .)
    RBRACKET        reduce using rule 9 (statement -> control_structures .)


state 10

    (10) statement -> function .

    COMMENT_MULTI   reduce using rule 10 (statement -> function .)
    COMMENT_SINGLE  reduce using rule 10 (statement -> function .)
    SEMICOLON       reduce using rule 10 (statement -> function .)
    PRINT           reduce using rule 10 (statement -> function .)
    STRING          reduce using rule 10 (statement -> function .)
    VAR             reduce using rule 10 (statement -> function .)
    FINAL           reduce using rule 10 (statement -> function .)
    ID              reduce using rule 10 (statement -> function .)
    VOID            reduce using rule 10 (statement -> function .)
    LIST            reduce using rule 10 (statement -> function .)
    DYNAMIC         reduce using rule 10 (statement -> function .)
    MAP             reduce using rule 10 (statement -> function .)
    WHILE           reduce using rule 10 (statement -> function .)
    INT             reduce using rule 10 (statement -> function .)
    DOUBLE          reduce using rule 10 (statement -> function .)
    BOOL            reduce using rule 10 (statement -> function .)
    IF              reduce using rule 10 (statement -> function .)
    FOR             reduce using rule 10 (statement -> function .)
    $end            reduce using rule 10 (statement -> function .)
    RBRACKET        reduce using rule 10 (statement -> function .)


state 11

    (11) statement -> list_definition .

    COMMENT_MULTI   reduce using rule 11 (statement -> list_definition .)
    COMMENT_SINGLE  reduce using rule 11 (statement -> list_definition .)
    SEMICOLON       reduce using rule 11 (statement -> list_definition .)
    PRINT           reduce using rule 11 (statement -> list_definition .)
    STRING          reduce using rule 11 (statement -> list_definition .)
    VAR             reduce using rule 11 (statement -> list_definition .)
    FINAL           reduce using rule 11 (statement -> list_definition .)
    ID              reduce using rule 11 (statement -> list_definition .)
    VOID            reduce using rule 11 (statement -> list_definition .)
    LIST            reduce using rule 11 (statement -> list_definition .)
    DYNAMIC         reduce using rule 11 (statement -> list_definition .)
    MAP             reduce using rule 11 (statement -> list_definition .)
    WHILE           reduce using rule 11 (statement -> list_definition .)
    INT             reduce using rule 11 (statement -> list_definition .)
    DOUBLE          reduce using rule 11 (statement -> list_definition .)
    BOOL            reduce using rule 11 (statement -> list_definition .)
    IF              reduce using rule 11 (statement -> list_definition .)
    FOR             reduce using rule 11 (statement -> list_definition .)
    $end            reduce using rule 11 (statement -> list_definition .)
    RBRACKET        reduce using rule 11 (statement -> list_definition .)


state 12

    (12) statement -> variable_definition .

    COMMENT_MULTI   reduce using rule 12 (statement -> variable_definition .)
    COMMENT_SINGLE  reduce using rule 12 (statement -> variable_definition .)
    SEMICOLON       reduce using rule 12 (statement -> variable_definition .)
    PRINT           reduce using rule 12 (statement -> variable_definition .)
    STRING          reduce using rule 12 (statement -> variable_definition .)
    VAR             reduce using rule 12 (statement -> variable_definition .)
    FINAL           reduce using rule 12 (statement -> variable_definition .)
    ID              reduce using rule 12 (statement -> variable_definition .)
    VOID            reduce using rule 12 (statement -> variable_definition .)
    LIST            reduce using rule 12 (statement -> variable_definition .)
    DYNAMIC         reduce using rule 12 (statement -> variable_definition .)
    MAP             reduce using rule 12 (statement -> variable_definition .)
    WHILE           reduce using rule 12 (statement -> variable_definition .)
    INT             reduce using rule 12 (statement -> variable_definition .)
    DOUBLE          reduce using rule 12 (statement -> variable_definition .)
    BOOL            reduce using rule 12 (statement -> variable_definition .)
    IF              reduce using rule 12 (statement -> variable_definition .)
    FOR             reduce using rule 12 (statement -> variable_definition .)
    $end            reduce using rule 12 (statement -> variable_definition .)
    RBRACKET        reduce using rule 12 (statement -> variable_definition .)


state 13

    (13) statement -> variable_usage .

    COMMENT_MULTI   reduce using rule 13 (statement -> variable_usage .)
    COMMENT_SINGLE  reduce using rule 13 (statement -> variable_usage .)
    SEMICOLON       reduce using rule 13 (statement -> variable_usage .)
    PRINT           reduce using rule 13 (statement -> variable_usage .)
    STRING          reduce using rule 13 (statement -> variable_usage .)
    VAR             reduce using rule 13 (statement -> variable_usage .)
    FINAL           reduce using rule 13 (statement -> variable_usage .)
    ID              reduce using rule 13 (statement -> variable_usage .)
    VOID            reduce using rule 13 (statement -> variable_usage .)
    LIST            reduce using rule 13 (statement -> variable_usage .)
    DYNAMIC         reduce using rule 13 (statement -> variable_usage .)
    MAP             reduce using rule 13 (statement -> variable_usage .)
    WHILE           reduce using rule 13 (statement -> variable_usage .)
    INT             reduce using rule 13 (statement -> variable_usage .)
    DOUBLE          reduce using rule 13 (statement -> variable_usage .)
    BOOL            reduce using rule 13 (statement -> variable_usage .)
    IF              reduce using rule 13 (statement -> variable_usage .)
    FOR             reduce using rule 13 (statement -> variable_usage .)
    $end            reduce using rule 13 (statement -> variable_usage .)
    RBRACKET        reduce using rule 13 (statement -> variable_usage .)


state 14

    (14) statement -> call_function .

    COMMENT_MULTI   reduce using rule 14 (statement -> call_function .)
    COMMENT_SINGLE  reduce using rule 14 (statement -> call_function .)
    SEMICOLON       reduce using rule 14 (statement -> call_function .)
    PRINT           reduce using rule 14 (statement -> call_function .)
    STRING          reduce using rule 14 (statement -> call_function .)
    VAR             reduce using rule 14 (statement -> call_function .)
    FINAL           reduce using rule 14 (statement -> call_function .)
    ID              reduce using rule 14 (statement -> call_function .)
    VOID            reduce using rule 14 (statement -> call_function .)
    LIST            reduce using rule 14 (statement -> call_function .)
    DYNAMIC         reduce using rule 14 (statement -> call_function .)
    MAP             reduce using rule 14 (statement -> call_function .)
    WHILE           reduce using rule 14 (statement -> call_function .)
    INT             reduce using rule 14 (statement -> call_function .)
    DOUBLE          reduce using rule 14 (statement -> call_function .)
    BOOL            reduce using rule 14 (statement -> call_function .)
    IF              reduce using rule 14 (statement -> call_function .)
    FOR             reduce using rule 14 (statement -> call_function .)
    $end            reduce using rule 14 (statement -> call_function .)
    RBRACKET        reduce using rule 14 (statement -> call_function .)


state 15

    (15) statement -> COMMENT_MULTI .

    COMMENT_MULTI   reduce using rule 15 (statement -> COMMENT_MULTI .)
    COMMENT_SINGLE  reduce using rule 15 (statement -> COMMENT_MULTI .)
    SEMICOLON       reduce using rule 15 (statement -> COMMENT_MULTI .)
    PRINT           reduce using rule 15 (statement -> COMMENT_MULTI .)
    STRING          reduce using rule 15 (statement -> COMMENT_MULTI .)
    VAR             reduce using rule 15 (statement -> COMMENT_MULTI .)
    FINAL           reduce using rule 15 (statement -> COMMENT_MULTI .)
    ID              reduce using rule 15 (statement -> COMMENT_MULTI .)
    VOID            reduce using rule 15 (statement -> COMMENT_MULTI .)
    LIST            reduce using rule 15 (statement -> COMMENT_MULTI .)
    DYNAMIC         reduce using rule 15 (statement -> COMMENT_MULTI .)
    MAP             reduce using rule 15 (statement -> COMMENT_MULTI .)
    WHILE           reduce using rule 15 (statement -> COMMENT_MULTI .)
    INT             reduce using rule 15 (statement -> COMMENT_MULTI .)
    DOUBLE          reduce using rule 15 (statement -> COMMENT_MULTI .)
    BOOL            reduce using rule 15 (statement -> COMMENT_MULTI .)
    IF              reduce using rule 15 (statement -> COMMENT_MULTI .)
    FOR             reduce using rule 15 (statement -> COMMENT_MULTI .)
    $end            reduce using rule 15 (statement -> COMMENT_MULTI .)
    RBRACKET        reduce using rule 15 (statement -> COMMENT_MULTI .)


state 16

    (16) statement -> COMMENT_SINGLE .

    COMMENT_MULTI   reduce using rule 16 (statement -> COMMENT_SINGLE .)
    COMMENT_SINGLE  reduce using rule 16 (statement -> COMMENT_SINGLE .)
    SEMICOLON       reduce using rule 16 (statement -> COMMENT_SINGLE .)
    PRINT           reduce using rule 16 (statement -> COMMENT_SINGLE .)
    STRING          reduce using rule 16 (statement -> COMMENT_SINGLE .)
    VAR             reduce using rule 16 (statement -> COMMENT_SINGLE .)
    FINAL           reduce using rule 16 (statement -> COMMENT_SINGLE .)
    ID              reduce using rule 16 (statement -> COMMENT_SINGLE .)
    VOID            reduce using rule 16 (statement -> COMMENT_SINGLE .)
    LIST            reduce using rule 16 (statement -> COMMENT_SINGLE .)
    DYNAMIC         reduce using rule 16 (statement -> COMMENT_SINGLE .)
    MAP             reduce using rule 16 (statement -> COMMENT_SINGLE .)
    WHILE           reduce using rule 16 (statement -> COMMENT_SINGLE .)
    INT             reduce using rule 16 (statement -> COMMENT_SINGLE .)
    DOUBLE          reduce using rule 16 (statement -> COMMENT_SINGLE .)
    BOOL            reduce using rule 16 (statement -> COMMENT_SINGLE .)
    IF              reduce using rule 16 (statement -> COMMENT_SINGLE .)
    FOR             reduce using rule 16 (statement -> COMMENT_SINGLE .)
    $end            reduce using rule 16 (statement -> COMMENT_SINGLE .)
    RBRACKET        reduce using rule 16 (statement -> COMMENT_SINGLE .)


state 17

    (17) statement -> SEMICOLON .

    COMMENT_MULTI   reduce using rule 17 (statement -> SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 17 (statement -> SEMICOLON .)
    SEMICOLON       reduce using rule 17 (statement -> SEMICOLON .)
    PRINT           reduce using rule 17 (statement -> SEMICOLON .)
    STRING          reduce using rule 17 (statement -> SEMICOLON .)
    VAR             reduce using rule 17 (statement -> SEMICOLON .)
    FINAL           reduce using rule 17 (statement -> SEMICOLON .)
    ID              reduce using rule 17 (statement -> SEMICOLON .)
    VOID            reduce using rule 17 (statement -> SEMICOLON .)
    LIST            reduce using rule 17 (statement -> SEMICOLON .)
    DYNAMIC         reduce using rule 17 (statement -> SEMICOLON .)
    MAP             reduce using rule 17 (statement -> SEMICOLON .)
    WHILE           reduce using rule 17 (statement -> SEMICOLON .)
    INT             reduce using rule 17 (statement -> SEMICOLON .)
    DOUBLE          reduce using rule 17 (statement -> SEMICOLON .)
    BOOL            reduce using rule 17 (statement -> SEMICOLON .)
    IF              reduce using rule 17 (statement -> SEMICOLON .)
    FOR             reduce using rule 17 (statement -> SEMICOLON .)
    $end            reduce using rule 17 (statement -> SEMICOLON .)
    RBRACKET        reduce using rule 17 (statement -> SEMICOLON .)


state 18

    (40) print -> PRINT . LPAREN RPAREN SEMICOLON
    (41) print -> PRINT . LPAREN print_options RPAREN SEMICOLON

    LPAREN          shift and go to state 43


state 19

    (25) data_input -> STRING . ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> STRING . QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (91) type -> STRING .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 44
    QUESTION        shift and go to state 45

  ! ID              [ reduce using rule 91 (type -> STRING .) ]


state 20

    (123) constructor -> ID . LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (21) variable_usage -> ID . SEMICOLON
    (22) variable_usage -> ID . ASSIGN value SEMICOLON
    (23) call_function -> ID . LPAREN argument_list RPAREN
    (24) call_function -> ID . LPAREN RPAREN

    LPAREN          shift and go to state 46
    SEMICOLON       shift and go to state 47
    ASSIGN          shift and go to state 48


state 21

    (100) set -> VAR . ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> VAR . ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (39) variable_definition -> VAR . ID ASSIGN expression SEMICOLON

    ID              shift and go to state 49


state 22

    (102) set -> FINAL . ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON

    ID              shift and go to state 50


state 23

    (126) map -> map_declaration . map_assignment
    (128) map_assignment -> . LBRACKET map_contents RBRACKET

    LBRACKET        shift and go to state 52

    map_assignment                 shift and go to state 51

state 24

    (18) control_structures -> control_structures_if_else .

    COMMENT_MULTI   reduce using rule 18 (control_structures -> control_structures_if_else .)
    COMMENT_SINGLE  reduce using rule 18 (control_structures -> control_structures_if_else .)
    SEMICOLON       reduce using rule 18 (control_structures -> control_structures_if_else .)
    PRINT           reduce using rule 18 (control_structures -> control_structures_if_else .)
    STRING          reduce using rule 18 (control_structures -> control_structures_if_else .)
    VAR             reduce using rule 18 (control_structures -> control_structures_if_else .)
    FINAL           reduce using rule 18 (control_structures -> control_structures_if_else .)
    ID              reduce using rule 18 (control_structures -> control_structures_if_else .)
    VOID            reduce using rule 18 (control_structures -> control_structures_if_else .)
    LIST            reduce using rule 18 (control_structures -> control_structures_if_else .)
    DYNAMIC         reduce using rule 18 (control_structures -> control_structures_if_else .)
    MAP             reduce using rule 18 (control_structures -> control_structures_if_else .)
    WHILE           reduce using rule 18 (control_structures -> control_structures_if_else .)
    INT             reduce using rule 18 (control_structures -> control_structures_if_else .)
    DOUBLE          reduce using rule 18 (control_structures -> control_structures_if_else .)
    BOOL            reduce using rule 18 (control_structures -> control_structures_if_else .)
    IF              reduce using rule 18 (control_structures -> control_structures_if_else .)
    FOR             reduce using rule 18 (control_structures -> control_structures_if_else .)
    $end            reduce using rule 18 (control_structures -> control_structures_if_else .)
    RBRACKET        reduce using rule 18 (control_structures -> control_structures_if_else .)


state 25

    (19) control_structures -> control_structures_for .

    COMMENT_MULTI   reduce using rule 19 (control_structures -> control_structures_for .)
    COMMENT_SINGLE  reduce using rule 19 (control_structures -> control_structures_for .)
    SEMICOLON       reduce using rule 19 (control_structures -> control_structures_for .)
    PRINT           reduce using rule 19 (control_structures -> control_structures_for .)
    STRING          reduce using rule 19 (control_structures -> control_structures_for .)
    VAR             reduce using rule 19 (control_structures -> control_structures_for .)
    FINAL           reduce using rule 19 (control_structures -> control_structures_for .)
    ID              reduce using rule 19 (control_structures -> control_structures_for .)
    VOID            reduce using rule 19 (control_structures -> control_structures_for .)
    LIST            reduce using rule 19 (control_structures -> control_structures_for .)
    DYNAMIC         reduce using rule 19 (control_structures -> control_structures_for .)
    MAP             reduce using rule 19 (control_structures -> control_structures_for .)
    WHILE           reduce using rule 19 (control_structures -> control_structures_for .)
    INT             reduce using rule 19 (control_structures -> control_structures_for .)
    DOUBLE          reduce using rule 19 (control_structures -> control_structures_for .)
    BOOL            reduce using rule 19 (control_structures -> control_structures_for .)
    IF              reduce using rule 19 (control_structures -> control_structures_for .)
    FOR             reduce using rule 19 (control_structures -> control_structures_for .)
    $end            reduce using rule 19 (control_structures -> control_structures_for .)
    RBRACKET        reduce using rule 19 (control_structures -> control_structures_for .)


state 26

    (20) control_structures -> control_structures_while .

    COMMENT_MULTI   reduce using rule 20 (control_structures -> control_structures_while .)
    COMMENT_SINGLE  reduce using rule 20 (control_structures -> control_structures_while .)
    SEMICOLON       reduce using rule 20 (control_structures -> control_structures_while .)
    PRINT           reduce using rule 20 (control_structures -> control_structures_while .)
    STRING          reduce using rule 20 (control_structures -> control_structures_while .)
    VAR             reduce using rule 20 (control_structures -> control_structures_while .)
    FINAL           reduce using rule 20 (control_structures -> control_structures_while .)
    ID              reduce using rule 20 (control_structures -> control_structures_while .)
    VOID            reduce using rule 20 (control_structures -> control_structures_while .)
    LIST            reduce using rule 20 (control_structures -> control_structures_while .)
    DYNAMIC         reduce using rule 20 (control_structures -> control_structures_while .)
    MAP             reduce using rule 20 (control_structures -> control_structures_while .)
    WHILE           reduce using rule 20 (control_structures -> control_structures_while .)
    INT             reduce using rule 20 (control_structures -> control_structures_while .)
    DOUBLE          reduce using rule 20 (control_structures -> control_structures_while .)
    BOOL            reduce using rule 20 (control_structures -> control_structures_while .)
    IF              reduce using rule 20 (control_structures -> control_structures_while .)
    FOR             reduce using rule 20 (control_structures -> control_structures_while .)
    $end            reduce using rule 20 (control_structures -> control_structures_while .)
    RBRACKET        reduce using rule 20 (control_structures -> control_structures_while .)


state 27

    (31) function -> type . ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> type . ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (124) function -> type . ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (37) variable_definition -> type . ID ASSIGN expression SEMICOLON

    ID              shift and go to state 53


state 28

    (32) function -> VOID . ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (34) function -> VOID . ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> VOID . ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> VOID . ID LPAREN parameter_list RPAREN LBRACKET RBRACKET

    ID              shift and go to state 54


state 29

    (82) list_definition -> LIST . LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (93) type -> LIST .

    LESS            shift and go to state 55
    ID              reduce using rule 93 (type -> LIST .)


state 30

    (38) variable_definition -> DYNAMIC . ID ASSIGN expression SEMICOLON

    ID              shift and go to state 56


state 31

    (127) map_declaration -> MAP . LESS key_type COMMA type GREATER ID ASSIGN

    LESS            shift and go to state 57


state 32

    (58) control_structures_if_else -> if_block .
    (59) control_structures_if_else -> if_block . else_if_blocks
    (60) control_structures_if_else -> if_block . else_if_blocks else_block
    (61) control_structures_if_else -> if_block . else_block
    (63) else_if_blocks -> . ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (64) else_if_blocks -> . else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (65) else_block -> . ELSE LBRACKET statement_list RBRACKET

    COMMENT_MULTI   reduce using rule 58 (control_structures_if_else -> if_block .)
    COMMENT_SINGLE  reduce using rule 58 (control_structures_if_else -> if_block .)
    SEMICOLON       reduce using rule 58 (control_structures_if_else -> if_block .)
    PRINT           reduce using rule 58 (control_structures_if_else -> if_block .)
    STRING          reduce using rule 58 (control_structures_if_else -> if_block .)
    VAR             reduce using rule 58 (control_structures_if_else -> if_block .)
    FINAL           reduce using rule 58 (control_structures_if_else -> if_block .)
    ID              reduce using rule 58 (control_structures_if_else -> if_block .)
    VOID            reduce using rule 58 (control_structures_if_else -> if_block .)
    LIST            reduce using rule 58 (control_structures_if_else -> if_block .)
    DYNAMIC         reduce using rule 58 (control_structures_if_else -> if_block .)
    MAP             reduce using rule 58 (control_structures_if_else -> if_block .)
    WHILE           reduce using rule 58 (control_structures_if_else -> if_block .)
    INT             reduce using rule 58 (control_structures_if_else -> if_block .)
    DOUBLE          reduce using rule 58 (control_structures_if_else -> if_block .)
    BOOL            reduce using rule 58 (control_structures_if_else -> if_block .)
    IF              reduce using rule 58 (control_structures_if_else -> if_block .)
    FOR             reduce using rule 58 (control_structures_if_else -> if_block .)
    $end            reduce using rule 58 (control_structures_if_else -> if_block .)
    RBRACKET        reduce using rule 58 (control_structures_if_else -> if_block .)
    ELSE            shift and go to state 60

    else_if_blocks                 shift and go to state 58
    else_block                     shift and go to state 59

state 33

    (118) control_structures_for -> for_classic .

    COMMENT_MULTI   reduce using rule 118 (control_structures_for -> for_classic .)
    COMMENT_SINGLE  reduce using rule 118 (control_structures_for -> for_classic .)
    SEMICOLON       reduce using rule 118 (control_structures_for -> for_classic .)
    PRINT           reduce using rule 118 (control_structures_for -> for_classic .)
    STRING          reduce using rule 118 (control_structures_for -> for_classic .)
    VAR             reduce using rule 118 (control_structures_for -> for_classic .)
    FINAL           reduce using rule 118 (control_structures_for -> for_classic .)
    ID              reduce using rule 118 (control_structures_for -> for_classic .)
    VOID            reduce using rule 118 (control_structures_for -> for_classic .)
    LIST            reduce using rule 118 (control_structures_for -> for_classic .)
    DYNAMIC         reduce using rule 118 (control_structures_for -> for_classic .)
    MAP             reduce using rule 118 (control_structures_for -> for_classic .)
    WHILE           reduce using rule 118 (control_structures_for -> for_classic .)
    INT             reduce using rule 118 (control_structures_for -> for_classic .)
    DOUBLE          reduce using rule 118 (control_structures_for -> for_classic .)
    BOOL            reduce using rule 118 (control_structures_for -> for_classic .)
    IF              reduce using rule 118 (control_structures_for -> for_classic .)
    FOR             reduce using rule 118 (control_structures_for -> for_classic .)
    $end            reduce using rule 118 (control_structures_for -> for_classic .)
    RBRACKET        reduce using rule 118 (control_structures_for -> for_classic .)


state 34

    (119) control_structures_for -> for_in .

    COMMENT_MULTI   reduce using rule 119 (control_structures_for -> for_in .)
    COMMENT_SINGLE  reduce using rule 119 (control_structures_for -> for_in .)
    SEMICOLON       reduce using rule 119 (control_structures_for -> for_in .)
    PRINT           reduce using rule 119 (control_structures_for -> for_in .)
    STRING          reduce using rule 119 (control_structures_for -> for_in .)
    VAR             reduce using rule 119 (control_structures_for -> for_in .)
    FINAL           reduce using rule 119 (control_structures_for -> for_in .)
    ID              reduce using rule 119 (control_structures_for -> for_in .)
    VOID            reduce using rule 119 (control_structures_for -> for_in .)
    LIST            reduce using rule 119 (control_structures_for -> for_in .)
    DYNAMIC         reduce using rule 119 (control_structures_for -> for_in .)
    MAP             reduce using rule 119 (control_structures_for -> for_in .)
    WHILE           reduce using rule 119 (control_structures_for -> for_in .)
    INT             reduce using rule 119 (control_structures_for -> for_in .)
    DOUBLE          reduce using rule 119 (control_structures_for -> for_in .)
    BOOL            reduce using rule 119 (control_structures_for -> for_in .)
    IF              reduce using rule 119 (control_structures_for -> for_in .)
    FOR             reduce using rule 119 (control_structures_for -> for_in .)
    $end            reduce using rule 119 (control_structures_for -> for_in .)
    RBRACKET        reduce using rule 119 (control_structures_for -> for_in .)


state 35

    (120) control_structures_for -> for_each .

    COMMENT_MULTI   reduce using rule 120 (control_structures_for -> for_each .)
    COMMENT_SINGLE  reduce using rule 120 (control_structures_for -> for_each .)
    SEMICOLON       reduce using rule 120 (control_structures_for -> for_each .)
    PRINT           reduce using rule 120 (control_structures_for -> for_each .)
    STRING          reduce using rule 120 (control_structures_for -> for_each .)
    VAR             reduce using rule 120 (control_structures_for -> for_each .)
    FINAL           reduce using rule 120 (control_structures_for -> for_each .)
    ID              reduce using rule 120 (control_structures_for -> for_each .)
    VOID            reduce using rule 120 (control_structures_for -> for_each .)
    LIST            reduce using rule 120 (control_structures_for -> for_each .)
    DYNAMIC         reduce using rule 120 (control_structures_for -> for_each .)
    MAP             reduce using rule 120 (control_structures_for -> for_each .)
    WHILE           reduce using rule 120 (control_structures_for -> for_each .)
    INT             reduce using rule 120 (control_structures_for -> for_each .)
    DOUBLE          reduce using rule 120 (control_structures_for -> for_each .)
    BOOL            reduce using rule 120 (control_structures_for -> for_each .)
    IF              reduce using rule 120 (control_structures_for -> for_each .)
    FOR             reduce using rule 120 (control_structures_for -> for_each .)
    $end            reduce using rule 120 (control_structures_for -> for_each .)
    RBRACKET        reduce using rule 120 (control_structures_for -> for_each .)


state 36

    (125) control_structures_while -> WHILE . LPAREN conditions LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 61


state 37

    (89) type -> INT .

    ID              reduce using rule 89 (type -> INT .)
    GREATER         reduce using rule 89 (type -> INT .)


state 38

    (90) type -> DOUBLE .

    ID              reduce using rule 90 (type -> DOUBLE .)
    GREATER         reduce using rule 90 (type -> DOUBLE .)


state 39

    (92) type -> BOOL .

    ID              reduce using rule 92 (type -> BOOL .)
    GREATER         reduce using rule 92 (type -> BOOL .)


state 40

    (62) if_block -> IF . LPAREN conditions RPAREN LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 62


state 41

    (111) for_classic -> FOR . LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> FOR . LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> FOR . LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 63


state 42

    (3) statement_list -> statement_list statement .

    COMMENT_MULTI   reduce using rule 3 (statement_list -> statement_list statement .)
    COMMENT_SINGLE  reduce using rule 3 (statement_list -> statement_list statement .)
    SEMICOLON       reduce using rule 3 (statement_list -> statement_list statement .)
    PRINT           reduce using rule 3 (statement_list -> statement_list statement .)
    STRING          reduce using rule 3 (statement_list -> statement_list statement .)
    VAR             reduce using rule 3 (statement_list -> statement_list statement .)
    FINAL           reduce using rule 3 (statement_list -> statement_list statement .)
    ID              reduce using rule 3 (statement_list -> statement_list statement .)
    VOID            reduce using rule 3 (statement_list -> statement_list statement .)
    LIST            reduce using rule 3 (statement_list -> statement_list statement .)
    DYNAMIC         reduce using rule 3 (statement_list -> statement_list statement .)
    MAP             reduce using rule 3 (statement_list -> statement_list statement .)
    WHILE           reduce using rule 3 (statement_list -> statement_list statement .)
    INT             reduce using rule 3 (statement_list -> statement_list statement .)
    DOUBLE          reduce using rule 3 (statement_list -> statement_list statement .)
    BOOL            reduce using rule 3 (statement_list -> statement_list statement .)
    IF              reduce using rule 3 (statement_list -> statement_list statement .)
    FOR             reduce using rule 3 (statement_list -> statement_list statement .)
    $end            reduce using rule 3 (statement_list -> statement_list statement .)
    RBRACKET        reduce using rule 3 (statement_list -> statement_list statement .)


state 43

    (40) print -> PRINT LPAREN . RPAREN SEMICOLON
    (41) print -> PRINT LPAREN . print_options RPAREN SEMICOLON
    (42) print_options -> . interpolated_string
    (43) print_options -> . expression
    (44) print_options -> . length
    (45) print_options -> . call_function
    (85) interpolated_string -> . string_part
    (86) interpolated_string -> . string_part PLUS interpolated_string
    (46) expression -> . operations
    (56) expression -> . conditions
    (57) expression -> . value
    (27) length -> . call_list DOT LENGTH
    (28) length -> . TEXT DOT LENGTH
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (87) string_part -> . TEXT
    (88) string_part -> . TEXT PLUS value
    (47) operations -> . operation
    (48) operations -> . operation operand operations
    (66) conditions -> . condition
    (67) conditions -> . condition AND conditions
    (68) conditions -> . condition OR conditions
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE
    (81) call_list -> . LSBRACKET value_list RSBRACKET
    (49) operation -> . operand operator operand
    (69) condition -> . value comparator value
    (70) condition -> . NOT condition
    (50) operand -> . NUMBER
    (51) operand -> . DOUBLE

    RPAREN          shift and go to state 64
    TEXT            shift and go to state 75
    ID              shift and go to state 76
    NUMBER          shift and go to state 80
    NDOUBLE         shift and go to state 81
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83
    LSBRACKET       shift and go to state 84
    NOT             shift and go to state 85
    DOUBLE          shift and go to state 86

    print_options                  shift and go to state 65
    interpolated_string            shift and go to state 66
    expression                     shift and go to state 67
    length                         shift and go to state 68
    call_function                  shift and go to state 69
    string_part                    shift and go to state 70
    operations                     shift and go to state 71
    conditions                     shift and go to state 72
    value                          shift and go to state 73
    call_list                      shift and go to state 74
    operation                      shift and go to state 77
    operand                        shift and go to state 78
    condition                      shift and go to state 79

state 44

    (25) data_input -> STRING ID . ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    ASSIGN          shift and go to state 87


state 45

    (26) data_input -> STRING QUESTION . ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    ID              shift and go to state 88


state 46

    (123) constructor -> ID LPAREN . constructor_parenthesis_content RPAREN SEMICOLON
    (23) call_function -> ID LPAREN . argument_list RPAREN
    (24) call_function -> ID LPAREN . RPAREN
    (121) constructor_parenthesis_content -> . THIS DOT ID
    (122) constructor_parenthesis_content -> . THIS DOT ID COMMA constructor_parenthesis_content
    (29) argument_list -> . expression
    (30) argument_list -> . argument_list COMMA expression
    (46) expression -> . operations
    (56) expression -> . conditions
    (57) expression -> . value
    (47) operations -> . operation
    (48) operations -> . operation operand operations
    (66) conditions -> . condition
    (67) conditions -> . condition AND conditions
    (68) conditions -> . condition OR conditions
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE
    (49) operation -> . operand operator operand
    (69) condition -> . value comparator value
    (70) condition -> . NOT condition
    (50) operand -> . NUMBER
    (51) operand -> . DOUBLE

    RPAREN          shift and go to state 91
    THIS            shift and go to state 93
    NUMBER          shift and go to state 80
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83
    NOT             shift and go to state 85
    DOUBLE          shift and go to state 86

    constructor_parenthesis_content shift and go to state 90
    argument_list                  shift and go to state 92
    expression                     shift and go to state 94
    operations                     shift and go to state 71
    conditions                     shift and go to state 72
    value                          shift and go to state 73
    operation                      shift and go to state 77
    operand                        shift and go to state 78
    condition                      shift and go to state 79

state 47

    (21) variable_usage -> ID SEMICOLON .

    COMMENT_MULTI   reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    SEMICOLON       reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    PRINT           reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    STRING          reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    VAR             reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    FINAL           reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    ID              reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    VOID            reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    LIST            reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    DYNAMIC         reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    MAP             reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    WHILE           reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    INT             reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    DOUBLE          reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    BOOL            reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    IF              reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    FOR             reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    $end            reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    RBRACKET        reduce using rule 21 (variable_usage -> ID SEMICOLON .)


state 48

    (22) variable_usage -> ID ASSIGN . value SEMICOLON
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83

    value                          shift and go to state 96

state 49

    (100) set -> VAR ID . ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> VAR ID . ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (39) variable_definition -> VAR ID . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 98


state 50

    (102) set -> FINAL ID . ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON

    ASSIGN          shift and go to state 99


state 51

    (126) map -> map_declaration map_assignment .

    COMMENT_MULTI   reduce using rule 126 (map -> map_declaration map_assignment .)
    COMMENT_SINGLE  reduce using rule 126 (map -> map_declaration map_assignment .)
    SEMICOLON       reduce using rule 126 (map -> map_declaration map_assignment .)
    PRINT           reduce using rule 126 (map -> map_declaration map_assignment .)
    STRING          reduce using rule 126 (map -> map_declaration map_assignment .)
    VAR             reduce using rule 126 (map -> map_declaration map_assignment .)
    FINAL           reduce using rule 126 (map -> map_declaration map_assignment .)
    ID              reduce using rule 126 (map -> map_declaration map_assignment .)
    VOID            reduce using rule 126 (map -> map_declaration map_assignment .)
    LIST            reduce using rule 126 (map -> map_declaration map_assignment .)
    DYNAMIC         reduce using rule 126 (map -> map_declaration map_assignment .)
    MAP             reduce using rule 126 (map -> map_declaration map_assignment .)
    WHILE           reduce using rule 126 (map -> map_declaration map_assignment .)
    INT             reduce using rule 126 (map -> map_declaration map_assignment .)
    DOUBLE          reduce using rule 126 (map -> map_declaration map_assignment .)
    BOOL            reduce using rule 126 (map -> map_declaration map_assignment .)
    IF              reduce using rule 126 (map -> map_declaration map_assignment .)
    FOR             reduce using rule 126 (map -> map_declaration map_assignment .)
    $end            reduce using rule 126 (map -> map_declaration map_assignment .)
    RBRACKET        reduce using rule 126 (map -> map_declaration map_assignment .)


state 52

    (128) map_assignment -> LBRACKET . map_contents RBRACKET
    (129) map_contents -> . map_content
    (130) map_contents -> . map_content COMMA map_contents
    (131) map_content -> . key_value COLON value
    (132) key_value -> . TEXT

    TEXT            shift and go to state 103

    map_contents                   shift and go to state 100
    map_content                    shift and go to state 101
    key_value                      shift and go to state 102

state 53

    (31) function -> type ID . LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> type ID . LPAREN RPAREN LBRACKET statement_list RBRACKET
    (124) function -> type ID . LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (37) variable_definition -> type ID . ASSIGN expression SEMICOLON

    LPAREN          shift and go to state 104
    ASSIGN          shift and go to state 105


state 54

    (32) function -> VOID ID . LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (34) function -> VOID ID . LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> VOID ID . LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> VOID ID . LPAREN parameter_list RPAREN LBRACKET RBRACKET

    LPAREN          shift and go to state 106


state 55

    (82) list_definition -> LIST LESS . type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST

    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    STRING          shift and go to state 109
    BOOL            shift and go to state 39
    LIST            shift and go to state 107

    type                           shift and go to state 108

state 56

    (38) variable_definition -> DYNAMIC ID . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 110


state 57

    (127) map_declaration -> MAP LESS . key_type COMMA type GREATER ID ASSIGN
    (133) key_type -> . STRING

    STRING          shift and go to state 112

    key_type                       shift and go to state 111

state 58

    (59) control_structures_if_else -> if_block else_if_blocks .
    (60) control_structures_if_else -> if_block else_if_blocks . else_block
    (64) else_if_blocks -> else_if_blocks . ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (65) else_block -> . ELSE LBRACKET statement_list RBRACKET

    COMMENT_MULTI   reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    COMMENT_SINGLE  reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    SEMICOLON       reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    PRINT           reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    STRING          reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    VAR             reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    FINAL           reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    ID              reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    VOID            reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    LIST            reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    DYNAMIC         reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    MAP             reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    WHILE           reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    INT             reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    DOUBLE          reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    BOOL            reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    IF              reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    FOR             reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    $end            reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    RBRACKET        reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    ELSE            shift and go to state 114

    else_block                     shift and go to state 113

state 59

    (61) control_structures_if_else -> if_block else_block .

    COMMENT_MULTI   reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    COMMENT_SINGLE  reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    SEMICOLON       reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    PRINT           reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    STRING          reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    VAR             reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    FINAL           reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    ID              reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    VOID            reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    LIST            reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    DYNAMIC         reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    MAP             reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    WHILE           reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    INT             reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    DOUBLE          reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    BOOL            reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    IF              reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    FOR             reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    $end            reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    RBRACKET        reduce using rule 61 (control_structures_if_else -> if_block else_block .)


state 60

    (63) else_if_blocks -> ELSE . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (65) else_block -> ELSE . LBRACKET statement_list RBRACKET

    IF              shift and go to state 115
    LBRACKET        shift and go to state 116


state 61

    (125) control_structures_while -> WHILE LPAREN . conditions LBRACKET statement_list RBRACKET
    (66) conditions -> . condition
    (67) conditions -> . condition AND conditions
    (68) conditions -> . condition OR conditions
    (69) condition -> . value comparator value
    (70) condition -> . NOT condition
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NOT             shift and go to state 85
    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83

    conditions                     shift and go to state 117
    condition                      shift and go to state 79
    value                          shift and go to state 118

state 62

    (62) if_block -> IF LPAREN . conditions RPAREN LBRACKET statement_list RBRACKET
    (66) conditions -> . condition
    (67) conditions -> . condition AND conditions
    (68) conditions -> . condition OR conditions
    (69) condition -> . value comparator value
    (70) condition -> . NOT condition
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NOT             shift and go to state 85
    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83

    conditions                     shift and go to state 119
    condition                      shift and go to state 79
    value                          shift and go to state 118

state 63

    (111) for_classic -> FOR LPAREN . for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> FOR LPAREN . for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> FOR LPAREN . for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (110) for_classic_parenthesis_content -> . for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON for_classic_changes
    (112) for_in_parenthesis_content -> . FINAL ID IN ID
    (116) for_each_parenthesis_content -> . FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID
    (103) for_classic_initialization -> . INT ID ASSIGN NUMBER
    (104) for_classic_initialization -> . DOUBLE ID ASSIGN NDOUBLE

    FINAL           shift and go to state 124
    INT             shift and go to state 125
    DOUBLE          shift and go to state 126

    for_classic_parenthesis_content shift and go to state 120
    for_in_parenthesis_content     shift and go to state 121
    for_each_parenthesis_content   shift and go to state 122
    for_classic_initialization     shift and go to state 123

state 64

    (40) print -> PRINT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 127


state 65

    (41) print -> PRINT LPAREN print_options . RPAREN SEMICOLON

    RPAREN          shift and go to state 128


state 66

    (42) print_options -> interpolated_string .

    RPAREN          reduce using rule 42 (print_options -> interpolated_string .)


state 67

    (43) print_options -> expression .

    RPAREN          reduce using rule 43 (print_options -> expression .)


state 68

    (44) print_options -> length .

    RPAREN          reduce using rule 44 (print_options -> length .)


state 69

    (45) print_options -> call_function .

    RPAREN          reduce using rule 45 (print_options -> call_function .)


state 70

    (85) interpolated_string -> string_part .
    (86) interpolated_string -> string_part . PLUS interpolated_string

    RPAREN          reduce using rule 85 (interpolated_string -> string_part .)
    PLUS            shift and go to state 129


state 71

    (46) expression -> operations .

    RPAREN          reduce using rule 46 (expression -> operations .)
    COMMA           reduce using rule 46 (expression -> operations .)
    SEMICOLON       reduce using rule 46 (expression -> operations .)
    COMMENT_MULTI   reduce using rule 46 (expression -> operations .)
    COMMENT_SINGLE  reduce using rule 46 (expression -> operations .)
    PRINT           reduce using rule 46 (expression -> operations .)
    STRING          reduce using rule 46 (expression -> operations .)
    VAR             reduce using rule 46 (expression -> operations .)
    FINAL           reduce using rule 46 (expression -> operations .)
    ID              reduce using rule 46 (expression -> operations .)
    VOID            reduce using rule 46 (expression -> operations .)
    LIST            reduce using rule 46 (expression -> operations .)
    DYNAMIC         reduce using rule 46 (expression -> operations .)
    MAP             reduce using rule 46 (expression -> operations .)
    WHILE           reduce using rule 46 (expression -> operations .)
    INT             reduce using rule 46 (expression -> operations .)
    DOUBLE          reduce using rule 46 (expression -> operations .)
    BOOL            reduce using rule 46 (expression -> operations .)
    IF              reduce using rule 46 (expression -> operations .)
    FOR             reduce using rule 46 (expression -> operations .)
    $end            reduce using rule 46 (expression -> operations .)
    RBRACKET        reduce using rule 46 (expression -> operations .)


state 72

    (56) expression -> conditions .

    RPAREN          reduce using rule 56 (expression -> conditions .)
    COMMA           reduce using rule 56 (expression -> conditions .)
    SEMICOLON       reduce using rule 56 (expression -> conditions .)
    COMMENT_MULTI   reduce using rule 56 (expression -> conditions .)
    COMMENT_SINGLE  reduce using rule 56 (expression -> conditions .)
    PRINT           reduce using rule 56 (expression -> conditions .)
    STRING          reduce using rule 56 (expression -> conditions .)
    VAR             reduce using rule 56 (expression -> conditions .)
    FINAL           reduce using rule 56 (expression -> conditions .)
    ID              reduce using rule 56 (expression -> conditions .)
    VOID            reduce using rule 56 (expression -> conditions .)
    LIST            reduce using rule 56 (expression -> conditions .)
    DYNAMIC         reduce using rule 56 (expression -> conditions .)
    MAP             reduce using rule 56 (expression -> conditions .)
    WHILE           reduce using rule 56 (expression -> conditions .)
    INT             reduce using rule 56 (expression -> conditions .)
    DOUBLE          reduce using rule 56 (expression -> conditions .)
    BOOL            reduce using rule 56 (expression -> conditions .)
    IF              reduce using rule 56 (expression -> conditions .)
    FOR             reduce using rule 56 (expression -> conditions .)
    $end            reduce using rule 56 (expression -> conditions .)
    RBRACKET        reduce using rule 56 (expression -> conditions .)


state 73

    (57) expression -> value .
    (69) condition -> value . comparator value
    (71) comparator -> . GREATER
    (72) comparator -> . LESS
    (73) comparator -> . EQUALS
    (74) comparator -> . GREATER_EQUAL
    (75) comparator -> . LESS_EQUAL
    (76) comparator -> . NOT_EQUALS

    RPAREN          reduce using rule 57 (expression -> value .)
    COMMA           reduce using rule 57 (expression -> value .)
    SEMICOLON       reduce using rule 57 (expression -> value .)
    COMMENT_MULTI   reduce using rule 57 (expression -> value .)
    COMMENT_SINGLE  reduce using rule 57 (expression -> value .)
    PRINT           reduce using rule 57 (expression -> value .)
    STRING          reduce using rule 57 (expression -> value .)
    VAR             reduce using rule 57 (expression -> value .)
    FINAL           reduce using rule 57 (expression -> value .)
    ID              reduce using rule 57 (expression -> value .)
    VOID            reduce using rule 57 (expression -> value .)
    LIST            reduce using rule 57 (expression -> value .)
    DYNAMIC         reduce using rule 57 (expression -> value .)
    MAP             reduce using rule 57 (expression -> value .)
    WHILE           reduce using rule 57 (expression -> value .)
    INT             reduce using rule 57 (expression -> value .)
    DOUBLE          reduce using rule 57 (expression -> value .)
    BOOL            reduce using rule 57 (expression -> value .)
    IF              reduce using rule 57 (expression -> value .)
    FOR             reduce using rule 57 (expression -> value .)
    $end            reduce using rule 57 (expression -> value .)
    RBRACKET        reduce using rule 57 (expression -> value .)
    GREATER         shift and go to state 131
    LESS            shift and go to state 132
    EQUALS          shift and go to state 133
    GREATER_EQUAL   shift and go to state 134
    LESS_EQUAL      shift and go to state 135
    NOT_EQUALS      shift and go to state 136

    comparator                     shift and go to state 130

state 74

    (27) length -> call_list . DOT LENGTH

    DOT             shift and go to state 137


state 75

    (28) length -> TEXT . DOT LENGTH
    (87) string_part -> TEXT .
    (88) string_part -> TEXT . PLUS value
    (96) value -> TEXT .

  ! shift/reduce conflict for PLUS resolved as shift
  ! reduce/reduce conflict for RPAREN resolved using rule 87 (string_part -> TEXT .)
    DOT             shift and go to state 138
    RPAREN          reduce using rule 87 (string_part -> TEXT .)
    PLUS            shift and go to state 139
    GREATER         reduce using rule 96 (value -> TEXT .)
    LESS            reduce using rule 96 (value -> TEXT .)
    EQUALS          reduce using rule 96 (value -> TEXT .)
    GREATER_EQUAL   reduce using rule 96 (value -> TEXT .)
    LESS_EQUAL      reduce using rule 96 (value -> TEXT .)
    NOT_EQUALS      reduce using rule 96 (value -> TEXT .)

  ! PLUS            [ reduce using rule 87 (string_part -> TEXT .) ]
  ! RPAREN          [ reduce using rule 96 (value -> TEXT .) ]


state 76

    (23) call_function -> ID . LPAREN argument_list RPAREN
    (24) call_function -> ID . LPAREN RPAREN
    (97) value -> ID .

    LPAREN          shift and go to state 140
    GREATER         reduce using rule 97 (value -> ID .)
    LESS            reduce using rule 97 (value -> ID .)
    EQUALS          reduce using rule 97 (value -> ID .)
    GREATER_EQUAL   reduce using rule 97 (value -> ID .)
    LESS_EQUAL      reduce using rule 97 (value -> ID .)
    NOT_EQUALS      reduce using rule 97 (value -> ID .)
    RPAREN          reduce using rule 97 (value -> ID .)


state 77

    (47) operations -> operation .
    (48) operations -> operation . operand operations
    (50) operand -> . NUMBER
    (51) operand -> . DOUBLE

  ! shift/reduce conflict for DOUBLE resolved as shift
    RPAREN          reduce using rule 47 (operations -> operation .)
    COMMA           reduce using rule 47 (operations -> operation .)
    SEMICOLON       reduce using rule 47 (operations -> operation .)
    COMMENT_MULTI   reduce using rule 47 (operations -> operation .)
    COMMENT_SINGLE  reduce using rule 47 (operations -> operation .)
    PRINT           reduce using rule 47 (operations -> operation .)
    STRING          reduce using rule 47 (operations -> operation .)
    VAR             reduce using rule 47 (operations -> operation .)
    FINAL           reduce using rule 47 (operations -> operation .)
    ID              reduce using rule 47 (operations -> operation .)
    VOID            reduce using rule 47 (operations -> operation .)
    LIST            reduce using rule 47 (operations -> operation .)
    DYNAMIC         reduce using rule 47 (operations -> operation .)
    MAP             reduce using rule 47 (operations -> operation .)
    WHILE           reduce using rule 47 (operations -> operation .)
    INT             reduce using rule 47 (operations -> operation .)
    BOOL            reduce using rule 47 (operations -> operation .)
    IF              reduce using rule 47 (operations -> operation .)
    FOR             reduce using rule 47 (operations -> operation .)
    $end            reduce using rule 47 (operations -> operation .)
    RBRACKET        reduce using rule 47 (operations -> operation .)
    NUMBER          shift and go to state 142
    DOUBLE          shift and go to state 86

  ! DOUBLE          [ reduce using rule 47 (operations -> operation .) ]

    operand                        shift and go to state 141

state 78

    (49) operation -> operand . operator operand
    (52) operator -> . PLUS
    (53) operator -> . MINUS
    (54) operator -> . TIMES
    (55) operator -> . DIVIDE

    PLUS            shift and go to state 144
    MINUS           shift and go to state 145
    TIMES           shift and go to state 146
    DIVIDE          shift and go to state 147

    operator                       shift and go to state 143

state 79

    (66) conditions -> condition .
    (67) conditions -> condition . AND conditions
    (68) conditions -> condition . OR conditions

    RPAREN          reduce using rule 66 (conditions -> condition .)
    COMMA           reduce using rule 66 (conditions -> condition .)
    LBRACKET        reduce using rule 66 (conditions -> condition .)
    SEMICOLON       reduce using rule 66 (conditions -> condition .)
    COMMENT_MULTI   reduce using rule 66 (conditions -> condition .)
    COMMENT_SINGLE  reduce using rule 66 (conditions -> condition .)
    PRINT           reduce using rule 66 (conditions -> condition .)
    STRING          reduce using rule 66 (conditions -> condition .)
    VAR             reduce using rule 66 (conditions -> condition .)
    FINAL           reduce using rule 66 (conditions -> condition .)
    ID              reduce using rule 66 (conditions -> condition .)
    VOID            reduce using rule 66 (conditions -> condition .)
    LIST            reduce using rule 66 (conditions -> condition .)
    DYNAMIC         reduce using rule 66 (conditions -> condition .)
    MAP             reduce using rule 66 (conditions -> condition .)
    WHILE           reduce using rule 66 (conditions -> condition .)
    INT             reduce using rule 66 (conditions -> condition .)
    DOUBLE          reduce using rule 66 (conditions -> condition .)
    BOOL            reduce using rule 66 (conditions -> condition .)
    IF              reduce using rule 66 (conditions -> condition .)
    FOR             reduce using rule 66 (conditions -> condition .)
    $end            reduce using rule 66 (conditions -> condition .)
    RBRACKET        reduce using rule 66 (conditions -> condition .)
    AND             shift and go to state 148
    OR              shift and go to state 149


state 80

    (94) value -> NUMBER .
    (50) operand -> NUMBER .

    GREATER         reduce using rule 94 (value -> NUMBER .)
    LESS            reduce using rule 94 (value -> NUMBER .)
    EQUALS          reduce using rule 94 (value -> NUMBER .)
    GREATER_EQUAL   reduce using rule 94 (value -> NUMBER .)
    LESS_EQUAL      reduce using rule 94 (value -> NUMBER .)
    NOT_EQUALS      reduce using rule 94 (value -> NUMBER .)
    RPAREN          reduce using rule 94 (value -> NUMBER .)
    COMMA           reduce using rule 94 (value -> NUMBER .)
    SEMICOLON       reduce using rule 94 (value -> NUMBER .)
    COMMENT_MULTI   reduce using rule 94 (value -> NUMBER .)
    COMMENT_SINGLE  reduce using rule 94 (value -> NUMBER .)
    PRINT           reduce using rule 94 (value -> NUMBER .)
    STRING          reduce using rule 94 (value -> NUMBER .)
    VAR             reduce using rule 94 (value -> NUMBER .)
    FINAL           reduce using rule 94 (value -> NUMBER .)
    ID              reduce using rule 94 (value -> NUMBER .)
    VOID            reduce using rule 94 (value -> NUMBER .)
    LIST            reduce using rule 94 (value -> NUMBER .)
    DYNAMIC         reduce using rule 94 (value -> NUMBER .)
    MAP             reduce using rule 94 (value -> NUMBER .)
    WHILE           reduce using rule 94 (value -> NUMBER .)
    INT             reduce using rule 94 (value -> NUMBER .)
    DOUBLE          reduce using rule 94 (value -> NUMBER .)
    BOOL            reduce using rule 94 (value -> NUMBER .)
    IF              reduce using rule 94 (value -> NUMBER .)
    FOR             reduce using rule 94 (value -> NUMBER .)
    $end            reduce using rule 94 (value -> NUMBER .)
    RBRACKET        reduce using rule 94 (value -> NUMBER .)
    PLUS            reduce using rule 50 (operand -> NUMBER .)
    MINUS           reduce using rule 50 (operand -> NUMBER .)
    TIMES           reduce using rule 50 (operand -> NUMBER .)
    DIVIDE          reduce using rule 50 (operand -> NUMBER .)


state 81

    (95) value -> NDOUBLE .

    GREATER         reduce using rule 95 (value -> NDOUBLE .)
    LESS            reduce using rule 95 (value -> NDOUBLE .)
    EQUALS          reduce using rule 95 (value -> NDOUBLE .)
    GREATER_EQUAL   reduce using rule 95 (value -> NDOUBLE .)
    LESS_EQUAL      reduce using rule 95 (value -> NDOUBLE .)
    NOT_EQUALS      reduce using rule 95 (value -> NDOUBLE .)
    RPAREN          reduce using rule 95 (value -> NDOUBLE .)
    COMMA           reduce using rule 95 (value -> NDOUBLE .)
    SEMICOLON       reduce using rule 95 (value -> NDOUBLE .)
    RSBRACKET       reduce using rule 95 (value -> NDOUBLE .)
    AND             reduce using rule 95 (value -> NDOUBLE .)
    OR              reduce using rule 95 (value -> NDOUBLE .)
    LBRACKET        reduce using rule 95 (value -> NDOUBLE .)
    COMMENT_MULTI   reduce using rule 95 (value -> NDOUBLE .)
    COMMENT_SINGLE  reduce using rule 95 (value -> NDOUBLE .)
    PRINT           reduce using rule 95 (value -> NDOUBLE .)
    STRING          reduce using rule 95 (value -> NDOUBLE .)
    VAR             reduce using rule 95 (value -> NDOUBLE .)
    FINAL           reduce using rule 95 (value -> NDOUBLE .)
    ID              reduce using rule 95 (value -> NDOUBLE .)
    VOID            reduce using rule 95 (value -> NDOUBLE .)
    LIST            reduce using rule 95 (value -> NDOUBLE .)
    DYNAMIC         reduce using rule 95 (value -> NDOUBLE .)
    MAP             reduce using rule 95 (value -> NDOUBLE .)
    WHILE           reduce using rule 95 (value -> NDOUBLE .)
    INT             reduce using rule 95 (value -> NDOUBLE .)
    DOUBLE          reduce using rule 95 (value -> NDOUBLE .)
    BOOL            reduce using rule 95 (value -> NDOUBLE .)
    IF              reduce using rule 95 (value -> NDOUBLE .)
    FOR             reduce using rule 95 (value -> NDOUBLE .)
    $end            reduce using rule 95 (value -> NDOUBLE .)
    RBRACKET        reduce using rule 95 (value -> NDOUBLE .)
    PLUS            reduce using rule 95 (value -> NDOUBLE .)


state 82

    (98) value -> TRUE .

    GREATER         reduce using rule 98 (value -> TRUE .)
    LESS            reduce using rule 98 (value -> TRUE .)
    EQUALS          reduce using rule 98 (value -> TRUE .)
    GREATER_EQUAL   reduce using rule 98 (value -> TRUE .)
    LESS_EQUAL      reduce using rule 98 (value -> TRUE .)
    NOT_EQUALS      reduce using rule 98 (value -> TRUE .)
    RPAREN          reduce using rule 98 (value -> TRUE .)
    COMMA           reduce using rule 98 (value -> TRUE .)
    SEMICOLON       reduce using rule 98 (value -> TRUE .)
    RSBRACKET       reduce using rule 98 (value -> TRUE .)
    AND             reduce using rule 98 (value -> TRUE .)
    OR              reduce using rule 98 (value -> TRUE .)
    LBRACKET        reduce using rule 98 (value -> TRUE .)
    COMMENT_MULTI   reduce using rule 98 (value -> TRUE .)
    COMMENT_SINGLE  reduce using rule 98 (value -> TRUE .)
    PRINT           reduce using rule 98 (value -> TRUE .)
    STRING          reduce using rule 98 (value -> TRUE .)
    VAR             reduce using rule 98 (value -> TRUE .)
    FINAL           reduce using rule 98 (value -> TRUE .)
    ID              reduce using rule 98 (value -> TRUE .)
    VOID            reduce using rule 98 (value -> TRUE .)
    LIST            reduce using rule 98 (value -> TRUE .)
    DYNAMIC         reduce using rule 98 (value -> TRUE .)
    MAP             reduce using rule 98 (value -> TRUE .)
    WHILE           reduce using rule 98 (value -> TRUE .)
    INT             reduce using rule 98 (value -> TRUE .)
    DOUBLE          reduce using rule 98 (value -> TRUE .)
    BOOL            reduce using rule 98 (value -> TRUE .)
    IF              reduce using rule 98 (value -> TRUE .)
    FOR             reduce using rule 98 (value -> TRUE .)
    $end            reduce using rule 98 (value -> TRUE .)
    RBRACKET        reduce using rule 98 (value -> TRUE .)
    PLUS            reduce using rule 98 (value -> TRUE .)


state 83

    (99) value -> FALSE .

    GREATER         reduce using rule 99 (value -> FALSE .)
    LESS            reduce using rule 99 (value -> FALSE .)
    EQUALS          reduce using rule 99 (value -> FALSE .)
    GREATER_EQUAL   reduce using rule 99 (value -> FALSE .)
    LESS_EQUAL      reduce using rule 99 (value -> FALSE .)
    NOT_EQUALS      reduce using rule 99 (value -> FALSE .)
    RPAREN          reduce using rule 99 (value -> FALSE .)
    COMMA           reduce using rule 99 (value -> FALSE .)
    SEMICOLON       reduce using rule 99 (value -> FALSE .)
    RSBRACKET       reduce using rule 99 (value -> FALSE .)
    AND             reduce using rule 99 (value -> FALSE .)
    OR              reduce using rule 99 (value -> FALSE .)
    LBRACKET        reduce using rule 99 (value -> FALSE .)
    COMMENT_MULTI   reduce using rule 99 (value -> FALSE .)
    COMMENT_SINGLE  reduce using rule 99 (value -> FALSE .)
    PRINT           reduce using rule 99 (value -> FALSE .)
    STRING          reduce using rule 99 (value -> FALSE .)
    VAR             reduce using rule 99 (value -> FALSE .)
    FINAL           reduce using rule 99 (value -> FALSE .)
    ID              reduce using rule 99 (value -> FALSE .)
    VOID            reduce using rule 99 (value -> FALSE .)
    LIST            reduce using rule 99 (value -> FALSE .)
    DYNAMIC         reduce using rule 99 (value -> FALSE .)
    MAP             reduce using rule 99 (value -> FALSE .)
    WHILE           reduce using rule 99 (value -> FALSE .)
    INT             reduce using rule 99 (value -> FALSE .)
    DOUBLE          reduce using rule 99 (value -> FALSE .)
    BOOL            reduce using rule 99 (value -> FALSE .)
    IF              reduce using rule 99 (value -> FALSE .)
    FOR             reduce using rule 99 (value -> FALSE .)
    $end            reduce using rule 99 (value -> FALSE .)
    RBRACKET        reduce using rule 99 (value -> FALSE .)
    PLUS            reduce using rule 99 (value -> FALSE .)


state 84

    (81) call_list -> LSBRACKET . value_list RSBRACKET
    (83) value_list -> . value
    (84) value_list -> . value COMMA value_list
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83

    value_list                     shift and go to state 150
    value                          shift and go to state 151

state 85

    (70) condition -> NOT . condition
    (69) condition -> . value comparator value
    (70) condition -> . NOT condition
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NOT             shift and go to state 85
    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83

    condition                      shift and go to state 152
    value                          shift and go to state 118

state 86

    (51) operand -> DOUBLE .

    PLUS            reduce using rule 51 (operand -> DOUBLE .)
    MINUS           reduce using rule 51 (operand -> DOUBLE .)
    TIMES           reduce using rule 51 (operand -> DOUBLE .)
    DIVIDE          reduce using rule 51 (operand -> DOUBLE .)
    NUMBER          reduce using rule 51 (operand -> DOUBLE .)
    DOUBLE          reduce using rule 51 (operand -> DOUBLE .)
    RPAREN          reduce using rule 51 (operand -> DOUBLE .)
    COMMA           reduce using rule 51 (operand -> DOUBLE .)
    SEMICOLON       reduce using rule 51 (operand -> DOUBLE .)
    COMMENT_MULTI   reduce using rule 51 (operand -> DOUBLE .)
    COMMENT_SINGLE  reduce using rule 51 (operand -> DOUBLE .)
    PRINT           reduce using rule 51 (operand -> DOUBLE .)
    STRING          reduce using rule 51 (operand -> DOUBLE .)
    VAR             reduce using rule 51 (operand -> DOUBLE .)
    FINAL           reduce using rule 51 (operand -> DOUBLE .)
    ID              reduce using rule 51 (operand -> DOUBLE .)
    VOID            reduce using rule 51 (operand -> DOUBLE .)
    LIST            reduce using rule 51 (operand -> DOUBLE .)
    DYNAMIC         reduce using rule 51 (operand -> DOUBLE .)
    MAP             reduce using rule 51 (operand -> DOUBLE .)
    WHILE           reduce using rule 51 (operand -> DOUBLE .)
    INT             reduce using rule 51 (operand -> DOUBLE .)
    BOOL            reduce using rule 51 (operand -> DOUBLE .)
    IF              reduce using rule 51 (operand -> DOUBLE .)
    FOR             reduce using rule 51 (operand -> DOUBLE .)
    $end            reduce using rule 51 (operand -> DOUBLE .)
    RBRACKET        reduce using rule 51 (operand -> DOUBLE .)


state 87

    (25) data_input -> STRING ID ASSIGN . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    STDIN           shift and go to state 153


state 88

    (26) data_input -> STRING QUESTION ID . ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    ASSIGN          shift and go to state 154


state 89

    (97) value -> ID .

    GREATER         reduce using rule 97 (value -> ID .)
    LESS            reduce using rule 97 (value -> ID .)
    EQUALS          reduce using rule 97 (value -> ID .)
    GREATER_EQUAL   reduce using rule 97 (value -> ID .)
    LESS_EQUAL      reduce using rule 97 (value -> ID .)
    NOT_EQUALS      reduce using rule 97 (value -> ID .)
    RPAREN          reduce using rule 97 (value -> ID .)
    COMMA           reduce using rule 97 (value -> ID .)
    SEMICOLON       reduce using rule 97 (value -> ID .)
    RSBRACKET       reduce using rule 97 (value -> ID .)
    AND             reduce using rule 97 (value -> ID .)
    OR              reduce using rule 97 (value -> ID .)
    LBRACKET        reduce using rule 97 (value -> ID .)
    COMMENT_MULTI   reduce using rule 97 (value -> ID .)
    COMMENT_SINGLE  reduce using rule 97 (value -> ID .)
    PRINT           reduce using rule 97 (value -> ID .)
    STRING          reduce using rule 97 (value -> ID .)
    VAR             reduce using rule 97 (value -> ID .)
    FINAL           reduce using rule 97 (value -> ID .)
    ID              reduce using rule 97 (value -> ID .)
    VOID            reduce using rule 97 (value -> ID .)
    LIST            reduce using rule 97 (value -> ID .)
    DYNAMIC         reduce using rule 97 (value -> ID .)
    MAP             reduce using rule 97 (value -> ID .)
    WHILE           reduce using rule 97 (value -> ID .)
    INT             reduce using rule 97 (value -> ID .)
    DOUBLE          reduce using rule 97 (value -> ID .)
    BOOL            reduce using rule 97 (value -> ID .)
    IF              reduce using rule 97 (value -> ID .)
    FOR             reduce using rule 97 (value -> ID .)
    $end            reduce using rule 97 (value -> ID .)
    RBRACKET        reduce using rule 97 (value -> ID .)
    PLUS            reduce using rule 97 (value -> ID .)


state 90

    (123) constructor -> ID LPAREN constructor_parenthesis_content . RPAREN SEMICOLON

    RPAREN          shift and go to state 155


state 91

    (24) call_function -> ID LPAREN RPAREN .

    COMMENT_MULTI   reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    COMMENT_SINGLE  reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    SEMICOLON       reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    PRINT           reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    STRING          reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    VAR             reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    FINAL           reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    ID              reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    VOID            reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    LIST            reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    DYNAMIC         reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    MAP             reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    WHILE           reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    INT             reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    DOUBLE          reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    BOOL            reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    IF              reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    FOR             reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    $end            reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    RPAREN          reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    RBRACKET        reduce using rule 24 (call_function -> ID LPAREN RPAREN .)


state 92

    (23) call_function -> ID LPAREN argument_list . RPAREN
    (30) argument_list -> argument_list . COMMA expression

    RPAREN          shift and go to state 156
    COMMA           shift and go to state 157


state 93

    (121) constructor_parenthesis_content -> THIS . DOT ID
    (122) constructor_parenthesis_content -> THIS . DOT ID COMMA constructor_parenthesis_content

    DOT             shift and go to state 158


state 94

    (29) argument_list -> expression .

    RPAREN          reduce using rule 29 (argument_list -> expression .)
    COMMA           reduce using rule 29 (argument_list -> expression .)


state 95

    (96) value -> TEXT .

    GREATER         reduce using rule 96 (value -> TEXT .)
    LESS            reduce using rule 96 (value -> TEXT .)
    EQUALS          reduce using rule 96 (value -> TEXT .)
    GREATER_EQUAL   reduce using rule 96 (value -> TEXT .)
    LESS_EQUAL      reduce using rule 96 (value -> TEXT .)
    NOT_EQUALS      reduce using rule 96 (value -> TEXT .)
    RPAREN          reduce using rule 96 (value -> TEXT .)
    COMMA           reduce using rule 96 (value -> TEXT .)
    SEMICOLON       reduce using rule 96 (value -> TEXT .)
    RSBRACKET       reduce using rule 96 (value -> TEXT .)
    AND             reduce using rule 96 (value -> TEXT .)
    OR              reduce using rule 96 (value -> TEXT .)
    LBRACKET        reduce using rule 96 (value -> TEXT .)
    COMMENT_MULTI   reduce using rule 96 (value -> TEXT .)
    COMMENT_SINGLE  reduce using rule 96 (value -> TEXT .)
    PRINT           reduce using rule 96 (value -> TEXT .)
    STRING          reduce using rule 96 (value -> TEXT .)
    VAR             reduce using rule 96 (value -> TEXT .)
    FINAL           reduce using rule 96 (value -> TEXT .)
    ID              reduce using rule 96 (value -> TEXT .)
    VOID            reduce using rule 96 (value -> TEXT .)
    LIST            reduce using rule 96 (value -> TEXT .)
    DYNAMIC         reduce using rule 96 (value -> TEXT .)
    MAP             reduce using rule 96 (value -> TEXT .)
    WHILE           reduce using rule 96 (value -> TEXT .)
    INT             reduce using rule 96 (value -> TEXT .)
    DOUBLE          reduce using rule 96 (value -> TEXT .)
    BOOL            reduce using rule 96 (value -> TEXT .)
    IF              reduce using rule 96 (value -> TEXT .)
    FOR             reduce using rule 96 (value -> TEXT .)
    $end            reduce using rule 96 (value -> TEXT .)
    RBRACKET        reduce using rule 96 (value -> TEXT .)
    PLUS            reduce using rule 96 (value -> TEXT .)


state 96

    (22) variable_usage -> ID ASSIGN value . SEMICOLON

    SEMICOLON       shift and go to state 159


state 97

    (94) value -> NUMBER .

    SEMICOLON       reduce using rule 94 (value -> NUMBER .)
    GREATER         reduce using rule 94 (value -> NUMBER .)
    LESS            reduce using rule 94 (value -> NUMBER .)
    EQUALS          reduce using rule 94 (value -> NUMBER .)
    GREATER_EQUAL   reduce using rule 94 (value -> NUMBER .)
    LESS_EQUAL      reduce using rule 94 (value -> NUMBER .)
    NOT_EQUALS      reduce using rule 94 (value -> NUMBER .)
    COMMA           reduce using rule 94 (value -> NUMBER .)
    RSBRACKET       reduce using rule 94 (value -> NUMBER .)
    AND             reduce using rule 94 (value -> NUMBER .)
    OR              reduce using rule 94 (value -> NUMBER .)
    RPAREN          reduce using rule 94 (value -> NUMBER .)
    LBRACKET        reduce using rule 94 (value -> NUMBER .)
    COMMENT_MULTI   reduce using rule 94 (value -> NUMBER .)
    COMMENT_SINGLE  reduce using rule 94 (value -> NUMBER .)
    PRINT           reduce using rule 94 (value -> NUMBER .)
    STRING          reduce using rule 94 (value -> NUMBER .)
    VAR             reduce using rule 94 (value -> NUMBER .)
    FINAL           reduce using rule 94 (value -> NUMBER .)
    ID              reduce using rule 94 (value -> NUMBER .)
    VOID            reduce using rule 94 (value -> NUMBER .)
    LIST            reduce using rule 94 (value -> NUMBER .)
    DYNAMIC         reduce using rule 94 (value -> NUMBER .)
    MAP             reduce using rule 94 (value -> NUMBER .)
    WHILE           reduce using rule 94 (value -> NUMBER .)
    INT             reduce using rule 94 (value -> NUMBER .)
    DOUBLE          reduce using rule 94 (value -> NUMBER .)
    BOOL            reduce using rule 94 (value -> NUMBER .)
    IF              reduce using rule 94 (value -> NUMBER .)
    FOR             reduce using rule 94 (value -> NUMBER .)
    $end            reduce using rule 94 (value -> NUMBER .)
    RBRACKET        reduce using rule 94 (value -> NUMBER .)
    PLUS            reduce using rule 94 (value -> NUMBER .)


state 98

    (100) set -> VAR ID ASSIGN . LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> VAR ID ASSIGN . LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (39) variable_definition -> VAR ID ASSIGN . expression SEMICOLON
    (46) expression -> . operations
    (56) expression -> . conditions
    (57) expression -> . value
    (47) operations -> . operation
    (48) operations -> . operation operand operations
    (66) conditions -> . condition
    (67) conditions -> . condition AND conditions
    (68) conditions -> . condition OR conditions
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE
    (49) operation -> . operand operator operand
    (69) condition -> . value comparator value
    (70) condition -> . NOT condition
    (50) operand -> . NUMBER
    (51) operand -> . DOUBLE

    LBRACKET        shift and go to state 160
    LESS            shift and go to state 161
    NUMBER          shift and go to state 80
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83
    NOT             shift and go to state 85
    DOUBLE          shift and go to state 86

    expression                     shift and go to state 162
    operations                     shift and go to state 71
    conditions                     shift and go to state 72
    value                          shift and go to state 73
    operation                      shift and go to state 77
    operand                        shift and go to state 78
    condition                      shift and go to state 79

state 99

    (102) set -> FINAL ID ASSIGN . CONST LBRACKET value_list RBRACKET SEMICOLON

    CONST           shift and go to state 163


state 100

    (128) map_assignment -> LBRACKET map_contents . RBRACKET

    RBRACKET        shift and go to state 164


state 101

    (129) map_contents -> map_content .
    (130) map_contents -> map_content . COMMA map_contents

    RBRACKET        reduce using rule 129 (map_contents -> map_content .)
    COMMA           shift and go to state 165


state 102

    (131) map_content -> key_value . COLON value

    COLON           shift and go to state 166


state 103

    (132) key_value -> TEXT .

    COLON           reduce using rule 132 (key_value -> TEXT .)


state 104

    (31) function -> type ID LPAREN . parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> type ID LPAREN . RPAREN LBRACKET statement_list RBRACKET
    (124) function -> type ID LPAREN . parameter_list RPAREN ASSIGN GREATER expression
    (77) parameter_list -> . parameter
    (78) parameter_list -> . parameter_list COMMA parameter
    (79) parameter -> . type ID
    (80) parameter -> . REQUIRED type ID
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST

    RPAREN          shift and go to state 169
    REQUIRED        shift and go to state 171
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    STRING          shift and go to state 109
    BOOL            shift and go to state 39
    LIST            shift and go to state 107

    type                           shift and go to state 167
    parameter_list                 shift and go to state 168
    parameter                      shift and go to state 170

state 105

    (37) variable_definition -> type ID ASSIGN . expression SEMICOLON
    (46) expression -> . operations
    (56) expression -> . conditions
    (57) expression -> . value
    (47) operations -> . operation
    (48) operations -> . operation operand operations
    (66) conditions -> . condition
    (67) conditions -> . condition AND conditions
    (68) conditions -> . condition OR conditions
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE
    (49) operation -> . operand operator operand
    (69) condition -> . value comparator value
    (70) condition -> . NOT condition
    (50) operand -> . NUMBER
    (51) operand -> . DOUBLE

    NUMBER          shift and go to state 80
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83
    NOT             shift and go to state 85
    DOUBLE          shift and go to state 86

    expression                     shift and go to state 172
    operations                     shift and go to state 71
    conditions                     shift and go to state 72
    value                          shift and go to state 73
    operation                      shift and go to state 77
    operand                        shift and go to state 78
    condition                      shift and go to state 79

state 106

    (32) function -> VOID ID LPAREN . parameter_list RPAREN LBRACKET statement_list RBRACKET
    (34) function -> VOID ID LPAREN . RPAREN LBRACKET statement_list RBRACKET
    (35) function -> VOID ID LPAREN . RPAREN LBRACKET RBRACKET
    (36) function -> VOID ID LPAREN . parameter_list RPAREN LBRACKET RBRACKET
    (77) parameter_list -> . parameter
    (78) parameter_list -> . parameter_list COMMA parameter
    (79) parameter -> . type ID
    (80) parameter -> . REQUIRED type ID
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST

    RPAREN          shift and go to state 174
    REQUIRED        shift and go to state 171
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    STRING          shift and go to state 109
    BOOL            shift and go to state 39
    LIST            shift and go to state 107

    parameter_list                 shift and go to state 173
    parameter                      shift and go to state 170
    type                           shift and go to state 167

state 107

    (93) type -> LIST .

    GREATER         reduce using rule 93 (type -> LIST .)
    ID              reduce using rule 93 (type -> LIST .)


state 108

    (82) list_definition -> LIST LESS type . GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON

    GREATER         shift and go to state 175


state 109

    (91) type -> STRING .

    GREATER         reduce using rule 91 (type -> STRING .)
    ID              reduce using rule 91 (type -> STRING .)


state 110

    (38) variable_definition -> DYNAMIC ID ASSIGN . expression SEMICOLON
    (46) expression -> . operations
    (56) expression -> . conditions
    (57) expression -> . value
    (47) operations -> . operation
    (48) operations -> . operation operand operations
    (66) conditions -> . condition
    (67) conditions -> . condition AND conditions
    (68) conditions -> . condition OR conditions
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE
    (49) operation -> . operand operator operand
    (69) condition -> . value comparator value
    (70) condition -> . NOT condition
    (50) operand -> . NUMBER
    (51) operand -> . DOUBLE

    NUMBER          shift and go to state 80
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83
    NOT             shift and go to state 85
    DOUBLE          shift and go to state 86

    expression                     shift and go to state 176
    operations                     shift and go to state 71
    conditions                     shift and go to state 72
    value                          shift and go to state 73
    operation                      shift and go to state 77
    operand                        shift and go to state 78
    condition                      shift and go to state 79

state 111

    (127) map_declaration -> MAP LESS key_type . COMMA type GREATER ID ASSIGN

    COMMA           shift and go to state 177


state 112

    (133) key_type -> STRING .

    COMMA           reduce using rule 133 (key_type -> STRING .)


state 113

    (60) control_structures_if_else -> if_block else_if_blocks else_block .

    COMMENT_MULTI   reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    COMMENT_SINGLE  reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    SEMICOLON       reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    PRINT           reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    STRING          reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    VAR             reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    FINAL           reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    ID              reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    VOID            reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    LIST            reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    DYNAMIC         reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    MAP             reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    WHILE           reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    INT             reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    DOUBLE          reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    BOOL            reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    IF              reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    FOR             reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    $end            reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    RBRACKET        reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)


state 114

    (64) else_if_blocks -> else_if_blocks ELSE . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (65) else_block -> ELSE . LBRACKET statement_list RBRACKET

    IF              shift and go to state 178
    LBRACKET        shift and go to state 116


state 115

    (63) else_if_blocks -> ELSE IF . LPAREN conditions RPAREN LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 179


state 116

    (65) else_block -> ELSE LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement_list                 shift and go to state 180
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 117

    (125) control_structures_while -> WHILE LPAREN conditions . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 181


state 118

    (69) condition -> value . comparator value
    (71) comparator -> . GREATER
    (72) comparator -> . LESS
    (73) comparator -> . EQUALS
    (74) comparator -> . GREATER_EQUAL
    (75) comparator -> . LESS_EQUAL
    (76) comparator -> . NOT_EQUALS

    GREATER         shift and go to state 131
    LESS            shift and go to state 132
    EQUALS          shift and go to state 133
    GREATER_EQUAL   shift and go to state 134
    LESS_EQUAL      shift and go to state 135
    NOT_EQUALS      shift and go to state 136

    comparator                     shift and go to state 130

state 119

    (62) if_block -> IF LPAREN conditions . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 182


state 120

    (111) for_classic -> FOR LPAREN for_classic_parenthesis_content . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 183


state 121

    (113) for_in -> FOR LPAREN for_in_parenthesis_content . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 184


state 122

    (117) for_each -> FOR LPAREN for_each_parenthesis_content . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 185


state 123

    (110) for_classic_parenthesis_content -> for_classic_initialization . SEMICOLON for_classic_conditions SEMICOLON for_classic_changes

    SEMICOLON       shift and go to state 186


state 124

    (112) for_in_parenthesis_content -> FINAL . ID IN ID
    (116) for_each_parenthesis_content -> FINAL . ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID

    ID              shift and go to state 187


state 125

    (103) for_classic_initialization -> INT . ID ASSIGN NUMBER

    ID              shift and go to state 188


state 126

    (104) for_classic_initialization -> DOUBLE . ID ASSIGN NDOUBLE

    ID              shift and go to state 189


state 127

    (40) print -> PRINT LPAREN RPAREN SEMICOLON .

    COMMENT_MULTI   reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)


state 128

    (41) print -> PRINT LPAREN print_options RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 190


state 129

    (86) interpolated_string -> string_part PLUS . interpolated_string
    (85) interpolated_string -> . string_part
    (86) interpolated_string -> . string_part PLUS interpolated_string
    (87) string_part -> . TEXT
    (88) string_part -> . TEXT PLUS value

    TEXT            shift and go to state 192

    string_part                    shift and go to state 70
    interpolated_string            shift and go to state 191

state 130

    (69) condition -> value comparator . value
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83

    value                          shift and go to state 193

state 131

    (71) comparator -> GREATER .

    NUMBER          reduce using rule 71 (comparator -> GREATER .)
    NDOUBLE         reduce using rule 71 (comparator -> GREATER .)
    TEXT            reduce using rule 71 (comparator -> GREATER .)
    ID              reduce using rule 71 (comparator -> GREATER .)
    TRUE            reduce using rule 71 (comparator -> GREATER .)
    FALSE           reduce using rule 71 (comparator -> GREATER .)


state 132

    (72) comparator -> LESS .

    NUMBER          reduce using rule 72 (comparator -> LESS .)
    NDOUBLE         reduce using rule 72 (comparator -> LESS .)
    TEXT            reduce using rule 72 (comparator -> LESS .)
    ID              reduce using rule 72 (comparator -> LESS .)
    TRUE            reduce using rule 72 (comparator -> LESS .)
    FALSE           reduce using rule 72 (comparator -> LESS .)


state 133

    (73) comparator -> EQUALS .

    NUMBER          reduce using rule 73 (comparator -> EQUALS .)
    NDOUBLE         reduce using rule 73 (comparator -> EQUALS .)
    TEXT            reduce using rule 73 (comparator -> EQUALS .)
    ID              reduce using rule 73 (comparator -> EQUALS .)
    TRUE            reduce using rule 73 (comparator -> EQUALS .)
    FALSE           reduce using rule 73 (comparator -> EQUALS .)


state 134

    (74) comparator -> GREATER_EQUAL .

    NUMBER          reduce using rule 74 (comparator -> GREATER_EQUAL .)
    NDOUBLE         reduce using rule 74 (comparator -> GREATER_EQUAL .)
    TEXT            reduce using rule 74 (comparator -> GREATER_EQUAL .)
    ID              reduce using rule 74 (comparator -> GREATER_EQUAL .)
    TRUE            reduce using rule 74 (comparator -> GREATER_EQUAL .)
    FALSE           reduce using rule 74 (comparator -> GREATER_EQUAL .)


state 135

    (75) comparator -> LESS_EQUAL .

    NUMBER          reduce using rule 75 (comparator -> LESS_EQUAL .)
    NDOUBLE         reduce using rule 75 (comparator -> LESS_EQUAL .)
    TEXT            reduce using rule 75 (comparator -> LESS_EQUAL .)
    ID              reduce using rule 75 (comparator -> LESS_EQUAL .)
    TRUE            reduce using rule 75 (comparator -> LESS_EQUAL .)
    FALSE           reduce using rule 75 (comparator -> LESS_EQUAL .)


state 136

    (76) comparator -> NOT_EQUALS .

    NUMBER          reduce using rule 76 (comparator -> NOT_EQUALS .)
    NDOUBLE         reduce using rule 76 (comparator -> NOT_EQUALS .)
    TEXT            reduce using rule 76 (comparator -> NOT_EQUALS .)
    ID              reduce using rule 76 (comparator -> NOT_EQUALS .)
    TRUE            reduce using rule 76 (comparator -> NOT_EQUALS .)
    FALSE           reduce using rule 76 (comparator -> NOT_EQUALS .)


state 137

    (27) length -> call_list DOT . LENGTH

    LENGTH          shift and go to state 194


state 138

    (28) length -> TEXT DOT . LENGTH

    LENGTH          shift and go to state 195


state 139

    (88) string_part -> TEXT PLUS . value
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83

    value                          shift and go to state 196

state 140

    (23) call_function -> ID LPAREN . argument_list RPAREN
    (24) call_function -> ID LPAREN . RPAREN
    (29) argument_list -> . expression
    (30) argument_list -> . argument_list COMMA expression
    (46) expression -> . operations
    (56) expression -> . conditions
    (57) expression -> . value
    (47) operations -> . operation
    (48) operations -> . operation operand operations
    (66) conditions -> . condition
    (67) conditions -> . condition AND conditions
    (68) conditions -> . condition OR conditions
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE
    (49) operation -> . operand operator operand
    (69) condition -> . value comparator value
    (70) condition -> . NOT condition
    (50) operand -> . NUMBER
    (51) operand -> . DOUBLE

    RPAREN          shift and go to state 91
    NUMBER          shift and go to state 80
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83
    NOT             shift and go to state 85
    DOUBLE          shift and go to state 86

    argument_list                  shift and go to state 92
    expression                     shift and go to state 94
    operations                     shift and go to state 71
    conditions                     shift and go to state 72
    value                          shift and go to state 73
    operation                      shift and go to state 77
    operand                        shift and go to state 78
    condition                      shift and go to state 79

state 141

    (48) operations -> operation operand . operations
    (47) operations -> . operation
    (48) operations -> . operation operand operations
    (49) operation -> . operand operator operand
    (50) operand -> . NUMBER
    (51) operand -> . DOUBLE

    NUMBER          shift and go to state 142
    DOUBLE          shift and go to state 86

    operation                      shift and go to state 77
    operand                        shift and go to state 78
    operations                     shift and go to state 197

state 142

    (50) operand -> NUMBER .

    NUMBER          reduce using rule 50 (operand -> NUMBER .)
    DOUBLE          reduce using rule 50 (operand -> NUMBER .)
    PLUS            reduce using rule 50 (operand -> NUMBER .)
    MINUS           reduce using rule 50 (operand -> NUMBER .)
    TIMES           reduce using rule 50 (operand -> NUMBER .)
    DIVIDE          reduce using rule 50 (operand -> NUMBER .)
    RPAREN          reduce using rule 50 (operand -> NUMBER .)
    COMMA           reduce using rule 50 (operand -> NUMBER .)
    SEMICOLON       reduce using rule 50 (operand -> NUMBER .)
    COMMENT_MULTI   reduce using rule 50 (operand -> NUMBER .)
    COMMENT_SINGLE  reduce using rule 50 (operand -> NUMBER .)
    PRINT           reduce using rule 50 (operand -> NUMBER .)
    STRING          reduce using rule 50 (operand -> NUMBER .)
    VAR             reduce using rule 50 (operand -> NUMBER .)
    FINAL           reduce using rule 50 (operand -> NUMBER .)
    ID              reduce using rule 50 (operand -> NUMBER .)
    VOID            reduce using rule 50 (operand -> NUMBER .)
    LIST            reduce using rule 50 (operand -> NUMBER .)
    DYNAMIC         reduce using rule 50 (operand -> NUMBER .)
    MAP             reduce using rule 50 (operand -> NUMBER .)
    WHILE           reduce using rule 50 (operand -> NUMBER .)
    INT             reduce using rule 50 (operand -> NUMBER .)
    BOOL            reduce using rule 50 (operand -> NUMBER .)
    IF              reduce using rule 50 (operand -> NUMBER .)
    FOR             reduce using rule 50 (operand -> NUMBER .)
    $end            reduce using rule 50 (operand -> NUMBER .)
    RBRACKET        reduce using rule 50 (operand -> NUMBER .)


state 143

    (49) operation -> operand operator . operand
    (50) operand -> . NUMBER
    (51) operand -> . DOUBLE

    NUMBER          shift and go to state 142
    DOUBLE          shift and go to state 86

    operand                        shift and go to state 198

state 144

    (52) operator -> PLUS .

    NUMBER          reduce using rule 52 (operator -> PLUS .)
    DOUBLE          reduce using rule 52 (operator -> PLUS .)


state 145

    (53) operator -> MINUS .

    NUMBER          reduce using rule 53 (operator -> MINUS .)
    DOUBLE          reduce using rule 53 (operator -> MINUS .)


state 146

    (54) operator -> TIMES .

    NUMBER          reduce using rule 54 (operator -> TIMES .)
    DOUBLE          reduce using rule 54 (operator -> TIMES .)


state 147

    (55) operator -> DIVIDE .

    NUMBER          reduce using rule 55 (operator -> DIVIDE .)
    DOUBLE          reduce using rule 55 (operator -> DIVIDE .)


state 148

    (67) conditions -> condition AND . conditions
    (66) conditions -> . condition
    (67) conditions -> . condition AND conditions
    (68) conditions -> . condition OR conditions
    (69) condition -> . value comparator value
    (70) condition -> . NOT condition
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NOT             shift and go to state 85
    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83

    condition                      shift and go to state 79
    conditions                     shift and go to state 199
    value                          shift and go to state 118

state 149

    (68) conditions -> condition OR . conditions
    (66) conditions -> . condition
    (67) conditions -> . condition AND conditions
    (68) conditions -> . condition OR conditions
    (69) condition -> . value comparator value
    (70) condition -> . NOT condition
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NOT             shift and go to state 85
    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83

    condition                      shift and go to state 79
    conditions                     shift and go to state 200
    value                          shift and go to state 118

state 150

    (81) call_list -> LSBRACKET value_list . RSBRACKET

    RSBRACKET       shift and go to state 201


state 151

    (83) value_list -> value .
    (84) value_list -> value . COMMA value_list

    RSBRACKET       reduce using rule 83 (value_list -> value .)
    RBRACKET        reduce using rule 83 (value_list -> value .)
    COMMA           shift and go to state 202


state 152

    (70) condition -> NOT condition .

    AND             reduce using rule 70 (condition -> NOT condition .)
    OR              reduce using rule 70 (condition -> NOT condition .)
    RPAREN          reduce using rule 70 (condition -> NOT condition .)
    COMMA           reduce using rule 70 (condition -> NOT condition .)
    LBRACKET        reduce using rule 70 (condition -> NOT condition .)
    SEMICOLON       reduce using rule 70 (condition -> NOT condition .)
    COMMENT_MULTI   reduce using rule 70 (condition -> NOT condition .)
    COMMENT_SINGLE  reduce using rule 70 (condition -> NOT condition .)
    PRINT           reduce using rule 70 (condition -> NOT condition .)
    STRING          reduce using rule 70 (condition -> NOT condition .)
    VAR             reduce using rule 70 (condition -> NOT condition .)
    FINAL           reduce using rule 70 (condition -> NOT condition .)
    ID              reduce using rule 70 (condition -> NOT condition .)
    VOID            reduce using rule 70 (condition -> NOT condition .)
    LIST            reduce using rule 70 (condition -> NOT condition .)
    DYNAMIC         reduce using rule 70 (condition -> NOT condition .)
    MAP             reduce using rule 70 (condition -> NOT condition .)
    WHILE           reduce using rule 70 (condition -> NOT condition .)
    INT             reduce using rule 70 (condition -> NOT condition .)
    DOUBLE          reduce using rule 70 (condition -> NOT condition .)
    BOOL            reduce using rule 70 (condition -> NOT condition .)
    IF              reduce using rule 70 (condition -> NOT condition .)
    FOR             reduce using rule 70 (condition -> NOT condition .)
    $end            reduce using rule 70 (condition -> NOT condition .)
    RBRACKET        reduce using rule 70 (condition -> NOT condition .)


state 153

    (25) data_input -> STRING ID ASSIGN STDIN . DOT READLINESYNC LPAREN RPAREN SEMICOLON

    DOT             shift and go to state 203


state 154

    (26) data_input -> STRING QUESTION ID ASSIGN . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    STDIN           shift and go to state 204


state 155

    (123) constructor -> ID LPAREN constructor_parenthesis_content RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 205


state 156

    (23) call_function -> ID LPAREN argument_list RPAREN .

    COMMENT_MULTI   reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    COMMENT_SINGLE  reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    SEMICOLON       reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    PRINT           reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    STRING          reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    VAR             reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    FINAL           reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    ID              reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    VOID            reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    LIST            reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    DYNAMIC         reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    MAP             reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    WHILE           reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    INT             reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    DOUBLE          reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    BOOL            reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    IF              reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    FOR             reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    $end            reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    RPAREN          reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    RBRACKET        reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)


state 157

    (30) argument_list -> argument_list COMMA . expression
    (46) expression -> . operations
    (56) expression -> . conditions
    (57) expression -> . value
    (47) operations -> . operation
    (48) operations -> . operation operand operations
    (66) conditions -> . condition
    (67) conditions -> . condition AND conditions
    (68) conditions -> . condition OR conditions
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE
    (49) operation -> . operand operator operand
    (69) condition -> . value comparator value
    (70) condition -> . NOT condition
    (50) operand -> . NUMBER
    (51) operand -> . DOUBLE

    NUMBER          shift and go to state 80
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83
    NOT             shift and go to state 85
    DOUBLE          shift and go to state 86

    expression                     shift and go to state 206
    operations                     shift and go to state 71
    conditions                     shift and go to state 72
    value                          shift and go to state 73
    operation                      shift and go to state 77
    operand                        shift and go to state 78
    condition                      shift and go to state 79

state 158

    (121) constructor_parenthesis_content -> THIS DOT . ID
    (122) constructor_parenthesis_content -> THIS DOT . ID COMMA constructor_parenthesis_content

    ID              shift and go to state 207


state 159

    (22) variable_usage -> ID ASSIGN value SEMICOLON .

    COMMENT_MULTI   reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    SEMICOLON       reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    PRINT           reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    STRING          reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    VAR             reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    FINAL           reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    ID              reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    VOID            reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    LIST            reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    DYNAMIC         reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    MAP             reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    WHILE           reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    INT             reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    DOUBLE          reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    BOOL            reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    IF              reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    FOR             reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    $end            reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    RBRACKET        reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)


state 160

    (100) set -> VAR ID ASSIGN LBRACKET . value_list RBRACKET SEMICOLON
    (83) value_list -> . value
    (84) value_list -> . value COMMA value_list
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83

    value_list                     shift and go to state 208
    value                          shift and go to state 151

state 161

    (101) set -> VAR ID ASSIGN LESS . STRING GREATER LBRACKET RBRACKET SEMICOLON

    STRING          shift and go to state 209


state 162

    (39) variable_definition -> VAR ID ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 210


state 163

    (102) set -> FINAL ID ASSIGN CONST . LBRACKET value_list RBRACKET SEMICOLON

    LBRACKET        shift and go to state 211


state 164

    (128) map_assignment -> LBRACKET map_contents RBRACKET .

    COMMENT_MULTI   reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    COMMENT_SINGLE  reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    SEMICOLON       reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    PRINT           reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    STRING          reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    VAR             reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    FINAL           reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    ID              reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    VOID            reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    LIST            reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    DYNAMIC         reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    MAP             reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    WHILE           reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    INT             reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    DOUBLE          reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    BOOL            reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    IF              reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    FOR             reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    $end            reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    RBRACKET        reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)


state 165

    (130) map_contents -> map_content COMMA . map_contents
    (129) map_contents -> . map_content
    (130) map_contents -> . map_content COMMA map_contents
    (131) map_content -> . key_value COLON value
    (132) key_value -> . TEXT

    TEXT            shift and go to state 103

    map_content                    shift and go to state 101
    map_contents                   shift and go to state 212
    key_value                      shift and go to state 102

state 166

    (131) map_content -> key_value COLON . value
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83

    value                          shift and go to state 213

state 167

    (79) parameter -> type . ID

    ID              shift and go to state 214


state 168

    (31) function -> type ID LPAREN parameter_list . RPAREN LBRACKET statement_list RBRACKET
    (124) function -> type ID LPAREN parameter_list . RPAREN ASSIGN GREATER expression
    (78) parameter_list -> parameter_list . COMMA parameter

    RPAREN          shift and go to state 215
    COMMA           shift and go to state 216


state 169

    (33) function -> type ID LPAREN RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 217


state 170

    (77) parameter_list -> parameter .

    RPAREN          reduce using rule 77 (parameter_list -> parameter .)
    COMMA           reduce using rule 77 (parameter_list -> parameter .)


state 171

    (80) parameter -> REQUIRED . type ID
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST

    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    STRING          shift and go to state 109
    BOOL            shift and go to state 39
    LIST            shift and go to state 107

    type                           shift and go to state 218

state 172

    (37) variable_definition -> type ID ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 219


state 173

    (32) function -> VOID ID LPAREN parameter_list . RPAREN LBRACKET statement_list RBRACKET
    (36) function -> VOID ID LPAREN parameter_list . RPAREN LBRACKET RBRACKET
    (78) parameter_list -> parameter_list . COMMA parameter

    RPAREN          shift and go to state 220
    COMMA           shift and go to state 216


state 174

    (34) function -> VOID ID LPAREN RPAREN . LBRACKET statement_list RBRACKET
    (35) function -> VOID ID LPAREN RPAREN . LBRACKET RBRACKET

    LBRACKET        shift and go to state 221


state 175

    (82) list_definition -> LIST LESS type GREATER . ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON

    ID              shift and go to state 222


state 176

    (38) variable_definition -> DYNAMIC ID ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 223


state 177

    (127) map_declaration -> MAP LESS key_type COMMA . type GREATER ID ASSIGN
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST

    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    STRING          shift and go to state 109
    BOOL            shift and go to state 39
    LIST            shift and go to state 107

    type                           shift and go to state 224

state 178

    (64) else_if_blocks -> else_if_blocks ELSE IF . LPAREN conditions RPAREN LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 225


state 179

    (63) else_if_blocks -> ELSE IF LPAREN . conditions RPAREN LBRACKET statement_list RBRACKET
    (66) conditions -> . condition
    (67) conditions -> . condition AND conditions
    (68) conditions -> . condition OR conditions
    (69) condition -> . value comparator value
    (70) condition -> . NOT condition
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NOT             shift and go to state 85
    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83

    conditions                     shift and go to state 226
    condition                      shift and go to state 79
    value                          shift and go to state 118

state 180

    (65) else_block -> ELSE LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 227
    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement                      shift and go to state 42
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 181

    (125) control_structures_while -> WHILE LPAREN conditions LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement_list                 shift and go to state 228
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 182

    (62) if_block -> IF LPAREN conditions RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 229


state 183

    (111) for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 230


state 184

    (113) for_in -> FOR LPAREN for_in_parenthesis_content RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 231


state 185

    (117) for_each -> FOR LPAREN for_each_parenthesis_content RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 232


state 186

    (110) for_classic_parenthesis_content -> for_classic_initialization SEMICOLON . for_classic_conditions SEMICOLON for_classic_changes
    (105) for_classic_conditions -> . conditions
    (66) conditions -> . condition
    (67) conditions -> . condition AND conditions
    (68) conditions -> . condition OR conditions
    (69) condition -> . value comparator value
    (70) condition -> . NOT condition
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NOT             shift and go to state 85
    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83

    for_classic_conditions         shift and go to state 233
    conditions                     shift and go to state 234
    condition                      shift and go to state 79
    value                          shift and go to state 118

state 187

    (112) for_in_parenthesis_content -> FINAL ID . IN ID
    (116) for_each_parenthesis_content -> FINAL ID . LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID

    IN              shift and go to state 235
    LPAREN          shift and go to state 236


state 188

    (103) for_classic_initialization -> INT ID . ASSIGN NUMBER

    ASSIGN          shift and go to state 237


state 189

    (104) for_classic_initialization -> DOUBLE ID . ASSIGN NDOUBLE

    ASSIGN          shift and go to state 238


state 190

    (41) print -> PRINT LPAREN print_options RPAREN SEMICOLON .

    COMMENT_MULTI   reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    PRINT           reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    STRING          reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    VAR             reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    FINAL           reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    ID              reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    VOID            reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    LIST            reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    MAP             reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    WHILE           reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    INT             reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    BOOL            reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    IF              reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    FOR             reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    $end            reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)


state 191

    (86) interpolated_string -> string_part PLUS interpolated_string .

    RPAREN          reduce using rule 86 (interpolated_string -> string_part PLUS interpolated_string .)


state 192

    (87) string_part -> TEXT .
    (88) string_part -> TEXT . PLUS value

  ! shift/reduce conflict for PLUS resolved as shift
    RPAREN          reduce using rule 87 (string_part -> TEXT .)
    PLUS            shift and go to state 139

  ! PLUS            [ reduce using rule 87 (string_part -> TEXT .) ]


state 193

    (69) condition -> value comparator value .

    AND             reduce using rule 69 (condition -> value comparator value .)
    OR              reduce using rule 69 (condition -> value comparator value .)
    RPAREN          reduce using rule 69 (condition -> value comparator value .)
    COMMA           reduce using rule 69 (condition -> value comparator value .)
    LBRACKET        reduce using rule 69 (condition -> value comparator value .)
    SEMICOLON       reduce using rule 69 (condition -> value comparator value .)
    COMMENT_MULTI   reduce using rule 69 (condition -> value comparator value .)
    COMMENT_SINGLE  reduce using rule 69 (condition -> value comparator value .)
    PRINT           reduce using rule 69 (condition -> value comparator value .)
    STRING          reduce using rule 69 (condition -> value comparator value .)
    VAR             reduce using rule 69 (condition -> value comparator value .)
    FINAL           reduce using rule 69 (condition -> value comparator value .)
    ID              reduce using rule 69 (condition -> value comparator value .)
    VOID            reduce using rule 69 (condition -> value comparator value .)
    LIST            reduce using rule 69 (condition -> value comparator value .)
    DYNAMIC         reduce using rule 69 (condition -> value comparator value .)
    MAP             reduce using rule 69 (condition -> value comparator value .)
    WHILE           reduce using rule 69 (condition -> value comparator value .)
    INT             reduce using rule 69 (condition -> value comparator value .)
    DOUBLE          reduce using rule 69 (condition -> value comparator value .)
    BOOL            reduce using rule 69 (condition -> value comparator value .)
    IF              reduce using rule 69 (condition -> value comparator value .)
    FOR             reduce using rule 69 (condition -> value comparator value .)
    $end            reduce using rule 69 (condition -> value comparator value .)
    RBRACKET        reduce using rule 69 (condition -> value comparator value .)


state 194

    (27) length -> call_list DOT LENGTH .

    RPAREN          reduce using rule 27 (length -> call_list DOT LENGTH .)


state 195

    (28) length -> TEXT DOT LENGTH .

    RPAREN          reduce using rule 28 (length -> TEXT DOT LENGTH .)


state 196

    (88) string_part -> TEXT PLUS value .

    PLUS            reduce using rule 88 (string_part -> TEXT PLUS value .)
    RPAREN          reduce using rule 88 (string_part -> TEXT PLUS value .)


state 197

    (48) operations -> operation operand operations .

    RPAREN          reduce using rule 48 (operations -> operation operand operations .)
    COMMA           reduce using rule 48 (operations -> operation operand operations .)
    SEMICOLON       reduce using rule 48 (operations -> operation operand operations .)
    COMMENT_MULTI   reduce using rule 48 (operations -> operation operand operations .)
    COMMENT_SINGLE  reduce using rule 48 (operations -> operation operand operations .)
    PRINT           reduce using rule 48 (operations -> operation operand operations .)
    STRING          reduce using rule 48 (operations -> operation operand operations .)
    VAR             reduce using rule 48 (operations -> operation operand operations .)
    FINAL           reduce using rule 48 (operations -> operation operand operations .)
    ID              reduce using rule 48 (operations -> operation operand operations .)
    VOID            reduce using rule 48 (operations -> operation operand operations .)
    LIST            reduce using rule 48 (operations -> operation operand operations .)
    DYNAMIC         reduce using rule 48 (operations -> operation operand operations .)
    MAP             reduce using rule 48 (operations -> operation operand operations .)
    WHILE           reduce using rule 48 (operations -> operation operand operations .)
    INT             reduce using rule 48 (operations -> operation operand operations .)
    DOUBLE          reduce using rule 48 (operations -> operation operand operations .)
    BOOL            reduce using rule 48 (operations -> operation operand operations .)
    IF              reduce using rule 48 (operations -> operation operand operations .)
    FOR             reduce using rule 48 (operations -> operation operand operations .)
    $end            reduce using rule 48 (operations -> operation operand operations .)
    RBRACKET        reduce using rule 48 (operations -> operation operand operations .)


state 198

    (49) operation -> operand operator operand .

    NUMBER          reduce using rule 49 (operation -> operand operator operand .)
    DOUBLE          reduce using rule 49 (operation -> operand operator operand .)
    RPAREN          reduce using rule 49 (operation -> operand operator operand .)
    COMMA           reduce using rule 49 (operation -> operand operator operand .)
    SEMICOLON       reduce using rule 49 (operation -> operand operator operand .)
    COMMENT_MULTI   reduce using rule 49 (operation -> operand operator operand .)
    COMMENT_SINGLE  reduce using rule 49 (operation -> operand operator operand .)
    PRINT           reduce using rule 49 (operation -> operand operator operand .)
    STRING          reduce using rule 49 (operation -> operand operator operand .)
    VAR             reduce using rule 49 (operation -> operand operator operand .)
    FINAL           reduce using rule 49 (operation -> operand operator operand .)
    ID              reduce using rule 49 (operation -> operand operator operand .)
    VOID            reduce using rule 49 (operation -> operand operator operand .)
    LIST            reduce using rule 49 (operation -> operand operator operand .)
    DYNAMIC         reduce using rule 49 (operation -> operand operator operand .)
    MAP             reduce using rule 49 (operation -> operand operator operand .)
    WHILE           reduce using rule 49 (operation -> operand operator operand .)
    INT             reduce using rule 49 (operation -> operand operator operand .)
    BOOL            reduce using rule 49 (operation -> operand operator operand .)
    IF              reduce using rule 49 (operation -> operand operator operand .)
    FOR             reduce using rule 49 (operation -> operand operator operand .)
    $end            reduce using rule 49 (operation -> operand operator operand .)
    RBRACKET        reduce using rule 49 (operation -> operand operator operand .)


state 199

    (67) conditions -> condition AND conditions .

    RPAREN          reduce using rule 67 (conditions -> condition AND conditions .)
    COMMA           reduce using rule 67 (conditions -> condition AND conditions .)
    LBRACKET        reduce using rule 67 (conditions -> condition AND conditions .)
    SEMICOLON       reduce using rule 67 (conditions -> condition AND conditions .)
    COMMENT_MULTI   reduce using rule 67 (conditions -> condition AND conditions .)
    COMMENT_SINGLE  reduce using rule 67 (conditions -> condition AND conditions .)
    PRINT           reduce using rule 67 (conditions -> condition AND conditions .)
    STRING          reduce using rule 67 (conditions -> condition AND conditions .)
    VAR             reduce using rule 67 (conditions -> condition AND conditions .)
    FINAL           reduce using rule 67 (conditions -> condition AND conditions .)
    ID              reduce using rule 67 (conditions -> condition AND conditions .)
    VOID            reduce using rule 67 (conditions -> condition AND conditions .)
    LIST            reduce using rule 67 (conditions -> condition AND conditions .)
    DYNAMIC         reduce using rule 67 (conditions -> condition AND conditions .)
    MAP             reduce using rule 67 (conditions -> condition AND conditions .)
    WHILE           reduce using rule 67 (conditions -> condition AND conditions .)
    INT             reduce using rule 67 (conditions -> condition AND conditions .)
    DOUBLE          reduce using rule 67 (conditions -> condition AND conditions .)
    BOOL            reduce using rule 67 (conditions -> condition AND conditions .)
    IF              reduce using rule 67 (conditions -> condition AND conditions .)
    FOR             reduce using rule 67 (conditions -> condition AND conditions .)
    $end            reduce using rule 67 (conditions -> condition AND conditions .)
    RBRACKET        reduce using rule 67 (conditions -> condition AND conditions .)


state 200

    (68) conditions -> condition OR conditions .

    RPAREN          reduce using rule 68 (conditions -> condition OR conditions .)
    COMMA           reduce using rule 68 (conditions -> condition OR conditions .)
    LBRACKET        reduce using rule 68 (conditions -> condition OR conditions .)
    SEMICOLON       reduce using rule 68 (conditions -> condition OR conditions .)
    COMMENT_MULTI   reduce using rule 68 (conditions -> condition OR conditions .)
    COMMENT_SINGLE  reduce using rule 68 (conditions -> condition OR conditions .)
    PRINT           reduce using rule 68 (conditions -> condition OR conditions .)
    STRING          reduce using rule 68 (conditions -> condition OR conditions .)
    VAR             reduce using rule 68 (conditions -> condition OR conditions .)
    FINAL           reduce using rule 68 (conditions -> condition OR conditions .)
    ID              reduce using rule 68 (conditions -> condition OR conditions .)
    VOID            reduce using rule 68 (conditions -> condition OR conditions .)
    LIST            reduce using rule 68 (conditions -> condition OR conditions .)
    DYNAMIC         reduce using rule 68 (conditions -> condition OR conditions .)
    MAP             reduce using rule 68 (conditions -> condition OR conditions .)
    WHILE           reduce using rule 68 (conditions -> condition OR conditions .)
    INT             reduce using rule 68 (conditions -> condition OR conditions .)
    DOUBLE          reduce using rule 68 (conditions -> condition OR conditions .)
    BOOL            reduce using rule 68 (conditions -> condition OR conditions .)
    IF              reduce using rule 68 (conditions -> condition OR conditions .)
    FOR             reduce using rule 68 (conditions -> condition OR conditions .)
    $end            reduce using rule 68 (conditions -> condition OR conditions .)
    RBRACKET        reduce using rule 68 (conditions -> condition OR conditions .)


state 201

    (81) call_list -> LSBRACKET value_list RSBRACKET .

    DOT             reduce using rule 81 (call_list -> LSBRACKET value_list RSBRACKET .)


state 202

    (84) value_list -> value COMMA . value_list
    (83) value_list -> . value
    (84) value_list -> . value COMMA value_list
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83

    value                          shift and go to state 151
    value_list                     shift and go to state 239

state 203

    (25) data_input -> STRING ID ASSIGN STDIN DOT . READLINESYNC LPAREN RPAREN SEMICOLON

    READLINESYNC    shift and go to state 240


state 204

    (26) data_input -> STRING QUESTION ID ASSIGN STDIN . DOT READLINESYNC LPAREN RPAREN SEMICOLON

    DOT             shift and go to state 241


state 205

    (123) constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .

    COMMENT_MULTI   reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    PRINT           reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    STRING          reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    VAR             reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    FINAL           reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    ID              reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    VOID            reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    LIST            reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    MAP             reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    WHILE           reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    INT             reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    BOOL            reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    IF              reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    FOR             reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    $end            reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)


state 206

    (30) argument_list -> argument_list COMMA expression .

    RPAREN          reduce using rule 30 (argument_list -> argument_list COMMA expression .)
    COMMA           reduce using rule 30 (argument_list -> argument_list COMMA expression .)


state 207

    (121) constructor_parenthesis_content -> THIS DOT ID .
    (122) constructor_parenthesis_content -> THIS DOT ID . COMMA constructor_parenthesis_content

    RPAREN          reduce using rule 121 (constructor_parenthesis_content -> THIS DOT ID .)
    COMMA           shift and go to state 242


state 208

    (100) set -> VAR ID ASSIGN LBRACKET value_list . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 243


state 209

    (101) set -> VAR ID ASSIGN LESS STRING . GREATER LBRACKET RBRACKET SEMICOLON

    GREATER         shift and go to state 244


state 210

    (39) variable_definition -> VAR ID ASSIGN expression SEMICOLON .

    COMMENT_MULTI   reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    DYNAMIC         reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    RBRACKET        reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)


state 211

    (102) set -> FINAL ID ASSIGN CONST LBRACKET . value_list RBRACKET SEMICOLON
    (83) value_list -> . value
    (84) value_list -> . value COMMA value_list
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83

    value_list                     shift and go to state 245
    value                          shift and go to state 151

state 212

    (130) map_contents -> map_content COMMA map_contents .

    RBRACKET        reduce using rule 130 (map_contents -> map_content COMMA map_contents .)


state 213

    (131) map_content -> key_value COLON value .

    COMMA           reduce using rule 131 (map_content -> key_value COLON value .)
    RBRACKET        reduce using rule 131 (map_content -> key_value COLON value .)


state 214

    (79) parameter -> type ID .

    RPAREN          reduce using rule 79 (parameter -> type ID .)
    COMMA           reduce using rule 79 (parameter -> type ID .)


state 215

    (31) function -> type ID LPAREN parameter_list RPAREN . LBRACKET statement_list RBRACKET
    (124) function -> type ID LPAREN parameter_list RPAREN . ASSIGN GREATER expression

    LBRACKET        shift and go to state 246
    ASSIGN          shift and go to state 247


state 216

    (78) parameter_list -> parameter_list COMMA . parameter
    (79) parameter -> . type ID
    (80) parameter -> . REQUIRED type ID
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST

    REQUIRED        shift and go to state 171
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    STRING          shift and go to state 109
    BOOL            shift and go to state 39
    LIST            shift and go to state 107

    parameter                      shift and go to state 248
    type                           shift and go to state 167

state 217

    (33) function -> type ID LPAREN RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    type                           shift and go to state 27
    statement_list                 shift and go to state 249
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 218

    (80) parameter -> REQUIRED type . ID

    ID              shift and go to state 250


state 219

    (37) variable_definition -> type ID ASSIGN expression SEMICOLON .

    COMMENT_MULTI   reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    DYNAMIC         reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    RBRACKET        reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)


state 220

    (32) function -> VOID ID LPAREN parameter_list RPAREN . LBRACKET statement_list RBRACKET
    (36) function -> VOID ID LPAREN parameter_list RPAREN . LBRACKET RBRACKET

    LBRACKET        shift and go to state 251


state 221

    (34) function -> VOID ID LPAREN RPAREN LBRACKET . statement_list RBRACKET
    (35) function -> VOID ID LPAREN RPAREN LBRACKET . RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 253
    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement_list                 shift and go to state 252
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 222

    (82) list_definition -> LIST LESS type GREATER ID . ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON

    ASSIGN          shift and go to state 254


state 223

    (38) variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .

    COMMENT_MULTI   reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    DYNAMIC         reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    RBRACKET        reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)


state 224

    (127) map_declaration -> MAP LESS key_type COMMA type . GREATER ID ASSIGN

    GREATER         shift and go to state 255


state 225

    (64) else_if_blocks -> else_if_blocks ELSE IF LPAREN . conditions RPAREN LBRACKET statement_list RBRACKET
    (66) conditions -> . condition
    (67) conditions -> . condition AND conditions
    (68) conditions -> . condition OR conditions
    (69) condition -> . value comparator value
    (70) condition -> . NOT condition
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NOT             shift and go to state 85
    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83

    conditions                     shift and go to state 256
    condition                      shift and go to state 79
    value                          shift and go to state 118

state 226

    (63) else_if_blocks -> ELSE IF LPAREN conditions . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 257


state 227

    (65) else_block -> ELSE LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)


state 228

    (125) control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 258
    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement                      shift and go to state 42
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 229

    (62) if_block -> IF LPAREN conditions RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement_list                 shift and go to state 259
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 230

    (111) for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement_list                 shift and go to state 260
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 231

    (113) for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement_list                 shift and go to state 261
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 232

    (117) for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement_list                 shift and go to state 262
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 233

    (110) for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions . SEMICOLON for_classic_changes

    SEMICOLON       shift and go to state 263


state 234

    (105) for_classic_conditions -> conditions .

    SEMICOLON       reduce using rule 105 (for_classic_conditions -> conditions .)


state 235

    (112) for_in_parenthesis_content -> FINAL ID IN . ID

    ID              shift and go to state 264


state 236

    (116) for_each_parenthesis_content -> FINAL ID LPAREN . for_each_parenthesis_parenthesis_content RPAREN IN ID
    (114) for_each_parenthesis_parenthesis_content -> . COLON ID
    (115) for_each_parenthesis_parenthesis_content -> . COLON ID COMMA for_each_parenthesis_parenthesis_content

    COLON           shift and go to state 266

    for_each_parenthesis_parenthesis_content shift and go to state 265

state 237

    (103) for_classic_initialization -> INT ID ASSIGN . NUMBER

    NUMBER          shift and go to state 267


state 238

    (104) for_classic_initialization -> DOUBLE ID ASSIGN . NDOUBLE

    NDOUBLE         shift and go to state 268


state 239

    (84) value_list -> value COMMA value_list .

    RSBRACKET       reduce using rule 84 (value_list -> value COMMA value_list .)
    RBRACKET        reduce using rule 84 (value_list -> value COMMA value_list .)


state 240

    (25) data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 269


state 241

    (26) data_input -> STRING QUESTION ID ASSIGN STDIN DOT . READLINESYNC LPAREN RPAREN SEMICOLON

    READLINESYNC    shift and go to state 270


state 242

    (122) constructor_parenthesis_content -> THIS DOT ID COMMA . constructor_parenthesis_content
    (121) constructor_parenthesis_content -> . THIS DOT ID
    (122) constructor_parenthesis_content -> . THIS DOT ID COMMA constructor_parenthesis_content

    THIS            shift and go to state 93

    constructor_parenthesis_content shift and go to state 271

state 243

    (100) set -> VAR ID ASSIGN LBRACKET value_list RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 272


state 244

    (101) set -> VAR ID ASSIGN LESS STRING GREATER . LBRACKET RBRACKET SEMICOLON

    LBRACKET        shift and go to state 273


state 245

    (102) set -> FINAL ID ASSIGN CONST LBRACKET value_list . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 274


state 246

    (31) function -> type ID LPAREN parameter_list RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    type                           shift and go to state 27
    statement_list                 shift and go to state 275
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 247

    (124) function -> type ID LPAREN parameter_list RPAREN ASSIGN . GREATER expression

    GREATER         shift and go to state 276


state 248

    (78) parameter_list -> parameter_list COMMA parameter .

    RPAREN          reduce using rule 78 (parameter_list -> parameter_list COMMA parameter .)
    COMMA           reduce using rule 78 (parameter_list -> parameter_list COMMA parameter .)


state 249

    (33) function -> type ID LPAREN RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 277
    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    type                           shift and go to state 27
    statement                      shift and go to state 42
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 250

    (80) parameter -> REQUIRED type ID .

    RPAREN          reduce using rule 80 (parameter -> REQUIRED type ID .)
    COMMA           reduce using rule 80 (parameter -> REQUIRED type ID .)


state 251

    (32) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET . statement_list RBRACKET
    (36) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET . RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 279
    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement_list                 shift and go to state 278
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 252

    (34) function -> VOID ID LPAREN RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 280
    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement                      shift and go to state 42
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 253

    (35) function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .

    COMMENT_MULTI   reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    COMMENT_SINGLE  reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    SEMICOLON       reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    PRINT           reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    STRING          reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    VAR             reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    FINAL           reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    ID              reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    VOID            reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    LIST            reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    DYNAMIC         reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    MAP             reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    WHILE           reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    INT             reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    DOUBLE          reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    BOOL            reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    IF              reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    FOR             reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    $end            reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)


state 254

    (82) list_definition -> LIST LESS type GREATER ID ASSIGN . LSBRACKET value_list RSBRACKET SEMICOLON

    LSBRACKET       shift and go to state 281


state 255

    (127) map_declaration -> MAP LESS key_type COMMA type GREATER . ID ASSIGN

    ID              shift and go to state 282


state 256

    (64) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 283


state 257

    (63) else_if_blocks -> ELSE IF LPAREN conditions RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 284


state 258

    (125) control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)


state 259

    (62) if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 285
    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement                      shift and go to state 42
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 260

    (111) for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 286
    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement                      shift and go to state 42
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 261

    (113) for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 287
    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement                      shift and go to state 42
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 262

    (117) for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 288
    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement                      shift and go to state 42
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 263

    (110) for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON . for_classic_changes
    (106) for_classic_changes -> . ID comparator value
    (107) for_classic_changes -> . ID INCREMENT
    (108) for_classic_changes -> . ID DECREMENT
    (109) for_classic_changes -> . ID comparator value COMMA for_classic_changes

    ID              shift and go to state 290

    for_classic_changes            shift and go to state 289

state 264

    (112) for_in_parenthesis_content -> FINAL ID IN ID .

    RPAREN          reduce using rule 112 (for_in_parenthesis_content -> FINAL ID IN ID .)


state 265

    (116) for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content . RPAREN IN ID

    RPAREN          shift and go to state 291


state 266

    (114) for_each_parenthesis_parenthesis_content -> COLON . ID
    (115) for_each_parenthesis_parenthesis_content -> COLON . ID COMMA for_each_parenthesis_parenthesis_content

    ID              shift and go to state 292


state 267

    (103) for_classic_initialization -> INT ID ASSIGN NUMBER .

    SEMICOLON       reduce using rule 103 (for_classic_initialization -> INT ID ASSIGN NUMBER .)


state 268

    (104) for_classic_initialization -> DOUBLE ID ASSIGN NDOUBLE .

    SEMICOLON       reduce using rule 104 (for_classic_initialization -> DOUBLE ID ASSIGN NDOUBLE .)


state 269

    (25) data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 293


state 270

    (26) data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 294


state 271

    (122) constructor_parenthesis_content -> THIS DOT ID COMMA constructor_parenthesis_content .

    RPAREN          reduce using rule 122 (constructor_parenthesis_content -> THIS DOT ID COMMA constructor_parenthesis_content .)


state 272

    (100) set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .

    COMMENT_MULTI   reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    SEMICOLON       reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    PRINT           reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    STRING          reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    VAR             reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    FINAL           reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    ID              reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    VOID            reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    LIST            reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    MAP             reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    WHILE           reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    INT             reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    BOOL            reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    IF              reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    FOR             reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    $end            reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    RBRACKET        reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)


state 273

    (101) set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 295


state 274

    (102) set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 296


state 275

    (31) function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 297
    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    type                           shift and go to state 27
    statement                      shift and go to state 42
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 276

    (124) function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER . expression
    (46) expression -> . operations
    (56) expression -> . conditions
    (57) expression -> . value
    (47) operations -> . operation
    (48) operations -> . operation operand operations
    (66) conditions -> . condition
    (67) conditions -> . condition AND conditions
    (68) conditions -> . condition OR conditions
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE
    (49) operation -> . operand operator operand
    (69) condition -> . value comparator value
    (70) condition -> . NOT condition
    (50) operand -> . NUMBER
    (51) operand -> . DOUBLE

    NUMBER          shift and go to state 80
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83
    NOT             shift and go to state 85
    DOUBLE          shift and go to state 86

    expression                     shift and go to state 298
    operations                     shift and go to state 71
    conditions                     shift and go to state 72
    value                          shift and go to state 73
    operation                      shift and go to state 77
    operand                        shift and go to state 78
    condition                      shift and go to state 79

state 277

    (33) function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)


state 278

    (32) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 299
    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement                      shift and go to state 42
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 279

    (36) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .

    COMMENT_MULTI   reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    COMMENT_SINGLE  reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    SEMICOLON       reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    PRINT           reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    STRING          reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    VAR             reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    FINAL           reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    ID              reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    VOID            reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    LIST            reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    DYNAMIC         reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    MAP             reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    WHILE           reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    INT             reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    DOUBLE          reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    BOOL            reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    IF              reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    FOR             reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    $end            reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)


state 280

    (34) function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)


state 281

    (82) list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET . value_list RSBRACKET SEMICOLON
    (83) value_list -> . value
    (84) value_list -> . value COMMA value_list
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83

    value_list                     shift and go to state 300
    value                          shift and go to state 151

state 282

    (127) map_declaration -> MAP LESS key_type COMMA type GREATER ID . ASSIGN

    ASSIGN          shift and go to state 301


state 283

    (64) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 302


state 284

    (63) else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement_list                 shift and go to state 303
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 285

    (62) if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .

    ELSE            reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_MULTI   reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)


state 286

    (111) for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)


state 287

    (113) for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)


state 288

    (117) for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)


state 289

    (110) for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON for_classic_changes .

    RPAREN          reduce using rule 110 (for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON for_classic_changes .)


state 290

    (106) for_classic_changes -> ID . comparator value
    (107) for_classic_changes -> ID . INCREMENT
    (108) for_classic_changes -> ID . DECREMENT
    (109) for_classic_changes -> ID . comparator value COMMA for_classic_changes
    (71) comparator -> . GREATER
    (72) comparator -> . LESS
    (73) comparator -> . EQUALS
    (74) comparator -> . GREATER_EQUAL
    (75) comparator -> . LESS_EQUAL
    (76) comparator -> . NOT_EQUALS

    INCREMENT       shift and go to state 305
    DECREMENT       shift and go to state 306
    GREATER         shift and go to state 131
    LESS            shift and go to state 132
    EQUALS          shift and go to state 133
    GREATER_EQUAL   shift and go to state 134
    LESS_EQUAL      shift and go to state 135
    NOT_EQUALS      shift and go to state 136

    comparator                     shift and go to state 304

state 291

    (116) for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN . IN ID

    IN              shift and go to state 307


state 292

    (114) for_each_parenthesis_parenthesis_content -> COLON ID .
    (115) for_each_parenthesis_parenthesis_content -> COLON ID . COMMA for_each_parenthesis_parenthesis_content

    RPAREN          reduce using rule 114 (for_each_parenthesis_parenthesis_content -> COLON ID .)
    COMMA           shift and go to state 308


state 293

    (25) data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 309


state 294

    (26) data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 310


state 295

    (101) set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 311


state 296

    (102) set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .

    COMMENT_MULTI   reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    SEMICOLON       reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    PRINT           reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    STRING          reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    VAR             reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    FINAL           reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    ID              reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    VOID            reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    LIST            reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    MAP             reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    WHILE           reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    INT             reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    BOOL            reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    IF              reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    FOR             reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    $end            reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    RBRACKET        reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)


state 297

    (31) function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)


state 298

    (124) function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .

    COMMENT_MULTI   reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    COMMENT_SINGLE  reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    SEMICOLON       reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    PRINT           reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    STRING          reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    VAR             reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    FINAL           reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    ID              reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    VOID            reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    LIST            reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    DYNAMIC         reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    MAP             reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    WHILE           reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    INT             reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    DOUBLE          reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    BOOL            reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    IF              reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    FOR             reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    $end            reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    RBRACKET        reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)


state 299

    (32) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)


state 300

    (82) list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list . RSBRACKET SEMICOLON

    RSBRACKET       shift and go to state 312


state 301

    (127) map_declaration -> MAP LESS key_type COMMA type GREATER ID ASSIGN .

    LBRACKET        reduce using rule 127 (map_declaration -> MAP LESS key_type COMMA type GREATER ID ASSIGN .)


state 302

    (64) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement_list                 shift and go to state 313
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 303

    (63) else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 314
    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement                      shift and go to state 42
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 304

    (106) for_classic_changes -> ID comparator . value
    (109) for_classic_changes -> ID comparator . value COMMA for_classic_changes
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83

    value                          shift and go to state 315

state 305

    (107) for_classic_changes -> ID INCREMENT .

    RPAREN          reduce using rule 107 (for_classic_changes -> ID INCREMENT .)


state 306

    (108) for_classic_changes -> ID DECREMENT .

    RPAREN          reduce using rule 108 (for_classic_changes -> ID DECREMENT .)


state 307

    (116) for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN . ID

    ID              shift and go to state 316


state 308

    (115) for_each_parenthesis_parenthesis_content -> COLON ID COMMA . for_each_parenthesis_parenthesis_content
    (114) for_each_parenthesis_parenthesis_content -> . COLON ID
    (115) for_each_parenthesis_parenthesis_content -> . COLON ID COMMA for_each_parenthesis_parenthesis_content

    COLON           shift and go to state 266

    for_each_parenthesis_parenthesis_content shift and go to state 317

state 309

    (25) data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .

    COMMENT_MULTI   reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)


state 310

    (26) data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 318


state 311

    (101) set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .

    COMMENT_MULTI   reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    SEMICOLON       reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    PRINT           reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    STRING          reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    VAR             reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    FINAL           reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    ID              reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    VOID            reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    LIST            reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    MAP             reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    WHILE           reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    INT             reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    BOOL            reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    IF              reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    FOR             reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    $end            reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    RBRACKET        reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)


state 312

    (82) list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 319


state 313

    (64) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 320
    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement                      shift and go to state 42
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 314

    (63) else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .

    ELSE            reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_MULTI   reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)


state 315

    (106) for_classic_changes -> ID comparator value .
    (109) for_classic_changes -> ID comparator value . COMMA for_classic_changes

    RPAREN          reduce using rule 106 (for_classic_changes -> ID comparator value .)
    COMMA           shift and go to state 321


state 316

    (116) for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID .

    RPAREN          reduce using rule 116 (for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID .)


state 317

    (115) for_each_parenthesis_parenthesis_content -> COLON ID COMMA for_each_parenthesis_parenthesis_content .

    RPAREN          reduce using rule 115 (for_each_parenthesis_parenthesis_content -> COLON ID COMMA for_each_parenthesis_parenthesis_content .)


state 318

    (26) data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .

    COMMENT_MULTI   reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)


state 319

    (82) list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .

    COMMENT_MULTI   reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    SEMICOLON       reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    PRINT           reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    STRING          reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    VAR             reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    FINAL           reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    ID              reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    VOID            reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    LIST            reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    MAP             reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    WHILE           reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    INT             reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    BOOL            reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    IF              reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    FOR             reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    $end            reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    RBRACKET        reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)


state 320

    (64) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .

    ELSE            reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_MULTI   reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)


state 321

    (109) for_classic_changes -> ID comparator value COMMA . for_classic_changes
    (106) for_classic_changes -> . ID comparator value
    (107) for_classic_changes -> . ID INCREMENT
    (108) for_classic_changes -> . ID DECREMENT
    (109) for_classic_changes -> . ID comparator value COMMA for_classic_changes

    ID              shift and go to state 290

    for_classic_changes            shift and go to state 322

state 322

    (109) for_classic_changes -> ID comparator value COMMA for_classic_changes .

    RPAREN          reduce using rule 109 (for_classic_changes -> ID comparator value COMMA for_classic_changes .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 19 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 75 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 77 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 192 resolved as shift
WARNING: reduce/reduce conflict in state 75 resolved using rule (string_part -> TEXT)
WARNING: rejected rule (value -> TEXT) in state 75
