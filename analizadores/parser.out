Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AS
    ASSERT
    ASYNC
    AWAIT
    BREAK
    CASE
    CATCH
    CLASS
    CONTINUE
    COVARIANT
    DEFAULT
    DEFERRED
    DO
    DOLLARSIGN
    DOUBLE_COLON
    ENUM
    EXPORT
    EXTENDS
    EXTENSION
    EXTERNAL
    FACTORY
    FINALLY
    FUNCTION
    GET
    HIDE
    IMPLEMENTS
    IMPORT
    INTERFACE
    IS
    LATE
    LIBRARY
    MIXIN
    MODULE
    NEW
    NULL
    NUM
    NUMERAL
    OBJECT
    ON
    OPERATOR
    PART
    RETHROW
    RETURN
    SET
    SHOW
    STATIC
    SUPER
    SWITCH
    SYNC
    THROW
    TRY
    TYPEDEF
    WITH
    YIELD

Grammar

Rule 0     S' -> program
Rule 1     program -> statement_list
Rule 2     statement_list -> statement
Rule 3     statement_list -> statement_list statement
Rule 4     statement -> print
Rule 5     statement -> data_input
Rule 6     statement -> set
Rule 7     statement -> map
Rule 8     statement -> constructor
Rule 9     statement -> control_structures
Rule 10    statement -> function
Rule 11    statement -> list_definition
Rule 12    statement -> variable_definition
Rule 13    statement -> variable_usage
Rule 14    statement -> call_function
Rule 15    statement -> SEMICOLON
Rule 16    control_structures -> control_structures_if_else
Rule 17    control_structures -> control_structures_for
Rule 18    control_structures -> control_structures_while
Rule 19    variable_usage -> ID
Rule 20    call_function -> ID LPAREN argument_list RPAREN
Rule 21    call_function -> ID LPAREN RPAREN
Rule 22    data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
Rule 23    data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
Rule 24    length -> call_list DOT LENGTH
Rule 25    length -> TEXT DOT LENGTH
Rule 26    argument_list -> expression
Rule 27    argument_list -> argument_list COMMA expression
Rule 28    function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
Rule 29    function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
Rule 30    function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
Rule 31    function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
Rule 32    function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET
Rule 33    function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
Rule 34    variable_definition -> type ID ASSIGN expression SEMICOLON
Rule 35    variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON
Rule 36    variable_definition -> VAR ID ASSIGN expression SEMICOLON
Rule 37    variable_definition -> INT ID ASSIGN length SEMICOLON
Rule 38    variable_definition -> INT ID ASSIGN NUMBER SEMICOLON
Rule 39    variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON
Rule 40    print -> PRINT LPAREN RPAREN SEMICOLON
Rule 41    print -> PRINT LPAREN value RPAREN SEMICOLON
Rule 42    print -> PRINT LPAREN expression RPAREN SEMICOLON
Rule 43    print -> PRINT LPAREN length RPAREN SEMICOLON
Rule 44    expression -> expression PLUS expression
Rule 45    expression -> expression MINUS expression
Rule 46    expression -> expression TIMES expression
Rule 47    expression -> expression DIVIDE expression
Rule 48    expression -> expression AND expression
Rule 49    expression -> expression OR expression
Rule 50    expression -> value comparator value
Rule 51    expression -> value PLUS value
Rule 52    expression -> value
Rule 53    control_structures_if_else -> if_block
Rule 54    control_structures_if_else -> if_block else_if_blocks
Rule 55    control_structures_if_else -> if_block else_if_blocks else_block
Rule 56    control_structures_if_else -> if_block else_block
Rule 57    if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
Rule 58    else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
Rule 59    else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
Rule 60    else_block -> ELSE LBRACKET statement_list RBRACKET
Rule 61    conditions -> condition
Rule 62    conditions -> conditions AND conditions
Rule 63    conditions -> conditions OR conditions
Rule 64    condition -> value comparator value
Rule 65    condition -> NOT condition
Rule 66    condition -> LPAREN conditions RPAREN
Rule 67    comparator -> GREATER
Rule 68    comparator -> LESS
Rule 69    comparator -> EQUALS
Rule 70    comparator -> GREATER_EQUAL
Rule 71    comparator -> LESS_EQUAL
Rule 72    comparator -> NOT_EQUALS
Rule 73    parameter_list -> parameter
Rule 74    parameter_list -> parameter_list COMMA parameter
Rule 75    parameter -> type ID
Rule 76    parameter -> REQUIRED type ID
Rule 77    type -> INT
Rule 78    type -> DOUBLE
Rule 79    type -> STRING
Rule 80    type -> BOOL
Rule 81    type -> LIST
Rule 82    call_list -> LSBRACKET value_list RSBRACKET
Rule 83    list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
Rule 84    value_list -> value
Rule 85    value_list -> value_list COMMA value
Rule 86    value -> NUMBER
Rule 87    value -> NDOUBLE
Rule 88    value -> TEXT
Rule 89    value -> ID
Rule 90    value -> interpolated_string
Rule 91    value -> TRUE
Rule 92    value -> FALSE
Rule 93    interpolated_string -> TEXT PLUS ID
Rule 94    interpolated_string -> TEXT PLUS expression
Rule 95    set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
Rule 96    set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
Rule 97    set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
Rule 98    for_classic_initialization -> INT ID ASSIGN NUMBER
Rule 99    for_classic_initialization -> DOUBLE ID ASSIGN NDOUBLE
Rule 100   for_classic_conditions -> conditions
Rule 101   for_classic_changes -> ID comparator value
Rule 102   for_classic_changes -> ID INCREMENT
Rule 103   for_classic_changes -> ID DECREMENT
Rule 104   for_classic_changes -> ID comparator value COMMA for_classic_changes
Rule 105   for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON for_classic_changes
Rule 106   for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
Rule 107   for_in_parenthesis_content -> FINAL ID IN ID
Rule 108   for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
Rule 109   for_each_parenthesis_parenthesis_content -> COLON ID
Rule 110   for_each_parenthesis_parenthesis_content -> COLON ID COMMA for_each_parenthesis_parenthesis_content
Rule 111   for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID
Rule 112   for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
Rule 113   control_structures_for -> for_classic
Rule 114   control_structures_for -> for_in
Rule 115   control_structures_for -> for_each
Rule 116   constructor_parenthesis_content -> THIS DOT ID
Rule 117   constructor_parenthesis_content -> THIS DOT ID COMMA constructor_parenthesis_content
Rule 118   constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
Rule 119   function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
Rule 120   control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET
Rule 121   map -> map_declaration map_assignment
Rule 122   map_declaration -> MAP LESS key_type COMMA type GREATER ID ASSIGN
Rule 123   map_assignment -> LBRACKET map_contents RBRACKET
Rule 124   map_contents -> map_content
Rule 125   map_contents -> map_content COMMA map_contents
Rule 126   map_content -> key_value COLON value
Rule 127   key_value -> TEXT
Rule 128   key_type -> STRING

Terminals, with rules where they appear

ABSTRACT             : 
AND                  : 48 62
AS                   : 
ASSERT               : 
ASSIGN               : 22 23 34 35 36 37 38 39 83 95 96 97 98 99 119 122
ASYNC                : 
AWAIT                : 
BOOL                 : 80
BREAK                : 
CASE                 : 
CATCH                : 
CLASS                : 
COLON                : 109 110 126
COMMA                : 27 74 85 104 110 117 122 125
CONST                : 97
CONTINUE             : 
COVARIANT            : 
DECREMENT            : 103
DEFAULT              : 
DEFERRED             : 
DIVIDE               : 47
DO                   : 
DOLLARSIGN           : 
DOT                  : 22 23 24 25 116 117
DOUBLE               : 39 78 99
DOUBLE_COLON         : 
DYNAMIC              : 35
ELSE                 : 58 59 60
ENUM                 : 
EQUALS               : 69
EXPORT               : 
EXTENDS              : 
EXTENSION            : 
EXTERNAL             : 
FACTORY              : 
FALSE                : 92
FINAL                : 97 107 111
FINALLY              : 
FOR                  : 106 108 112
FUNCTION             : 
GET                  : 
GREATER              : 67 83 96 119 122
GREATER_EQUAL        : 70
HIDE                 : 
ID                   : 19 20 21 22 23 28 29 30 31 32 33 34 35 36 37 38 39 75 76 83 89 93 95 96 97 98 99 101 102 103 104 107 107 109 110 111 111 116 117 118 119 122
IF                   : 57 58 59
IMPLEMENTS           : 
IMPORT               : 
IN                   : 107 111
INCREMENT            : 102
INT                  : 37 38 77 98
INTERFACE            : 
IS                   : 
LATE                 : 
LBRACKET             : 28 29 30 31 32 33 57 58 59 60 95 96 97 106 108 112 120 123
LENGTH               : 24 25
LESS                 : 68 83 96 122
LESS_EQUAL           : 71
LIBRARY              : 
LIST                 : 81 83
LPAREN               : 20 21 22 23 28 29 30 31 32 33 40 41 42 43 57 58 59 66 106 108 111 112 118 119 120
LSBRACKET            : 82 83
MAP                  : 122
MINUS                : 45
MIXIN                : 
MODULE               : 
NDOUBLE              : 39 87 99
NEW                  : 
NOT                  : 65
NOT_EQUALS           : 72
NULL                 : 
NUM                  : 
NUMBER               : 38 86 98
NUMERAL              : 
OBJECT               : 
ON                   : 
OPERATOR             : 
OR                   : 49 63
PART                 : 
PLUS                 : 44 51 93 94
PRINT                : 40 41 42 43
QUESTION             : 23
RBRACKET             : 28 29 30 31 32 33 57 58 59 60 95 96 97 106 108 112 120 123
READLINESYNC         : 22 23
REQUIRED             : 76
RETHROW              : 
RETURN               : 
RPAREN               : 20 21 22 23 28 29 30 31 32 33 40 41 42 43 57 58 59 66 106 108 111 112 118 119
RSBRACKET            : 82 83
SEMICOLON            : 15 22 23 34 35 36 37 38 39 40 41 42 43 83 95 96 97 105 105 118
SET                  : 
SHOW                 : 
STATIC               : 
STDIN                : 22 23
STRING               : 22 23 79 96 128
SUPER                : 
SWITCH               : 
SYNC                 : 
TEXT                 : 25 88 93 94 127
THIS                 : 116 117
THROW                : 
TIMES                : 46
TRUE                 : 91
TRY                  : 
TYPEDEF              : 
VAR                  : 36 95 96
VOID                 : 29 31 32 33
WHILE                : 120
WITH                 : 
YIELD                : 
error                : 

Nonterminals, with rules where they appear

argument_list        : 20 27
call_function        : 14
call_list            : 24
comparator           : 50 64 101 104
condition            : 61 65
conditions           : 57 58 59 62 62 63 63 66 100 120
constructor          : 8
constructor_parenthesis_content : 117 118
control_structures   : 9
control_structures_for : 17
control_structures_if_else : 16
control_structures_while : 18
data_input           : 5
else_block           : 55 56
else_if_blocks       : 54 55 59
expression           : 26 27 34 35 36 42 44 44 45 45 46 46 47 47 48 48 49 49 94 119
for_classic          : 113
for_classic_changes  : 104 105
for_classic_conditions : 105
for_classic_initialization : 105
for_classic_parenthesis_content : 106
for_each             : 115
for_each_parenthesis_content : 112
for_each_parenthesis_parenthesis_content : 110 111
for_in               : 114
for_in_parenthesis_content : 108
function             : 10
if_block             : 53 54 55 56
interpolated_string  : 90
key_type             : 122
key_value            : 126
length               : 37 43
list_definition      : 11
map                  : 7
map_assignment       : 121
map_content          : 124 125
map_contents         : 123 125
map_declaration      : 121
parameter            : 73 74
parameter_list       : 28 29 33 74 119
print                : 4
program              : 0
set                  : 6
statement            : 2 3
statement_list       : 1 3 28 29 30 31 57 58 59 60 106 108 112 120
type                 : 28 30 34 75 76 83 119 122
value                : 41 50 50 51 51 52 64 64 84 85 101 104 126
value_list           : 82 83 85 95 97
variable_definition  : 12
variable_usage       : 13

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement_list
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (95) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (96) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (97) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (121) map -> . map_declaration map_assignment
    (118) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (119) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (122) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (53) control_structures_if_else -> . if_block
    (54) control_structures_if_else -> . if_block else_if_blocks
    (55) control_structures_if_else -> . if_block else_if_blocks else_block
    (56) control_structures_if_else -> . if_block else_block
    (113) control_structures_for -> . for_classic
    (114) control_structures_for -> . for_in
    (115) control_structures_for -> . for_each
    (120) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (77) type -> . INT
    (78) type -> . DOUBLE
    (79) type -> . STRING
    (80) type -> . BOOL
    (81) type -> . LIST
    (57) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (106) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (112) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    program                        shift and go to state 1
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 1

    (0) S' -> program .



state 2

    (1) program -> statement_list .
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (95) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (96) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (97) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (121) map -> . map_declaration map_assignment
    (118) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (119) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (122) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (53) control_structures_if_else -> . if_block
    (54) control_structures_if_else -> . if_block else_if_blocks
    (55) control_structures_if_else -> . if_block else_if_blocks else_block
    (56) control_structures_if_else -> . if_block else_block
    (113) control_structures_for -> . for_classic
    (114) control_structures_for -> . for_in
    (115) control_structures_for -> . for_each
    (120) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (77) type -> . INT
    (78) type -> . DOUBLE
    (79) type -> . STRING
    (80) type -> . BOOL
    (81) type -> . LIST
    (57) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (106) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (112) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    $end            reduce using rule 1 (program -> statement_list .)
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement                      shift and go to state 40
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 3

    (2) statement_list -> statement .

    SEMICOLON       reduce using rule 2 (statement_list -> statement .)
    PRINT           reduce using rule 2 (statement_list -> statement .)
    STRING          reduce using rule 2 (statement_list -> statement .)
    VAR             reduce using rule 2 (statement_list -> statement .)
    FINAL           reduce using rule 2 (statement_list -> statement .)
    ID              reduce using rule 2 (statement_list -> statement .)
    VOID            reduce using rule 2 (statement_list -> statement .)
    LIST            reduce using rule 2 (statement_list -> statement .)
    DYNAMIC         reduce using rule 2 (statement_list -> statement .)
    INT             reduce using rule 2 (statement_list -> statement .)
    DOUBLE          reduce using rule 2 (statement_list -> statement .)
    MAP             reduce using rule 2 (statement_list -> statement .)
    WHILE           reduce using rule 2 (statement_list -> statement .)
    BOOL            reduce using rule 2 (statement_list -> statement .)
    IF              reduce using rule 2 (statement_list -> statement .)
    FOR             reduce using rule 2 (statement_list -> statement .)
    $end            reduce using rule 2 (statement_list -> statement .)
    RBRACKET        reduce using rule 2 (statement_list -> statement .)


state 4

    (4) statement -> print .

    SEMICOLON       reduce using rule 4 (statement -> print .)
    PRINT           reduce using rule 4 (statement -> print .)
    STRING          reduce using rule 4 (statement -> print .)
    VAR             reduce using rule 4 (statement -> print .)
    FINAL           reduce using rule 4 (statement -> print .)
    ID              reduce using rule 4 (statement -> print .)
    VOID            reduce using rule 4 (statement -> print .)
    LIST            reduce using rule 4 (statement -> print .)
    DYNAMIC         reduce using rule 4 (statement -> print .)
    INT             reduce using rule 4 (statement -> print .)
    DOUBLE          reduce using rule 4 (statement -> print .)
    MAP             reduce using rule 4 (statement -> print .)
    WHILE           reduce using rule 4 (statement -> print .)
    BOOL            reduce using rule 4 (statement -> print .)
    IF              reduce using rule 4 (statement -> print .)
    FOR             reduce using rule 4 (statement -> print .)
    $end            reduce using rule 4 (statement -> print .)
    RBRACKET        reduce using rule 4 (statement -> print .)


state 5

    (5) statement -> data_input .

    SEMICOLON       reduce using rule 5 (statement -> data_input .)
    PRINT           reduce using rule 5 (statement -> data_input .)
    STRING          reduce using rule 5 (statement -> data_input .)
    VAR             reduce using rule 5 (statement -> data_input .)
    FINAL           reduce using rule 5 (statement -> data_input .)
    ID              reduce using rule 5 (statement -> data_input .)
    VOID            reduce using rule 5 (statement -> data_input .)
    LIST            reduce using rule 5 (statement -> data_input .)
    DYNAMIC         reduce using rule 5 (statement -> data_input .)
    INT             reduce using rule 5 (statement -> data_input .)
    DOUBLE          reduce using rule 5 (statement -> data_input .)
    MAP             reduce using rule 5 (statement -> data_input .)
    WHILE           reduce using rule 5 (statement -> data_input .)
    BOOL            reduce using rule 5 (statement -> data_input .)
    IF              reduce using rule 5 (statement -> data_input .)
    FOR             reduce using rule 5 (statement -> data_input .)
    $end            reduce using rule 5 (statement -> data_input .)
    RBRACKET        reduce using rule 5 (statement -> data_input .)


state 6

    (6) statement -> set .

    SEMICOLON       reduce using rule 6 (statement -> set .)
    PRINT           reduce using rule 6 (statement -> set .)
    STRING          reduce using rule 6 (statement -> set .)
    VAR             reduce using rule 6 (statement -> set .)
    FINAL           reduce using rule 6 (statement -> set .)
    ID              reduce using rule 6 (statement -> set .)
    VOID            reduce using rule 6 (statement -> set .)
    LIST            reduce using rule 6 (statement -> set .)
    DYNAMIC         reduce using rule 6 (statement -> set .)
    INT             reduce using rule 6 (statement -> set .)
    DOUBLE          reduce using rule 6 (statement -> set .)
    MAP             reduce using rule 6 (statement -> set .)
    WHILE           reduce using rule 6 (statement -> set .)
    BOOL            reduce using rule 6 (statement -> set .)
    IF              reduce using rule 6 (statement -> set .)
    FOR             reduce using rule 6 (statement -> set .)
    $end            reduce using rule 6 (statement -> set .)
    RBRACKET        reduce using rule 6 (statement -> set .)


state 7

    (7) statement -> map .

    SEMICOLON       reduce using rule 7 (statement -> map .)
    PRINT           reduce using rule 7 (statement -> map .)
    STRING          reduce using rule 7 (statement -> map .)
    VAR             reduce using rule 7 (statement -> map .)
    FINAL           reduce using rule 7 (statement -> map .)
    ID              reduce using rule 7 (statement -> map .)
    VOID            reduce using rule 7 (statement -> map .)
    LIST            reduce using rule 7 (statement -> map .)
    DYNAMIC         reduce using rule 7 (statement -> map .)
    INT             reduce using rule 7 (statement -> map .)
    DOUBLE          reduce using rule 7 (statement -> map .)
    MAP             reduce using rule 7 (statement -> map .)
    WHILE           reduce using rule 7 (statement -> map .)
    BOOL            reduce using rule 7 (statement -> map .)
    IF              reduce using rule 7 (statement -> map .)
    FOR             reduce using rule 7 (statement -> map .)
    $end            reduce using rule 7 (statement -> map .)
    RBRACKET        reduce using rule 7 (statement -> map .)


state 8

    (8) statement -> constructor .

    SEMICOLON       reduce using rule 8 (statement -> constructor .)
    PRINT           reduce using rule 8 (statement -> constructor .)
    STRING          reduce using rule 8 (statement -> constructor .)
    VAR             reduce using rule 8 (statement -> constructor .)
    FINAL           reduce using rule 8 (statement -> constructor .)
    ID              reduce using rule 8 (statement -> constructor .)
    VOID            reduce using rule 8 (statement -> constructor .)
    LIST            reduce using rule 8 (statement -> constructor .)
    DYNAMIC         reduce using rule 8 (statement -> constructor .)
    INT             reduce using rule 8 (statement -> constructor .)
    DOUBLE          reduce using rule 8 (statement -> constructor .)
    MAP             reduce using rule 8 (statement -> constructor .)
    WHILE           reduce using rule 8 (statement -> constructor .)
    BOOL            reduce using rule 8 (statement -> constructor .)
    IF              reduce using rule 8 (statement -> constructor .)
    FOR             reduce using rule 8 (statement -> constructor .)
    $end            reduce using rule 8 (statement -> constructor .)
    RBRACKET        reduce using rule 8 (statement -> constructor .)


state 9

    (9) statement -> control_structures .

    SEMICOLON       reduce using rule 9 (statement -> control_structures .)
    PRINT           reduce using rule 9 (statement -> control_structures .)
    STRING          reduce using rule 9 (statement -> control_structures .)
    VAR             reduce using rule 9 (statement -> control_structures .)
    FINAL           reduce using rule 9 (statement -> control_structures .)
    ID              reduce using rule 9 (statement -> control_structures .)
    VOID            reduce using rule 9 (statement -> control_structures .)
    LIST            reduce using rule 9 (statement -> control_structures .)
    DYNAMIC         reduce using rule 9 (statement -> control_structures .)
    INT             reduce using rule 9 (statement -> control_structures .)
    DOUBLE          reduce using rule 9 (statement -> control_structures .)
    MAP             reduce using rule 9 (statement -> control_structures .)
    WHILE           reduce using rule 9 (statement -> control_structures .)
    BOOL            reduce using rule 9 (statement -> control_structures .)
    IF              reduce using rule 9 (statement -> control_structures .)
    FOR             reduce using rule 9 (statement -> control_structures .)
    $end            reduce using rule 9 (statement -> control_structures .)
    RBRACKET        reduce using rule 9 (statement -> control_structures .)


state 10

    (10) statement -> function .

    SEMICOLON       reduce using rule 10 (statement -> function .)
    PRINT           reduce using rule 10 (statement -> function .)
    STRING          reduce using rule 10 (statement -> function .)
    VAR             reduce using rule 10 (statement -> function .)
    FINAL           reduce using rule 10 (statement -> function .)
    ID              reduce using rule 10 (statement -> function .)
    VOID            reduce using rule 10 (statement -> function .)
    LIST            reduce using rule 10 (statement -> function .)
    DYNAMIC         reduce using rule 10 (statement -> function .)
    INT             reduce using rule 10 (statement -> function .)
    DOUBLE          reduce using rule 10 (statement -> function .)
    MAP             reduce using rule 10 (statement -> function .)
    WHILE           reduce using rule 10 (statement -> function .)
    BOOL            reduce using rule 10 (statement -> function .)
    IF              reduce using rule 10 (statement -> function .)
    FOR             reduce using rule 10 (statement -> function .)
    $end            reduce using rule 10 (statement -> function .)
    RBRACKET        reduce using rule 10 (statement -> function .)


state 11

    (11) statement -> list_definition .

    SEMICOLON       reduce using rule 11 (statement -> list_definition .)
    PRINT           reduce using rule 11 (statement -> list_definition .)
    STRING          reduce using rule 11 (statement -> list_definition .)
    VAR             reduce using rule 11 (statement -> list_definition .)
    FINAL           reduce using rule 11 (statement -> list_definition .)
    ID              reduce using rule 11 (statement -> list_definition .)
    VOID            reduce using rule 11 (statement -> list_definition .)
    LIST            reduce using rule 11 (statement -> list_definition .)
    DYNAMIC         reduce using rule 11 (statement -> list_definition .)
    INT             reduce using rule 11 (statement -> list_definition .)
    DOUBLE          reduce using rule 11 (statement -> list_definition .)
    MAP             reduce using rule 11 (statement -> list_definition .)
    WHILE           reduce using rule 11 (statement -> list_definition .)
    BOOL            reduce using rule 11 (statement -> list_definition .)
    IF              reduce using rule 11 (statement -> list_definition .)
    FOR             reduce using rule 11 (statement -> list_definition .)
    $end            reduce using rule 11 (statement -> list_definition .)
    RBRACKET        reduce using rule 11 (statement -> list_definition .)


state 12

    (12) statement -> variable_definition .

    SEMICOLON       reduce using rule 12 (statement -> variable_definition .)
    PRINT           reduce using rule 12 (statement -> variable_definition .)
    STRING          reduce using rule 12 (statement -> variable_definition .)
    VAR             reduce using rule 12 (statement -> variable_definition .)
    FINAL           reduce using rule 12 (statement -> variable_definition .)
    ID              reduce using rule 12 (statement -> variable_definition .)
    VOID            reduce using rule 12 (statement -> variable_definition .)
    LIST            reduce using rule 12 (statement -> variable_definition .)
    DYNAMIC         reduce using rule 12 (statement -> variable_definition .)
    INT             reduce using rule 12 (statement -> variable_definition .)
    DOUBLE          reduce using rule 12 (statement -> variable_definition .)
    MAP             reduce using rule 12 (statement -> variable_definition .)
    WHILE           reduce using rule 12 (statement -> variable_definition .)
    BOOL            reduce using rule 12 (statement -> variable_definition .)
    IF              reduce using rule 12 (statement -> variable_definition .)
    FOR             reduce using rule 12 (statement -> variable_definition .)
    $end            reduce using rule 12 (statement -> variable_definition .)
    RBRACKET        reduce using rule 12 (statement -> variable_definition .)


state 13

    (13) statement -> variable_usage .

    SEMICOLON       reduce using rule 13 (statement -> variable_usage .)
    PRINT           reduce using rule 13 (statement -> variable_usage .)
    STRING          reduce using rule 13 (statement -> variable_usage .)
    VAR             reduce using rule 13 (statement -> variable_usage .)
    FINAL           reduce using rule 13 (statement -> variable_usage .)
    ID              reduce using rule 13 (statement -> variable_usage .)
    VOID            reduce using rule 13 (statement -> variable_usage .)
    LIST            reduce using rule 13 (statement -> variable_usage .)
    DYNAMIC         reduce using rule 13 (statement -> variable_usage .)
    INT             reduce using rule 13 (statement -> variable_usage .)
    DOUBLE          reduce using rule 13 (statement -> variable_usage .)
    MAP             reduce using rule 13 (statement -> variable_usage .)
    WHILE           reduce using rule 13 (statement -> variable_usage .)
    BOOL            reduce using rule 13 (statement -> variable_usage .)
    IF              reduce using rule 13 (statement -> variable_usage .)
    FOR             reduce using rule 13 (statement -> variable_usage .)
    $end            reduce using rule 13 (statement -> variable_usage .)
    RBRACKET        reduce using rule 13 (statement -> variable_usage .)


state 14

    (14) statement -> call_function .

    SEMICOLON       reduce using rule 14 (statement -> call_function .)
    PRINT           reduce using rule 14 (statement -> call_function .)
    STRING          reduce using rule 14 (statement -> call_function .)
    VAR             reduce using rule 14 (statement -> call_function .)
    FINAL           reduce using rule 14 (statement -> call_function .)
    ID              reduce using rule 14 (statement -> call_function .)
    VOID            reduce using rule 14 (statement -> call_function .)
    LIST            reduce using rule 14 (statement -> call_function .)
    DYNAMIC         reduce using rule 14 (statement -> call_function .)
    INT             reduce using rule 14 (statement -> call_function .)
    DOUBLE          reduce using rule 14 (statement -> call_function .)
    MAP             reduce using rule 14 (statement -> call_function .)
    WHILE           reduce using rule 14 (statement -> call_function .)
    BOOL            reduce using rule 14 (statement -> call_function .)
    IF              reduce using rule 14 (statement -> call_function .)
    FOR             reduce using rule 14 (statement -> call_function .)
    $end            reduce using rule 14 (statement -> call_function .)
    RBRACKET        reduce using rule 14 (statement -> call_function .)


state 15

    (15) statement -> SEMICOLON .

    SEMICOLON       reduce using rule 15 (statement -> SEMICOLON .)
    PRINT           reduce using rule 15 (statement -> SEMICOLON .)
    STRING          reduce using rule 15 (statement -> SEMICOLON .)
    VAR             reduce using rule 15 (statement -> SEMICOLON .)
    FINAL           reduce using rule 15 (statement -> SEMICOLON .)
    ID              reduce using rule 15 (statement -> SEMICOLON .)
    VOID            reduce using rule 15 (statement -> SEMICOLON .)
    LIST            reduce using rule 15 (statement -> SEMICOLON .)
    DYNAMIC         reduce using rule 15 (statement -> SEMICOLON .)
    INT             reduce using rule 15 (statement -> SEMICOLON .)
    DOUBLE          reduce using rule 15 (statement -> SEMICOLON .)
    MAP             reduce using rule 15 (statement -> SEMICOLON .)
    WHILE           reduce using rule 15 (statement -> SEMICOLON .)
    BOOL            reduce using rule 15 (statement -> SEMICOLON .)
    IF              reduce using rule 15 (statement -> SEMICOLON .)
    FOR             reduce using rule 15 (statement -> SEMICOLON .)
    $end            reduce using rule 15 (statement -> SEMICOLON .)
    RBRACKET        reduce using rule 15 (statement -> SEMICOLON .)


state 16

    (40) print -> PRINT . LPAREN RPAREN SEMICOLON
    (41) print -> PRINT . LPAREN value RPAREN SEMICOLON
    (42) print -> PRINT . LPAREN expression RPAREN SEMICOLON
    (43) print -> PRINT . LPAREN length RPAREN SEMICOLON

    LPAREN          shift and go to state 41


state 17

    (22) data_input -> STRING . ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> STRING . QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (79) type -> STRING .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 42
    QUESTION        shift and go to state 43

  ! ID              [ reduce using rule 79 (type -> STRING .) ]


state 18

    (118) constructor -> ID . LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (19) variable_usage -> ID .
    (20) call_function -> ID . LPAREN argument_list RPAREN
    (21) call_function -> ID . LPAREN RPAREN

    LPAREN          shift and go to state 44
    SEMICOLON       reduce using rule 19 (variable_usage -> ID .)
    PRINT           reduce using rule 19 (variable_usage -> ID .)
    STRING          reduce using rule 19 (variable_usage -> ID .)
    VAR             reduce using rule 19 (variable_usage -> ID .)
    FINAL           reduce using rule 19 (variable_usage -> ID .)
    ID              reduce using rule 19 (variable_usage -> ID .)
    VOID            reduce using rule 19 (variable_usage -> ID .)
    LIST            reduce using rule 19 (variable_usage -> ID .)
    DYNAMIC         reduce using rule 19 (variable_usage -> ID .)
    INT             reduce using rule 19 (variable_usage -> ID .)
    DOUBLE          reduce using rule 19 (variable_usage -> ID .)
    MAP             reduce using rule 19 (variable_usage -> ID .)
    WHILE           reduce using rule 19 (variable_usage -> ID .)
    BOOL            reduce using rule 19 (variable_usage -> ID .)
    IF              reduce using rule 19 (variable_usage -> ID .)
    FOR             reduce using rule 19 (variable_usage -> ID .)
    $end            reduce using rule 19 (variable_usage -> ID .)
    RBRACKET        reduce using rule 19 (variable_usage -> ID .)


state 19

    (95) set -> VAR . ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (96) set -> VAR . ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (36) variable_definition -> VAR . ID ASSIGN expression SEMICOLON

    ID              shift and go to state 45


state 20

    (97) set -> FINAL . ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON

    ID              shift and go to state 46


state 21

    (121) map -> map_declaration . map_assignment
    (123) map_assignment -> . LBRACKET map_contents RBRACKET

    LBRACKET        shift and go to state 48

    map_assignment                 shift and go to state 47

state 22

    (16) control_structures -> control_structures_if_else .

    SEMICOLON       reduce using rule 16 (control_structures -> control_structures_if_else .)
    PRINT           reduce using rule 16 (control_structures -> control_structures_if_else .)
    STRING          reduce using rule 16 (control_structures -> control_structures_if_else .)
    VAR             reduce using rule 16 (control_structures -> control_structures_if_else .)
    FINAL           reduce using rule 16 (control_structures -> control_structures_if_else .)
    ID              reduce using rule 16 (control_structures -> control_structures_if_else .)
    VOID            reduce using rule 16 (control_structures -> control_structures_if_else .)
    LIST            reduce using rule 16 (control_structures -> control_structures_if_else .)
    DYNAMIC         reduce using rule 16 (control_structures -> control_structures_if_else .)
    INT             reduce using rule 16 (control_structures -> control_structures_if_else .)
    DOUBLE          reduce using rule 16 (control_structures -> control_structures_if_else .)
    MAP             reduce using rule 16 (control_structures -> control_structures_if_else .)
    WHILE           reduce using rule 16 (control_structures -> control_structures_if_else .)
    BOOL            reduce using rule 16 (control_structures -> control_structures_if_else .)
    IF              reduce using rule 16 (control_structures -> control_structures_if_else .)
    FOR             reduce using rule 16 (control_structures -> control_structures_if_else .)
    $end            reduce using rule 16 (control_structures -> control_structures_if_else .)
    RBRACKET        reduce using rule 16 (control_structures -> control_structures_if_else .)


state 23

    (17) control_structures -> control_structures_for .

    SEMICOLON       reduce using rule 17 (control_structures -> control_structures_for .)
    PRINT           reduce using rule 17 (control_structures -> control_structures_for .)
    STRING          reduce using rule 17 (control_structures -> control_structures_for .)
    VAR             reduce using rule 17 (control_structures -> control_structures_for .)
    FINAL           reduce using rule 17 (control_structures -> control_structures_for .)
    ID              reduce using rule 17 (control_structures -> control_structures_for .)
    VOID            reduce using rule 17 (control_structures -> control_structures_for .)
    LIST            reduce using rule 17 (control_structures -> control_structures_for .)
    DYNAMIC         reduce using rule 17 (control_structures -> control_structures_for .)
    INT             reduce using rule 17 (control_structures -> control_structures_for .)
    DOUBLE          reduce using rule 17 (control_structures -> control_structures_for .)
    MAP             reduce using rule 17 (control_structures -> control_structures_for .)
    WHILE           reduce using rule 17 (control_structures -> control_structures_for .)
    BOOL            reduce using rule 17 (control_structures -> control_structures_for .)
    IF              reduce using rule 17 (control_structures -> control_structures_for .)
    FOR             reduce using rule 17 (control_structures -> control_structures_for .)
    $end            reduce using rule 17 (control_structures -> control_structures_for .)
    RBRACKET        reduce using rule 17 (control_structures -> control_structures_for .)


state 24

    (18) control_structures -> control_structures_while .

    SEMICOLON       reduce using rule 18 (control_structures -> control_structures_while .)
    PRINT           reduce using rule 18 (control_structures -> control_structures_while .)
    STRING          reduce using rule 18 (control_structures -> control_structures_while .)
    VAR             reduce using rule 18 (control_structures -> control_structures_while .)
    FINAL           reduce using rule 18 (control_structures -> control_structures_while .)
    ID              reduce using rule 18 (control_structures -> control_structures_while .)
    VOID            reduce using rule 18 (control_structures -> control_structures_while .)
    LIST            reduce using rule 18 (control_structures -> control_structures_while .)
    DYNAMIC         reduce using rule 18 (control_structures -> control_structures_while .)
    INT             reduce using rule 18 (control_structures -> control_structures_while .)
    DOUBLE          reduce using rule 18 (control_structures -> control_structures_while .)
    MAP             reduce using rule 18 (control_structures -> control_structures_while .)
    WHILE           reduce using rule 18 (control_structures -> control_structures_while .)
    BOOL            reduce using rule 18 (control_structures -> control_structures_while .)
    IF              reduce using rule 18 (control_structures -> control_structures_while .)
    FOR             reduce using rule 18 (control_structures -> control_structures_while .)
    $end            reduce using rule 18 (control_structures -> control_structures_while .)
    RBRACKET        reduce using rule 18 (control_structures -> control_structures_while .)


state 25

    (28) function -> type . ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> type . ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (119) function -> type . ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (34) variable_definition -> type . ID ASSIGN expression SEMICOLON

    ID              shift and go to state 49


state 26

    (29) function -> VOID . ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (31) function -> VOID . ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> VOID . ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> VOID . ID LPAREN parameter_list RPAREN LBRACKET RBRACKET

    ID              shift and go to state 50


state 27

    (83) list_definition -> LIST . LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (81) type -> LIST .

    LESS            shift and go to state 51
    ID              reduce using rule 81 (type -> LIST .)


state 28

    (35) variable_definition -> DYNAMIC . ID ASSIGN expression SEMICOLON

    ID              shift and go to state 52


state 29

    (37) variable_definition -> INT . ID ASSIGN length SEMICOLON
    (38) variable_definition -> INT . ID ASSIGN NUMBER SEMICOLON
    (77) type -> INT .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 53

  ! ID              [ reduce using rule 77 (type -> INT .) ]


state 30

    (39) variable_definition -> DOUBLE . ID ASSIGN NDOUBLE SEMICOLON
    (78) type -> DOUBLE .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 54

  ! ID              [ reduce using rule 78 (type -> DOUBLE .) ]


state 31

    (122) map_declaration -> MAP . LESS key_type COMMA type GREATER ID ASSIGN

    LESS            shift and go to state 55


state 32

    (53) control_structures_if_else -> if_block .
    (54) control_structures_if_else -> if_block . else_if_blocks
    (55) control_structures_if_else -> if_block . else_if_blocks else_block
    (56) control_structures_if_else -> if_block . else_block
    (58) else_if_blocks -> . ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (59) else_if_blocks -> . else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (60) else_block -> . ELSE LBRACKET statement_list RBRACKET

    SEMICOLON       reduce using rule 53 (control_structures_if_else -> if_block .)
    PRINT           reduce using rule 53 (control_structures_if_else -> if_block .)
    STRING          reduce using rule 53 (control_structures_if_else -> if_block .)
    VAR             reduce using rule 53 (control_structures_if_else -> if_block .)
    FINAL           reduce using rule 53 (control_structures_if_else -> if_block .)
    ID              reduce using rule 53 (control_structures_if_else -> if_block .)
    VOID            reduce using rule 53 (control_structures_if_else -> if_block .)
    LIST            reduce using rule 53 (control_structures_if_else -> if_block .)
    DYNAMIC         reduce using rule 53 (control_structures_if_else -> if_block .)
    INT             reduce using rule 53 (control_structures_if_else -> if_block .)
    DOUBLE          reduce using rule 53 (control_structures_if_else -> if_block .)
    MAP             reduce using rule 53 (control_structures_if_else -> if_block .)
    WHILE           reduce using rule 53 (control_structures_if_else -> if_block .)
    BOOL            reduce using rule 53 (control_structures_if_else -> if_block .)
    IF              reduce using rule 53 (control_structures_if_else -> if_block .)
    FOR             reduce using rule 53 (control_structures_if_else -> if_block .)
    $end            reduce using rule 53 (control_structures_if_else -> if_block .)
    RBRACKET        reduce using rule 53 (control_structures_if_else -> if_block .)
    ELSE            shift and go to state 58

    else_if_blocks                 shift and go to state 56
    else_block                     shift and go to state 57

state 33

    (113) control_structures_for -> for_classic .

    SEMICOLON       reduce using rule 113 (control_structures_for -> for_classic .)
    PRINT           reduce using rule 113 (control_structures_for -> for_classic .)
    STRING          reduce using rule 113 (control_structures_for -> for_classic .)
    VAR             reduce using rule 113 (control_structures_for -> for_classic .)
    FINAL           reduce using rule 113 (control_structures_for -> for_classic .)
    ID              reduce using rule 113 (control_structures_for -> for_classic .)
    VOID            reduce using rule 113 (control_structures_for -> for_classic .)
    LIST            reduce using rule 113 (control_structures_for -> for_classic .)
    DYNAMIC         reduce using rule 113 (control_structures_for -> for_classic .)
    INT             reduce using rule 113 (control_structures_for -> for_classic .)
    DOUBLE          reduce using rule 113 (control_structures_for -> for_classic .)
    MAP             reduce using rule 113 (control_structures_for -> for_classic .)
    WHILE           reduce using rule 113 (control_structures_for -> for_classic .)
    BOOL            reduce using rule 113 (control_structures_for -> for_classic .)
    IF              reduce using rule 113 (control_structures_for -> for_classic .)
    FOR             reduce using rule 113 (control_structures_for -> for_classic .)
    $end            reduce using rule 113 (control_structures_for -> for_classic .)
    RBRACKET        reduce using rule 113 (control_structures_for -> for_classic .)


state 34

    (114) control_structures_for -> for_in .

    SEMICOLON       reduce using rule 114 (control_structures_for -> for_in .)
    PRINT           reduce using rule 114 (control_structures_for -> for_in .)
    STRING          reduce using rule 114 (control_structures_for -> for_in .)
    VAR             reduce using rule 114 (control_structures_for -> for_in .)
    FINAL           reduce using rule 114 (control_structures_for -> for_in .)
    ID              reduce using rule 114 (control_structures_for -> for_in .)
    VOID            reduce using rule 114 (control_structures_for -> for_in .)
    LIST            reduce using rule 114 (control_structures_for -> for_in .)
    DYNAMIC         reduce using rule 114 (control_structures_for -> for_in .)
    INT             reduce using rule 114 (control_structures_for -> for_in .)
    DOUBLE          reduce using rule 114 (control_structures_for -> for_in .)
    MAP             reduce using rule 114 (control_structures_for -> for_in .)
    WHILE           reduce using rule 114 (control_structures_for -> for_in .)
    BOOL            reduce using rule 114 (control_structures_for -> for_in .)
    IF              reduce using rule 114 (control_structures_for -> for_in .)
    FOR             reduce using rule 114 (control_structures_for -> for_in .)
    $end            reduce using rule 114 (control_structures_for -> for_in .)
    RBRACKET        reduce using rule 114 (control_structures_for -> for_in .)


state 35

    (115) control_structures_for -> for_each .

    SEMICOLON       reduce using rule 115 (control_structures_for -> for_each .)
    PRINT           reduce using rule 115 (control_structures_for -> for_each .)
    STRING          reduce using rule 115 (control_structures_for -> for_each .)
    VAR             reduce using rule 115 (control_structures_for -> for_each .)
    FINAL           reduce using rule 115 (control_structures_for -> for_each .)
    ID              reduce using rule 115 (control_structures_for -> for_each .)
    VOID            reduce using rule 115 (control_structures_for -> for_each .)
    LIST            reduce using rule 115 (control_structures_for -> for_each .)
    DYNAMIC         reduce using rule 115 (control_structures_for -> for_each .)
    INT             reduce using rule 115 (control_structures_for -> for_each .)
    DOUBLE          reduce using rule 115 (control_structures_for -> for_each .)
    MAP             reduce using rule 115 (control_structures_for -> for_each .)
    WHILE           reduce using rule 115 (control_structures_for -> for_each .)
    BOOL            reduce using rule 115 (control_structures_for -> for_each .)
    IF              reduce using rule 115 (control_structures_for -> for_each .)
    FOR             reduce using rule 115 (control_structures_for -> for_each .)
    $end            reduce using rule 115 (control_structures_for -> for_each .)
    RBRACKET        reduce using rule 115 (control_structures_for -> for_each .)


state 36

    (120) control_structures_while -> WHILE . LPAREN conditions LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 59


state 37

    (80) type -> BOOL .

    ID              reduce using rule 80 (type -> BOOL .)
    GREATER         reduce using rule 80 (type -> BOOL .)


state 38

    (57) if_block -> IF . LPAREN conditions RPAREN LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 60


state 39

    (106) for_classic -> FOR . LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_in -> FOR . LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (112) for_each -> FOR . LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 61


state 40

    (3) statement_list -> statement_list statement .

    SEMICOLON       reduce using rule 3 (statement_list -> statement_list statement .)
    PRINT           reduce using rule 3 (statement_list -> statement_list statement .)
    STRING          reduce using rule 3 (statement_list -> statement_list statement .)
    VAR             reduce using rule 3 (statement_list -> statement_list statement .)
    FINAL           reduce using rule 3 (statement_list -> statement_list statement .)
    ID              reduce using rule 3 (statement_list -> statement_list statement .)
    VOID            reduce using rule 3 (statement_list -> statement_list statement .)
    LIST            reduce using rule 3 (statement_list -> statement_list statement .)
    DYNAMIC         reduce using rule 3 (statement_list -> statement_list statement .)
    INT             reduce using rule 3 (statement_list -> statement_list statement .)
    DOUBLE          reduce using rule 3 (statement_list -> statement_list statement .)
    MAP             reduce using rule 3 (statement_list -> statement_list statement .)
    WHILE           reduce using rule 3 (statement_list -> statement_list statement .)
    BOOL            reduce using rule 3 (statement_list -> statement_list statement .)
    IF              reduce using rule 3 (statement_list -> statement_list statement .)
    FOR             reduce using rule 3 (statement_list -> statement_list statement .)
    $end            reduce using rule 3 (statement_list -> statement_list statement .)
    RBRACKET        reduce using rule 3 (statement_list -> statement_list statement .)


state 41

    (40) print -> PRINT LPAREN . RPAREN SEMICOLON
    (41) print -> PRINT LPAREN . value RPAREN SEMICOLON
    (42) print -> PRINT LPAREN . expression RPAREN SEMICOLON
    (43) print -> PRINT LPAREN . length RPAREN SEMICOLON
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (44) expression -> . expression PLUS expression
    (45) expression -> . expression MINUS expression
    (46) expression -> . expression TIMES expression
    (47) expression -> . expression DIVIDE expression
    (48) expression -> . expression AND expression
    (49) expression -> . expression OR expression
    (50) expression -> . value comparator value
    (51) expression -> . value PLUS value
    (52) expression -> . value
    (24) length -> . call_list DOT LENGTH
    (25) length -> . TEXT DOT LENGTH
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression
    (82) call_list -> . LSBRACKET value_list RSBRACKET

    RPAREN          shift and go to state 62
    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 68
    ID              shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72
    LSBRACKET       shift and go to state 74

    value                          shift and go to state 63
    expression                     shift and go to state 64
    length                         shift and go to state 65
    interpolated_string            shift and go to state 70
    call_list                      shift and go to state 73

state 42

    (22) data_input -> STRING ID . ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    ASSIGN          shift and go to state 75


state 43

    (23) data_input -> STRING QUESTION . ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    ID              shift and go to state 76


state 44

    (118) constructor -> ID LPAREN . constructor_parenthesis_content RPAREN SEMICOLON
    (20) call_function -> ID LPAREN . argument_list RPAREN
    (21) call_function -> ID LPAREN . RPAREN
    (116) constructor_parenthesis_content -> . THIS DOT ID
    (117) constructor_parenthesis_content -> . THIS DOT ID COMMA constructor_parenthesis_content
    (26) argument_list -> . expression
    (27) argument_list -> . argument_list COMMA expression
    (44) expression -> . expression PLUS expression
    (45) expression -> . expression MINUS expression
    (46) expression -> . expression TIMES expression
    (47) expression -> . expression DIVIDE expression
    (48) expression -> . expression AND expression
    (49) expression -> . expression OR expression
    (50) expression -> . value comparator value
    (51) expression -> . value PLUS value
    (52) expression -> . value
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression

    RPAREN          shift and go to state 78
    THIS            shift and go to state 80
    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 83
    ID              shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72

    constructor_parenthesis_content shift and go to state 77
    argument_list                  shift and go to state 79
    expression                     shift and go to state 81
    value                          shift and go to state 82
    interpolated_string            shift and go to state 70

state 45

    (95) set -> VAR ID . ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (96) set -> VAR ID . ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (36) variable_definition -> VAR ID . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 84


state 46

    (97) set -> FINAL ID . ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON

    ASSIGN          shift and go to state 85


state 47

    (121) map -> map_declaration map_assignment .

    SEMICOLON       reduce using rule 121 (map -> map_declaration map_assignment .)
    PRINT           reduce using rule 121 (map -> map_declaration map_assignment .)
    STRING          reduce using rule 121 (map -> map_declaration map_assignment .)
    VAR             reduce using rule 121 (map -> map_declaration map_assignment .)
    FINAL           reduce using rule 121 (map -> map_declaration map_assignment .)
    ID              reduce using rule 121 (map -> map_declaration map_assignment .)
    VOID            reduce using rule 121 (map -> map_declaration map_assignment .)
    LIST            reduce using rule 121 (map -> map_declaration map_assignment .)
    DYNAMIC         reduce using rule 121 (map -> map_declaration map_assignment .)
    INT             reduce using rule 121 (map -> map_declaration map_assignment .)
    DOUBLE          reduce using rule 121 (map -> map_declaration map_assignment .)
    MAP             reduce using rule 121 (map -> map_declaration map_assignment .)
    WHILE           reduce using rule 121 (map -> map_declaration map_assignment .)
    BOOL            reduce using rule 121 (map -> map_declaration map_assignment .)
    IF              reduce using rule 121 (map -> map_declaration map_assignment .)
    FOR             reduce using rule 121 (map -> map_declaration map_assignment .)
    $end            reduce using rule 121 (map -> map_declaration map_assignment .)
    RBRACKET        reduce using rule 121 (map -> map_declaration map_assignment .)


state 48

    (123) map_assignment -> LBRACKET . map_contents RBRACKET
    (124) map_contents -> . map_content
    (125) map_contents -> . map_content COMMA map_contents
    (126) map_content -> . key_value COLON value
    (127) key_value -> . TEXT

    TEXT            shift and go to state 89

    map_contents                   shift and go to state 86
    map_content                    shift and go to state 87
    key_value                      shift and go to state 88

state 49

    (28) function -> type ID . LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> type ID . LPAREN RPAREN LBRACKET statement_list RBRACKET
    (119) function -> type ID . LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (34) variable_definition -> type ID . ASSIGN expression SEMICOLON

    LPAREN          shift and go to state 90
    ASSIGN          shift and go to state 91


state 50

    (29) function -> VOID ID . LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (31) function -> VOID ID . LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> VOID ID . LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> VOID ID . LPAREN parameter_list RPAREN LBRACKET RBRACKET

    LPAREN          shift and go to state 92


state 51

    (83) list_definition -> LIST LESS . type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (77) type -> . INT
    (78) type -> . DOUBLE
    (79) type -> . STRING
    (80) type -> . BOOL
    (81) type -> . LIST

    INT             shift and go to state 95
    DOUBLE          shift and go to state 96
    STRING          shift and go to state 97
    BOOL            shift and go to state 37
    LIST            shift and go to state 93

    type                           shift and go to state 94

state 52

    (35) variable_definition -> DYNAMIC ID . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 98


state 53

    (37) variable_definition -> INT ID . ASSIGN length SEMICOLON
    (38) variable_definition -> INT ID . ASSIGN NUMBER SEMICOLON

    ASSIGN          shift and go to state 99


state 54

    (39) variable_definition -> DOUBLE ID . ASSIGN NDOUBLE SEMICOLON

    ASSIGN          shift and go to state 100


state 55

    (122) map_declaration -> MAP LESS . key_type COMMA type GREATER ID ASSIGN
    (128) key_type -> . STRING

    STRING          shift and go to state 102

    key_type                       shift and go to state 101

state 56

    (54) control_structures_if_else -> if_block else_if_blocks .
    (55) control_structures_if_else -> if_block else_if_blocks . else_block
    (59) else_if_blocks -> else_if_blocks . ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (60) else_block -> . ELSE LBRACKET statement_list RBRACKET

    SEMICOLON       reduce using rule 54 (control_structures_if_else -> if_block else_if_blocks .)
    PRINT           reduce using rule 54 (control_structures_if_else -> if_block else_if_blocks .)
    STRING          reduce using rule 54 (control_structures_if_else -> if_block else_if_blocks .)
    VAR             reduce using rule 54 (control_structures_if_else -> if_block else_if_blocks .)
    FINAL           reduce using rule 54 (control_structures_if_else -> if_block else_if_blocks .)
    ID              reduce using rule 54 (control_structures_if_else -> if_block else_if_blocks .)
    VOID            reduce using rule 54 (control_structures_if_else -> if_block else_if_blocks .)
    LIST            reduce using rule 54 (control_structures_if_else -> if_block else_if_blocks .)
    DYNAMIC         reduce using rule 54 (control_structures_if_else -> if_block else_if_blocks .)
    INT             reduce using rule 54 (control_structures_if_else -> if_block else_if_blocks .)
    DOUBLE          reduce using rule 54 (control_structures_if_else -> if_block else_if_blocks .)
    MAP             reduce using rule 54 (control_structures_if_else -> if_block else_if_blocks .)
    WHILE           reduce using rule 54 (control_structures_if_else -> if_block else_if_blocks .)
    BOOL            reduce using rule 54 (control_structures_if_else -> if_block else_if_blocks .)
    IF              reduce using rule 54 (control_structures_if_else -> if_block else_if_blocks .)
    FOR             reduce using rule 54 (control_structures_if_else -> if_block else_if_blocks .)
    $end            reduce using rule 54 (control_structures_if_else -> if_block else_if_blocks .)
    RBRACKET        reduce using rule 54 (control_structures_if_else -> if_block else_if_blocks .)
    ELSE            shift and go to state 104

    else_block                     shift and go to state 103

state 57

    (56) control_structures_if_else -> if_block else_block .

    SEMICOLON       reduce using rule 56 (control_structures_if_else -> if_block else_block .)
    PRINT           reduce using rule 56 (control_structures_if_else -> if_block else_block .)
    STRING          reduce using rule 56 (control_structures_if_else -> if_block else_block .)
    VAR             reduce using rule 56 (control_structures_if_else -> if_block else_block .)
    FINAL           reduce using rule 56 (control_structures_if_else -> if_block else_block .)
    ID              reduce using rule 56 (control_structures_if_else -> if_block else_block .)
    VOID            reduce using rule 56 (control_structures_if_else -> if_block else_block .)
    LIST            reduce using rule 56 (control_structures_if_else -> if_block else_block .)
    DYNAMIC         reduce using rule 56 (control_structures_if_else -> if_block else_block .)
    INT             reduce using rule 56 (control_structures_if_else -> if_block else_block .)
    DOUBLE          reduce using rule 56 (control_structures_if_else -> if_block else_block .)
    MAP             reduce using rule 56 (control_structures_if_else -> if_block else_block .)
    WHILE           reduce using rule 56 (control_structures_if_else -> if_block else_block .)
    BOOL            reduce using rule 56 (control_structures_if_else -> if_block else_block .)
    IF              reduce using rule 56 (control_structures_if_else -> if_block else_block .)
    FOR             reduce using rule 56 (control_structures_if_else -> if_block else_block .)
    $end            reduce using rule 56 (control_structures_if_else -> if_block else_block .)
    RBRACKET        reduce using rule 56 (control_structures_if_else -> if_block else_block .)


state 58

    (58) else_if_blocks -> ELSE . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (60) else_block -> ELSE . LBRACKET statement_list RBRACKET

    IF              shift and go to state 105
    LBRACKET        shift and go to state 106


state 59

    (120) control_structures_while -> WHILE LPAREN . conditions LBRACKET statement_list RBRACKET
    (61) conditions -> . condition
    (62) conditions -> . conditions AND conditions
    (63) conditions -> . conditions OR conditions
    (64) condition -> . value comparator value
    (65) condition -> . NOT condition
    (66) condition -> . LPAREN conditions RPAREN
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 111
    LPAREN          shift and go to state 107
    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 83
    ID              shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72

    conditions                     shift and go to state 108
    condition                      shift and go to state 109
    value                          shift and go to state 110
    interpolated_string            shift and go to state 70

state 60

    (57) if_block -> IF LPAREN . conditions RPAREN LBRACKET statement_list RBRACKET
    (61) conditions -> . condition
    (62) conditions -> . conditions AND conditions
    (63) conditions -> . conditions OR conditions
    (64) condition -> . value comparator value
    (65) condition -> . NOT condition
    (66) condition -> . LPAREN conditions RPAREN
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 111
    LPAREN          shift and go to state 107
    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 83
    ID              shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72

    conditions                     shift and go to state 112
    condition                      shift and go to state 109
    value                          shift and go to state 110
    interpolated_string            shift and go to state 70

state 61

    (106) for_classic -> FOR LPAREN . for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_in -> FOR LPAREN . for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (112) for_each -> FOR LPAREN . for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (105) for_classic_parenthesis_content -> . for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON for_classic_changes
    (107) for_in_parenthesis_content -> . FINAL ID IN ID
    (111) for_each_parenthesis_content -> . FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID
    (98) for_classic_initialization -> . INT ID ASSIGN NUMBER
    (99) for_classic_initialization -> . DOUBLE ID ASSIGN NDOUBLE

    FINAL           shift and go to state 117
    INT             shift and go to state 118
    DOUBLE          shift and go to state 119

    for_classic_parenthesis_content shift and go to state 113
    for_in_parenthesis_content     shift and go to state 114
    for_each_parenthesis_content   shift and go to state 115
    for_classic_initialization     shift and go to state 116

state 62

    (40) print -> PRINT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 120


state 63

    (41) print -> PRINT LPAREN value . RPAREN SEMICOLON
    (50) expression -> value . comparator value
    (51) expression -> value . PLUS value
    (52) expression -> value .
    (67) comparator -> . GREATER
    (68) comparator -> . LESS
    (69) comparator -> . EQUALS
    (70) comparator -> . GREATER_EQUAL
    (71) comparator -> . LESS_EQUAL
    (72) comparator -> . NOT_EQUALS

  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
    RPAREN          shift and go to state 121
    PLUS            shift and go to state 123
    MINUS           reduce using rule 52 (expression -> value .)
    TIMES           reduce using rule 52 (expression -> value .)
    DIVIDE          reduce using rule 52 (expression -> value .)
    AND             reduce using rule 52 (expression -> value .)
    OR              reduce using rule 52 (expression -> value .)
    GREATER         shift and go to state 124
    LESS            shift and go to state 125
    EQUALS          shift and go to state 126
    GREATER_EQUAL   shift and go to state 127
    LESS_EQUAL      shift and go to state 128
    NOT_EQUALS      shift and go to state 129

  ! RPAREN          [ reduce using rule 52 (expression -> value .) ]
  ! PLUS            [ reduce using rule 52 (expression -> value .) ]

    comparator                     shift and go to state 122

state 64

    (42) print -> PRINT LPAREN expression . RPAREN SEMICOLON
    (44) expression -> expression . PLUS expression
    (45) expression -> expression . MINUS expression
    (46) expression -> expression . TIMES expression
    (47) expression -> expression . DIVIDE expression
    (48) expression -> expression . AND expression
    (49) expression -> expression . OR expression

    RPAREN          shift and go to state 130
    PLUS            shift and go to state 131
    MINUS           shift and go to state 132
    TIMES           shift and go to state 133
    DIVIDE          shift and go to state 134
    AND             shift and go to state 135
    OR              shift and go to state 136


state 65

    (43) print -> PRINT LPAREN length . RPAREN SEMICOLON

    RPAREN          shift and go to state 137


state 66

    (86) value -> NUMBER .

    RPAREN          reduce using rule 86 (value -> NUMBER .)
    PLUS            reduce using rule 86 (value -> NUMBER .)
    GREATER         reduce using rule 86 (value -> NUMBER .)
    LESS            reduce using rule 86 (value -> NUMBER .)
    EQUALS          reduce using rule 86 (value -> NUMBER .)
    GREATER_EQUAL   reduce using rule 86 (value -> NUMBER .)
    LESS_EQUAL      reduce using rule 86 (value -> NUMBER .)
    NOT_EQUALS      reduce using rule 86 (value -> NUMBER .)
    MINUS           reduce using rule 86 (value -> NUMBER .)
    TIMES           reduce using rule 86 (value -> NUMBER .)
    DIVIDE          reduce using rule 86 (value -> NUMBER .)
    AND             reduce using rule 86 (value -> NUMBER .)
    OR              reduce using rule 86 (value -> NUMBER .)
    COMMA           reduce using rule 86 (value -> NUMBER .)
    RSBRACKET       reduce using rule 86 (value -> NUMBER .)
    SEMICOLON       reduce using rule 86 (value -> NUMBER .)
    PRINT           reduce using rule 86 (value -> NUMBER .)
    STRING          reduce using rule 86 (value -> NUMBER .)
    VAR             reduce using rule 86 (value -> NUMBER .)
    FINAL           reduce using rule 86 (value -> NUMBER .)
    ID              reduce using rule 86 (value -> NUMBER .)
    VOID            reduce using rule 86 (value -> NUMBER .)
    LIST            reduce using rule 86 (value -> NUMBER .)
    DYNAMIC         reduce using rule 86 (value -> NUMBER .)
    INT             reduce using rule 86 (value -> NUMBER .)
    DOUBLE          reduce using rule 86 (value -> NUMBER .)
    MAP             reduce using rule 86 (value -> NUMBER .)
    WHILE           reduce using rule 86 (value -> NUMBER .)
    BOOL            reduce using rule 86 (value -> NUMBER .)
    IF              reduce using rule 86 (value -> NUMBER .)
    FOR             reduce using rule 86 (value -> NUMBER .)
    $end            reduce using rule 86 (value -> NUMBER .)
    RBRACKET        reduce using rule 86 (value -> NUMBER .)
    LBRACKET        reduce using rule 86 (value -> NUMBER .)


state 67

    (87) value -> NDOUBLE .

    RPAREN          reduce using rule 87 (value -> NDOUBLE .)
    PLUS            reduce using rule 87 (value -> NDOUBLE .)
    GREATER         reduce using rule 87 (value -> NDOUBLE .)
    LESS            reduce using rule 87 (value -> NDOUBLE .)
    EQUALS          reduce using rule 87 (value -> NDOUBLE .)
    GREATER_EQUAL   reduce using rule 87 (value -> NDOUBLE .)
    LESS_EQUAL      reduce using rule 87 (value -> NDOUBLE .)
    NOT_EQUALS      reduce using rule 87 (value -> NDOUBLE .)
    MINUS           reduce using rule 87 (value -> NDOUBLE .)
    TIMES           reduce using rule 87 (value -> NDOUBLE .)
    DIVIDE          reduce using rule 87 (value -> NDOUBLE .)
    AND             reduce using rule 87 (value -> NDOUBLE .)
    OR              reduce using rule 87 (value -> NDOUBLE .)
    COMMA           reduce using rule 87 (value -> NDOUBLE .)
    RSBRACKET       reduce using rule 87 (value -> NDOUBLE .)
    SEMICOLON       reduce using rule 87 (value -> NDOUBLE .)
    PRINT           reduce using rule 87 (value -> NDOUBLE .)
    STRING          reduce using rule 87 (value -> NDOUBLE .)
    VAR             reduce using rule 87 (value -> NDOUBLE .)
    FINAL           reduce using rule 87 (value -> NDOUBLE .)
    ID              reduce using rule 87 (value -> NDOUBLE .)
    VOID            reduce using rule 87 (value -> NDOUBLE .)
    LIST            reduce using rule 87 (value -> NDOUBLE .)
    DYNAMIC         reduce using rule 87 (value -> NDOUBLE .)
    INT             reduce using rule 87 (value -> NDOUBLE .)
    DOUBLE          reduce using rule 87 (value -> NDOUBLE .)
    MAP             reduce using rule 87 (value -> NDOUBLE .)
    WHILE           reduce using rule 87 (value -> NDOUBLE .)
    BOOL            reduce using rule 87 (value -> NDOUBLE .)
    IF              reduce using rule 87 (value -> NDOUBLE .)
    FOR             reduce using rule 87 (value -> NDOUBLE .)
    $end            reduce using rule 87 (value -> NDOUBLE .)
    RBRACKET        reduce using rule 87 (value -> NDOUBLE .)
    LBRACKET        reduce using rule 87 (value -> NDOUBLE .)


state 68

    (88) value -> TEXT .
    (25) length -> TEXT . DOT LENGTH
    (93) interpolated_string -> TEXT . PLUS ID
    (94) interpolated_string -> TEXT . PLUS expression

  ! shift/reduce conflict for PLUS resolved as shift
    RPAREN          reduce using rule 88 (value -> TEXT .)
    GREATER         reduce using rule 88 (value -> TEXT .)
    LESS            reduce using rule 88 (value -> TEXT .)
    EQUALS          reduce using rule 88 (value -> TEXT .)
    GREATER_EQUAL   reduce using rule 88 (value -> TEXT .)
    LESS_EQUAL      reduce using rule 88 (value -> TEXT .)
    NOT_EQUALS      reduce using rule 88 (value -> TEXT .)
    MINUS           reduce using rule 88 (value -> TEXT .)
    TIMES           reduce using rule 88 (value -> TEXT .)
    DIVIDE          reduce using rule 88 (value -> TEXT .)
    AND             reduce using rule 88 (value -> TEXT .)
    OR              reduce using rule 88 (value -> TEXT .)
    DOT             shift and go to state 138
    PLUS            shift and go to state 139

  ! PLUS            [ reduce using rule 88 (value -> TEXT .) ]


state 69

    (89) value -> ID .

    RPAREN          reduce using rule 89 (value -> ID .)
    PLUS            reduce using rule 89 (value -> ID .)
    GREATER         reduce using rule 89 (value -> ID .)
    LESS            reduce using rule 89 (value -> ID .)
    EQUALS          reduce using rule 89 (value -> ID .)
    GREATER_EQUAL   reduce using rule 89 (value -> ID .)
    LESS_EQUAL      reduce using rule 89 (value -> ID .)
    NOT_EQUALS      reduce using rule 89 (value -> ID .)
    MINUS           reduce using rule 89 (value -> ID .)
    TIMES           reduce using rule 89 (value -> ID .)
    DIVIDE          reduce using rule 89 (value -> ID .)
    AND             reduce using rule 89 (value -> ID .)
    OR              reduce using rule 89 (value -> ID .)
    COMMA           reduce using rule 89 (value -> ID .)
    RSBRACKET       reduce using rule 89 (value -> ID .)
    SEMICOLON       reduce using rule 89 (value -> ID .)
    PRINT           reduce using rule 89 (value -> ID .)
    STRING          reduce using rule 89 (value -> ID .)
    VAR             reduce using rule 89 (value -> ID .)
    FINAL           reduce using rule 89 (value -> ID .)
    ID              reduce using rule 89 (value -> ID .)
    VOID            reduce using rule 89 (value -> ID .)
    LIST            reduce using rule 89 (value -> ID .)
    DYNAMIC         reduce using rule 89 (value -> ID .)
    INT             reduce using rule 89 (value -> ID .)
    DOUBLE          reduce using rule 89 (value -> ID .)
    MAP             reduce using rule 89 (value -> ID .)
    WHILE           reduce using rule 89 (value -> ID .)
    BOOL            reduce using rule 89 (value -> ID .)
    IF              reduce using rule 89 (value -> ID .)
    FOR             reduce using rule 89 (value -> ID .)
    $end            reduce using rule 89 (value -> ID .)
    RBRACKET        reduce using rule 89 (value -> ID .)
    LBRACKET        reduce using rule 89 (value -> ID .)


state 70

    (90) value -> interpolated_string .

    RPAREN          reduce using rule 90 (value -> interpolated_string .)
    PLUS            reduce using rule 90 (value -> interpolated_string .)
    GREATER         reduce using rule 90 (value -> interpolated_string .)
    LESS            reduce using rule 90 (value -> interpolated_string .)
    EQUALS          reduce using rule 90 (value -> interpolated_string .)
    GREATER_EQUAL   reduce using rule 90 (value -> interpolated_string .)
    LESS_EQUAL      reduce using rule 90 (value -> interpolated_string .)
    NOT_EQUALS      reduce using rule 90 (value -> interpolated_string .)
    MINUS           reduce using rule 90 (value -> interpolated_string .)
    TIMES           reduce using rule 90 (value -> interpolated_string .)
    DIVIDE          reduce using rule 90 (value -> interpolated_string .)
    AND             reduce using rule 90 (value -> interpolated_string .)
    OR              reduce using rule 90 (value -> interpolated_string .)
    COMMA           reduce using rule 90 (value -> interpolated_string .)
    RSBRACKET       reduce using rule 90 (value -> interpolated_string .)
    SEMICOLON       reduce using rule 90 (value -> interpolated_string .)
    PRINT           reduce using rule 90 (value -> interpolated_string .)
    STRING          reduce using rule 90 (value -> interpolated_string .)
    VAR             reduce using rule 90 (value -> interpolated_string .)
    FINAL           reduce using rule 90 (value -> interpolated_string .)
    ID              reduce using rule 90 (value -> interpolated_string .)
    VOID            reduce using rule 90 (value -> interpolated_string .)
    LIST            reduce using rule 90 (value -> interpolated_string .)
    DYNAMIC         reduce using rule 90 (value -> interpolated_string .)
    INT             reduce using rule 90 (value -> interpolated_string .)
    DOUBLE          reduce using rule 90 (value -> interpolated_string .)
    MAP             reduce using rule 90 (value -> interpolated_string .)
    WHILE           reduce using rule 90 (value -> interpolated_string .)
    BOOL            reduce using rule 90 (value -> interpolated_string .)
    IF              reduce using rule 90 (value -> interpolated_string .)
    FOR             reduce using rule 90 (value -> interpolated_string .)
    $end            reduce using rule 90 (value -> interpolated_string .)
    RBRACKET        reduce using rule 90 (value -> interpolated_string .)
    LBRACKET        reduce using rule 90 (value -> interpolated_string .)


state 71

    (91) value -> TRUE .

    RPAREN          reduce using rule 91 (value -> TRUE .)
    PLUS            reduce using rule 91 (value -> TRUE .)
    GREATER         reduce using rule 91 (value -> TRUE .)
    LESS            reduce using rule 91 (value -> TRUE .)
    EQUALS          reduce using rule 91 (value -> TRUE .)
    GREATER_EQUAL   reduce using rule 91 (value -> TRUE .)
    LESS_EQUAL      reduce using rule 91 (value -> TRUE .)
    NOT_EQUALS      reduce using rule 91 (value -> TRUE .)
    MINUS           reduce using rule 91 (value -> TRUE .)
    TIMES           reduce using rule 91 (value -> TRUE .)
    DIVIDE          reduce using rule 91 (value -> TRUE .)
    AND             reduce using rule 91 (value -> TRUE .)
    OR              reduce using rule 91 (value -> TRUE .)
    COMMA           reduce using rule 91 (value -> TRUE .)
    RSBRACKET       reduce using rule 91 (value -> TRUE .)
    SEMICOLON       reduce using rule 91 (value -> TRUE .)
    PRINT           reduce using rule 91 (value -> TRUE .)
    STRING          reduce using rule 91 (value -> TRUE .)
    VAR             reduce using rule 91 (value -> TRUE .)
    FINAL           reduce using rule 91 (value -> TRUE .)
    ID              reduce using rule 91 (value -> TRUE .)
    VOID            reduce using rule 91 (value -> TRUE .)
    LIST            reduce using rule 91 (value -> TRUE .)
    DYNAMIC         reduce using rule 91 (value -> TRUE .)
    INT             reduce using rule 91 (value -> TRUE .)
    DOUBLE          reduce using rule 91 (value -> TRUE .)
    MAP             reduce using rule 91 (value -> TRUE .)
    WHILE           reduce using rule 91 (value -> TRUE .)
    BOOL            reduce using rule 91 (value -> TRUE .)
    IF              reduce using rule 91 (value -> TRUE .)
    FOR             reduce using rule 91 (value -> TRUE .)
    $end            reduce using rule 91 (value -> TRUE .)
    RBRACKET        reduce using rule 91 (value -> TRUE .)
    LBRACKET        reduce using rule 91 (value -> TRUE .)


state 72

    (92) value -> FALSE .

    RPAREN          reduce using rule 92 (value -> FALSE .)
    PLUS            reduce using rule 92 (value -> FALSE .)
    GREATER         reduce using rule 92 (value -> FALSE .)
    LESS            reduce using rule 92 (value -> FALSE .)
    EQUALS          reduce using rule 92 (value -> FALSE .)
    GREATER_EQUAL   reduce using rule 92 (value -> FALSE .)
    LESS_EQUAL      reduce using rule 92 (value -> FALSE .)
    NOT_EQUALS      reduce using rule 92 (value -> FALSE .)
    MINUS           reduce using rule 92 (value -> FALSE .)
    TIMES           reduce using rule 92 (value -> FALSE .)
    DIVIDE          reduce using rule 92 (value -> FALSE .)
    AND             reduce using rule 92 (value -> FALSE .)
    OR              reduce using rule 92 (value -> FALSE .)
    COMMA           reduce using rule 92 (value -> FALSE .)
    RSBRACKET       reduce using rule 92 (value -> FALSE .)
    SEMICOLON       reduce using rule 92 (value -> FALSE .)
    PRINT           reduce using rule 92 (value -> FALSE .)
    STRING          reduce using rule 92 (value -> FALSE .)
    VAR             reduce using rule 92 (value -> FALSE .)
    FINAL           reduce using rule 92 (value -> FALSE .)
    ID              reduce using rule 92 (value -> FALSE .)
    VOID            reduce using rule 92 (value -> FALSE .)
    LIST            reduce using rule 92 (value -> FALSE .)
    DYNAMIC         reduce using rule 92 (value -> FALSE .)
    INT             reduce using rule 92 (value -> FALSE .)
    DOUBLE          reduce using rule 92 (value -> FALSE .)
    MAP             reduce using rule 92 (value -> FALSE .)
    WHILE           reduce using rule 92 (value -> FALSE .)
    BOOL            reduce using rule 92 (value -> FALSE .)
    IF              reduce using rule 92 (value -> FALSE .)
    FOR             reduce using rule 92 (value -> FALSE .)
    $end            reduce using rule 92 (value -> FALSE .)
    RBRACKET        reduce using rule 92 (value -> FALSE .)
    LBRACKET        reduce using rule 92 (value -> FALSE .)


state 73

    (24) length -> call_list . DOT LENGTH

    DOT             shift and go to state 140


state 74

    (82) call_list -> LSBRACKET . value_list RSBRACKET
    (84) value_list -> . value
    (85) value_list -> . value_list COMMA value
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 83
    ID              shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72

    value_list                     shift and go to state 141
    value                          shift and go to state 142
    interpolated_string            shift and go to state 70

state 75

    (22) data_input -> STRING ID ASSIGN . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    STDIN           shift and go to state 143


state 76

    (23) data_input -> STRING QUESTION ID . ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    ASSIGN          shift and go to state 144


state 77

    (118) constructor -> ID LPAREN constructor_parenthesis_content . RPAREN SEMICOLON

    RPAREN          shift and go to state 145


state 78

    (21) call_function -> ID LPAREN RPAREN .

    SEMICOLON       reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    PRINT           reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    STRING          reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    VAR             reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    FINAL           reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    ID              reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    VOID            reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    LIST            reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    DYNAMIC         reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    INT             reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    DOUBLE          reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    MAP             reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    WHILE           reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    BOOL            reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    IF              reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    FOR             reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    $end            reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    RBRACKET        reduce using rule 21 (call_function -> ID LPAREN RPAREN .)


state 79

    (20) call_function -> ID LPAREN argument_list . RPAREN
    (27) argument_list -> argument_list . COMMA expression

    RPAREN          shift and go to state 146
    COMMA           shift and go to state 147


state 80

    (116) constructor_parenthesis_content -> THIS . DOT ID
    (117) constructor_parenthesis_content -> THIS . DOT ID COMMA constructor_parenthesis_content

    DOT             shift and go to state 148


state 81

    (26) argument_list -> expression .
    (44) expression -> expression . PLUS expression
    (45) expression -> expression . MINUS expression
    (46) expression -> expression . TIMES expression
    (47) expression -> expression . DIVIDE expression
    (48) expression -> expression . AND expression
    (49) expression -> expression . OR expression

    RPAREN          reduce using rule 26 (argument_list -> expression .)
    COMMA           reduce using rule 26 (argument_list -> expression .)
    PLUS            shift and go to state 131
    MINUS           shift and go to state 132
    TIMES           shift and go to state 133
    DIVIDE          shift and go to state 134
    AND             shift and go to state 135
    OR              shift and go to state 136


state 82

    (50) expression -> value . comparator value
    (51) expression -> value . PLUS value
    (52) expression -> value .
    (67) comparator -> . GREATER
    (68) comparator -> . LESS
    (69) comparator -> . EQUALS
    (70) comparator -> . GREATER_EQUAL
    (71) comparator -> . LESS_EQUAL
    (72) comparator -> . NOT_EQUALS

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUALS resolved as shift
    PLUS            shift and go to state 123
    MINUS           reduce using rule 52 (expression -> value .)
    TIMES           reduce using rule 52 (expression -> value .)
    DIVIDE          reduce using rule 52 (expression -> value .)
    AND             reduce using rule 52 (expression -> value .)
    OR              reduce using rule 52 (expression -> value .)
    RPAREN          reduce using rule 52 (expression -> value .)
    COMMA           reduce using rule 52 (expression -> value .)
    SEMICOLON       reduce using rule 52 (expression -> value .)
    RSBRACKET       reduce using rule 52 (expression -> value .)
    PRINT           reduce using rule 52 (expression -> value .)
    STRING          reduce using rule 52 (expression -> value .)
    VAR             reduce using rule 52 (expression -> value .)
    FINAL           reduce using rule 52 (expression -> value .)
    ID              reduce using rule 52 (expression -> value .)
    VOID            reduce using rule 52 (expression -> value .)
    LIST            reduce using rule 52 (expression -> value .)
    DYNAMIC         reduce using rule 52 (expression -> value .)
    INT             reduce using rule 52 (expression -> value .)
    DOUBLE          reduce using rule 52 (expression -> value .)
    MAP             reduce using rule 52 (expression -> value .)
    WHILE           reduce using rule 52 (expression -> value .)
    BOOL            reduce using rule 52 (expression -> value .)
    IF              reduce using rule 52 (expression -> value .)
    FOR             reduce using rule 52 (expression -> value .)
    $end            reduce using rule 52 (expression -> value .)
    RBRACKET        reduce using rule 52 (expression -> value .)
    LBRACKET        reduce using rule 52 (expression -> value .)
    GREATER         shift and go to state 124
    LESS            shift and go to state 125
    EQUALS          shift and go to state 126
    GREATER_EQUAL   shift and go to state 127
    LESS_EQUAL      shift and go to state 128
    NOT_EQUALS      shift and go to state 129

  ! PLUS            [ reduce using rule 52 (expression -> value .) ]
  ! GREATER         [ reduce using rule 52 (expression -> value .) ]
  ! LESS            [ reduce using rule 52 (expression -> value .) ]
  ! EQUALS          [ reduce using rule 52 (expression -> value .) ]
  ! GREATER_EQUAL   [ reduce using rule 52 (expression -> value .) ]
  ! LESS_EQUAL      [ reduce using rule 52 (expression -> value .) ]
  ! NOT_EQUALS      [ reduce using rule 52 (expression -> value .) ]

    comparator                     shift and go to state 122

state 83

    (88) value -> TEXT .
    (93) interpolated_string -> TEXT . PLUS ID
    (94) interpolated_string -> TEXT . PLUS expression

  ! shift/reduce conflict for PLUS resolved as shift
    GREATER         reduce using rule 88 (value -> TEXT .)
    LESS            reduce using rule 88 (value -> TEXT .)
    EQUALS          reduce using rule 88 (value -> TEXT .)
    GREATER_EQUAL   reduce using rule 88 (value -> TEXT .)
    LESS_EQUAL      reduce using rule 88 (value -> TEXT .)
    NOT_EQUALS      reduce using rule 88 (value -> TEXT .)
    MINUS           reduce using rule 88 (value -> TEXT .)
    TIMES           reduce using rule 88 (value -> TEXT .)
    DIVIDE          reduce using rule 88 (value -> TEXT .)
    AND             reduce using rule 88 (value -> TEXT .)
    OR              reduce using rule 88 (value -> TEXT .)
    RPAREN          reduce using rule 88 (value -> TEXT .)
    COMMA           reduce using rule 88 (value -> TEXT .)
    RSBRACKET       reduce using rule 88 (value -> TEXT .)
    SEMICOLON       reduce using rule 88 (value -> TEXT .)
    PRINT           reduce using rule 88 (value -> TEXT .)
    STRING          reduce using rule 88 (value -> TEXT .)
    VAR             reduce using rule 88 (value -> TEXT .)
    FINAL           reduce using rule 88 (value -> TEXT .)
    ID              reduce using rule 88 (value -> TEXT .)
    VOID            reduce using rule 88 (value -> TEXT .)
    LIST            reduce using rule 88 (value -> TEXT .)
    DYNAMIC         reduce using rule 88 (value -> TEXT .)
    INT             reduce using rule 88 (value -> TEXT .)
    DOUBLE          reduce using rule 88 (value -> TEXT .)
    MAP             reduce using rule 88 (value -> TEXT .)
    WHILE           reduce using rule 88 (value -> TEXT .)
    BOOL            reduce using rule 88 (value -> TEXT .)
    IF              reduce using rule 88 (value -> TEXT .)
    FOR             reduce using rule 88 (value -> TEXT .)
    $end            reduce using rule 88 (value -> TEXT .)
    RBRACKET        reduce using rule 88 (value -> TEXT .)
    LBRACKET        reduce using rule 88 (value -> TEXT .)
    PLUS            shift and go to state 139

  ! PLUS            [ reduce using rule 88 (value -> TEXT .) ]


state 84

    (95) set -> VAR ID ASSIGN . LBRACKET value_list RBRACKET SEMICOLON
    (96) set -> VAR ID ASSIGN . LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (36) variable_definition -> VAR ID ASSIGN . expression SEMICOLON
    (44) expression -> . expression PLUS expression
    (45) expression -> . expression MINUS expression
    (46) expression -> . expression TIMES expression
    (47) expression -> . expression DIVIDE expression
    (48) expression -> . expression AND expression
    (49) expression -> . expression OR expression
    (50) expression -> . value comparator value
    (51) expression -> . value PLUS value
    (52) expression -> . value
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression

    LBRACKET        shift and go to state 149
    LESS            shift and go to state 150
    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 83
    ID              shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72

    expression                     shift and go to state 151
    value                          shift and go to state 82
    interpolated_string            shift and go to state 70

state 85

    (97) set -> FINAL ID ASSIGN . CONST LBRACKET value_list RBRACKET SEMICOLON

    CONST           shift and go to state 152


state 86

    (123) map_assignment -> LBRACKET map_contents . RBRACKET

    RBRACKET        shift and go to state 153


state 87

    (124) map_contents -> map_content .
    (125) map_contents -> map_content . COMMA map_contents

    RBRACKET        reduce using rule 124 (map_contents -> map_content .)
    COMMA           shift and go to state 154


state 88

    (126) map_content -> key_value . COLON value

    COLON           shift and go to state 155


state 89

    (127) key_value -> TEXT .

    COLON           reduce using rule 127 (key_value -> TEXT .)


state 90

    (28) function -> type ID LPAREN . parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> type ID LPAREN . RPAREN LBRACKET statement_list RBRACKET
    (119) function -> type ID LPAREN . parameter_list RPAREN ASSIGN GREATER expression
    (73) parameter_list -> . parameter
    (74) parameter_list -> . parameter_list COMMA parameter
    (75) parameter -> . type ID
    (76) parameter -> . REQUIRED type ID
    (77) type -> . INT
    (78) type -> . DOUBLE
    (79) type -> . STRING
    (80) type -> . BOOL
    (81) type -> . LIST

    RPAREN          shift and go to state 158
    REQUIRED        shift and go to state 160
    INT             shift and go to state 95
    DOUBLE          shift and go to state 96
    STRING          shift and go to state 97
    BOOL            shift and go to state 37
    LIST            shift and go to state 93

    type                           shift and go to state 156
    parameter_list                 shift and go to state 157
    parameter                      shift and go to state 159

state 91

    (34) variable_definition -> type ID ASSIGN . expression SEMICOLON
    (44) expression -> . expression PLUS expression
    (45) expression -> . expression MINUS expression
    (46) expression -> . expression TIMES expression
    (47) expression -> . expression DIVIDE expression
    (48) expression -> . expression AND expression
    (49) expression -> . expression OR expression
    (50) expression -> . value comparator value
    (51) expression -> . value PLUS value
    (52) expression -> . value
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 83
    ID              shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72

    expression                     shift and go to state 161
    value                          shift and go to state 82
    interpolated_string            shift and go to state 70

state 92

    (29) function -> VOID ID LPAREN . parameter_list RPAREN LBRACKET statement_list RBRACKET
    (31) function -> VOID ID LPAREN . RPAREN LBRACKET statement_list RBRACKET
    (32) function -> VOID ID LPAREN . RPAREN LBRACKET RBRACKET
    (33) function -> VOID ID LPAREN . parameter_list RPAREN LBRACKET RBRACKET
    (73) parameter_list -> . parameter
    (74) parameter_list -> . parameter_list COMMA parameter
    (75) parameter -> . type ID
    (76) parameter -> . REQUIRED type ID
    (77) type -> . INT
    (78) type -> . DOUBLE
    (79) type -> . STRING
    (80) type -> . BOOL
    (81) type -> . LIST

    RPAREN          shift and go to state 163
    REQUIRED        shift and go to state 160
    INT             shift and go to state 95
    DOUBLE          shift and go to state 96
    STRING          shift and go to state 97
    BOOL            shift and go to state 37
    LIST            shift and go to state 93

    parameter_list                 shift and go to state 162
    parameter                      shift and go to state 159
    type                           shift and go to state 156

state 93

    (81) type -> LIST .

    GREATER         reduce using rule 81 (type -> LIST .)
    ID              reduce using rule 81 (type -> LIST .)


state 94

    (83) list_definition -> LIST LESS type . GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON

    GREATER         shift and go to state 164


state 95

    (77) type -> INT .

    GREATER         reduce using rule 77 (type -> INT .)
    ID              reduce using rule 77 (type -> INT .)


state 96

    (78) type -> DOUBLE .

    GREATER         reduce using rule 78 (type -> DOUBLE .)
    ID              reduce using rule 78 (type -> DOUBLE .)


state 97

    (79) type -> STRING .

    GREATER         reduce using rule 79 (type -> STRING .)
    ID              reduce using rule 79 (type -> STRING .)


state 98

    (35) variable_definition -> DYNAMIC ID ASSIGN . expression SEMICOLON
    (44) expression -> . expression PLUS expression
    (45) expression -> . expression MINUS expression
    (46) expression -> . expression TIMES expression
    (47) expression -> . expression DIVIDE expression
    (48) expression -> . expression AND expression
    (49) expression -> . expression OR expression
    (50) expression -> . value comparator value
    (51) expression -> . value PLUS value
    (52) expression -> . value
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 83
    ID              shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72

    expression                     shift and go to state 165
    value                          shift and go to state 82
    interpolated_string            shift and go to state 70

state 99

    (37) variable_definition -> INT ID ASSIGN . length SEMICOLON
    (38) variable_definition -> INT ID ASSIGN . NUMBER SEMICOLON
    (24) length -> . call_list DOT LENGTH
    (25) length -> . TEXT DOT LENGTH
    (82) call_list -> . LSBRACKET value_list RSBRACKET

    NUMBER          shift and go to state 167
    TEXT            shift and go to state 168
    LSBRACKET       shift and go to state 74

    length                         shift and go to state 166
    call_list                      shift and go to state 73

state 100

    (39) variable_definition -> DOUBLE ID ASSIGN . NDOUBLE SEMICOLON

    NDOUBLE         shift and go to state 169


state 101

    (122) map_declaration -> MAP LESS key_type . COMMA type GREATER ID ASSIGN

    COMMA           shift and go to state 170


state 102

    (128) key_type -> STRING .

    COMMA           reduce using rule 128 (key_type -> STRING .)


state 103

    (55) control_structures_if_else -> if_block else_if_blocks else_block .

    SEMICOLON       reduce using rule 55 (control_structures_if_else -> if_block else_if_blocks else_block .)
    PRINT           reduce using rule 55 (control_structures_if_else -> if_block else_if_blocks else_block .)
    STRING          reduce using rule 55 (control_structures_if_else -> if_block else_if_blocks else_block .)
    VAR             reduce using rule 55 (control_structures_if_else -> if_block else_if_blocks else_block .)
    FINAL           reduce using rule 55 (control_structures_if_else -> if_block else_if_blocks else_block .)
    ID              reduce using rule 55 (control_structures_if_else -> if_block else_if_blocks else_block .)
    VOID            reduce using rule 55 (control_structures_if_else -> if_block else_if_blocks else_block .)
    LIST            reduce using rule 55 (control_structures_if_else -> if_block else_if_blocks else_block .)
    DYNAMIC         reduce using rule 55 (control_structures_if_else -> if_block else_if_blocks else_block .)
    INT             reduce using rule 55 (control_structures_if_else -> if_block else_if_blocks else_block .)
    DOUBLE          reduce using rule 55 (control_structures_if_else -> if_block else_if_blocks else_block .)
    MAP             reduce using rule 55 (control_structures_if_else -> if_block else_if_blocks else_block .)
    WHILE           reduce using rule 55 (control_structures_if_else -> if_block else_if_blocks else_block .)
    BOOL            reduce using rule 55 (control_structures_if_else -> if_block else_if_blocks else_block .)
    IF              reduce using rule 55 (control_structures_if_else -> if_block else_if_blocks else_block .)
    FOR             reduce using rule 55 (control_structures_if_else -> if_block else_if_blocks else_block .)
    $end            reduce using rule 55 (control_structures_if_else -> if_block else_if_blocks else_block .)
    RBRACKET        reduce using rule 55 (control_structures_if_else -> if_block else_if_blocks else_block .)


state 104

    (59) else_if_blocks -> else_if_blocks ELSE . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (60) else_block -> ELSE . LBRACKET statement_list RBRACKET

    IF              shift and go to state 171
    LBRACKET        shift and go to state 106


state 105

    (58) else_if_blocks -> ELSE IF . LPAREN conditions RPAREN LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 172


state 106

    (60) else_block -> ELSE LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (95) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (96) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (97) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (121) map -> . map_declaration map_assignment
    (118) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (119) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (122) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (53) control_structures_if_else -> . if_block
    (54) control_structures_if_else -> . if_block else_if_blocks
    (55) control_structures_if_else -> . if_block else_if_blocks else_block
    (56) control_structures_if_else -> . if_block else_block
    (113) control_structures_for -> . for_classic
    (114) control_structures_for -> . for_in
    (115) control_structures_for -> . for_each
    (120) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (77) type -> . INT
    (78) type -> . DOUBLE
    (79) type -> . STRING
    (80) type -> . BOOL
    (81) type -> . LIST
    (57) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (106) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (112) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement_list                 shift and go to state 173
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 107

    (66) condition -> LPAREN . conditions RPAREN
    (61) conditions -> . condition
    (62) conditions -> . conditions AND conditions
    (63) conditions -> . conditions OR conditions
    (64) condition -> . value comparator value
    (65) condition -> . NOT condition
    (66) condition -> . LPAREN conditions RPAREN
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 111
    LPAREN          shift and go to state 107
    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 83
    ID              shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72

    conditions                     shift and go to state 174
    condition                      shift and go to state 109
    value                          shift and go to state 110
    interpolated_string            shift and go to state 70

state 108

    (120) control_structures_while -> WHILE LPAREN conditions . LBRACKET statement_list RBRACKET
    (62) conditions -> conditions . AND conditions
    (63) conditions -> conditions . OR conditions

    LBRACKET        shift and go to state 175
    AND             shift and go to state 176
    OR              shift and go to state 177


state 109

    (61) conditions -> condition .

    LBRACKET        reduce using rule 61 (conditions -> condition .)
    AND             reduce using rule 61 (conditions -> condition .)
    OR              reduce using rule 61 (conditions -> condition .)
    RPAREN          reduce using rule 61 (conditions -> condition .)
    SEMICOLON       reduce using rule 61 (conditions -> condition .)


state 110

    (64) condition -> value . comparator value
    (67) comparator -> . GREATER
    (68) comparator -> . LESS
    (69) comparator -> . EQUALS
    (70) comparator -> . GREATER_EQUAL
    (71) comparator -> . LESS_EQUAL
    (72) comparator -> . NOT_EQUALS

    GREATER         shift and go to state 124
    LESS            shift and go to state 125
    EQUALS          shift and go to state 126
    GREATER_EQUAL   shift and go to state 127
    LESS_EQUAL      shift and go to state 128
    NOT_EQUALS      shift and go to state 129

    comparator                     shift and go to state 178

state 111

    (65) condition -> NOT . condition
    (64) condition -> . value comparator value
    (65) condition -> . NOT condition
    (66) condition -> . LPAREN conditions RPAREN
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 111
    LPAREN          shift and go to state 107
    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 83
    ID              shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72

    condition                      shift and go to state 179
    value                          shift and go to state 110
    interpolated_string            shift and go to state 70

state 112

    (57) if_block -> IF LPAREN conditions . RPAREN LBRACKET statement_list RBRACKET
    (62) conditions -> conditions . AND conditions
    (63) conditions -> conditions . OR conditions

    RPAREN          shift and go to state 180
    AND             shift and go to state 176
    OR              shift and go to state 177


state 113

    (106) for_classic -> FOR LPAREN for_classic_parenthesis_content . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 181


state 114

    (108) for_in -> FOR LPAREN for_in_parenthesis_content . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 182


state 115

    (112) for_each -> FOR LPAREN for_each_parenthesis_content . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 183


state 116

    (105) for_classic_parenthesis_content -> for_classic_initialization . SEMICOLON for_classic_conditions SEMICOLON for_classic_changes

    SEMICOLON       shift and go to state 184


state 117

    (107) for_in_parenthesis_content -> FINAL . ID IN ID
    (111) for_each_parenthesis_content -> FINAL . ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID

    ID              shift and go to state 185


state 118

    (98) for_classic_initialization -> INT . ID ASSIGN NUMBER

    ID              shift and go to state 186


state 119

    (99) for_classic_initialization -> DOUBLE . ID ASSIGN NDOUBLE

    ID              shift and go to state 187


state 120

    (40) print -> PRINT LPAREN RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)


state 121

    (41) print -> PRINT LPAREN value RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 188


state 122

    (50) expression -> value comparator . value
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 83
    ID              shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72

    value                          shift and go to state 189
    interpolated_string            shift and go to state 70

state 123

    (51) expression -> value PLUS . value
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 83
    ID              shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72

    value                          shift and go to state 190
    interpolated_string            shift and go to state 70

state 124

    (67) comparator -> GREATER .

    NUMBER          reduce using rule 67 (comparator -> GREATER .)
    NDOUBLE         reduce using rule 67 (comparator -> GREATER .)
    TEXT            reduce using rule 67 (comparator -> GREATER .)
    ID              reduce using rule 67 (comparator -> GREATER .)
    TRUE            reduce using rule 67 (comparator -> GREATER .)
    FALSE           reduce using rule 67 (comparator -> GREATER .)


state 125

    (68) comparator -> LESS .

    NUMBER          reduce using rule 68 (comparator -> LESS .)
    NDOUBLE         reduce using rule 68 (comparator -> LESS .)
    TEXT            reduce using rule 68 (comparator -> LESS .)
    ID              reduce using rule 68 (comparator -> LESS .)
    TRUE            reduce using rule 68 (comparator -> LESS .)
    FALSE           reduce using rule 68 (comparator -> LESS .)


state 126

    (69) comparator -> EQUALS .

    NUMBER          reduce using rule 69 (comparator -> EQUALS .)
    NDOUBLE         reduce using rule 69 (comparator -> EQUALS .)
    TEXT            reduce using rule 69 (comparator -> EQUALS .)
    ID              reduce using rule 69 (comparator -> EQUALS .)
    TRUE            reduce using rule 69 (comparator -> EQUALS .)
    FALSE           reduce using rule 69 (comparator -> EQUALS .)


state 127

    (70) comparator -> GREATER_EQUAL .

    NUMBER          reduce using rule 70 (comparator -> GREATER_EQUAL .)
    NDOUBLE         reduce using rule 70 (comparator -> GREATER_EQUAL .)
    TEXT            reduce using rule 70 (comparator -> GREATER_EQUAL .)
    ID              reduce using rule 70 (comparator -> GREATER_EQUAL .)
    TRUE            reduce using rule 70 (comparator -> GREATER_EQUAL .)
    FALSE           reduce using rule 70 (comparator -> GREATER_EQUAL .)


state 128

    (71) comparator -> LESS_EQUAL .

    NUMBER          reduce using rule 71 (comparator -> LESS_EQUAL .)
    NDOUBLE         reduce using rule 71 (comparator -> LESS_EQUAL .)
    TEXT            reduce using rule 71 (comparator -> LESS_EQUAL .)
    ID              reduce using rule 71 (comparator -> LESS_EQUAL .)
    TRUE            reduce using rule 71 (comparator -> LESS_EQUAL .)
    FALSE           reduce using rule 71 (comparator -> LESS_EQUAL .)


state 129

    (72) comparator -> NOT_EQUALS .

    NUMBER          reduce using rule 72 (comparator -> NOT_EQUALS .)
    NDOUBLE         reduce using rule 72 (comparator -> NOT_EQUALS .)
    TEXT            reduce using rule 72 (comparator -> NOT_EQUALS .)
    ID              reduce using rule 72 (comparator -> NOT_EQUALS .)
    TRUE            reduce using rule 72 (comparator -> NOT_EQUALS .)
    FALSE           reduce using rule 72 (comparator -> NOT_EQUALS .)


state 130

    (42) print -> PRINT LPAREN expression RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 191


state 131

    (44) expression -> expression PLUS . expression
    (44) expression -> . expression PLUS expression
    (45) expression -> . expression MINUS expression
    (46) expression -> . expression TIMES expression
    (47) expression -> . expression DIVIDE expression
    (48) expression -> . expression AND expression
    (49) expression -> . expression OR expression
    (50) expression -> . value comparator value
    (51) expression -> . value PLUS value
    (52) expression -> . value
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 83
    ID              shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72

    expression                     shift and go to state 192
    value                          shift and go to state 82
    interpolated_string            shift and go to state 70

state 132

    (45) expression -> expression MINUS . expression
    (44) expression -> . expression PLUS expression
    (45) expression -> . expression MINUS expression
    (46) expression -> . expression TIMES expression
    (47) expression -> . expression DIVIDE expression
    (48) expression -> . expression AND expression
    (49) expression -> . expression OR expression
    (50) expression -> . value comparator value
    (51) expression -> . value PLUS value
    (52) expression -> . value
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 83
    ID              shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72

    expression                     shift and go to state 193
    value                          shift and go to state 82
    interpolated_string            shift and go to state 70

state 133

    (46) expression -> expression TIMES . expression
    (44) expression -> . expression PLUS expression
    (45) expression -> . expression MINUS expression
    (46) expression -> . expression TIMES expression
    (47) expression -> . expression DIVIDE expression
    (48) expression -> . expression AND expression
    (49) expression -> . expression OR expression
    (50) expression -> . value comparator value
    (51) expression -> . value PLUS value
    (52) expression -> . value
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 83
    ID              shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72

    expression                     shift and go to state 194
    value                          shift and go to state 82
    interpolated_string            shift and go to state 70

state 134

    (47) expression -> expression DIVIDE . expression
    (44) expression -> . expression PLUS expression
    (45) expression -> . expression MINUS expression
    (46) expression -> . expression TIMES expression
    (47) expression -> . expression DIVIDE expression
    (48) expression -> . expression AND expression
    (49) expression -> . expression OR expression
    (50) expression -> . value comparator value
    (51) expression -> . value PLUS value
    (52) expression -> . value
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 83
    ID              shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72

    expression                     shift and go to state 195
    value                          shift and go to state 82
    interpolated_string            shift and go to state 70

state 135

    (48) expression -> expression AND . expression
    (44) expression -> . expression PLUS expression
    (45) expression -> . expression MINUS expression
    (46) expression -> . expression TIMES expression
    (47) expression -> . expression DIVIDE expression
    (48) expression -> . expression AND expression
    (49) expression -> . expression OR expression
    (50) expression -> . value comparator value
    (51) expression -> . value PLUS value
    (52) expression -> . value
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 83
    ID              shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72

    expression                     shift and go to state 196
    value                          shift and go to state 82
    interpolated_string            shift and go to state 70

state 136

    (49) expression -> expression OR . expression
    (44) expression -> . expression PLUS expression
    (45) expression -> . expression MINUS expression
    (46) expression -> . expression TIMES expression
    (47) expression -> . expression DIVIDE expression
    (48) expression -> . expression AND expression
    (49) expression -> . expression OR expression
    (50) expression -> . value comparator value
    (51) expression -> . value PLUS value
    (52) expression -> . value
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 83
    ID              shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72

    expression                     shift and go to state 197
    value                          shift and go to state 82
    interpolated_string            shift and go to state 70

state 137

    (43) print -> PRINT LPAREN length RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 198


state 138

    (25) length -> TEXT DOT . LENGTH

    LENGTH          shift and go to state 199


state 139

    (93) interpolated_string -> TEXT PLUS . ID
    (94) interpolated_string -> TEXT PLUS . expression
    (44) expression -> . expression PLUS expression
    (45) expression -> . expression MINUS expression
    (46) expression -> . expression TIMES expression
    (47) expression -> . expression DIVIDE expression
    (48) expression -> . expression AND expression
    (49) expression -> . expression OR expression
    (50) expression -> . value comparator value
    (51) expression -> . value PLUS value
    (52) expression -> . value
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression

    ID              shift and go to state 200
    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 83
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72

    expression                     shift and go to state 201
    value                          shift and go to state 82
    interpolated_string            shift and go to state 70

state 140

    (24) length -> call_list DOT . LENGTH

    LENGTH          shift and go to state 202


state 141

    (82) call_list -> LSBRACKET value_list . RSBRACKET
    (85) value_list -> value_list . COMMA value

    RSBRACKET       shift and go to state 203
    COMMA           shift and go to state 204


state 142

    (84) value_list -> value .

    RSBRACKET       reduce using rule 84 (value_list -> value .)
    COMMA           reduce using rule 84 (value_list -> value .)
    RBRACKET        reduce using rule 84 (value_list -> value .)


state 143

    (22) data_input -> STRING ID ASSIGN STDIN . DOT READLINESYNC LPAREN RPAREN SEMICOLON

    DOT             shift and go to state 205


state 144

    (23) data_input -> STRING QUESTION ID ASSIGN . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    STDIN           shift and go to state 206


state 145

    (118) constructor -> ID LPAREN constructor_parenthesis_content RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 207


state 146

    (20) call_function -> ID LPAREN argument_list RPAREN .

    SEMICOLON       reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    PRINT           reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    STRING          reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    VAR             reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    FINAL           reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    ID              reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    VOID            reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    LIST            reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    DYNAMIC         reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    INT             reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    DOUBLE          reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    MAP             reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    WHILE           reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    BOOL            reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    IF              reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    FOR             reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    $end            reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    RBRACKET        reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)


state 147

    (27) argument_list -> argument_list COMMA . expression
    (44) expression -> . expression PLUS expression
    (45) expression -> . expression MINUS expression
    (46) expression -> . expression TIMES expression
    (47) expression -> . expression DIVIDE expression
    (48) expression -> . expression AND expression
    (49) expression -> . expression OR expression
    (50) expression -> . value comparator value
    (51) expression -> . value PLUS value
    (52) expression -> . value
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 83
    ID              shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72

    expression                     shift and go to state 208
    value                          shift and go to state 82
    interpolated_string            shift and go to state 70

state 148

    (116) constructor_parenthesis_content -> THIS DOT . ID
    (117) constructor_parenthesis_content -> THIS DOT . ID COMMA constructor_parenthesis_content

    ID              shift and go to state 209


state 149

    (95) set -> VAR ID ASSIGN LBRACKET . value_list RBRACKET SEMICOLON
    (84) value_list -> . value
    (85) value_list -> . value_list COMMA value
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 83
    ID              shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72

    value_list                     shift and go to state 210
    value                          shift and go to state 142
    interpolated_string            shift and go to state 70

state 150

    (96) set -> VAR ID ASSIGN LESS . STRING GREATER LBRACKET RBRACKET SEMICOLON

    STRING          shift and go to state 211


state 151

    (36) variable_definition -> VAR ID ASSIGN expression . SEMICOLON
    (44) expression -> expression . PLUS expression
    (45) expression -> expression . MINUS expression
    (46) expression -> expression . TIMES expression
    (47) expression -> expression . DIVIDE expression
    (48) expression -> expression . AND expression
    (49) expression -> expression . OR expression

    SEMICOLON       shift and go to state 212
    PLUS            shift and go to state 131
    MINUS           shift and go to state 132
    TIMES           shift and go to state 133
    DIVIDE          shift and go to state 134
    AND             shift and go to state 135
    OR              shift and go to state 136


state 152

    (97) set -> FINAL ID ASSIGN CONST . LBRACKET value_list RBRACKET SEMICOLON

    LBRACKET        shift and go to state 213


state 153

    (123) map_assignment -> LBRACKET map_contents RBRACKET .

    SEMICOLON       reduce using rule 123 (map_assignment -> LBRACKET map_contents RBRACKET .)
    PRINT           reduce using rule 123 (map_assignment -> LBRACKET map_contents RBRACKET .)
    STRING          reduce using rule 123 (map_assignment -> LBRACKET map_contents RBRACKET .)
    VAR             reduce using rule 123 (map_assignment -> LBRACKET map_contents RBRACKET .)
    FINAL           reduce using rule 123 (map_assignment -> LBRACKET map_contents RBRACKET .)
    ID              reduce using rule 123 (map_assignment -> LBRACKET map_contents RBRACKET .)
    VOID            reduce using rule 123 (map_assignment -> LBRACKET map_contents RBRACKET .)
    LIST            reduce using rule 123 (map_assignment -> LBRACKET map_contents RBRACKET .)
    DYNAMIC         reduce using rule 123 (map_assignment -> LBRACKET map_contents RBRACKET .)
    INT             reduce using rule 123 (map_assignment -> LBRACKET map_contents RBRACKET .)
    DOUBLE          reduce using rule 123 (map_assignment -> LBRACKET map_contents RBRACKET .)
    MAP             reduce using rule 123 (map_assignment -> LBRACKET map_contents RBRACKET .)
    WHILE           reduce using rule 123 (map_assignment -> LBRACKET map_contents RBRACKET .)
    BOOL            reduce using rule 123 (map_assignment -> LBRACKET map_contents RBRACKET .)
    IF              reduce using rule 123 (map_assignment -> LBRACKET map_contents RBRACKET .)
    FOR             reduce using rule 123 (map_assignment -> LBRACKET map_contents RBRACKET .)
    $end            reduce using rule 123 (map_assignment -> LBRACKET map_contents RBRACKET .)
    RBRACKET        reduce using rule 123 (map_assignment -> LBRACKET map_contents RBRACKET .)


state 154

    (125) map_contents -> map_content COMMA . map_contents
    (124) map_contents -> . map_content
    (125) map_contents -> . map_content COMMA map_contents
    (126) map_content -> . key_value COLON value
    (127) key_value -> . TEXT

    TEXT            shift and go to state 89

    map_content                    shift and go to state 87
    map_contents                   shift and go to state 214
    key_value                      shift and go to state 88

state 155

    (126) map_content -> key_value COLON . value
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 83
    ID              shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72

    value                          shift and go to state 215
    interpolated_string            shift and go to state 70

state 156

    (75) parameter -> type . ID

    ID              shift and go to state 216


state 157

    (28) function -> type ID LPAREN parameter_list . RPAREN LBRACKET statement_list RBRACKET
    (119) function -> type ID LPAREN parameter_list . RPAREN ASSIGN GREATER expression
    (74) parameter_list -> parameter_list . COMMA parameter

    RPAREN          shift and go to state 217
    COMMA           shift and go to state 218


state 158

    (30) function -> type ID LPAREN RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 219


state 159

    (73) parameter_list -> parameter .

    RPAREN          reduce using rule 73 (parameter_list -> parameter .)
    COMMA           reduce using rule 73 (parameter_list -> parameter .)


state 160

    (76) parameter -> REQUIRED . type ID
    (77) type -> . INT
    (78) type -> . DOUBLE
    (79) type -> . STRING
    (80) type -> . BOOL
    (81) type -> . LIST

    INT             shift and go to state 95
    DOUBLE          shift and go to state 96
    STRING          shift and go to state 97
    BOOL            shift and go to state 37
    LIST            shift and go to state 93

    type                           shift and go to state 220

state 161

    (34) variable_definition -> type ID ASSIGN expression . SEMICOLON
    (44) expression -> expression . PLUS expression
    (45) expression -> expression . MINUS expression
    (46) expression -> expression . TIMES expression
    (47) expression -> expression . DIVIDE expression
    (48) expression -> expression . AND expression
    (49) expression -> expression . OR expression

    SEMICOLON       shift and go to state 221
    PLUS            shift and go to state 131
    MINUS           shift and go to state 132
    TIMES           shift and go to state 133
    DIVIDE          shift and go to state 134
    AND             shift and go to state 135
    OR              shift and go to state 136


state 162

    (29) function -> VOID ID LPAREN parameter_list . RPAREN LBRACKET statement_list RBRACKET
    (33) function -> VOID ID LPAREN parameter_list . RPAREN LBRACKET RBRACKET
    (74) parameter_list -> parameter_list . COMMA parameter

    RPAREN          shift and go to state 222
    COMMA           shift and go to state 218


state 163

    (31) function -> VOID ID LPAREN RPAREN . LBRACKET statement_list RBRACKET
    (32) function -> VOID ID LPAREN RPAREN . LBRACKET RBRACKET

    LBRACKET        shift and go to state 223


state 164

    (83) list_definition -> LIST LESS type GREATER . ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON

    ID              shift and go to state 224


state 165

    (35) variable_definition -> DYNAMIC ID ASSIGN expression . SEMICOLON
    (44) expression -> expression . PLUS expression
    (45) expression -> expression . MINUS expression
    (46) expression -> expression . TIMES expression
    (47) expression -> expression . DIVIDE expression
    (48) expression -> expression . AND expression
    (49) expression -> expression . OR expression

    SEMICOLON       shift and go to state 225
    PLUS            shift and go to state 131
    MINUS           shift and go to state 132
    TIMES           shift and go to state 133
    DIVIDE          shift and go to state 134
    AND             shift and go to state 135
    OR              shift and go to state 136


state 166

    (37) variable_definition -> INT ID ASSIGN length . SEMICOLON

    SEMICOLON       shift and go to state 226


state 167

    (38) variable_definition -> INT ID ASSIGN NUMBER . SEMICOLON

    SEMICOLON       shift and go to state 227


state 168

    (25) length -> TEXT . DOT LENGTH

    DOT             shift and go to state 138


state 169

    (39) variable_definition -> DOUBLE ID ASSIGN NDOUBLE . SEMICOLON

    SEMICOLON       shift and go to state 228


state 170

    (122) map_declaration -> MAP LESS key_type COMMA . type GREATER ID ASSIGN
    (77) type -> . INT
    (78) type -> . DOUBLE
    (79) type -> . STRING
    (80) type -> . BOOL
    (81) type -> . LIST

    INT             shift and go to state 95
    DOUBLE          shift and go to state 96
    STRING          shift and go to state 97
    BOOL            shift and go to state 37
    LIST            shift and go to state 93

    type                           shift and go to state 229

state 171

    (59) else_if_blocks -> else_if_blocks ELSE IF . LPAREN conditions RPAREN LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 230


state 172

    (58) else_if_blocks -> ELSE IF LPAREN . conditions RPAREN LBRACKET statement_list RBRACKET
    (61) conditions -> . condition
    (62) conditions -> . conditions AND conditions
    (63) conditions -> . conditions OR conditions
    (64) condition -> . value comparator value
    (65) condition -> . NOT condition
    (66) condition -> . LPAREN conditions RPAREN
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 111
    LPAREN          shift and go to state 107
    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 83
    ID              shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72

    conditions                     shift and go to state 231
    condition                      shift and go to state 109
    value                          shift and go to state 110
    interpolated_string            shift and go to state 70

state 173

    (60) else_block -> ELSE LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (95) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (96) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (97) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (121) map -> . map_declaration map_assignment
    (118) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (119) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (122) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (53) control_structures_if_else -> . if_block
    (54) control_structures_if_else -> . if_block else_if_blocks
    (55) control_structures_if_else -> . if_block else_if_blocks else_block
    (56) control_structures_if_else -> . if_block else_block
    (113) control_structures_for -> . for_classic
    (114) control_structures_for -> . for_in
    (115) control_structures_for -> . for_each
    (120) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (77) type -> . INT
    (78) type -> . DOUBLE
    (79) type -> . STRING
    (80) type -> . BOOL
    (81) type -> . LIST
    (57) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (106) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (112) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 232
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement                      shift and go to state 40
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 174

    (66) condition -> LPAREN conditions . RPAREN
    (62) conditions -> conditions . AND conditions
    (63) conditions -> conditions . OR conditions

    RPAREN          shift and go to state 233
    AND             shift and go to state 176
    OR              shift and go to state 177


state 175

    (120) control_structures_while -> WHILE LPAREN conditions LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (95) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (96) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (97) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (121) map -> . map_declaration map_assignment
    (118) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (119) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (122) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (53) control_structures_if_else -> . if_block
    (54) control_structures_if_else -> . if_block else_if_blocks
    (55) control_structures_if_else -> . if_block else_if_blocks else_block
    (56) control_structures_if_else -> . if_block else_block
    (113) control_structures_for -> . for_classic
    (114) control_structures_for -> . for_in
    (115) control_structures_for -> . for_each
    (120) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (77) type -> . INT
    (78) type -> . DOUBLE
    (79) type -> . STRING
    (80) type -> . BOOL
    (81) type -> . LIST
    (57) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (106) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (112) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement_list                 shift and go to state 234
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 176

    (62) conditions -> conditions AND . conditions
    (61) conditions -> . condition
    (62) conditions -> . conditions AND conditions
    (63) conditions -> . conditions OR conditions
    (64) condition -> . value comparator value
    (65) condition -> . NOT condition
    (66) condition -> . LPAREN conditions RPAREN
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 111
    LPAREN          shift and go to state 107
    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 83
    ID              shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72

    conditions                     shift and go to state 235
    condition                      shift and go to state 109
    value                          shift and go to state 110
    interpolated_string            shift and go to state 70

state 177

    (63) conditions -> conditions OR . conditions
    (61) conditions -> . condition
    (62) conditions -> . conditions AND conditions
    (63) conditions -> . conditions OR conditions
    (64) condition -> . value comparator value
    (65) condition -> . NOT condition
    (66) condition -> . LPAREN conditions RPAREN
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 111
    LPAREN          shift and go to state 107
    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 83
    ID              shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72

    conditions                     shift and go to state 236
    condition                      shift and go to state 109
    value                          shift and go to state 110
    interpolated_string            shift and go to state 70

state 178

    (64) condition -> value comparator . value
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 83
    ID              shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72

    value                          shift and go to state 237
    interpolated_string            shift and go to state 70

state 179

    (65) condition -> NOT condition .

    LBRACKET        reduce using rule 65 (condition -> NOT condition .)
    AND             reduce using rule 65 (condition -> NOT condition .)
    OR              reduce using rule 65 (condition -> NOT condition .)
    RPAREN          reduce using rule 65 (condition -> NOT condition .)
    SEMICOLON       reduce using rule 65 (condition -> NOT condition .)


state 180

    (57) if_block -> IF LPAREN conditions RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 238


state 181

    (106) for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 239


state 182

    (108) for_in -> FOR LPAREN for_in_parenthesis_content RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 240


state 183

    (112) for_each -> FOR LPAREN for_each_parenthesis_content RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 241


state 184

    (105) for_classic_parenthesis_content -> for_classic_initialization SEMICOLON . for_classic_conditions SEMICOLON for_classic_changes
    (100) for_classic_conditions -> . conditions
    (61) conditions -> . condition
    (62) conditions -> . conditions AND conditions
    (63) conditions -> . conditions OR conditions
    (64) condition -> . value comparator value
    (65) condition -> . NOT condition
    (66) condition -> . LPAREN conditions RPAREN
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 111
    LPAREN          shift and go to state 107
    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 83
    ID              shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72

    for_classic_conditions         shift and go to state 242
    conditions                     shift and go to state 243
    condition                      shift and go to state 109
    value                          shift and go to state 110
    interpolated_string            shift and go to state 70

state 185

    (107) for_in_parenthesis_content -> FINAL ID . IN ID
    (111) for_each_parenthesis_content -> FINAL ID . LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID

    IN              shift and go to state 244
    LPAREN          shift and go to state 245


state 186

    (98) for_classic_initialization -> INT ID . ASSIGN NUMBER

    ASSIGN          shift and go to state 246


state 187

    (99) for_classic_initialization -> DOUBLE ID . ASSIGN NDOUBLE

    ASSIGN          shift and go to state 247


state 188

    (41) print -> PRINT LPAREN value RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 41 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    PRINT           reduce using rule 41 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    STRING          reduce using rule 41 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    VAR             reduce using rule 41 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    FINAL           reduce using rule 41 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    ID              reduce using rule 41 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    VOID            reduce using rule 41 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    LIST            reduce using rule 41 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 41 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    INT             reduce using rule 41 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 41 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    MAP             reduce using rule 41 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    WHILE           reduce using rule 41 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    BOOL            reduce using rule 41 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    IF              reduce using rule 41 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    FOR             reduce using rule 41 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    $end            reduce using rule 41 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 41 (print -> PRINT LPAREN value RPAREN SEMICOLON .)


state 189

    (50) expression -> value comparator value .

    RPAREN          reduce using rule 50 (expression -> value comparator value .)
    PLUS            reduce using rule 50 (expression -> value comparator value .)
    MINUS           reduce using rule 50 (expression -> value comparator value .)
    TIMES           reduce using rule 50 (expression -> value comparator value .)
    DIVIDE          reduce using rule 50 (expression -> value comparator value .)
    AND             reduce using rule 50 (expression -> value comparator value .)
    OR              reduce using rule 50 (expression -> value comparator value .)
    COMMA           reduce using rule 50 (expression -> value comparator value .)
    SEMICOLON       reduce using rule 50 (expression -> value comparator value .)
    GREATER         reduce using rule 50 (expression -> value comparator value .)
    LESS            reduce using rule 50 (expression -> value comparator value .)
    EQUALS          reduce using rule 50 (expression -> value comparator value .)
    GREATER_EQUAL   reduce using rule 50 (expression -> value comparator value .)
    LESS_EQUAL      reduce using rule 50 (expression -> value comparator value .)
    NOT_EQUALS      reduce using rule 50 (expression -> value comparator value .)
    RSBRACKET       reduce using rule 50 (expression -> value comparator value .)
    PRINT           reduce using rule 50 (expression -> value comparator value .)
    STRING          reduce using rule 50 (expression -> value comparator value .)
    VAR             reduce using rule 50 (expression -> value comparator value .)
    FINAL           reduce using rule 50 (expression -> value comparator value .)
    ID              reduce using rule 50 (expression -> value comparator value .)
    VOID            reduce using rule 50 (expression -> value comparator value .)
    LIST            reduce using rule 50 (expression -> value comparator value .)
    DYNAMIC         reduce using rule 50 (expression -> value comparator value .)
    INT             reduce using rule 50 (expression -> value comparator value .)
    DOUBLE          reduce using rule 50 (expression -> value comparator value .)
    MAP             reduce using rule 50 (expression -> value comparator value .)
    WHILE           reduce using rule 50 (expression -> value comparator value .)
    BOOL            reduce using rule 50 (expression -> value comparator value .)
    IF              reduce using rule 50 (expression -> value comparator value .)
    FOR             reduce using rule 50 (expression -> value comparator value .)
    $end            reduce using rule 50 (expression -> value comparator value .)
    RBRACKET        reduce using rule 50 (expression -> value comparator value .)
    LBRACKET        reduce using rule 50 (expression -> value comparator value .)


state 190

    (51) expression -> value PLUS value .

    RPAREN          reduce using rule 51 (expression -> value PLUS value .)
    PLUS            reduce using rule 51 (expression -> value PLUS value .)
    MINUS           reduce using rule 51 (expression -> value PLUS value .)
    TIMES           reduce using rule 51 (expression -> value PLUS value .)
    DIVIDE          reduce using rule 51 (expression -> value PLUS value .)
    AND             reduce using rule 51 (expression -> value PLUS value .)
    OR              reduce using rule 51 (expression -> value PLUS value .)
    COMMA           reduce using rule 51 (expression -> value PLUS value .)
    SEMICOLON       reduce using rule 51 (expression -> value PLUS value .)
    GREATER         reduce using rule 51 (expression -> value PLUS value .)
    LESS            reduce using rule 51 (expression -> value PLUS value .)
    EQUALS          reduce using rule 51 (expression -> value PLUS value .)
    GREATER_EQUAL   reduce using rule 51 (expression -> value PLUS value .)
    LESS_EQUAL      reduce using rule 51 (expression -> value PLUS value .)
    NOT_EQUALS      reduce using rule 51 (expression -> value PLUS value .)
    RSBRACKET       reduce using rule 51 (expression -> value PLUS value .)
    PRINT           reduce using rule 51 (expression -> value PLUS value .)
    STRING          reduce using rule 51 (expression -> value PLUS value .)
    VAR             reduce using rule 51 (expression -> value PLUS value .)
    FINAL           reduce using rule 51 (expression -> value PLUS value .)
    ID              reduce using rule 51 (expression -> value PLUS value .)
    VOID            reduce using rule 51 (expression -> value PLUS value .)
    LIST            reduce using rule 51 (expression -> value PLUS value .)
    DYNAMIC         reduce using rule 51 (expression -> value PLUS value .)
    INT             reduce using rule 51 (expression -> value PLUS value .)
    DOUBLE          reduce using rule 51 (expression -> value PLUS value .)
    MAP             reduce using rule 51 (expression -> value PLUS value .)
    WHILE           reduce using rule 51 (expression -> value PLUS value .)
    BOOL            reduce using rule 51 (expression -> value PLUS value .)
    IF              reduce using rule 51 (expression -> value PLUS value .)
    FOR             reduce using rule 51 (expression -> value PLUS value .)
    $end            reduce using rule 51 (expression -> value PLUS value .)
    RBRACKET        reduce using rule 51 (expression -> value PLUS value .)
    LBRACKET        reduce using rule 51 (expression -> value PLUS value .)


state 191

    (42) print -> PRINT LPAREN expression RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 42 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    PRINT           reduce using rule 42 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    STRING          reduce using rule 42 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    VAR             reduce using rule 42 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FINAL           reduce using rule 42 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    ID              reduce using rule 42 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    VOID            reduce using rule 42 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LIST            reduce using rule 42 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 42 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    INT             reduce using rule 42 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 42 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    MAP             reduce using rule 42 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    WHILE           reduce using rule 42 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    BOOL            reduce using rule 42 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    IF              reduce using rule 42 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FOR             reduce using rule 42 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    $end            reduce using rule 42 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 42 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)


state 192

    (44) expression -> expression PLUS expression .
    (44) expression -> expression . PLUS expression
    (45) expression -> expression . MINUS expression
    (46) expression -> expression . TIMES expression
    (47) expression -> expression . DIVIDE expression
    (48) expression -> expression . AND expression
    (49) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 44 (expression -> expression PLUS expression .)
    COMMA           reduce using rule 44 (expression -> expression PLUS expression .)
    SEMICOLON       reduce using rule 44 (expression -> expression PLUS expression .)
    GREATER         reduce using rule 44 (expression -> expression PLUS expression .)
    LESS            reduce using rule 44 (expression -> expression PLUS expression .)
    EQUALS          reduce using rule 44 (expression -> expression PLUS expression .)
    GREATER_EQUAL   reduce using rule 44 (expression -> expression PLUS expression .)
    LESS_EQUAL      reduce using rule 44 (expression -> expression PLUS expression .)
    NOT_EQUALS      reduce using rule 44 (expression -> expression PLUS expression .)
    RSBRACKET       reduce using rule 44 (expression -> expression PLUS expression .)
    PRINT           reduce using rule 44 (expression -> expression PLUS expression .)
    STRING          reduce using rule 44 (expression -> expression PLUS expression .)
    VAR             reduce using rule 44 (expression -> expression PLUS expression .)
    FINAL           reduce using rule 44 (expression -> expression PLUS expression .)
    ID              reduce using rule 44 (expression -> expression PLUS expression .)
    VOID            reduce using rule 44 (expression -> expression PLUS expression .)
    LIST            reduce using rule 44 (expression -> expression PLUS expression .)
    DYNAMIC         reduce using rule 44 (expression -> expression PLUS expression .)
    INT             reduce using rule 44 (expression -> expression PLUS expression .)
    DOUBLE          reduce using rule 44 (expression -> expression PLUS expression .)
    MAP             reduce using rule 44 (expression -> expression PLUS expression .)
    WHILE           reduce using rule 44 (expression -> expression PLUS expression .)
    BOOL            reduce using rule 44 (expression -> expression PLUS expression .)
    IF              reduce using rule 44 (expression -> expression PLUS expression .)
    FOR             reduce using rule 44 (expression -> expression PLUS expression .)
    $end            reduce using rule 44 (expression -> expression PLUS expression .)
    RBRACKET        reduce using rule 44 (expression -> expression PLUS expression .)
    LBRACKET        reduce using rule 44 (expression -> expression PLUS expression .)
    PLUS            shift and go to state 131
    MINUS           shift and go to state 132
    TIMES           shift and go to state 133
    DIVIDE          shift and go to state 134
    AND             shift and go to state 135
    OR              shift and go to state 136

  ! PLUS            [ reduce using rule 44 (expression -> expression PLUS expression .) ]
  ! MINUS           [ reduce using rule 44 (expression -> expression PLUS expression .) ]
  ! TIMES           [ reduce using rule 44 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 44 (expression -> expression PLUS expression .) ]
  ! AND             [ reduce using rule 44 (expression -> expression PLUS expression .) ]
  ! OR              [ reduce using rule 44 (expression -> expression PLUS expression .) ]


state 193

    (45) expression -> expression MINUS expression .
    (44) expression -> expression . PLUS expression
    (45) expression -> expression . MINUS expression
    (46) expression -> expression . TIMES expression
    (47) expression -> expression . DIVIDE expression
    (48) expression -> expression . AND expression
    (49) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 45 (expression -> expression MINUS expression .)
    COMMA           reduce using rule 45 (expression -> expression MINUS expression .)
    SEMICOLON       reduce using rule 45 (expression -> expression MINUS expression .)
    GREATER         reduce using rule 45 (expression -> expression MINUS expression .)
    LESS            reduce using rule 45 (expression -> expression MINUS expression .)
    EQUALS          reduce using rule 45 (expression -> expression MINUS expression .)
    GREATER_EQUAL   reduce using rule 45 (expression -> expression MINUS expression .)
    LESS_EQUAL      reduce using rule 45 (expression -> expression MINUS expression .)
    NOT_EQUALS      reduce using rule 45 (expression -> expression MINUS expression .)
    RSBRACKET       reduce using rule 45 (expression -> expression MINUS expression .)
    PRINT           reduce using rule 45 (expression -> expression MINUS expression .)
    STRING          reduce using rule 45 (expression -> expression MINUS expression .)
    VAR             reduce using rule 45 (expression -> expression MINUS expression .)
    FINAL           reduce using rule 45 (expression -> expression MINUS expression .)
    ID              reduce using rule 45 (expression -> expression MINUS expression .)
    VOID            reduce using rule 45 (expression -> expression MINUS expression .)
    LIST            reduce using rule 45 (expression -> expression MINUS expression .)
    DYNAMIC         reduce using rule 45 (expression -> expression MINUS expression .)
    INT             reduce using rule 45 (expression -> expression MINUS expression .)
    DOUBLE          reduce using rule 45 (expression -> expression MINUS expression .)
    MAP             reduce using rule 45 (expression -> expression MINUS expression .)
    WHILE           reduce using rule 45 (expression -> expression MINUS expression .)
    BOOL            reduce using rule 45 (expression -> expression MINUS expression .)
    IF              reduce using rule 45 (expression -> expression MINUS expression .)
    FOR             reduce using rule 45 (expression -> expression MINUS expression .)
    $end            reduce using rule 45 (expression -> expression MINUS expression .)
    RBRACKET        reduce using rule 45 (expression -> expression MINUS expression .)
    LBRACKET        reduce using rule 45 (expression -> expression MINUS expression .)
    PLUS            shift and go to state 131
    MINUS           shift and go to state 132
    TIMES           shift and go to state 133
    DIVIDE          shift and go to state 134
    AND             shift and go to state 135
    OR              shift and go to state 136

  ! PLUS            [ reduce using rule 45 (expression -> expression MINUS expression .) ]
  ! MINUS           [ reduce using rule 45 (expression -> expression MINUS expression .) ]
  ! TIMES           [ reduce using rule 45 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 45 (expression -> expression MINUS expression .) ]
  ! AND             [ reduce using rule 45 (expression -> expression MINUS expression .) ]
  ! OR              [ reduce using rule 45 (expression -> expression MINUS expression .) ]


state 194

    (46) expression -> expression TIMES expression .
    (44) expression -> expression . PLUS expression
    (45) expression -> expression . MINUS expression
    (46) expression -> expression . TIMES expression
    (47) expression -> expression . DIVIDE expression
    (48) expression -> expression . AND expression
    (49) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 46 (expression -> expression TIMES expression .)
    COMMA           reduce using rule 46 (expression -> expression TIMES expression .)
    SEMICOLON       reduce using rule 46 (expression -> expression TIMES expression .)
    GREATER         reduce using rule 46 (expression -> expression TIMES expression .)
    LESS            reduce using rule 46 (expression -> expression TIMES expression .)
    EQUALS          reduce using rule 46 (expression -> expression TIMES expression .)
    GREATER_EQUAL   reduce using rule 46 (expression -> expression TIMES expression .)
    LESS_EQUAL      reduce using rule 46 (expression -> expression TIMES expression .)
    NOT_EQUALS      reduce using rule 46 (expression -> expression TIMES expression .)
    RSBRACKET       reduce using rule 46 (expression -> expression TIMES expression .)
    PRINT           reduce using rule 46 (expression -> expression TIMES expression .)
    STRING          reduce using rule 46 (expression -> expression TIMES expression .)
    VAR             reduce using rule 46 (expression -> expression TIMES expression .)
    FINAL           reduce using rule 46 (expression -> expression TIMES expression .)
    ID              reduce using rule 46 (expression -> expression TIMES expression .)
    VOID            reduce using rule 46 (expression -> expression TIMES expression .)
    LIST            reduce using rule 46 (expression -> expression TIMES expression .)
    DYNAMIC         reduce using rule 46 (expression -> expression TIMES expression .)
    INT             reduce using rule 46 (expression -> expression TIMES expression .)
    DOUBLE          reduce using rule 46 (expression -> expression TIMES expression .)
    MAP             reduce using rule 46 (expression -> expression TIMES expression .)
    WHILE           reduce using rule 46 (expression -> expression TIMES expression .)
    BOOL            reduce using rule 46 (expression -> expression TIMES expression .)
    IF              reduce using rule 46 (expression -> expression TIMES expression .)
    FOR             reduce using rule 46 (expression -> expression TIMES expression .)
    $end            reduce using rule 46 (expression -> expression TIMES expression .)
    RBRACKET        reduce using rule 46 (expression -> expression TIMES expression .)
    LBRACKET        reduce using rule 46 (expression -> expression TIMES expression .)
    PLUS            shift and go to state 131
    MINUS           shift and go to state 132
    TIMES           shift and go to state 133
    DIVIDE          shift and go to state 134
    AND             shift and go to state 135
    OR              shift and go to state 136

  ! PLUS            [ reduce using rule 46 (expression -> expression TIMES expression .) ]
  ! MINUS           [ reduce using rule 46 (expression -> expression TIMES expression .) ]
  ! TIMES           [ reduce using rule 46 (expression -> expression TIMES expression .) ]
  ! DIVIDE          [ reduce using rule 46 (expression -> expression TIMES expression .) ]
  ! AND             [ reduce using rule 46 (expression -> expression TIMES expression .) ]
  ! OR              [ reduce using rule 46 (expression -> expression TIMES expression .) ]


state 195

    (47) expression -> expression DIVIDE expression .
    (44) expression -> expression . PLUS expression
    (45) expression -> expression . MINUS expression
    (46) expression -> expression . TIMES expression
    (47) expression -> expression . DIVIDE expression
    (48) expression -> expression . AND expression
    (49) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 47 (expression -> expression DIVIDE expression .)
    COMMA           reduce using rule 47 (expression -> expression DIVIDE expression .)
    SEMICOLON       reduce using rule 47 (expression -> expression DIVIDE expression .)
    GREATER         reduce using rule 47 (expression -> expression DIVIDE expression .)
    LESS            reduce using rule 47 (expression -> expression DIVIDE expression .)
    EQUALS          reduce using rule 47 (expression -> expression DIVIDE expression .)
    GREATER_EQUAL   reduce using rule 47 (expression -> expression DIVIDE expression .)
    LESS_EQUAL      reduce using rule 47 (expression -> expression DIVIDE expression .)
    NOT_EQUALS      reduce using rule 47 (expression -> expression DIVIDE expression .)
    RSBRACKET       reduce using rule 47 (expression -> expression DIVIDE expression .)
    PRINT           reduce using rule 47 (expression -> expression DIVIDE expression .)
    STRING          reduce using rule 47 (expression -> expression DIVIDE expression .)
    VAR             reduce using rule 47 (expression -> expression DIVIDE expression .)
    FINAL           reduce using rule 47 (expression -> expression DIVIDE expression .)
    ID              reduce using rule 47 (expression -> expression DIVIDE expression .)
    VOID            reduce using rule 47 (expression -> expression DIVIDE expression .)
    LIST            reduce using rule 47 (expression -> expression DIVIDE expression .)
    DYNAMIC         reduce using rule 47 (expression -> expression DIVIDE expression .)
    INT             reduce using rule 47 (expression -> expression DIVIDE expression .)
    DOUBLE          reduce using rule 47 (expression -> expression DIVIDE expression .)
    MAP             reduce using rule 47 (expression -> expression DIVIDE expression .)
    WHILE           reduce using rule 47 (expression -> expression DIVIDE expression .)
    BOOL            reduce using rule 47 (expression -> expression DIVIDE expression .)
    IF              reduce using rule 47 (expression -> expression DIVIDE expression .)
    FOR             reduce using rule 47 (expression -> expression DIVIDE expression .)
    $end            reduce using rule 47 (expression -> expression DIVIDE expression .)
    RBRACKET        reduce using rule 47 (expression -> expression DIVIDE expression .)
    LBRACKET        reduce using rule 47 (expression -> expression DIVIDE expression .)
    PLUS            shift and go to state 131
    MINUS           shift and go to state 132
    TIMES           shift and go to state 133
    DIVIDE          shift and go to state 134
    AND             shift and go to state 135
    OR              shift and go to state 136

  ! PLUS            [ reduce using rule 47 (expression -> expression DIVIDE expression .) ]
  ! MINUS           [ reduce using rule 47 (expression -> expression DIVIDE expression .) ]
  ! TIMES           [ reduce using rule 47 (expression -> expression DIVIDE expression .) ]
  ! DIVIDE          [ reduce using rule 47 (expression -> expression DIVIDE expression .) ]
  ! AND             [ reduce using rule 47 (expression -> expression DIVIDE expression .) ]
  ! OR              [ reduce using rule 47 (expression -> expression DIVIDE expression .) ]


state 196

    (48) expression -> expression AND expression .
    (44) expression -> expression . PLUS expression
    (45) expression -> expression . MINUS expression
    (46) expression -> expression . TIMES expression
    (47) expression -> expression . DIVIDE expression
    (48) expression -> expression . AND expression
    (49) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 48 (expression -> expression AND expression .)
    COMMA           reduce using rule 48 (expression -> expression AND expression .)
    SEMICOLON       reduce using rule 48 (expression -> expression AND expression .)
    GREATER         reduce using rule 48 (expression -> expression AND expression .)
    LESS            reduce using rule 48 (expression -> expression AND expression .)
    EQUALS          reduce using rule 48 (expression -> expression AND expression .)
    GREATER_EQUAL   reduce using rule 48 (expression -> expression AND expression .)
    LESS_EQUAL      reduce using rule 48 (expression -> expression AND expression .)
    NOT_EQUALS      reduce using rule 48 (expression -> expression AND expression .)
    RSBRACKET       reduce using rule 48 (expression -> expression AND expression .)
    PRINT           reduce using rule 48 (expression -> expression AND expression .)
    STRING          reduce using rule 48 (expression -> expression AND expression .)
    VAR             reduce using rule 48 (expression -> expression AND expression .)
    FINAL           reduce using rule 48 (expression -> expression AND expression .)
    ID              reduce using rule 48 (expression -> expression AND expression .)
    VOID            reduce using rule 48 (expression -> expression AND expression .)
    LIST            reduce using rule 48 (expression -> expression AND expression .)
    DYNAMIC         reduce using rule 48 (expression -> expression AND expression .)
    INT             reduce using rule 48 (expression -> expression AND expression .)
    DOUBLE          reduce using rule 48 (expression -> expression AND expression .)
    MAP             reduce using rule 48 (expression -> expression AND expression .)
    WHILE           reduce using rule 48 (expression -> expression AND expression .)
    BOOL            reduce using rule 48 (expression -> expression AND expression .)
    IF              reduce using rule 48 (expression -> expression AND expression .)
    FOR             reduce using rule 48 (expression -> expression AND expression .)
    $end            reduce using rule 48 (expression -> expression AND expression .)
    RBRACKET        reduce using rule 48 (expression -> expression AND expression .)
    LBRACKET        reduce using rule 48 (expression -> expression AND expression .)
    PLUS            shift and go to state 131
    MINUS           shift and go to state 132
    TIMES           shift and go to state 133
    DIVIDE          shift and go to state 134
    AND             shift and go to state 135
    OR              shift and go to state 136

  ! PLUS            [ reduce using rule 48 (expression -> expression AND expression .) ]
  ! MINUS           [ reduce using rule 48 (expression -> expression AND expression .) ]
  ! TIMES           [ reduce using rule 48 (expression -> expression AND expression .) ]
  ! DIVIDE          [ reduce using rule 48 (expression -> expression AND expression .) ]
  ! AND             [ reduce using rule 48 (expression -> expression AND expression .) ]
  ! OR              [ reduce using rule 48 (expression -> expression AND expression .) ]


state 197

    (49) expression -> expression OR expression .
    (44) expression -> expression . PLUS expression
    (45) expression -> expression . MINUS expression
    (46) expression -> expression . TIMES expression
    (47) expression -> expression . DIVIDE expression
    (48) expression -> expression . AND expression
    (49) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 49 (expression -> expression OR expression .)
    COMMA           reduce using rule 49 (expression -> expression OR expression .)
    SEMICOLON       reduce using rule 49 (expression -> expression OR expression .)
    GREATER         reduce using rule 49 (expression -> expression OR expression .)
    LESS            reduce using rule 49 (expression -> expression OR expression .)
    EQUALS          reduce using rule 49 (expression -> expression OR expression .)
    GREATER_EQUAL   reduce using rule 49 (expression -> expression OR expression .)
    LESS_EQUAL      reduce using rule 49 (expression -> expression OR expression .)
    NOT_EQUALS      reduce using rule 49 (expression -> expression OR expression .)
    RSBRACKET       reduce using rule 49 (expression -> expression OR expression .)
    PRINT           reduce using rule 49 (expression -> expression OR expression .)
    STRING          reduce using rule 49 (expression -> expression OR expression .)
    VAR             reduce using rule 49 (expression -> expression OR expression .)
    FINAL           reduce using rule 49 (expression -> expression OR expression .)
    ID              reduce using rule 49 (expression -> expression OR expression .)
    VOID            reduce using rule 49 (expression -> expression OR expression .)
    LIST            reduce using rule 49 (expression -> expression OR expression .)
    DYNAMIC         reduce using rule 49 (expression -> expression OR expression .)
    INT             reduce using rule 49 (expression -> expression OR expression .)
    DOUBLE          reduce using rule 49 (expression -> expression OR expression .)
    MAP             reduce using rule 49 (expression -> expression OR expression .)
    WHILE           reduce using rule 49 (expression -> expression OR expression .)
    BOOL            reduce using rule 49 (expression -> expression OR expression .)
    IF              reduce using rule 49 (expression -> expression OR expression .)
    FOR             reduce using rule 49 (expression -> expression OR expression .)
    $end            reduce using rule 49 (expression -> expression OR expression .)
    RBRACKET        reduce using rule 49 (expression -> expression OR expression .)
    LBRACKET        reduce using rule 49 (expression -> expression OR expression .)
    PLUS            shift and go to state 131
    MINUS           shift and go to state 132
    TIMES           shift and go to state 133
    DIVIDE          shift and go to state 134
    AND             shift and go to state 135
    OR              shift and go to state 136

  ! PLUS            [ reduce using rule 49 (expression -> expression OR expression .) ]
  ! MINUS           [ reduce using rule 49 (expression -> expression OR expression .) ]
  ! TIMES           [ reduce using rule 49 (expression -> expression OR expression .) ]
  ! DIVIDE          [ reduce using rule 49 (expression -> expression OR expression .) ]
  ! AND             [ reduce using rule 49 (expression -> expression OR expression .) ]
  ! OR              [ reduce using rule 49 (expression -> expression OR expression .) ]


state 198

    (43) print -> PRINT LPAREN length RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 43 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    PRINT           reduce using rule 43 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    STRING          reduce using rule 43 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    VAR             reduce using rule 43 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    FINAL           reduce using rule 43 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    ID              reduce using rule 43 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    VOID            reduce using rule 43 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    LIST            reduce using rule 43 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 43 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    INT             reduce using rule 43 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 43 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    MAP             reduce using rule 43 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    WHILE           reduce using rule 43 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    BOOL            reduce using rule 43 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    IF              reduce using rule 43 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    FOR             reduce using rule 43 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    $end            reduce using rule 43 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 43 (print -> PRINT LPAREN length RPAREN SEMICOLON .)


state 199

    (25) length -> TEXT DOT LENGTH .

    RPAREN          reduce using rule 25 (length -> TEXT DOT LENGTH .)
    SEMICOLON       reduce using rule 25 (length -> TEXT DOT LENGTH .)


state 200

    (93) interpolated_string -> TEXT PLUS ID .
    (89) value -> ID .

  ! reduce/reduce conflict for RPAREN resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for COMMA resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for LESS resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for EQUALS resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUALS resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for RSBRACKET resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for PRINT resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for STRING resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for VAR resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for FINAL resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for ID resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for VOID resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for LIST resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for DYNAMIC resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for INT resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for DOUBLE resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for MAP resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for WHILE resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for BOOL resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for IF resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for FOR resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 89 (value -> ID .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 89 (value -> ID .)
    RPAREN          reduce using rule 89 (value -> ID .)
    PLUS            reduce using rule 89 (value -> ID .)
    MINUS           reduce using rule 89 (value -> ID .)
    TIMES           reduce using rule 89 (value -> ID .)
    DIVIDE          reduce using rule 89 (value -> ID .)
    AND             reduce using rule 89 (value -> ID .)
    OR              reduce using rule 89 (value -> ID .)
    COMMA           reduce using rule 89 (value -> ID .)
    SEMICOLON       reduce using rule 89 (value -> ID .)
    GREATER         reduce using rule 89 (value -> ID .)
    LESS            reduce using rule 89 (value -> ID .)
    EQUALS          reduce using rule 89 (value -> ID .)
    GREATER_EQUAL   reduce using rule 89 (value -> ID .)
    LESS_EQUAL      reduce using rule 89 (value -> ID .)
    NOT_EQUALS      reduce using rule 89 (value -> ID .)
    RSBRACKET       reduce using rule 89 (value -> ID .)
    PRINT           reduce using rule 89 (value -> ID .)
    STRING          reduce using rule 89 (value -> ID .)
    VAR             reduce using rule 89 (value -> ID .)
    FINAL           reduce using rule 89 (value -> ID .)
    ID              reduce using rule 89 (value -> ID .)
    VOID            reduce using rule 89 (value -> ID .)
    LIST            reduce using rule 89 (value -> ID .)
    DYNAMIC         reduce using rule 89 (value -> ID .)
    INT             reduce using rule 89 (value -> ID .)
    DOUBLE          reduce using rule 89 (value -> ID .)
    MAP             reduce using rule 89 (value -> ID .)
    WHILE           reduce using rule 89 (value -> ID .)
    BOOL            reduce using rule 89 (value -> ID .)
    IF              reduce using rule 89 (value -> ID .)
    FOR             reduce using rule 89 (value -> ID .)
    $end            reduce using rule 89 (value -> ID .)
    RBRACKET        reduce using rule 89 (value -> ID .)
    LBRACKET        reduce using rule 89 (value -> ID .)

  ! RPAREN          [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! PLUS            [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! GREATER         [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! LESS            [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! EQUALS          [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! GREATER_EQUAL   [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! LESS_EQUAL      [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! NOT_EQUALS      [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! MINUS           [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! TIMES           [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! DIVIDE          [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! AND             [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! OR              [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! COMMA           [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! RSBRACKET       [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! SEMICOLON       [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! PRINT           [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! STRING          [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! VAR             [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! FINAL           [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! ID              [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! VOID            [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! LIST            [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! DYNAMIC         [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! INT             [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! DOUBLE          [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! MAP             [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! WHILE           [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! BOOL            [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! IF              [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! FOR             [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! $end            [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! RBRACKET        [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]
  ! LBRACKET        [ reduce using rule 93 (interpolated_string -> TEXT PLUS ID .) ]


state 201

    (94) interpolated_string -> TEXT PLUS expression .
    (44) expression -> expression . PLUS expression
    (45) expression -> expression . MINUS expression
    (46) expression -> expression . TIMES expression
    (47) expression -> expression . DIVIDE expression
    (48) expression -> expression . AND expression
    (49) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 94 (interpolated_string -> TEXT PLUS expression .)
    GREATER         reduce using rule 94 (interpolated_string -> TEXT PLUS expression .)
    LESS            reduce using rule 94 (interpolated_string -> TEXT PLUS expression .)
    EQUALS          reduce using rule 94 (interpolated_string -> TEXT PLUS expression .)
    GREATER_EQUAL   reduce using rule 94 (interpolated_string -> TEXT PLUS expression .)
    LESS_EQUAL      reduce using rule 94 (interpolated_string -> TEXT PLUS expression .)
    NOT_EQUALS      reduce using rule 94 (interpolated_string -> TEXT PLUS expression .)
    COMMA           reduce using rule 94 (interpolated_string -> TEXT PLUS expression .)
    RSBRACKET       reduce using rule 94 (interpolated_string -> TEXT PLUS expression .)
    SEMICOLON       reduce using rule 94 (interpolated_string -> TEXT PLUS expression .)
    PRINT           reduce using rule 94 (interpolated_string -> TEXT PLUS expression .)
    STRING          reduce using rule 94 (interpolated_string -> TEXT PLUS expression .)
    VAR             reduce using rule 94 (interpolated_string -> TEXT PLUS expression .)
    FINAL           reduce using rule 94 (interpolated_string -> TEXT PLUS expression .)
    ID              reduce using rule 94 (interpolated_string -> TEXT PLUS expression .)
    VOID            reduce using rule 94 (interpolated_string -> TEXT PLUS expression .)
    LIST            reduce using rule 94 (interpolated_string -> TEXT PLUS expression .)
    DYNAMIC         reduce using rule 94 (interpolated_string -> TEXT PLUS expression .)
    INT             reduce using rule 94 (interpolated_string -> TEXT PLUS expression .)
    DOUBLE          reduce using rule 94 (interpolated_string -> TEXT PLUS expression .)
    MAP             reduce using rule 94 (interpolated_string -> TEXT PLUS expression .)
    WHILE           reduce using rule 94 (interpolated_string -> TEXT PLUS expression .)
    BOOL            reduce using rule 94 (interpolated_string -> TEXT PLUS expression .)
    IF              reduce using rule 94 (interpolated_string -> TEXT PLUS expression .)
    FOR             reduce using rule 94 (interpolated_string -> TEXT PLUS expression .)
    $end            reduce using rule 94 (interpolated_string -> TEXT PLUS expression .)
    RBRACKET        reduce using rule 94 (interpolated_string -> TEXT PLUS expression .)
    LBRACKET        reduce using rule 94 (interpolated_string -> TEXT PLUS expression .)
    PLUS            shift and go to state 131
    MINUS           shift and go to state 132
    TIMES           shift and go to state 133
    DIVIDE          shift and go to state 134
    AND             shift and go to state 135
    OR              shift and go to state 136

  ! PLUS            [ reduce using rule 94 (interpolated_string -> TEXT PLUS expression .) ]
  ! MINUS           [ reduce using rule 94 (interpolated_string -> TEXT PLUS expression .) ]
  ! TIMES           [ reduce using rule 94 (interpolated_string -> TEXT PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 94 (interpolated_string -> TEXT PLUS expression .) ]
  ! AND             [ reduce using rule 94 (interpolated_string -> TEXT PLUS expression .) ]
  ! OR              [ reduce using rule 94 (interpolated_string -> TEXT PLUS expression .) ]


state 202

    (24) length -> call_list DOT LENGTH .

    RPAREN          reduce using rule 24 (length -> call_list DOT LENGTH .)
    SEMICOLON       reduce using rule 24 (length -> call_list DOT LENGTH .)


state 203

    (82) call_list -> LSBRACKET value_list RSBRACKET .

    DOT             reduce using rule 82 (call_list -> LSBRACKET value_list RSBRACKET .)


state 204

    (85) value_list -> value_list COMMA . value
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 83
    ID              shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72

    value                          shift and go to state 248
    interpolated_string            shift and go to state 70

state 205

    (22) data_input -> STRING ID ASSIGN STDIN DOT . READLINESYNC LPAREN RPAREN SEMICOLON

    READLINESYNC    shift and go to state 249


state 206

    (23) data_input -> STRING QUESTION ID ASSIGN STDIN . DOT READLINESYNC LPAREN RPAREN SEMICOLON

    DOT             shift and go to state 250


state 207

    (118) constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 118 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    PRINT           reduce using rule 118 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    STRING          reduce using rule 118 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    VAR             reduce using rule 118 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    FINAL           reduce using rule 118 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    ID              reduce using rule 118 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    VOID            reduce using rule 118 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    LIST            reduce using rule 118 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 118 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    INT             reduce using rule 118 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 118 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    MAP             reduce using rule 118 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    WHILE           reduce using rule 118 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    BOOL            reduce using rule 118 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    IF              reduce using rule 118 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    FOR             reduce using rule 118 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    $end            reduce using rule 118 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 118 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)


state 208

    (27) argument_list -> argument_list COMMA expression .
    (44) expression -> expression . PLUS expression
    (45) expression -> expression . MINUS expression
    (46) expression -> expression . TIMES expression
    (47) expression -> expression . DIVIDE expression
    (48) expression -> expression . AND expression
    (49) expression -> expression . OR expression

    RPAREN          reduce using rule 27 (argument_list -> argument_list COMMA expression .)
    COMMA           reduce using rule 27 (argument_list -> argument_list COMMA expression .)
    PLUS            shift and go to state 131
    MINUS           shift and go to state 132
    TIMES           shift and go to state 133
    DIVIDE          shift and go to state 134
    AND             shift and go to state 135
    OR              shift and go to state 136


state 209

    (116) constructor_parenthesis_content -> THIS DOT ID .
    (117) constructor_parenthesis_content -> THIS DOT ID . COMMA constructor_parenthesis_content

    RPAREN          reduce using rule 116 (constructor_parenthesis_content -> THIS DOT ID .)
    COMMA           shift and go to state 251


state 210

    (95) set -> VAR ID ASSIGN LBRACKET value_list . RBRACKET SEMICOLON
    (85) value_list -> value_list . COMMA value

    RBRACKET        shift and go to state 252
    COMMA           shift and go to state 204


state 211

    (96) set -> VAR ID ASSIGN LESS STRING . GREATER LBRACKET RBRACKET SEMICOLON

    GREATER         shift and go to state 253


state 212

    (36) variable_definition -> VAR ID ASSIGN expression SEMICOLON .

    SEMICOLON       reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    DYNAMIC         reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    RBRACKET        reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)


state 213

    (97) set -> FINAL ID ASSIGN CONST LBRACKET . value_list RBRACKET SEMICOLON
    (84) value_list -> . value
    (85) value_list -> . value_list COMMA value
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 83
    ID              shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72

    value_list                     shift and go to state 254
    value                          shift and go to state 142
    interpolated_string            shift and go to state 70

state 214

    (125) map_contents -> map_content COMMA map_contents .

    RBRACKET        reduce using rule 125 (map_contents -> map_content COMMA map_contents .)


state 215

    (126) map_content -> key_value COLON value .

    COMMA           reduce using rule 126 (map_content -> key_value COLON value .)
    RBRACKET        reduce using rule 126 (map_content -> key_value COLON value .)


state 216

    (75) parameter -> type ID .

    RPAREN          reduce using rule 75 (parameter -> type ID .)
    COMMA           reduce using rule 75 (parameter -> type ID .)


state 217

    (28) function -> type ID LPAREN parameter_list RPAREN . LBRACKET statement_list RBRACKET
    (119) function -> type ID LPAREN parameter_list RPAREN . ASSIGN GREATER expression

    LBRACKET        shift and go to state 255
    ASSIGN          shift and go to state 256


state 218

    (74) parameter_list -> parameter_list COMMA . parameter
    (75) parameter -> . type ID
    (76) parameter -> . REQUIRED type ID
    (77) type -> . INT
    (78) type -> . DOUBLE
    (79) type -> . STRING
    (80) type -> . BOOL
    (81) type -> . LIST

    REQUIRED        shift and go to state 160
    INT             shift and go to state 95
    DOUBLE          shift and go to state 96
    STRING          shift and go to state 97
    BOOL            shift and go to state 37
    LIST            shift and go to state 93

    parameter                      shift and go to state 257
    type                           shift and go to state 156

state 219

    (30) function -> type ID LPAREN RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (95) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (96) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (97) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (121) map -> . map_declaration map_assignment
    (118) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (119) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (122) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (53) control_structures_if_else -> . if_block
    (54) control_structures_if_else -> . if_block else_if_blocks
    (55) control_structures_if_else -> . if_block else_if_blocks else_block
    (56) control_structures_if_else -> . if_block else_block
    (113) control_structures_for -> . for_classic
    (114) control_structures_for -> . for_in
    (115) control_structures_for -> . for_each
    (120) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (77) type -> . INT
    (78) type -> . DOUBLE
    (79) type -> . STRING
    (80) type -> . BOOL
    (81) type -> . LIST
    (57) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (106) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (112) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    type                           shift and go to state 25
    statement_list                 shift and go to state 258
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 220

    (76) parameter -> REQUIRED type . ID

    ID              shift and go to state 259


state 221

    (34) variable_definition -> type ID ASSIGN expression SEMICOLON .

    SEMICOLON       reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    DYNAMIC         reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    RBRACKET        reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)


state 222

    (29) function -> VOID ID LPAREN parameter_list RPAREN . LBRACKET statement_list RBRACKET
    (33) function -> VOID ID LPAREN parameter_list RPAREN . LBRACKET RBRACKET

    LBRACKET        shift and go to state 260


state 223

    (31) function -> VOID ID LPAREN RPAREN LBRACKET . statement_list RBRACKET
    (32) function -> VOID ID LPAREN RPAREN LBRACKET . RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (95) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (96) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (97) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (121) map -> . map_declaration map_assignment
    (118) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (119) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (122) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (53) control_structures_if_else -> . if_block
    (54) control_structures_if_else -> . if_block else_if_blocks
    (55) control_structures_if_else -> . if_block else_if_blocks else_block
    (56) control_structures_if_else -> . if_block else_block
    (113) control_structures_for -> . for_classic
    (114) control_structures_for -> . for_in
    (115) control_structures_for -> . for_each
    (120) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (77) type -> . INT
    (78) type -> . DOUBLE
    (79) type -> . STRING
    (80) type -> . BOOL
    (81) type -> . LIST
    (57) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (106) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (112) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 262
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement_list                 shift and go to state 261
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 224

    (83) list_definition -> LIST LESS type GREATER ID . ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON

    ASSIGN          shift and go to state 263


state 225

    (35) variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .

    SEMICOLON       reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    DYNAMIC         reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    RBRACKET        reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)


state 226

    (37) variable_definition -> INT ID ASSIGN length SEMICOLON .

    SEMICOLON       reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    PRINT           reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    STRING          reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    VAR             reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    FINAL           reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    ID              reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    VOID            reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    LIST            reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    DYNAMIC         reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    INT             reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    DOUBLE          reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    MAP             reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    WHILE           reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    BOOL            reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    IF              reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    FOR             reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    $end            reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    RBRACKET        reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)


state 227

    (38) variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .

    SEMICOLON       reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    PRINT           reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    STRING          reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    VAR             reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    FINAL           reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    ID              reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    VOID            reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    LIST            reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    DYNAMIC         reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    INT             reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    DOUBLE          reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    MAP             reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    WHILE           reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    BOOL            reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    IF              reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    FOR             reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    $end            reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    RBRACKET        reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)


state 228

    (39) variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .

    SEMICOLON       reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    PRINT           reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    STRING          reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    VAR             reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    FINAL           reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    ID              reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    VOID            reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    LIST            reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    DYNAMIC         reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    INT             reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    DOUBLE          reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    MAP             reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    WHILE           reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    BOOL            reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    IF              reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    FOR             reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    $end            reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    RBRACKET        reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)


state 229

    (122) map_declaration -> MAP LESS key_type COMMA type . GREATER ID ASSIGN

    GREATER         shift and go to state 264


state 230

    (59) else_if_blocks -> else_if_blocks ELSE IF LPAREN . conditions RPAREN LBRACKET statement_list RBRACKET
    (61) conditions -> . condition
    (62) conditions -> . conditions AND conditions
    (63) conditions -> . conditions OR conditions
    (64) condition -> . value comparator value
    (65) condition -> . NOT condition
    (66) condition -> . LPAREN conditions RPAREN
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 111
    LPAREN          shift and go to state 107
    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 83
    ID              shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72

    conditions                     shift and go to state 265
    condition                      shift and go to state 109
    value                          shift and go to state 110
    interpolated_string            shift and go to state 70

state 231

    (58) else_if_blocks -> ELSE IF LPAREN conditions . RPAREN LBRACKET statement_list RBRACKET
    (62) conditions -> conditions . AND conditions
    (63) conditions -> conditions . OR conditions

    RPAREN          shift and go to state 266
    AND             shift and go to state 176
    OR              shift and go to state 177


state 232

    (60) else_block -> ELSE LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 60 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 60 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 60 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 60 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 60 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 60 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 60 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 60 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 60 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 60 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 60 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 60 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 60 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 60 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 60 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 60 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 60 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 60 (else_block -> ELSE LBRACKET statement_list RBRACKET .)


state 233

    (66) condition -> LPAREN conditions RPAREN .

    LBRACKET        reduce using rule 66 (condition -> LPAREN conditions RPAREN .)
    AND             reduce using rule 66 (condition -> LPAREN conditions RPAREN .)
    OR              reduce using rule 66 (condition -> LPAREN conditions RPAREN .)
    RPAREN          reduce using rule 66 (condition -> LPAREN conditions RPAREN .)
    SEMICOLON       reduce using rule 66 (condition -> LPAREN conditions RPAREN .)


state 234

    (120) control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (95) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (96) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (97) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (121) map -> . map_declaration map_assignment
    (118) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (119) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (122) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (53) control_structures_if_else -> . if_block
    (54) control_structures_if_else -> . if_block else_if_blocks
    (55) control_structures_if_else -> . if_block else_if_blocks else_block
    (56) control_structures_if_else -> . if_block else_block
    (113) control_structures_for -> . for_classic
    (114) control_structures_for -> . for_in
    (115) control_structures_for -> . for_each
    (120) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (77) type -> . INT
    (78) type -> . DOUBLE
    (79) type -> . STRING
    (80) type -> . BOOL
    (81) type -> . LIST
    (57) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (106) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (112) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 267
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement                      shift and go to state 40
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 235

    (62) conditions -> conditions AND conditions .
    (62) conditions -> conditions . AND conditions
    (63) conditions -> conditions . OR conditions

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    LBRACKET        reduce using rule 62 (conditions -> conditions AND conditions .)
    RPAREN          reduce using rule 62 (conditions -> conditions AND conditions .)
    SEMICOLON       reduce using rule 62 (conditions -> conditions AND conditions .)
    AND             shift and go to state 176
    OR              shift and go to state 177

  ! AND             [ reduce using rule 62 (conditions -> conditions AND conditions .) ]
  ! OR              [ reduce using rule 62 (conditions -> conditions AND conditions .) ]


state 236

    (63) conditions -> conditions OR conditions .
    (62) conditions -> conditions . AND conditions
    (63) conditions -> conditions . OR conditions

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    LBRACKET        reduce using rule 63 (conditions -> conditions OR conditions .)
    RPAREN          reduce using rule 63 (conditions -> conditions OR conditions .)
    SEMICOLON       reduce using rule 63 (conditions -> conditions OR conditions .)
    AND             shift and go to state 176
    OR              shift and go to state 177

  ! AND             [ reduce using rule 63 (conditions -> conditions OR conditions .) ]
  ! OR              [ reduce using rule 63 (conditions -> conditions OR conditions .) ]


state 237

    (64) condition -> value comparator value .

    LBRACKET        reduce using rule 64 (condition -> value comparator value .)
    AND             reduce using rule 64 (condition -> value comparator value .)
    OR              reduce using rule 64 (condition -> value comparator value .)
    RPAREN          reduce using rule 64 (condition -> value comparator value .)
    SEMICOLON       reduce using rule 64 (condition -> value comparator value .)


state 238

    (57) if_block -> IF LPAREN conditions RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (95) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (96) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (97) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (121) map -> . map_declaration map_assignment
    (118) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (119) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (122) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (53) control_structures_if_else -> . if_block
    (54) control_structures_if_else -> . if_block else_if_blocks
    (55) control_structures_if_else -> . if_block else_if_blocks else_block
    (56) control_structures_if_else -> . if_block else_block
    (113) control_structures_for -> . for_classic
    (114) control_structures_for -> . for_in
    (115) control_structures_for -> . for_each
    (120) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (77) type -> . INT
    (78) type -> . DOUBLE
    (79) type -> . STRING
    (80) type -> . BOOL
    (81) type -> . LIST
    (57) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (106) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (112) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement_list                 shift and go to state 268
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 239

    (106) for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (95) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (96) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (97) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (121) map -> . map_declaration map_assignment
    (118) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (119) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (122) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (53) control_structures_if_else -> . if_block
    (54) control_structures_if_else -> . if_block else_if_blocks
    (55) control_structures_if_else -> . if_block else_if_blocks else_block
    (56) control_structures_if_else -> . if_block else_block
    (113) control_structures_for -> . for_classic
    (114) control_structures_for -> . for_in
    (115) control_structures_for -> . for_each
    (120) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (77) type -> . INT
    (78) type -> . DOUBLE
    (79) type -> . STRING
    (80) type -> . BOOL
    (81) type -> . LIST
    (57) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (106) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (112) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement_list                 shift and go to state 269
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 240

    (108) for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (95) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (96) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (97) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (121) map -> . map_declaration map_assignment
    (118) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (119) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (122) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (53) control_structures_if_else -> . if_block
    (54) control_structures_if_else -> . if_block else_if_blocks
    (55) control_structures_if_else -> . if_block else_if_blocks else_block
    (56) control_structures_if_else -> . if_block else_block
    (113) control_structures_for -> . for_classic
    (114) control_structures_for -> . for_in
    (115) control_structures_for -> . for_each
    (120) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (77) type -> . INT
    (78) type -> . DOUBLE
    (79) type -> . STRING
    (80) type -> . BOOL
    (81) type -> . LIST
    (57) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (106) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (112) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement_list                 shift and go to state 270
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 241

    (112) for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (95) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (96) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (97) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (121) map -> . map_declaration map_assignment
    (118) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (119) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (122) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (53) control_structures_if_else -> . if_block
    (54) control_structures_if_else -> . if_block else_if_blocks
    (55) control_structures_if_else -> . if_block else_if_blocks else_block
    (56) control_structures_if_else -> . if_block else_block
    (113) control_structures_for -> . for_classic
    (114) control_structures_for -> . for_in
    (115) control_structures_for -> . for_each
    (120) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (77) type -> . INT
    (78) type -> . DOUBLE
    (79) type -> . STRING
    (80) type -> . BOOL
    (81) type -> . LIST
    (57) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (106) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (112) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement_list                 shift and go to state 271
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 242

    (105) for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions . SEMICOLON for_classic_changes

    SEMICOLON       shift and go to state 272


state 243

    (100) for_classic_conditions -> conditions .
    (62) conditions -> conditions . AND conditions
    (63) conditions -> conditions . OR conditions

    SEMICOLON       reduce using rule 100 (for_classic_conditions -> conditions .)
    AND             shift and go to state 176
    OR              shift and go to state 177


state 244

    (107) for_in_parenthesis_content -> FINAL ID IN . ID

    ID              shift and go to state 273


state 245

    (111) for_each_parenthesis_content -> FINAL ID LPAREN . for_each_parenthesis_parenthesis_content RPAREN IN ID
    (109) for_each_parenthesis_parenthesis_content -> . COLON ID
    (110) for_each_parenthesis_parenthesis_content -> . COLON ID COMMA for_each_parenthesis_parenthesis_content

    COLON           shift and go to state 275

    for_each_parenthesis_parenthesis_content shift and go to state 274

state 246

    (98) for_classic_initialization -> INT ID ASSIGN . NUMBER

    NUMBER          shift and go to state 276


state 247

    (99) for_classic_initialization -> DOUBLE ID ASSIGN . NDOUBLE

    NDOUBLE         shift and go to state 277


state 248

    (85) value_list -> value_list COMMA value .

    RSBRACKET       reduce using rule 85 (value_list -> value_list COMMA value .)
    COMMA           reduce using rule 85 (value_list -> value_list COMMA value .)
    RBRACKET        reduce using rule 85 (value_list -> value_list COMMA value .)


state 249

    (22) data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 278


state 250

    (23) data_input -> STRING QUESTION ID ASSIGN STDIN DOT . READLINESYNC LPAREN RPAREN SEMICOLON

    READLINESYNC    shift and go to state 279


state 251

    (117) constructor_parenthesis_content -> THIS DOT ID COMMA . constructor_parenthesis_content
    (116) constructor_parenthesis_content -> . THIS DOT ID
    (117) constructor_parenthesis_content -> . THIS DOT ID COMMA constructor_parenthesis_content

    THIS            shift and go to state 80

    constructor_parenthesis_content shift and go to state 280

state 252

    (95) set -> VAR ID ASSIGN LBRACKET value_list RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 281


state 253

    (96) set -> VAR ID ASSIGN LESS STRING GREATER . LBRACKET RBRACKET SEMICOLON

    LBRACKET        shift and go to state 282


state 254

    (97) set -> FINAL ID ASSIGN CONST LBRACKET value_list . RBRACKET SEMICOLON
    (85) value_list -> value_list . COMMA value

    RBRACKET        shift and go to state 283
    COMMA           shift and go to state 204


state 255

    (28) function -> type ID LPAREN parameter_list RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (95) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (96) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (97) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (121) map -> . map_declaration map_assignment
    (118) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (119) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (122) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (53) control_structures_if_else -> . if_block
    (54) control_structures_if_else -> . if_block else_if_blocks
    (55) control_structures_if_else -> . if_block else_if_blocks else_block
    (56) control_structures_if_else -> . if_block else_block
    (113) control_structures_for -> . for_classic
    (114) control_structures_for -> . for_in
    (115) control_structures_for -> . for_each
    (120) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (77) type -> . INT
    (78) type -> . DOUBLE
    (79) type -> . STRING
    (80) type -> . BOOL
    (81) type -> . LIST
    (57) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (106) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (112) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    type                           shift and go to state 25
    statement_list                 shift and go to state 284
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 256

    (119) function -> type ID LPAREN parameter_list RPAREN ASSIGN . GREATER expression

    GREATER         shift and go to state 285


state 257

    (74) parameter_list -> parameter_list COMMA parameter .

    RPAREN          reduce using rule 74 (parameter_list -> parameter_list COMMA parameter .)
    COMMA           reduce using rule 74 (parameter_list -> parameter_list COMMA parameter .)


state 258

    (30) function -> type ID LPAREN RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (95) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (96) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (97) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (121) map -> . map_declaration map_assignment
    (118) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (119) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (122) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (53) control_structures_if_else -> . if_block
    (54) control_structures_if_else -> . if_block else_if_blocks
    (55) control_structures_if_else -> . if_block else_if_blocks else_block
    (56) control_structures_if_else -> . if_block else_block
    (113) control_structures_for -> . for_classic
    (114) control_structures_for -> . for_in
    (115) control_structures_for -> . for_each
    (120) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (77) type -> . INT
    (78) type -> . DOUBLE
    (79) type -> . STRING
    (80) type -> . BOOL
    (81) type -> . LIST
    (57) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (106) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (112) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 286
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    type                           shift and go to state 25
    statement                      shift and go to state 40
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 259

    (76) parameter -> REQUIRED type ID .

    RPAREN          reduce using rule 76 (parameter -> REQUIRED type ID .)
    COMMA           reduce using rule 76 (parameter -> REQUIRED type ID .)


state 260

    (29) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET . statement_list RBRACKET
    (33) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET . RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (95) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (96) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (97) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (121) map -> . map_declaration map_assignment
    (118) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (119) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (122) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (53) control_structures_if_else -> . if_block
    (54) control_structures_if_else -> . if_block else_if_blocks
    (55) control_structures_if_else -> . if_block else_if_blocks else_block
    (56) control_structures_if_else -> . if_block else_block
    (113) control_structures_for -> . for_classic
    (114) control_structures_for -> . for_in
    (115) control_structures_for -> . for_each
    (120) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (77) type -> . INT
    (78) type -> . DOUBLE
    (79) type -> . STRING
    (80) type -> . BOOL
    (81) type -> . LIST
    (57) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (106) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (112) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 288
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement_list                 shift and go to state 287
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 261

    (31) function -> VOID ID LPAREN RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (95) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (96) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (97) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (121) map -> . map_declaration map_assignment
    (118) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (119) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (122) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (53) control_structures_if_else -> . if_block
    (54) control_structures_if_else -> . if_block else_if_blocks
    (55) control_structures_if_else -> . if_block else_if_blocks else_block
    (56) control_structures_if_else -> . if_block else_block
    (113) control_structures_for -> . for_classic
    (114) control_structures_for -> . for_in
    (115) control_structures_for -> . for_each
    (120) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (77) type -> . INT
    (78) type -> . DOUBLE
    (79) type -> . STRING
    (80) type -> . BOOL
    (81) type -> . LIST
    (57) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (106) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (112) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 289
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement                      shift and go to state 40
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 262

    (32) function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .

    SEMICOLON       reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    PRINT           reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    STRING          reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    VAR             reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    FINAL           reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    ID              reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    VOID            reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    LIST            reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    DYNAMIC         reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    INT             reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    DOUBLE          reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    MAP             reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    WHILE           reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    BOOL            reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    IF              reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    FOR             reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    $end            reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)


state 263

    (83) list_definition -> LIST LESS type GREATER ID ASSIGN . LSBRACKET value_list RSBRACKET SEMICOLON

    LSBRACKET       shift and go to state 290


state 264

    (122) map_declaration -> MAP LESS key_type COMMA type GREATER . ID ASSIGN

    ID              shift and go to state 291


state 265

    (59) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions . RPAREN LBRACKET statement_list RBRACKET
    (62) conditions -> conditions . AND conditions
    (63) conditions -> conditions . OR conditions

    RPAREN          shift and go to state 292
    AND             shift and go to state 176
    OR              shift and go to state 177


state 266

    (58) else_if_blocks -> ELSE IF LPAREN conditions RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 293


state 267

    (120) control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 120 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 120 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 120 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 120 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 120 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 120 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 120 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 120 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 120 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 120 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 120 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 120 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 120 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 120 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 120 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 120 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 120 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 120 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)


state 268

    (57) if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (95) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (96) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (97) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (121) map -> . map_declaration map_assignment
    (118) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (119) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (122) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (53) control_structures_if_else -> . if_block
    (54) control_structures_if_else -> . if_block else_if_blocks
    (55) control_structures_if_else -> . if_block else_if_blocks else_block
    (56) control_structures_if_else -> . if_block else_block
    (113) control_structures_for -> . for_classic
    (114) control_structures_for -> . for_in
    (115) control_structures_for -> . for_each
    (120) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (77) type -> . INT
    (78) type -> . DOUBLE
    (79) type -> . STRING
    (80) type -> . BOOL
    (81) type -> . LIST
    (57) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (106) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (112) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 294
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement                      shift and go to state 40
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 269

    (106) for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (95) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (96) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (97) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (121) map -> . map_declaration map_assignment
    (118) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (119) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (122) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (53) control_structures_if_else -> . if_block
    (54) control_structures_if_else -> . if_block else_if_blocks
    (55) control_structures_if_else -> . if_block else_if_blocks else_block
    (56) control_structures_if_else -> . if_block else_block
    (113) control_structures_for -> . for_classic
    (114) control_structures_for -> . for_in
    (115) control_structures_for -> . for_each
    (120) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (77) type -> . INT
    (78) type -> . DOUBLE
    (79) type -> . STRING
    (80) type -> . BOOL
    (81) type -> . LIST
    (57) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (106) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (112) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 295
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement                      shift and go to state 40
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 270

    (108) for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (95) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (96) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (97) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (121) map -> . map_declaration map_assignment
    (118) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (119) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (122) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (53) control_structures_if_else -> . if_block
    (54) control_structures_if_else -> . if_block else_if_blocks
    (55) control_structures_if_else -> . if_block else_if_blocks else_block
    (56) control_structures_if_else -> . if_block else_block
    (113) control_structures_for -> . for_classic
    (114) control_structures_for -> . for_in
    (115) control_structures_for -> . for_each
    (120) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (77) type -> . INT
    (78) type -> . DOUBLE
    (79) type -> . STRING
    (80) type -> . BOOL
    (81) type -> . LIST
    (57) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (106) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (112) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 296
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement                      shift and go to state 40
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 271

    (112) for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (95) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (96) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (97) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (121) map -> . map_declaration map_assignment
    (118) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (119) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (122) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (53) control_structures_if_else -> . if_block
    (54) control_structures_if_else -> . if_block else_if_blocks
    (55) control_structures_if_else -> . if_block else_if_blocks else_block
    (56) control_structures_if_else -> . if_block else_block
    (113) control_structures_for -> . for_classic
    (114) control_structures_for -> . for_in
    (115) control_structures_for -> . for_each
    (120) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (77) type -> . INT
    (78) type -> . DOUBLE
    (79) type -> . STRING
    (80) type -> . BOOL
    (81) type -> . LIST
    (57) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (106) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (112) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 297
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement                      shift and go to state 40
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 272

    (105) for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON . for_classic_changes
    (101) for_classic_changes -> . ID comparator value
    (102) for_classic_changes -> . ID INCREMENT
    (103) for_classic_changes -> . ID DECREMENT
    (104) for_classic_changes -> . ID comparator value COMMA for_classic_changes

    ID              shift and go to state 299

    for_classic_changes            shift and go to state 298

state 273

    (107) for_in_parenthesis_content -> FINAL ID IN ID .

    RPAREN          reduce using rule 107 (for_in_parenthesis_content -> FINAL ID IN ID .)


state 274

    (111) for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content . RPAREN IN ID

    RPAREN          shift and go to state 300


state 275

    (109) for_each_parenthesis_parenthesis_content -> COLON . ID
    (110) for_each_parenthesis_parenthesis_content -> COLON . ID COMMA for_each_parenthesis_parenthesis_content

    ID              shift and go to state 301


state 276

    (98) for_classic_initialization -> INT ID ASSIGN NUMBER .

    SEMICOLON       reduce using rule 98 (for_classic_initialization -> INT ID ASSIGN NUMBER .)


state 277

    (99) for_classic_initialization -> DOUBLE ID ASSIGN NDOUBLE .

    SEMICOLON       reduce using rule 99 (for_classic_initialization -> DOUBLE ID ASSIGN NDOUBLE .)


state 278

    (22) data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 302


state 279

    (23) data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 303


state 280

    (117) constructor_parenthesis_content -> THIS DOT ID COMMA constructor_parenthesis_content .

    RPAREN          reduce using rule 117 (constructor_parenthesis_content -> THIS DOT ID COMMA constructor_parenthesis_content .)


state 281

    (95) set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .

    SEMICOLON       reduce using rule 95 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    PRINT           reduce using rule 95 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    STRING          reduce using rule 95 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    VAR             reduce using rule 95 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    FINAL           reduce using rule 95 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    ID              reduce using rule 95 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    VOID            reduce using rule 95 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    LIST            reduce using rule 95 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 95 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    INT             reduce using rule 95 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 95 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    MAP             reduce using rule 95 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    WHILE           reduce using rule 95 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    BOOL            reduce using rule 95 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    IF              reduce using rule 95 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    FOR             reduce using rule 95 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    $end            reduce using rule 95 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    RBRACKET        reduce using rule 95 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)


state 282

    (96) set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 304


state 283

    (97) set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 305


state 284

    (28) function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (95) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (96) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (97) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (121) map -> . map_declaration map_assignment
    (118) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (119) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (122) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (53) control_structures_if_else -> . if_block
    (54) control_structures_if_else -> . if_block else_if_blocks
    (55) control_structures_if_else -> . if_block else_if_blocks else_block
    (56) control_structures_if_else -> . if_block else_block
    (113) control_structures_for -> . for_classic
    (114) control_structures_for -> . for_in
    (115) control_structures_for -> . for_each
    (120) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (77) type -> . INT
    (78) type -> . DOUBLE
    (79) type -> . STRING
    (80) type -> . BOOL
    (81) type -> . LIST
    (57) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (106) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (112) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 306
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    type                           shift and go to state 25
    statement                      shift and go to state 40
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 285

    (119) function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER . expression
    (44) expression -> . expression PLUS expression
    (45) expression -> . expression MINUS expression
    (46) expression -> . expression TIMES expression
    (47) expression -> . expression DIVIDE expression
    (48) expression -> . expression AND expression
    (49) expression -> . expression OR expression
    (50) expression -> . value comparator value
    (51) expression -> . value PLUS value
    (52) expression -> . value
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 83
    ID              shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72

    expression                     shift and go to state 307
    value                          shift and go to state 82
    interpolated_string            shift and go to state 70

state 286

    (30) function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)


state 287

    (29) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (95) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (96) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (97) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (121) map -> . map_declaration map_assignment
    (118) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (119) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (122) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (53) control_structures_if_else -> . if_block
    (54) control_structures_if_else -> . if_block else_if_blocks
    (55) control_structures_if_else -> . if_block else_if_blocks else_block
    (56) control_structures_if_else -> . if_block else_block
    (113) control_structures_for -> . for_classic
    (114) control_structures_for -> . for_in
    (115) control_structures_for -> . for_each
    (120) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (77) type -> . INT
    (78) type -> . DOUBLE
    (79) type -> . STRING
    (80) type -> . BOOL
    (81) type -> . LIST
    (57) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (106) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (112) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 308
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement                      shift and go to state 40
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 288

    (33) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .

    SEMICOLON       reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    PRINT           reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    STRING          reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    VAR             reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    FINAL           reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    ID              reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    VOID            reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    LIST            reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    DYNAMIC         reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    INT             reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    DOUBLE          reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    MAP             reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    WHILE           reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    BOOL            reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    IF              reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    FOR             reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    $end            reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)


state 289

    (31) function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)


state 290

    (83) list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET . value_list RSBRACKET SEMICOLON
    (84) value_list -> . value
    (85) value_list -> . value_list COMMA value
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 83
    ID              shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72

    value_list                     shift and go to state 309
    value                          shift and go to state 142
    interpolated_string            shift and go to state 70

state 291

    (122) map_declaration -> MAP LESS key_type COMMA type GREATER ID . ASSIGN

    ASSIGN          shift and go to state 310


state 292

    (59) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 311


state 293

    (58) else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (95) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (96) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (97) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (121) map -> . map_declaration map_assignment
    (118) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (119) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (122) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (53) control_structures_if_else -> . if_block
    (54) control_structures_if_else -> . if_block else_if_blocks
    (55) control_structures_if_else -> . if_block else_if_blocks else_block
    (56) control_structures_if_else -> . if_block else_block
    (113) control_structures_for -> . for_classic
    (114) control_structures_for -> . for_in
    (115) control_structures_for -> . for_each
    (120) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (77) type -> . INT
    (78) type -> . DOUBLE
    (79) type -> . STRING
    (80) type -> . BOOL
    (81) type -> . LIST
    (57) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (106) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (112) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement_list                 shift and go to state 312
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 294

    (57) if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .

    ELSE            reduce using rule 57 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 57 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 57 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 57 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 57 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 57 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 57 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 57 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 57 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 57 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 57 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 57 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 57 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 57 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 57 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 57 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 57 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 57 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 57 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)


state 295

    (106) for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 106 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 106 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 106 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 106 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 106 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 106 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 106 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 106 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 106 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 106 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 106 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 106 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 106 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 106 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 106 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 106 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 106 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 106 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)


state 296

    (108) for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 108 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 108 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 108 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 108 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 108 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 108 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 108 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 108 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 108 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 108 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 108 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 108 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 108 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 108 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 108 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 108 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 108 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 108 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)


state 297

    (112) for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 112 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 112 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 112 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 112 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 112 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 112 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 112 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 112 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 112 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 112 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 112 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 112 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 112 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 112 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 112 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 112 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 112 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 112 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)


state 298

    (105) for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON for_classic_changes .

    RPAREN          reduce using rule 105 (for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON for_classic_changes .)


state 299

    (101) for_classic_changes -> ID . comparator value
    (102) for_classic_changes -> ID . INCREMENT
    (103) for_classic_changes -> ID . DECREMENT
    (104) for_classic_changes -> ID . comparator value COMMA for_classic_changes
    (67) comparator -> . GREATER
    (68) comparator -> . LESS
    (69) comparator -> . EQUALS
    (70) comparator -> . GREATER_EQUAL
    (71) comparator -> . LESS_EQUAL
    (72) comparator -> . NOT_EQUALS

    INCREMENT       shift and go to state 314
    DECREMENT       shift and go to state 315
    GREATER         shift and go to state 124
    LESS            shift and go to state 125
    EQUALS          shift and go to state 126
    GREATER_EQUAL   shift and go to state 127
    LESS_EQUAL      shift and go to state 128
    NOT_EQUALS      shift and go to state 129

    comparator                     shift and go to state 313

state 300

    (111) for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN . IN ID

    IN              shift and go to state 316


state 301

    (109) for_each_parenthesis_parenthesis_content -> COLON ID .
    (110) for_each_parenthesis_parenthesis_content -> COLON ID . COMMA for_each_parenthesis_parenthesis_content

    RPAREN          reduce using rule 109 (for_each_parenthesis_parenthesis_content -> COLON ID .)
    COMMA           shift and go to state 317


state 302

    (22) data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 318


state 303

    (23) data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 319


state 304

    (96) set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 320


state 305

    (97) set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .

    SEMICOLON       reduce using rule 97 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    PRINT           reduce using rule 97 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    STRING          reduce using rule 97 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    VAR             reduce using rule 97 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    FINAL           reduce using rule 97 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    ID              reduce using rule 97 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    VOID            reduce using rule 97 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    LIST            reduce using rule 97 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 97 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    INT             reduce using rule 97 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 97 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    MAP             reduce using rule 97 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    WHILE           reduce using rule 97 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    BOOL            reduce using rule 97 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    IF              reduce using rule 97 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    FOR             reduce using rule 97 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    $end            reduce using rule 97 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    RBRACKET        reduce using rule 97 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)


state 306

    (28) function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)


state 307

    (119) function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .
    (44) expression -> expression . PLUS expression
    (45) expression -> expression . MINUS expression
    (46) expression -> expression . TIMES expression
    (47) expression -> expression . DIVIDE expression
    (48) expression -> expression . AND expression
    (49) expression -> expression . OR expression

    SEMICOLON       reduce using rule 119 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    PRINT           reduce using rule 119 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    STRING          reduce using rule 119 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    VAR             reduce using rule 119 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    FINAL           reduce using rule 119 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    ID              reduce using rule 119 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    VOID            reduce using rule 119 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    LIST            reduce using rule 119 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    DYNAMIC         reduce using rule 119 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    INT             reduce using rule 119 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    DOUBLE          reduce using rule 119 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    MAP             reduce using rule 119 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    WHILE           reduce using rule 119 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    BOOL            reduce using rule 119 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    IF              reduce using rule 119 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    FOR             reduce using rule 119 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    $end            reduce using rule 119 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    RBRACKET        reduce using rule 119 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    PLUS            shift and go to state 131
    MINUS           shift and go to state 132
    TIMES           shift and go to state 133
    DIVIDE          shift and go to state 134
    AND             shift and go to state 135
    OR              shift and go to state 136


state 308

    (29) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)


state 309

    (83) list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list . RSBRACKET SEMICOLON
    (85) value_list -> value_list . COMMA value

    RSBRACKET       shift and go to state 321
    COMMA           shift and go to state 204


state 310

    (122) map_declaration -> MAP LESS key_type COMMA type GREATER ID ASSIGN .

    LBRACKET        reduce using rule 122 (map_declaration -> MAP LESS key_type COMMA type GREATER ID ASSIGN .)


state 311

    (59) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (95) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (96) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (97) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (121) map -> . map_declaration map_assignment
    (118) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (119) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (122) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (53) control_structures_if_else -> . if_block
    (54) control_structures_if_else -> . if_block else_if_blocks
    (55) control_structures_if_else -> . if_block else_if_blocks else_block
    (56) control_structures_if_else -> . if_block else_block
    (113) control_structures_for -> . for_classic
    (114) control_structures_for -> . for_in
    (115) control_structures_for -> . for_each
    (120) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (77) type -> . INT
    (78) type -> . DOUBLE
    (79) type -> . STRING
    (80) type -> . BOOL
    (81) type -> . LIST
    (57) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (106) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (112) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement_list                 shift and go to state 322
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 312

    (58) else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (95) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (96) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (97) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (121) map -> . map_declaration map_assignment
    (118) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (119) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (122) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (53) control_structures_if_else -> . if_block
    (54) control_structures_if_else -> . if_block else_if_blocks
    (55) control_structures_if_else -> . if_block else_if_blocks else_block
    (56) control_structures_if_else -> . if_block else_block
    (113) control_structures_for -> . for_classic
    (114) control_structures_for -> . for_in
    (115) control_structures_for -> . for_each
    (120) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (77) type -> . INT
    (78) type -> . DOUBLE
    (79) type -> . STRING
    (80) type -> . BOOL
    (81) type -> . LIST
    (57) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (106) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (112) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 323
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement                      shift and go to state 40
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 313

    (101) for_classic_changes -> ID comparator . value
    (104) for_classic_changes -> ID comparator . value COMMA for_classic_changes
    (86) value -> . NUMBER
    (87) value -> . NDOUBLE
    (88) value -> . TEXT
    (89) value -> . ID
    (90) value -> . interpolated_string
    (91) value -> . TRUE
    (92) value -> . FALSE
    (93) interpolated_string -> . TEXT PLUS ID
    (94) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 66
    NDOUBLE         shift and go to state 67
    TEXT            shift and go to state 83
    ID              shift and go to state 69
    TRUE            shift and go to state 71
    FALSE           shift and go to state 72

    value                          shift and go to state 324
    interpolated_string            shift and go to state 70

state 314

    (102) for_classic_changes -> ID INCREMENT .

    RPAREN          reduce using rule 102 (for_classic_changes -> ID INCREMENT .)


state 315

    (103) for_classic_changes -> ID DECREMENT .

    RPAREN          reduce using rule 103 (for_classic_changes -> ID DECREMENT .)


state 316

    (111) for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN . ID

    ID              shift and go to state 325


state 317

    (110) for_each_parenthesis_parenthesis_content -> COLON ID COMMA . for_each_parenthesis_parenthesis_content
    (109) for_each_parenthesis_parenthesis_content -> . COLON ID
    (110) for_each_parenthesis_parenthesis_content -> . COLON ID COMMA for_each_parenthesis_parenthesis_content

    COLON           shift and go to state 275

    for_each_parenthesis_parenthesis_content shift and go to state 326

state 318

    (22) data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)


state 319

    (23) data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 327


state 320

    (96) set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .

    SEMICOLON       reduce using rule 96 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    PRINT           reduce using rule 96 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    STRING          reduce using rule 96 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    VAR             reduce using rule 96 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    FINAL           reduce using rule 96 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    ID              reduce using rule 96 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    VOID            reduce using rule 96 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    LIST            reduce using rule 96 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 96 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    INT             reduce using rule 96 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 96 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    MAP             reduce using rule 96 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    WHILE           reduce using rule 96 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    BOOL            reduce using rule 96 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    IF              reduce using rule 96 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    FOR             reduce using rule 96 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    $end            reduce using rule 96 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    RBRACKET        reduce using rule 96 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)


state 321

    (83) list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 328


state 322

    (59) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (95) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (96) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (97) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (121) map -> . map_declaration map_assignment
    (118) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (119) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (83) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (122) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (53) control_structures_if_else -> . if_block
    (54) control_structures_if_else -> . if_block else_if_blocks
    (55) control_structures_if_else -> . if_block else_if_blocks else_block
    (56) control_structures_if_else -> . if_block else_block
    (113) control_structures_for -> . for_classic
    (114) control_structures_for -> . for_in
    (115) control_structures_for -> . for_each
    (120) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (77) type -> . INT
    (78) type -> . DOUBLE
    (79) type -> . STRING
    (80) type -> . BOOL
    (81) type -> . LIST
    (57) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (106) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (112) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 329
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement                      shift and go to state 40
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 323

    (58) else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .

    ELSE            reduce using rule 58 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 58 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 58 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 58 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 58 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 58 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 58 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 58 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 58 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 58 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 58 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 58 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 58 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 58 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 58 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 58 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 58 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 58 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 58 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)


state 324

    (101) for_classic_changes -> ID comparator value .
    (104) for_classic_changes -> ID comparator value . COMMA for_classic_changes

    RPAREN          reduce using rule 101 (for_classic_changes -> ID comparator value .)
    COMMA           shift and go to state 330


state 325

    (111) for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID .

    RPAREN          reduce using rule 111 (for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID .)


state 326

    (110) for_each_parenthesis_parenthesis_content -> COLON ID COMMA for_each_parenthesis_parenthesis_content .

    RPAREN          reduce using rule 110 (for_each_parenthesis_parenthesis_content -> COLON ID COMMA for_each_parenthesis_parenthesis_content .)


state 327

    (23) data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)


state 328

    (83) list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .

    SEMICOLON       reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    PRINT           reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    STRING          reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    VAR             reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    FINAL           reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    ID              reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    VOID            reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    LIST            reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    INT             reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    MAP             reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    WHILE           reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    BOOL            reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    IF              reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    FOR             reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    $end            reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    RBRACKET        reduce using rule 83 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)


state 329

    (59) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .

    ELSE            reduce using rule 59 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 59 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 59 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 59 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 59 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 59 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 59 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 59 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 59 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 59 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 59 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 59 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 59 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 59 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 59 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 59 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 59 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 59 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 59 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)


state 330

    (104) for_classic_changes -> ID comparator value COMMA . for_classic_changes
    (101) for_classic_changes -> . ID comparator value
    (102) for_classic_changes -> . ID INCREMENT
    (103) for_classic_changes -> . ID DECREMENT
    (104) for_classic_changes -> . ID comparator value COMMA for_classic_changes

    ID              shift and go to state 299

    for_classic_changes            shift and go to state 331

state 331

    (104) for_classic_changes -> ID comparator value COMMA for_classic_changes .

    RPAREN          reduce using rule 104 (for_classic_changes -> ID comparator value COMMA for_classic_changes .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 17 resolved as shift
WARNING: shift/reduce conflict for ID in state 29 resolved as shift
WARNING: shift/reduce conflict for ID in state 30 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 63 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 63 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 68 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 82 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 82 resolved as shift
WARNING: shift/reduce conflict for LESS in state 82 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 82 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 82 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 82 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUALS in state 82 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 83 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 192 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 192 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 192 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 192 resolved as shift
WARNING: shift/reduce conflict for AND in state 192 resolved as shift
WARNING: shift/reduce conflict for OR in state 192 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 193 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 193 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 193 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 193 resolved as shift
WARNING: shift/reduce conflict for AND in state 193 resolved as shift
WARNING: shift/reduce conflict for OR in state 193 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 194 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 194 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 194 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 194 resolved as shift
WARNING: shift/reduce conflict for AND in state 194 resolved as shift
WARNING: shift/reduce conflict for OR in state 194 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 195 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 195 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 195 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 195 resolved as shift
WARNING: shift/reduce conflict for AND in state 195 resolved as shift
WARNING: shift/reduce conflict for OR in state 195 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 196 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 196 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 196 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 196 resolved as shift
WARNING: shift/reduce conflict for AND in state 196 resolved as shift
WARNING: shift/reduce conflict for OR in state 196 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 197 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 197 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 197 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 197 resolved as shift
WARNING: shift/reduce conflict for AND in state 197 resolved as shift
WARNING: shift/reduce conflict for OR in state 197 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 201 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 201 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 201 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 201 resolved as shift
WARNING: shift/reduce conflict for AND in state 201 resolved as shift
WARNING: shift/reduce conflict for OR in state 201 resolved as shift
WARNING: shift/reduce conflict for AND in state 235 resolved as shift
WARNING: shift/reduce conflict for OR in state 235 resolved as shift
WARNING: shift/reduce conflict for AND in state 236 resolved as shift
WARNING: shift/reduce conflict for OR in state 236 resolved as shift
WARNING: reduce/reduce conflict in state 200 resolved using rule (value -> ID)
WARNING: rejected rule (interpolated_string -> TEXT PLUS ID) in state 200
WARNING: Rule (interpolated_string -> TEXT PLUS ID) is never reduced
