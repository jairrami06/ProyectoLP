Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AS
    ASSERT
    ASYNC
    AWAIT
    BREAK
    CASE
    CATCH
    CLASS
    CONTINUE
    COVARIANT
    DEFAULT
    DEFERRED
    DO
    DOLLARSIGN
    DOUBLE_COLON
    ENUM
    EXPORT
    EXTENDS
    EXTENSION
    EXTERNAL
    FACTORY
    FINALLY
    FUNCTION
    GET
    HIDE
    IMPLEMENTS
    IMPORT
    INTERFACE
    IS
    LATE
    LIBRARY
    MAP
    MIXIN
    MODULE
    NEW
    NULL
    NUM
    NUMERAL
    OBJECT
    ON
    OPERATOR
    PART
    RETHROW
    RETURN
    SET
    SHOW
    STATIC
    SUPER
    SWITCH
    SYNC
    THROW
    TRY
    TYPEDEF
    WHILE
    WITH
    YIELD

Grammar

Rule 0     S' -> program
Rule 1     program -> statement_list
Rule 2     statement_list -> statement
Rule 3     statement_list -> statement_list statement
Rule 4     statement -> print
Rule 5     statement -> data_input
Rule 6     statement -> set
Rule 7     statement -> constructor
Rule 8     statement -> control_structures
Rule 9     statement -> function
Rule 10    statement -> list_definition
Rule 11    statement -> variable_definition
Rule 12    statement -> variable_usage
Rule 13    statement -> call_function
Rule 14    statement -> SEMICOLON
Rule 15    control_structures -> control_structures_if_else
Rule 16    control_structures -> control_structures_for
Rule 17    variable_usage -> ID
Rule 18    call_function -> ID LPAREN argument_list RPAREN
Rule 19    call_function -> ID LPAREN RPAREN
Rule 20    data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
Rule 21    data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
Rule 22    length -> call_list DOT LENGTH
Rule 23    length -> TEXT DOT LENGTH
Rule 24    argument_list -> expression
Rule 25    argument_list -> argument_list COMMA expression
Rule 26    function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
Rule 27    function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
Rule 28    function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
Rule 29    function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
Rule 30    function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET
Rule 31    function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
Rule 32    variable_definition -> type ID ASSIGN expression SEMICOLON
Rule 33    variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON
Rule 34    variable_definition -> VAR ID ASSIGN expression SEMICOLON
Rule 35    variable_definition -> INT ID ASSIGN length SEMICOLON
Rule 36    print -> PRINT LPAREN RPAREN SEMICOLON
Rule 37    print -> PRINT LPAREN value RPAREN SEMICOLON
Rule 38    print -> PRINT LPAREN expression RPAREN SEMICOLON
Rule 39    print -> PRINT LPAREN length RPAREN SEMICOLON
Rule 40    expression -> expression PLUS expression
Rule 41    expression -> expression MINUS expression
Rule 42    expression -> expression TIMES expression
Rule 43    expression -> expression DIVIDE expression
Rule 44    expression -> expression AND expression
Rule 45    expression -> expression OR expression
Rule 46    expression -> value comparator value
Rule 47    expression -> value PLUS value
Rule 48    expression -> value
Rule 49    control_structures_if_else -> if_block
Rule 50    control_structures_if_else -> if_block else_if_blocks
Rule 51    control_structures_if_else -> if_block else_if_blocks else_block
Rule 52    control_structures_if_else -> if_block else_block
Rule 53    if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
Rule 54    else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
Rule 55    else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
Rule 56    else_block -> ELSE LBRACKET statement_list RBRACKET
Rule 57    conditions -> condition
Rule 58    conditions -> conditions AND conditions
Rule 59    conditions -> conditions OR conditions
Rule 60    condition -> value comparator value
Rule 61    condition -> NOT condition
Rule 62    condition -> LPAREN conditions RPAREN
Rule 63    comparator -> GREATER
Rule 64    comparator -> LESS
Rule 65    comparator -> EQUALS
Rule 66    comparator -> GREATER_EQUAL
Rule 67    comparator -> LESS_EQUAL
Rule 68    comparator -> NOT_EQUALS
Rule 69    parameter_list -> parameter
Rule 70    parameter_list -> parameter_list COMMA parameter
Rule 71    parameter -> type ID
Rule 72    parameter -> REQUIRED type ID
Rule 73    type -> INT
Rule 74    type -> DOUBLE
Rule 75    type -> STRING
Rule 76    type -> BOOL
Rule 77    type -> LIST
Rule 78    call_list -> LSBRACKET value_list RSBRACKET
Rule 79    list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
Rule 80    value_list -> value
Rule 81    value_list -> value_list COMMA value
Rule 82    value -> NUMBER
Rule 83    value -> NDOUBLE
Rule 84    value -> TEXT
Rule 85    value -> ID
Rule 86    value -> interpolated_string
Rule 87    value -> TRUE
Rule 88    value -> FALSE
Rule 89    interpolated_string -> TEXT PLUS ID
Rule 90    interpolated_string -> TEXT PLUS expression
Rule 91    set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
Rule 92    set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
Rule 93    set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
Rule 94    for_classic_initialization -> INT ID ASSIGN NUMBER
Rule 95    for_classic_initialization -> DOUBLE ID ASSIGN NDOUBLE
Rule 96    for_classic_conditions -> conditions
Rule 97    for_classic_changes -> ID comparator value
Rule 98    for_classic_changes -> ID INCREMENT
Rule 99    for_classic_changes -> ID DECREMENT
Rule 100   for_classic_changes -> ID comparator value COMMA for_classic_changes
Rule 101   for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON for_classic_changes
Rule 102   for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
Rule 103   for_in_parenthesis_content -> FINAL ID IN ID
Rule 104   for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
Rule 105   for_each_parenthesis_parenthesis_content -> COLON ID
Rule 106   for_each_parenthesis_parenthesis_content -> COLON ID COMMA for_each_parenthesis_parenthesis_content
Rule 107   for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID
Rule 108   for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
Rule 109   control_structures_for -> for_classic
Rule 110   control_structures_for -> for_in
Rule 111   control_structures_for -> for_each
Rule 112   constructor_parenthesis_content -> THIS DOT ID
Rule 113   constructor_parenthesis_content -> THIS DOT ID COMMA constructor_parenthesis_content
Rule 114   constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON

Terminals, with rules where they appear

ABSTRACT             : 
AND                  : 44 58
AS                   : 
ASSERT               : 
ASSIGN               : 20 21 32 33 34 35 79 91 92 93 94 95
ASYNC                : 
AWAIT                : 
BOOL                 : 76
BREAK                : 
CASE                 : 
CATCH                : 
CLASS                : 
COLON                : 105 106
COMMA                : 25 70 81 100 106 113
CONST                : 93
CONTINUE             : 
COVARIANT            : 
DECREMENT            : 99
DEFAULT              : 
DEFERRED             : 
DIVIDE               : 43
DO                   : 
DOLLARSIGN           : 
DOT                  : 20 21 22 23 112 113
DOUBLE               : 74 95
DOUBLE_COLON         : 
DYNAMIC              : 33
ELSE                 : 54 55 56
ENUM                 : 
EQUALS               : 65
EXPORT               : 
EXTENDS              : 
EXTENSION            : 
EXTERNAL             : 
FACTORY              : 
FALSE                : 88
FINAL                : 93 103 107
FINALLY              : 
FOR                  : 102 104 108
FUNCTION             : 
GET                  : 
GREATER              : 63 79 92
GREATER_EQUAL        : 66
HIDE                 : 
ID                   : 17 18 19 20 21 26 27 28 29 30 31 32 33 34 35 71 72 79 85 89 91 92 93 94 95 97 98 99 100 103 103 105 106 107 107 112 113 114
IF                   : 53 54 55
IMPLEMENTS           : 
IMPORT               : 
IN                   : 103 107
INCREMENT            : 98
INT                  : 35 73 94
INTERFACE            : 
IS                   : 
LATE                 : 
LBRACKET             : 26 27 28 29 30 31 53 54 55 56 91 92 93 102 104 108
LENGTH               : 22 23
LESS                 : 64 79 92
LESS_EQUAL           : 67
LIBRARY              : 
LIST                 : 77 79
LPAREN               : 18 19 20 21 26 27 28 29 30 31 36 37 38 39 53 54 55 62 102 104 107 108 114
LSBRACKET            : 78 79
MAP                  : 
MINUS                : 41
MIXIN                : 
MODULE               : 
NDOUBLE              : 83 95
NEW                  : 
NOT                  : 61
NOT_EQUALS           : 68
NULL                 : 
NUM                  : 
NUMBER               : 82 94
NUMERAL              : 
OBJECT               : 
ON                   : 
OPERATOR             : 
OR                   : 45 59
PART                 : 
PLUS                 : 40 47 89 90
PRINT                : 36 37 38 39
QUESTION             : 21
RBRACKET             : 26 27 28 29 30 31 53 54 55 56 91 92 93 102 104 108
READLINESYNC         : 20 21
REQUIRED             : 72
RETHROW              : 
RETURN               : 
RPAREN               : 18 19 20 21 26 27 28 29 30 31 36 37 38 39 53 54 55 62 102 104 107 108 114
RSBRACKET            : 78 79
SEMICOLON            : 14 20 21 32 33 34 35 36 37 38 39 79 91 92 93 101 101 114
SET                  : 
SHOW                 : 
STATIC               : 
STDIN                : 20 21
STRING               : 20 21 75 92
SUPER                : 
SWITCH               : 
SYNC                 : 
TEXT                 : 23 84 89 90
THIS                 : 112 113
THROW                : 
TIMES                : 42
TRUE                 : 87
TRY                  : 
TYPEDEF              : 
VAR                  : 34 91 92
VOID                 : 27 29 30 31
WHILE                : 
WITH                 : 
YIELD                : 
error                : 

Nonterminals, with rules where they appear

argument_list        : 18 25
call_function        : 13
call_list            : 22
comparator           : 46 60 97 100
condition            : 57 61
conditions           : 53 54 55 58 58 59 59 62 96
constructor          : 7
constructor_parenthesis_content : 113 114
control_structures   : 8
control_structures_for : 16
control_structures_if_else : 15
data_input           : 5
else_block           : 51 52
else_if_blocks       : 50 51 55
expression           : 24 25 32 33 34 38 40 40 41 41 42 42 43 43 44 44 45 45 90
for_classic          : 109
for_classic_changes  : 100 101
for_classic_conditions : 101
for_classic_initialization : 101
for_classic_parenthesis_content : 102
for_each             : 111
for_each_parenthesis_content : 108
for_each_parenthesis_parenthesis_content : 106 107
for_in               : 110
for_in_parenthesis_content : 104
function             : 9
if_block             : 49 50 51 52
interpolated_string  : 86
length               : 35 39
list_definition      : 10
parameter            : 69 70
parameter_list       : 26 27 31 70
print                : 4
program              : 0
set                  : 6
statement            : 2 3
statement_list       : 1 3 26 27 28 29 53 54 55 56 102 104 108
type                 : 26 28 32 71 72 79
value                : 37 46 46 47 47 48 60 60 80 81 97 100
value_list           : 78 79 81 91 93
variable_definition  : 11
variable_usage       : 12

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement_list
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . constructor
    (8) statement -> . control_structures
    (9) statement -> . function
    (10) statement -> . list_definition
    (11) statement -> . variable_definition
    (12) statement -> . variable_usage
    (13) statement -> . call_function
    (14) statement -> . SEMICOLON
    (36) print -> . PRINT LPAREN RPAREN SEMICOLON
    (37) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (38) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (39) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (20) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (21) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (91) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (92) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (93) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (114) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (15) control_structures -> . control_structures_if_else
    (16) control_structures -> . control_structures_for
    (26) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (27) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (28) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (31) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (79) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (32) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (33) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (34) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (17) variable_usage -> . ID
    (18) call_function -> . ID LPAREN argument_list RPAREN
    (19) call_function -> . ID LPAREN RPAREN
    (49) control_structures_if_else -> . if_block
    (50) control_structures_if_else -> . if_block else_if_blocks
    (51) control_structures_if_else -> . if_block else_if_blocks else_block
    (52) control_structures_if_else -> . if_block else_block
    (109) control_structures_for -> . for_classic
    (110) control_structures_for -> . for_in
    (111) control_structures_for -> . for_each
    (73) type -> . INT
    (74) type -> . DOUBLE
    (75) type -> . STRING
    (76) type -> . BOOL
    (77) type -> . LIST
    (53) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (102) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (104) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 14
    PRINT           shift and go to state 15
    STRING          shift and go to state 16
    VAR             shift and go to state 18
    FINAL           shift and go to state 19
    ID              shift and go to state 17
    VOID            shift and go to state 23
    LIST            shift and go to state 24
    DYNAMIC         shift and go to state 25
    INT             shift and go to state 26
    DOUBLE          shift and go to state 31
    BOOL            shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34

    program                        shift and go to state 1
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    constructor                    shift and go to state 7
    control_structures             shift and go to state 8
    function                       shift and go to state 9
    list_definition                shift and go to state 10
    variable_definition            shift and go to state 11
    variable_usage                 shift and go to state 12
    call_function                  shift and go to state 13
    control_structures_if_else     shift and go to state 20
    control_structures_for         shift and go to state 21
    type                           shift and go to state 22
    if_block                       shift and go to state 27
    for_classic                    shift and go to state 28
    for_in                         shift and go to state 29
    for_each                       shift and go to state 30

state 1

    (0) S' -> program .



state 2

    (1) program -> statement_list .
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . constructor
    (8) statement -> . control_structures
    (9) statement -> . function
    (10) statement -> . list_definition
    (11) statement -> . variable_definition
    (12) statement -> . variable_usage
    (13) statement -> . call_function
    (14) statement -> . SEMICOLON
    (36) print -> . PRINT LPAREN RPAREN SEMICOLON
    (37) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (38) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (39) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (20) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (21) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (91) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (92) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (93) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (114) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (15) control_structures -> . control_structures_if_else
    (16) control_structures -> . control_structures_for
    (26) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (27) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (28) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (31) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (79) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (32) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (33) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (34) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (17) variable_usage -> . ID
    (18) call_function -> . ID LPAREN argument_list RPAREN
    (19) call_function -> . ID LPAREN RPAREN
    (49) control_structures_if_else -> . if_block
    (50) control_structures_if_else -> . if_block else_if_blocks
    (51) control_structures_if_else -> . if_block else_if_blocks else_block
    (52) control_structures_if_else -> . if_block else_block
    (109) control_structures_for -> . for_classic
    (110) control_structures_for -> . for_in
    (111) control_structures_for -> . for_each
    (73) type -> . INT
    (74) type -> . DOUBLE
    (75) type -> . STRING
    (76) type -> . BOOL
    (77) type -> . LIST
    (53) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (102) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (104) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    $end            reduce using rule 1 (program -> statement_list .)
    SEMICOLON       shift and go to state 14
    PRINT           shift and go to state 15
    STRING          shift and go to state 16
    VAR             shift and go to state 18
    FINAL           shift and go to state 19
    ID              shift and go to state 17
    VOID            shift and go to state 23
    LIST            shift and go to state 24
    DYNAMIC         shift and go to state 25
    INT             shift and go to state 26
    DOUBLE          shift and go to state 31
    BOOL            shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34

    statement                      shift and go to state 35
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    constructor                    shift and go to state 7
    control_structures             shift and go to state 8
    function                       shift and go to state 9
    list_definition                shift and go to state 10
    variable_definition            shift and go to state 11
    variable_usage                 shift and go to state 12
    call_function                  shift and go to state 13
    control_structures_if_else     shift and go to state 20
    control_structures_for         shift and go to state 21
    type                           shift and go to state 22
    if_block                       shift and go to state 27
    for_classic                    shift and go to state 28
    for_in                         shift and go to state 29
    for_each                       shift and go to state 30

state 3

    (2) statement_list -> statement .

    SEMICOLON       reduce using rule 2 (statement_list -> statement .)
    PRINT           reduce using rule 2 (statement_list -> statement .)
    STRING          reduce using rule 2 (statement_list -> statement .)
    VAR             reduce using rule 2 (statement_list -> statement .)
    FINAL           reduce using rule 2 (statement_list -> statement .)
    ID              reduce using rule 2 (statement_list -> statement .)
    VOID            reduce using rule 2 (statement_list -> statement .)
    LIST            reduce using rule 2 (statement_list -> statement .)
    DYNAMIC         reduce using rule 2 (statement_list -> statement .)
    INT             reduce using rule 2 (statement_list -> statement .)
    DOUBLE          reduce using rule 2 (statement_list -> statement .)
    BOOL            reduce using rule 2 (statement_list -> statement .)
    IF              reduce using rule 2 (statement_list -> statement .)
    FOR             reduce using rule 2 (statement_list -> statement .)
    $end            reduce using rule 2 (statement_list -> statement .)
    RBRACKET        reduce using rule 2 (statement_list -> statement .)


state 4

    (4) statement -> print .

    SEMICOLON       reduce using rule 4 (statement -> print .)
    PRINT           reduce using rule 4 (statement -> print .)
    STRING          reduce using rule 4 (statement -> print .)
    VAR             reduce using rule 4 (statement -> print .)
    FINAL           reduce using rule 4 (statement -> print .)
    ID              reduce using rule 4 (statement -> print .)
    VOID            reduce using rule 4 (statement -> print .)
    LIST            reduce using rule 4 (statement -> print .)
    DYNAMIC         reduce using rule 4 (statement -> print .)
    INT             reduce using rule 4 (statement -> print .)
    DOUBLE          reduce using rule 4 (statement -> print .)
    BOOL            reduce using rule 4 (statement -> print .)
    IF              reduce using rule 4 (statement -> print .)
    FOR             reduce using rule 4 (statement -> print .)
    $end            reduce using rule 4 (statement -> print .)
    RBRACKET        reduce using rule 4 (statement -> print .)


state 5

    (5) statement -> data_input .

    SEMICOLON       reduce using rule 5 (statement -> data_input .)
    PRINT           reduce using rule 5 (statement -> data_input .)
    STRING          reduce using rule 5 (statement -> data_input .)
    VAR             reduce using rule 5 (statement -> data_input .)
    FINAL           reduce using rule 5 (statement -> data_input .)
    ID              reduce using rule 5 (statement -> data_input .)
    VOID            reduce using rule 5 (statement -> data_input .)
    LIST            reduce using rule 5 (statement -> data_input .)
    DYNAMIC         reduce using rule 5 (statement -> data_input .)
    INT             reduce using rule 5 (statement -> data_input .)
    DOUBLE          reduce using rule 5 (statement -> data_input .)
    BOOL            reduce using rule 5 (statement -> data_input .)
    IF              reduce using rule 5 (statement -> data_input .)
    FOR             reduce using rule 5 (statement -> data_input .)
    $end            reduce using rule 5 (statement -> data_input .)
    RBRACKET        reduce using rule 5 (statement -> data_input .)


state 6

    (6) statement -> set .

    SEMICOLON       reduce using rule 6 (statement -> set .)
    PRINT           reduce using rule 6 (statement -> set .)
    STRING          reduce using rule 6 (statement -> set .)
    VAR             reduce using rule 6 (statement -> set .)
    FINAL           reduce using rule 6 (statement -> set .)
    ID              reduce using rule 6 (statement -> set .)
    VOID            reduce using rule 6 (statement -> set .)
    LIST            reduce using rule 6 (statement -> set .)
    DYNAMIC         reduce using rule 6 (statement -> set .)
    INT             reduce using rule 6 (statement -> set .)
    DOUBLE          reduce using rule 6 (statement -> set .)
    BOOL            reduce using rule 6 (statement -> set .)
    IF              reduce using rule 6 (statement -> set .)
    FOR             reduce using rule 6 (statement -> set .)
    $end            reduce using rule 6 (statement -> set .)
    RBRACKET        reduce using rule 6 (statement -> set .)


state 7

    (7) statement -> constructor .

    SEMICOLON       reduce using rule 7 (statement -> constructor .)
    PRINT           reduce using rule 7 (statement -> constructor .)
    STRING          reduce using rule 7 (statement -> constructor .)
    VAR             reduce using rule 7 (statement -> constructor .)
    FINAL           reduce using rule 7 (statement -> constructor .)
    ID              reduce using rule 7 (statement -> constructor .)
    VOID            reduce using rule 7 (statement -> constructor .)
    LIST            reduce using rule 7 (statement -> constructor .)
    DYNAMIC         reduce using rule 7 (statement -> constructor .)
    INT             reduce using rule 7 (statement -> constructor .)
    DOUBLE          reduce using rule 7 (statement -> constructor .)
    BOOL            reduce using rule 7 (statement -> constructor .)
    IF              reduce using rule 7 (statement -> constructor .)
    FOR             reduce using rule 7 (statement -> constructor .)
    $end            reduce using rule 7 (statement -> constructor .)
    RBRACKET        reduce using rule 7 (statement -> constructor .)


state 8

    (8) statement -> control_structures .

    SEMICOLON       reduce using rule 8 (statement -> control_structures .)
    PRINT           reduce using rule 8 (statement -> control_structures .)
    STRING          reduce using rule 8 (statement -> control_structures .)
    VAR             reduce using rule 8 (statement -> control_structures .)
    FINAL           reduce using rule 8 (statement -> control_structures .)
    ID              reduce using rule 8 (statement -> control_structures .)
    VOID            reduce using rule 8 (statement -> control_structures .)
    LIST            reduce using rule 8 (statement -> control_structures .)
    DYNAMIC         reduce using rule 8 (statement -> control_structures .)
    INT             reduce using rule 8 (statement -> control_structures .)
    DOUBLE          reduce using rule 8 (statement -> control_structures .)
    BOOL            reduce using rule 8 (statement -> control_structures .)
    IF              reduce using rule 8 (statement -> control_structures .)
    FOR             reduce using rule 8 (statement -> control_structures .)
    $end            reduce using rule 8 (statement -> control_structures .)
    RBRACKET        reduce using rule 8 (statement -> control_structures .)


state 9

    (9) statement -> function .

    SEMICOLON       reduce using rule 9 (statement -> function .)
    PRINT           reduce using rule 9 (statement -> function .)
    STRING          reduce using rule 9 (statement -> function .)
    VAR             reduce using rule 9 (statement -> function .)
    FINAL           reduce using rule 9 (statement -> function .)
    ID              reduce using rule 9 (statement -> function .)
    VOID            reduce using rule 9 (statement -> function .)
    LIST            reduce using rule 9 (statement -> function .)
    DYNAMIC         reduce using rule 9 (statement -> function .)
    INT             reduce using rule 9 (statement -> function .)
    DOUBLE          reduce using rule 9 (statement -> function .)
    BOOL            reduce using rule 9 (statement -> function .)
    IF              reduce using rule 9 (statement -> function .)
    FOR             reduce using rule 9 (statement -> function .)
    $end            reduce using rule 9 (statement -> function .)
    RBRACKET        reduce using rule 9 (statement -> function .)


state 10

    (10) statement -> list_definition .

    SEMICOLON       reduce using rule 10 (statement -> list_definition .)
    PRINT           reduce using rule 10 (statement -> list_definition .)
    STRING          reduce using rule 10 (statement -> list_definition .)
    VAR             reduce using rule 10 (statement -> list_definition .)
    FINAL           reduce using rule 10 (statement -> list_definition .)
    ID              reduce using rule 10 (statement -> list_definition .)
    VOID            reduce using rule 10 (statement -> list_definition .)
    LIST            reduce using rule 10 (statement -> list_definition .)
    DYNAMIC         reduce using rule 10 (statement -> list_definition .)
    INT             reduce using rule 10 (statement -> list_definition .)
    DOUBLE          reduce using rule 10 (statement -> list_definition .)
    BOOL            reduce using rule 10 (statement -> list_definition .)
    IF              reduce using rule 10 (statement -> list_definition .)
    FOR             reduce using rule 10 (statement -> list_definition .)
    $end            reduce using rule 10 (statement -> list_definition .)
    RBRACKET        reduce using rule 10 (statement -> list_definition .)


state 11

    (11) statement -> variable_definition .

    SEMICOLON       reduce using rule 11 (statement -> variable_definition .)
    PRINT           reduce using rule 11 (statement -> variable_definition .)
    STRING          reduce using rule 11 (statement -> variable_definition .)
    VAR             reduce using rule 11 (statement -> variable_definition .)
    FINAL           reduce using rule 11 (statement -> variable_definition .)
    ID              reduce using rule 11 (statement -> variable_definition .)
    VOID            reduce using rule 11 (statement -> variable_definition .)
    LIST            reduce using rule 11 (statement -> variable_definition .)
    DYNAMIC         reduce using rule 11 (statement -> variable_definition .)
    INT             reduce using rule 11 (statement -> variable_definition .)
    DOUBLE          reduce using rule 11 (statement -> variable_definition .)
    BOOL            reduce using rule 11 (statement -> variable_definition .)
    IF              reduce using rule 11 (statement -> variable_definition .)
    FOR             reduce using rule 11 (statement -> variable_definition .)
    $end            reduce using rule 11 (statement -> variable_definition .)
    RBRACKET        reduce using rule 11 (statement -> variable_definition .)


state 12

    (12) statement -> variable_usage .

    SEMICOLON       reduce using rule 12 (statement -> variable_usage .)
    PRINT           reduce using rule 12 (statement -> variable_usage .)
    STRING          reduce using rule 12 (statement -> variable_usage .)
    VAR             reduce using rule 12 (statement -> variable_usage .)
    FINAL           reduce using rule 12 (statement -> variable_usage .)
    ID              reduce using rule 12 (statement -> variable_usage .)
    VOID            reduce using rule 12 (statement -> variable_usage .)
    LIST            reduce using rule 12 (statement -> variable_usage .)
    DYNAMIC         reduce using rule 12 (statement -> variable_usage .)
    INT             reduce using rule 12 (statement -> variable_usage .)
    DOUBLE          reduce using rule 12 (statement -> variable_usage .)
    BOOL            reduce using rule 12 (statement -> variable_usage .)
    IF              reduce using rule 12 (statement -> variable_usage .)
    FOR             reduce using rule 12 (statement -> variable_usage .)
    $end            reduce using rule 12 (statement -> variable_usage .)
    RBRACKET        reduce using rule 12 (statement -> variable_usage .)


state 13

    (13) statement -> call_function .

    SEMICOLON       reduce using rule 13 (statement -> call_function .)
    PRINT           reduce using rule 13 (statement -> call_function .)
    STRING          reduce using rule 13 (statement -> call_function .)
    VAR             reduce using rule 13 (statement -> call_function .)
    FINAL           reduce using rule 13 (statement -> call_function .)
    ID              reduce using rule 13 (statement -> call_function .)
    VOID            reduce using rule 13 (statement -> call_function .)
    LIST            reduce using rule 13 (statement -> call_function .)
    DYNAMIC         reduce using rule 13 (statement -> call_function .)
    INT             reduce using rule 13 (statement -> call_function .)
    DOUBLE          reduce using rule 13 (statement -> call_function .)
    BOOL            reduce using rule 13 (statement -> call_function .)
    IF              reduce using rule 13 (statement -> call_function .)
    FOR             reduce using rule 13 (statement -> call_function .)
    $end            reduce using rule 13 (statement -> call_function .)
    RBRACKET        reduce using rule 13 (statement -> call_function .)


state 14

    (14) statement -> SEMICOLON .

    SEMICOLON       reduce using rule 14 (statement -> SEMICOLON .)
    PRINT           reduce using rule 14 (statement -> SEMICOLON .)
    STRING          reduce using rule 14 (statement -> SEMICOLON .)
    VAR             reduce using rule 14 (statement -> SEMICOLON .)
    FINAL           reduce using rule 14 (statement -> SEMICOLON .)
    ID              reduce using rule 14 (statement -> SEMICOLON .)
    VOID            reduce using rule 14 (statement -> SEMICOLON .)
    LIST            reduce using rule 14 (statement -> SEMICOLON .)
    DYNAMIC         reduce using rule 14 (statement -> SEMICOLON .)
    INT             reduce using rule 14 (statement -> SEMICOLON .)
    DOUBLE          reduce using rule 14 (statement -> SEMICOLON .)
    BOOL            reduce using rule 14 (statement -> SEMICOLON .)
    IF              reduce using rule 14 (statement -> SEMICOLON .)
    FOR             reduce using rule 14 (statement -> SEMICOLON .)
    $end            reduce using rule 14 (statement -> SEMICOLON .)
    RBRACKET        reduce using rule 14 (statement -> SEMICOLON .)


state 15

    (36) print -> PRINT . LPAREN RPAREN SEMICOLON
    (37) print -> PRINT . LPAREN value RPAREN SEMICOLON
    (38) print -> PRINT . LPAREN expression RPAREN SEMICOLON
    (39) print -> PRINT . LPAREN length RPAREN SEMICOLON

    LPAREN          shift and go to state 36


state 16

    (20) data_input -> STRING . ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (21) data_input -> STRING . QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (75) type -> STRING .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 37
    QUESTION        shift and go to state 38

  ! ID              [ reduce using rule 75 (type -> STRING .) ]


state 17

    (114) constructor -> ID . LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (17) variable_usage -> ID .
    (18) call_function -> ID . LPAREN argument_list RPAREN
    (19) call_function -> ID . LPAREN RPAREN

    LPAREN          shift and go to state 39
    SEMICOLON       reduce using rule 17 (variable_usage -> ID .)
    PRINT           reduce using rule 17 (variable_usage -> ID .)
    STRING          reduce using rule 17 (variable_usage -> ID .)
    VAR             reduce using rule 17 (variable_usage -> ID .)
    FINAL           reduce using rule 17 (variable_usage -> ID .)
    ID              reduce using rule 17 (variable_usage -> ID .)
    VOID            reduce using rule 17 (variable_usage -> ID .)
    LIST            reduce using rule 17 (variable_usage -> ID .)
    DYNAMIC         reduce using rule 17 (variable_usage -> ID .)
    INT             reduce using rule 17 (variable_usage -> ID .)
    DOUBLE          reduce using rule 17 (variable_usage -> ID .)
    BOOL            reduce using rule 17 (variable_usage -> ID .)
    IF              reduce using rule 17 (variable_usage -> ID .)
    FOR             reduce using rule 17 (variable_usage -> ID .)
    $end            reduce using rule 17 (variable_usage -> ID .)
    RBRACKET        reduce using rule 17 (variable_usage -> ID .)


state 18

    (91) set -> VAR . ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (92) set -> VAR . ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (34) variable_definition -> VAR . ID ASSIGN expression SEMICOLON

    ID              shift and go to state 40


state 19

    (93) set -> FINAL . ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON

    ID              shift and go to state 41


state 20

    (15) control_structures -> control_structures_if_else .

    SEMICOLON       reduce using rule 15 (control_structures -> control_structures_if_else .)
    PRINT           reduce using rule 15 (control_structures -> control_structures_if_else .)
    STRING          reduce using rule 15 (control_structures -> control_structures_if_else .)
    VAR             reduce using rule 15 (control_structures -> control_structures_if_else .)
    FINAL           reduce using rule 15 (control_structures -> control_structures_if_else .)
    ID              reduce using rule 15 (control_structures -> control_structures_if_else .)
    VOID            reduce using rule 15 (control_structures -> control_structures_if_else .)
    LIST            reduce using rule 15 (control_structures -> control_structures_if_else .)
    DYNAMIC         reduce using rule 15 (control_structures -> control_structures_if_else .)
    INT             reduce using rule 15 (control_structures -> control_structures_if_else .)
    DOUBLE          reduce using rule 15 (control_structures -> control_structures_if_else .)
    BOOL            reduce using rule 15 (control_structures -> control_structures_if_else .)
    IF              reduce using rule 15 (control_structures -> control_structures_if_else .)
    FOR             reduce using rule 15 (control_structures -> control_structures_if_else .)
    $end            reduce using rule 15 (control_structures -> control_structures_if_else .)
    RBRACKET        reduce using rule 15 (control_structures -> control_structures_if_else .)


state 21

    (16) control_structures -> control_structures_for .

    SEMICOLON       reduce using rule 16 (control_structures -> control_structures_for .)
    PRINT           reduce using rule 16 (control_structures -> control_structures_for .)
    STRING          reduce using rule 16 (control_structures -> control_structures_for .)
    VAR             reduce using rule 16 (control_structures -> control_structures_for .)
    FINAL           reduce using rule 16 (control_structures -> control_structures_for .)
    ID              reduce using rule 16 (control_structures -> control_structures_for .)
    VOID            reduce using rule 16 (control_structures -> control_structures_for .)
    LIST            reduce using rule 16 (control_structures -> control_structures_for .)
    DYNAMIC         reduce using rule 16 (control_structures -> control_structures_for .)
    INT             reduce using rule 16 (control_structures -> control_structures_for .)
    DOUBLE          reduce using rule 16 (control_structures -> control_structures_for .)
    BOOL            reduce using rule 16 (control_structures -> control_structures_for .)
    IF              reduce using rule 16 (control_structures -> control_structures_for .)
    FOR             reduce using rule 16 (control_structures -> control_structures_for .)
    $end            reduce using rule 16 (control_structures -> control_structures_for .)
    RBRACKET        reduce using rule 16 (control_structures -> control_structures_for .)


state 22

    (26) function -> type . ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (28) function -> type . ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) variable_definition -> type . ID ASSIGN expression SEMICOLON

    ID              shift and go to state 42


state 23

    (27) function -> VOID . ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> VOID . ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (30) function -> VOID . ID LPAREN RPAREN LBRACKET RBRACKET
    (31) function -> VOID . ID LPAREN parameter_list RPAREN LBRACKET RBRACKET

    ID              shift and go to state 43


state 24

    (79) list_definition -> LIST . LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (77) type -> LIST .

    LESS            shift and go to state 44
    ID              reduce using rule 77 (type -> LIST .)


state 25

    (33) variable_definition -> DYNAMIC . ID ASSIGN expression SEMICOLON

    ID              shift and go to state 45


state 26

    (35) variable_definition -> INT . ID ASSIGN length SEMICOLON
    (73) type -> INT .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 46

  ! ID              [ reduce using rule 73 (type -> INT .) ]


state 27

    (49) control_structures_if_else -> if_block .
    (50) control_structures_if_else -> if_block . else_if_blocks
    (51) control_structures_if_else -> if_block . else_if_blocks else_block
    (52) control_structures_if_else -> if_block . else_block
    (54) else_if_blocks -> . ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (55) else_if_blocks -> . else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (56) else_block -> . ELSE LBRACKET statement_list RBRACKET

    SEMICOLON       reduce using rule 49 (control_structures_if_else -> if_block .)
    PRINT           reduce using rule 49 (control_structures_if_else -> if_block .)
    STRING          reduce using rule 49 (control_structures_if_else -> if_block .)
    VAR             reduce using rule 49 (control_structures_if_else -> if_block .)
    FINAL           reduce using rule 49 (control_structures_if_else -> if_block .)
    ID              reduce using rule 49 (control_structures_if_else -> if_block .)
    VOID            reduce using rule 49 (control_structures_if_else -> if_block .)
    LIST            reduce using rule 49 (control_structures_if_else -> if_block .)
    DYNAMIC         reduce using rule 49 (control_structures_if_else -> if_block .)
    INT             reduce using rule 49 (control_structures_if_else -> if_block .)
    DOUBLE          reduce using rule 49 (control_structures_if_else -> if_block .)
    BOOL            reduce using rule 49 (control_structures_if_else -> if_block .)
    IF              reduce using rule 49 (control_structures_if_else -> if_block .)
    FOR             reduce using rule 49 (control_structures_if_else -> if_block .)
    $end            reduce using rule 49 (control_structures_if_else -> if_block .)
    RBRACKET        reduce using rule 49 (control_structures_if_else -> if_block .)
    ELSE            shift and go to state 49

    else_if_blocks                 shift and go to state 47
    else_block                     shift and go to state 48

state 28

    (109) control_structures_for -> for_classic .

    SEMICOLON       reduce using rule 109 (control_structures_for -> for_classic .)
    PRINT           reduce using rule 109 (control_structures_for -> for_classic .)
    STRING          reduce using rule 109 (control_structures_for -> for_classic .)
    VAR             reduce using rule 109 (control_structures_for -> for_classic .)
    FINAL           reduce using rule 109 (control_structures_for -> for_classic .)
    ID              reduce using rule 109 (control_structures_for -> for_classic .)
    VOID            reduce using rule 109 (control_structures_for -> for_classic .)
    LIST            reduce using rule 109 (control_structures_for -> for_classic .)
    DYNAMIC         reduce using rule 109 (control_structures_for -> for_classic .)
    INT             reduce using rule 109 (control_structures_for -> for_classic .)
    DOUBLE          reduce using rule 109 (control_structures_for -> for_classic .)
    BOOL            reduce using rule 109 (control_structures_for -> for_classic .)
    IF              reduce using rule 109 (control_structures_for -> for_classic .)
    FOR             reduce using rule 109 (control_structures_for -> for_classic .)
    $end            reduce using rule 109 (control_structures_for -> for_classic .)
    RBRACKET        reduce using rule 109 (control_structures_for -> for_classic .)


state 29

    (110) control_structures_for -> for_in .

    SEMICOLON       reduce using rule 110 (control_structures_for -> for_in .)
    PRINT           reduce using rule 110 (control_structures_for -> for_in .)
    STRING          reduce using rule 110 (control_structures_for -> for_in .)
    VAR             reduce using rule 110 (control_structures_for -> for_in .)
    FINAL           reduce using rule 110 (control_structures_for -> for_in .)
    ID              reduce using rule 110 (control_structures_for -> for_in .)
    VOID            reduce using rule 110 (control_structures_for -> for_in .)
    LIST            reduce using rule 110 (control_structures_for -> for_in .)
    DYNAMIC         reduce using rule 110 (control_structures_for -> for_in .)
    INT             reduce using rule 110 (control_structures_for -> for_in .)
    DOUBLE          reduce using rule 110 (control_structures_for -> for_in .)
    BOOL            reduce using rule 110 (control_structures_for -> for_in .)
    IF              reduce using rule 110 (control_structures_for -> for_in .)
    FOR             reduce using rule 110 (control_structures_for -> for_in .)
    $end            reduce using rule 110 (control_structures_for -> for_in .)
    RBRACKET        reduce using rule 110 (control_structures_for -> for_in .)


state 30

    (111) control_structures_for -> for_each .

    SEMICOLON       reduce using rule 111 (control_structures_for -> for_each .)
    PRINT           reduce using rule 111 (control_structures_for -> for_each .)
    STRING          reduce using rule 111 (control_structures_for -> for_each .)
    VAR             reduce using rule 111 (control_structures_for -> for_each .)
    FINAL           reduce using rule 111 (control_structures_for -> for_each .)
    ID              reduce using rule 111 (control_structures_for -> for_each .)
    VOID            reduce using rule 111 (control_structures_for -> for_each .)
    LIST            reduce using rule 111 (control_structures_for -> for_each .)
    DYNAMIC         reduce using rule 111 (control_structures_for -> for_each .)
    INT             reduce using rule 111 (control_structures_for -> for_each .)
    DOUBLE          reduce using rule 111 (control_structures_for -> for_each .)
    BOOL            reduce using rule 111 (control_structures_for -> for_each .)
    IF              reduce using rule 111 (control_structures_for -> for_each .)
    FOR             reduce using rule 111 (control_structures_for -> for_each .)
    $end            reduce using rule 111 (control_structures_for -> for_each .)
    RBRACKET        reduce using rule 111 (control_structures_for -> for_each .)


state 31

    (74) type -> DOUBLE .

    ID              reduce using rule 74 (type -> DOUBLE .)
    GREATER         reduce using rule 74 (type -> DOUBLE .)


state 32

    (76) type -> BOOL .

    ID              reduce using rule 76 (type -> BOOL .)
    GREATER         reduce using rule 76 (type -> BOOL .)


state 33

    (53) if_block -> IF . LPAREN conditions RPAREN LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 50


state 34

    (102) for_classic -> FOR . LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (104) for_in -> FOR . LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_each -> FOR . LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 51


state 35

    (3) statement_list -> statement_list statement .

    SEMICOLON       reduce using rule 3 (statement_list -> statement_list statement .)
    PRINT           reduce using rule 3 (statement_list -> statement_list statement .)
    STRING          reduce using rule 3 (statement_list -> statement_list statement .)
    VAR             reduce using rule 3 (statement_list -> statement_list statement .)
    FINAL           reduce using rule 3 (statement_list -> statement_list statement .)
    ID              reduce using rule 3 (statement_list -> statement_list statement .)
    VOID            reduce using rule 3 (statement_list -> statement_list statement .)
    LIST            reduce using rule 3 (statement_list -> statement_list statement .)
    DYNAMIC         reduce using rule 3 (statement_list -> statement_list statement .)
    INT             reduce using rule 3 (statement_list -> statement_list statement .)
    DOUBLE          reduce using rule 3 (statement_list -> statement_list statement .)
    BOOL            reduce using rule 3 (statement_list -> statement_list statement .)
    IF              reduce using rule 3 (statement_list -> statement_list statement .)
    FOR             reduce using rule 3 (statement_list -> statement_list statement .)
    $end            reduce using rule 3 (statement_list -> statement_list statement .)
    RBRACKET        reduce using rule 3 (statement_list -> statement_list statement .)


state 36

    (36) print -> PRINT LPAREN . RPAREN SEMICOLON
    (37) print -> PRINT LPAREN . value RPAREN SEMICOLON
    (38) print -> PRINT LPAREN . expression RPAREN SEMICOLON
    (39) print -> PRINT LPAREN . length RPAREN SEMICOLON
    (82) value -> . NUMBER
    (83) value -> . NDOUBLE
    (84) value -> . TEXT
    (85) value -> . ID
    (86) value -> . interpolated_string
    (87) value -> . TRUE
    (88) value -> . FALSE
    (40) expression -> . expression PLUS expression
    (41) expression -> . expression MINUS expression
    (42) expression -> . expression TIMES expression
    (43) expression -> . expression DIVIDE expression
    (44) expression -> . expression AND expression
    (45) expression -> . expression OR expression
    (46) expression -> . value comparator value
    (47) expression -> . value PLUS value
    (48) expression -> . value
    (22) length -> . call_list DOT LENGTH
    (23) length -> . TEXT DOT LENGTH
    (89) interpolated_string -> . TEXT PLUS ID
    (90) interpolated_string -> . TEXT PLUS expression
    (78) call_list -> . LSBRACKET value_list RSBRACKET

    RPAREN          shift and go to state 52
    NUMBER          shift and go to state 56
    NDOUBLE         shift and go to state 57
    TEXT            shift and go to state 58
    ID              shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62
    LSBRACKET       shift and go to state 64

    value                          shift and go to state 53
    expression                     shift and go to state 54
    length                         shift and go to state 55
    interpolated_string            shift and go to state 60
    call_list                      shift and go to state 63

state 37

    (20) data_input -> STRING ID . ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    ASSIGN          shift and go to state 65


state 38

    (21) data_input -> STRING QUESTION . ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    ID              shift and go to state 66


state 39

    (114) constructor -> ID LPAREN . constructor_parenthesis_content RPAREN SEMICOLON
    (18) call_function -> ID LPAREN . argument_list RPAREN
    (19) call_function -> ID LPAREN . RPAREN
    (112) constructor_parenthesis_content -> . THIS DOT ID
    (113) constructor_parenthesis_content -> . THIS DOT ID COMMA constructor_parenthesis_content
    (24) argument_list -> . expression
    (25) argument_list -> . argument_list COMMA expression
    (40) expression -> . expression PLUS expression
    (41) expression -> . expression MINUS expression
    (42) expression -> . expression TIMES expression
    (43) expression -> . expression DIVIDE expression
    (44) expression -> . expression AND expression
    (45) expression -> . expression OR expression
    (46) expression -> . value comparator value
    (47) expression -> . value PLUS value
    (48) expression -> . value
    (82) value -> . NUMBER
    (83) value -> . NDOUBLE
    (84) value -> . TEXT
    (85) value -> . ID
    (86) value -> . interpolated_string
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) interpolated_string -> . TEXT PLUS ID
    (90) interpolated_string -> . TEXT PLUS expression

    RPAREN          shift and go to state 68
    THIS            shift and go to state 70
    NUMBER          shift and go to state 56
    NDOUBLE         shift and go to state 57
    TEXT            shift and go to state 73
    ID              shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62

    constructor_parenthesis_content shift and go to state 67
    argument_list                  shift and go to state 69
    expression                     shift and go to state 71
    value                          shift and go to state 72
    interpolated_string            shift and go to state 60

state 40

    (91) set -> VAR ID . ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (92) set -> VAR ID . ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (34) variable_definition -> VAR ID . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 74


state 41

    (93) set -> FINAL ID . ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON

    ASSIGN          shift and go to state 75


state 42

    (26) function -> type ID . LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (28) function -> type ID . LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) variable_definition -> type ID . ASSIGN expression SEMICOLON

    LPAREN          shift and go to state 76
    ASSIGN          shift and go to state 77


state 43

    (27) function -> VOID ID . LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> VOID ID . LPAREN RPAREN LBRACKET statement_list RBRACKET
    (30) function -> VOID ID . LPAREN RPAREN LBRACKET RBRACKET
    (31) function -> VOID ID . LPAREN parameter_list RPAREN LBRACKET RBRACKET

    LPAREN          shift and go to state 78


state 44

    (79) list_definition -> LIST LESS . type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (73) type -> . INT
    (74) type -> . DOUBLE
    (75) type -> . STRING
    (76) type -> . BOOL
    (77) type -> . LIST

    INT             shift and go to state 81
    DOUBLE          shift and go to state 31
    STRING          shift and go to state 82
    BOOL            shift and go to state 32
    LIST            shift and go to state 79

    type                           shift and go to state 80

state 45

    (33) variable_definition -> DYNAMIC ID . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 83


state 46

    (35) variable_definition -> INT ID . ASSIGN length SEMICOLON

    ASSIGN          shift and go to state 84


state 47

    (50) control_structures_if_else -> if_block else_if_blocks .
    (51) control_structures_if_else -> if_block else_if_blocks . else_block
    (55) else_if_blocks -> else_if_blocks . ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (56) else_block -> . ELSE LBRACKET statement_list RBRACKET

    SEMICOLON       reduce using rule 50 (control_structures_if_else -> if_block else_if_blocks .)
    PRINT           reduce using rule 50 (control_structures_if_else -> if_block else_if_blocks .)
    STRING          reduce using rule 50 (control_structures_if_else -> if_block else_if_blocks .)
    VAR             reduce using rule 50 (control_structures_if_else -> if_block else_if_blocks .)
    FINAL           reduce using rule 50 (control_structures_if_else -> if_block else_if_blocks .)
    ID              reduce using rule 50 (control_structures_if_else -> if_block else_if_blocks .)
    VOID            reduce using rule 50 (control_structures_if_else -> if_block else_if_blocks .)
    LIST            reduce using rule 50 (control_structures_if_else -> if_block else_if_blocks .)
    DYNAMIC         reduce using rule 50 (control_structures_if_else -> if_block else_if_blocks .)
    INT             reduce using rule 50 (control_structures_if_else -> if_block else_if_blocks .)
    DOUBLE          reduce using rule 50 (control_structures_if_else -> if_block else_if_blocks .)
    BOOL            reduce using rule 50 (control_structures_if_else -> if_block else_if_blocks .)
    IF              reduce using rule 50 (control_structures_if_else -> if_block else_if_blocks .)
    FOR             reduce using rule 50 (control_structures_if_else -> if_block else_if_blocks .)
    $end            reduce using rule 50 (control_structures_if_else -> if_block else_if_blocks .)
    RBRACKET        reduce using rule 50 (control_structures_if_else -> if_block else_if_blocks .)
    ELSE            shift and go to state 86

    else_block                     shift and go to state 85

state 48

    (52) control_structures_if_else -> if_block else_block .

    SEMICOLON       reduce using rule 52 (control_structures_if_else -> if_block else_block .)
    PRINT           reduce using rule 52 (control_structures_if_else -> if_block else_block .)
    STRING          reduce using rule 52 (control_structures_if_else -> if_block else_block .)
    VAR             reduce using rule 52 (control_structures_if_else -> if_block else_block .)
    FINAL           reduce using rule 52 (control_structures_if_else -> if_block else_block .)
    ID              reduce using rule 52 (control_structures_if_else -> if_block else_block .)
    VOID            reduce using rule 52 (control_structures_if_else -> if_block else_block .)
    LIST            reduce using rule 52 (control_structures_if_else -> if_block else_block .)
    DYNAMIC         reduce using rule 52 (control_structures_if_else -> if_block else_block .)
    INT             reduce using rule 52 (control_structures_if_else -> if_block else_block .)
    DOUBLE          reduce using rule 52 (control_structures_if_else -> if_block else_block .)
    BOOL            reduce using rule 52 (control_structures_if_else -> if_block else_block .)
    IF              reduce using rule 52 (control_structures_if_else -> if_block else_block .)
    FOR             reduce using rule 52 (control_structures_if_else -> if_block else_block .)
    $end            reduce using rule 52 (control_structures_if_else -> if_block else_block .)
    RBRACKET        reduce using rule 52 (control_structures_if_else -> if_block else_block .)


state 49

    (54) else_if_blocks -> ELSE . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (56) else_block -> ELSE . LBRACKET statement_list RBRACKET

    IF              shift and go to state 87
    LBRACKET        shift and go to state 88


state 50

    (53) if_block -> IF LPAREN . conditions RPAREN LBRACKET statement_list RBRACKET
    (57) conditions -> . condition
    (58) conditions -> . conditions AND conditions
    (59) conditions -> . conditions OR conditions
    (60) condition -> . value comparator value
    (61) condition -> . NOT condition
    (62) condition -> . LPAREN conditions RPAREN
    (82) value -> . NUMBER
    (83) value -> . NDOUBLE
    (84) value -> . TEXT
    (85) value -> . ID
    (86) value -> . interpolated_string
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) interpolated_string -> . TEXT PLUS ID
    (90) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 93
    LPAREN          shift and go to state 89
    NUMBER          shift and go to state 56
    NDOUBLE         shift and go to state 57
    TEXT            shift and go to state 73
    ID              shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62

    conditions                     shift and go to state 90
    condition                      shift and go to state 91
    value                          shift and go to state 92
    interpolated_string            shift and go to state 60

state 51

    (102) for_classic -> FOR LPAREN . for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (104) for_in -> FOR LPAREN . for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_each -> FOR LPAREN . for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (101) for_classic_parenthesis_content -> . for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON for_classic_changes
    (103) for_in_parenthesis_content -> . FINAL ID IN ID
    (107) for_each_parenthesis_content -> . FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID
    (94) for_classic_initialization -> . INT ID ASSIGN NUMBER
    (95) for_classic_initialization -> . DOUBLE ID ASSIGN NDOUBLE

    FINAL           shift and go to state 98
    INT             shift and go to state 99
    DOUBLE          shift and go to state 100

    for_classic_parenthesis_content shift and go to state 94
    for_in_parenthesis_content     shift and go to state 95
    for_each_parenthesis_content   shift and go to state 96
    for_classic_initialization     shift and go to state 97

state 52

    (36) print -> PRINT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 101


state 53

    (37) print -> PRINT LPAREN value . RPAREN SEMICOLON
    (46) expression -> value . comparator value
    (47) expression -> value . PLUS value
    (48) expression -> value .
    (63) comparator -> . GREATER
    (64) comparator -> . LESS
    (65) comparator -> . EQUALS
    (66) comparator -> . GREATER_EQUAL
    (67) comparator -> . LESS_EQUAL
    (68) comparator -> . NOT_EQUALS

  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
    RPAREN          shift and go to state 102
    PLUS            shift and go to state 104
    MINUS           reduce using rule 48 (expression -> value .)
    TIMES           reduce using rule 48 (expression -> value .)
    DIVIDE          reduce using rule 48 (expression -> value .)
    AND             reduce using rule 48 (expression -> value .)
    OR              reduce using rule 48 (expression -> value .)
    GREATER         shift and go to state 105
    LESS            shift and go to state 106
    EQUALS          shift and go to state 107
    GREATER_EQUAL   shift and go to state 108
    LESS_EQUAL      shift and go to state 109
    NOT_EQUALS      shift and go to state 110

  ! RPAREN          [ reduce using rule 48 (expression -> value .) ]
  ! PLUS            [ reduce using rule 48 (expression -> value .) ]

    comparator                     shift and go to state 103

state 54

    (38) print -> PRINT LPAREN expression . RPAREN SEMICOLON
    (40) expression -> expression . PLUS expression
    (41) expression -> expression . MINUS expression
    (42) expression -> expression . TIMES expression
    (43) expression -> expression . DIVIDE expression
    (44) expression -> expression . AND expression
    (45) expression -> expression . OR expression

    RPAREN          shift and go to state 111
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    TIMES           shift and go to state 114
    DIVIDE          shift and go to state 115
    AND             shift and go to state 116
    OR              shift and go to state 117


state 55

    (39) print -> PRINT LPAREN length . RPAREN SEMICOLON

    RPAREN          shift and go to state 118


state 56

    (82) value -> NUMBER .

    RPAREN          reduce using rule 82 (value -> NUMBER .)
    PLUS            reduce using rule 82 (value -> NUMBER .)
    GREATER         reduce using rule 82 (value -> NUMBER .)
    LESS            reduce using rule 82 (value -> NUMBER .)
    EQUALS          reduce using rule 82 (value -> NUMBER .)
    GREATER_EQUAL   reduce using rule 82 (value -> NUMBER .)
    LESS_EQUAL      reduce using rule 82 (value -> NUMBER .)
    NOT_EQUALS      reduce using rule 82 (value -> NUMBER .)
    MINUS           reduce using rule 82 (value -> NUMBER .)
    TIMES           reduce using rule 82 (value -> NUMBER .)
    DIVIDE          reduce using rule 82 (value -> NUMBER .)
    AND             reduce using rule 82 (value -> NUMBER .)
    OR              reduce using rule 82 (value -> NUMBER .)
    COMMA           reduce using rule 82 (value -> NUMBER .)
    RSBRACKET       reduce using rule 82 (value -> NUMBER .)
    SEMICOLON       reduce using rule 82 (value -> NUMBER .)
    RBRACKET        reduce using rule 82 (value -> NUMBER .)


state 57

    (83) value -> NDOUBLE .

    RPAREN          reduce using rule 83 (value -> NDOUBLE .)
    PLUS            reduce using rule 83 (value -> NDOUBLE .)
    GREATER         reduce using rule 83 (value -> NDOUBLE .)
    LESS            reduce using rule 83 (value -> NDOUBLE .)
    EQUALS          reduce using rule 83 (value -> NDOUBLE .)
    GREATER_EQUAL   reduce using rule 83 (value -> NDOUBLE .)
    LESS_EQUAL      reduce using rule 83 (value -> NDOUBLE .)
    NOT_EQUALS      reduce using rule 83 (value -> NDOUBLE .)
    MINUS           reduce using rule 83 (value -> NDOUBLE .)
    TIMES           reduce using rule 83 (value -> NDOUBLE .)
    DIVIDE          reduce using rule 83 (value -> NDOUBLE .)
    AND             reduce using rule 83 (value -> NDOUBLE .)
    OR              reduce using rule 83 (value -> NDOUBLE .)
    COMMA           reduce using rule 83 (value -> NDOUBLE .)
    RSBRACKET       reduce using rule 83 (value -> NDOUBLE .)
    SEMICOLON       reduce using rule 83 (value -> NDOUBLE .)
    RBRACKET        reduce using rule 83 (value -> NDOUBLE .)


state 58

    (84) value -> TEXT .
    (23) length -> TEXT . DOT LENGTH
    (89) interpolated_string -> TEXT . PLUS ID
    (90) interpolated_string -> TEXT . PLUS expression

  ! shift/reduce conflict for PLUS resolved as shift
    RPAREN          reduce using rule 84 (value -> TEXT .)
    GREATER         reduce using rule 84 (value -> TEXT .)
    LESS            reduce using rule 84 (value -> TEXT .)
    EQUALS          reduce using rule 84 (value -> TEXT .)
    GREATER_EQUAL   reduce using rule 84 (value -> TEXT .)
    LESS_EQUAL      reduce using rule 84 (value -> TEXT .)
    NOT_EQUALS      reduce using rule 84 (value -> TEXT .)
    MINUS           reduce using rule 84 (value -> TEXT .)
    TIMES           reduce using rule 84 (value -> TEXT .)
    DIVIDE          reduce using rule 84 (value -> TEXT .)
    AND             reduce using rule 84 (value -> TEXT .)
    OR              reduce using rule 84 (value -> TEXT .)
    DOT             shift and go to state 119
    PLUS            shift and go to state 120

  ! PLUS            [ reduce using rule 84 (value -> TEXT .) ]


state 59

    (85) value -> ID .

    RPAREN          reduce using rule 85 (value -> ID .)
    PLUS            reduce using rule 85 (value -> ID .)
    GREATER         reduce using rule 85 (value -> ID .)
    LESS            reduce using rule 85 (value -> ID .)
    EQUALS          reduce using rule 85 (value -> ID .)
    GREATER_EQUAL   reduce using rule 85 (value -> ID .)
    LESS_EQUAL      reduce using rule 85 (value -> ID .)
    NOT_EQUALS      reduce using rule 85 (value -> ID .)
    MINUS           reduce using rule 85 (value -> ID .)
    TIMES           reduce using rule 85 (value -> ID .)
    DIVIDE          reduce using rule 85 (value -> ID .)
    AND             reduce using rule 85 (value -> ID .)
    OR              reduce using rule 85 (value -> ID .)
    COMMA           reduce using rule 85 (value -> ID .)
    RSBRACKET       reduce using rule 85 (value -> ID .)
    SEMICOLON       reduce using rule 85 (value -> ID .)
    RBRACKET        reduce using rule 85 (value -> ID .)


state 60

    (86) value -> interpolated_string .

    RPAREN          reduce using rule 86 (value -> interpolated_string .)
    PLUS            reduce using rule 86 (value -> interpolated_string .)
    GREATER         reduce using rule 86 (value -> interpolated_string .)
    LESS            reduce using rule 86 (value -> interpolated_string .)
    EQUALS          reduce using rule 86 (value -> interpolated_string .)
    GREATER_EQUAL   reduce using rule 86 (value -> interpolated_string .)
    LESS_EQUAL      reduce using rule 86 (value -> interpolated_string .)
    NOT_EQUALS      reduce using rule 86 (value -> interpolated_string .)
    MINUS           reduce using rule 86 (value -> interpolated_string .)
    TIMES           reduce using rule 86 (value -> interpolated_string .)
    DIVIDE          reduce using rule 86 (value -> interpolated_string .)
    AND             reduce using rule 86 (value -> interpolated_string .)
    OR              reduce using rule 86 (value -> interpolated_string .)
    COMMA           reduce using rule 86 (value -> interpolated_string .)
    RSBRACKET       reduce using rule 86 (value -> interpolated_string .)
    SEMICOLON       reduce using rule 86 (value -> interpolated_string .)
    RBRACKET        reduce using rule 86 (value -> interpolated_string .)


state 61

    (87) value -> TRUE .

    RPAREN          reduce using rule 87 (value -> TRUE .)
    PLUS            reduce using rule 87 (value -> TRUE .)
    GREATER         reduce using rule 87 (value -> TRUE .)
    LESS            reduce using rule 87 (value -> TRUE .)
    EQUALS          reduce using rule 87 (value -> TRUE .)
    GREATER_EQUAL   reduce using rule 87 (value -> TRUE .)
    LESS_EQUAL      reduce using rule 87 (value -> TRUE .)
    NOT_EQUALS      reduce using rule 87 (value -> TRUE .)
    MINUS           reduce using rule 87 (value -> TRUE .)
    TIMES           reduce using rule 87 (value -> TRUE .)
    DIVIDE          reduce using rule 87 (value -> TRUE .)
    AND             reduce using rule 87 (value -> TRUE .)
    OR              reduce using rule 87 (value -> TRUE .)
    COMMA           reduce using rule 87 (value -> TRUE .)
    RSBRACKET       reduce using rule 87 (value -> TRUE .)
    SEMICOLON       reduce using rule 87 (value -> TRUE .)
    RBRACKET        reduce using rule 87 (value -> TRUE .)


state 62

    (88) value -> FALSE .

    RPAREN          reduce using rule 88 (value -> FALSE .)
    PLUS            reduce using rule 88 (value -> FALSE .)
    GREATER         reduce using rule 88 (value -> FALSE .)
    LESS            reduce using rule 88 (value -> FALSE .)
    EQUALS          reduce using rule 88 (value -> FALSE .)
    GREATER_EQUAL   reduce using rule 88 (value -> FALSE .)
    LESS_EQUAL      reduce using rule 88 (value -> FALSE .)
    NOT_EQUALS      reduce using rule 88 (value -> FALSE .)
    MINUS           reduce using rule 88 (value -> FALSE .)
    TIMES           reduce using rule 88 (value -> FALSE .)
    DIVIDE          reduce using rule 88 (value -> FALSE .)
    AND             reduce using rule 88 (value -> FALSE .)
    OR              reduce using rule 88 (value -> FALSE .)
    COMMA           reduce using rule 88 (value -> FALSE .)
    RSBRACKET       reduce using rule 88 (value -> FALSE .)
    SEMICOLON       reduce using rule 88 (value -> FALSE .)
    RBRACKET        reduce using rule 88 (value -> FALSE .)


state 63

    (22) length -> call_list . DOT LENGTH

    DOT             shift and go to state 121


state 64

    (78) call_list -> LSBRACKET . value_list RSBRACKET
    (80) value_list -> . value
    (81) value_list -> . value_list COMMA value
    (82) value -> . NUMBER
    (83) value -> . NDOUBLE
    (84) value -> . TEXT
    (85) value -> . ID
    (86) value -> . interpolated_string
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) interpolated_string -> . TEXT PLUS ID
    (90) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 56
    NDOUBLE         shift and go to state 57
    TEXT            shift and go to state 73
    ID              shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62

    value_list                     shift and go to state 122
    value                          shift and go to state 123
    interpolated_string            shift and go to state 60

state 65

    (20) data_input -> STRING ID ASSIGN . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    STDIN           shift and go to state 124


state 66

    (21) data_input -> STRING QUESTION ID . ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    ASSIGN          shift and go to state 125


state 67

    (114) constructor -> ID LPAREN constructor_parenthesis_content . RPAREN SEMICOLON

    RPAREN          shift and go to state 126


state 68

    (19) call_function -> ID LPAREN RPAREN .

    SEMICOLON       reduce using rule 19 (call_function -> ID LPAREN RPAREN .)
    PRINT           reduce using rule 19 (call_function -> ID LPAREN RPAREN .)
    STRING          reduce using rule 19 (call_function -> ID LPAREN RPAREN .)
    VAR             reduce using rule 19 (call_function -> ID LPAREN RPAREN .)
    FINAL           reduce using rule 19 (call_function -> ID LPAREN RPAREN .)
    ID              reduce using rule 19 (call_function -> ID LPAREN RPAREN .)
    VOID            reduce using rule 19 (call_function -> ID LPAREN RPAREN .)
    LIST            reduce using rule 19 (call_function -> ID LPAREN RPAREN .)
    DYNAMIC         reduce using rule 19 (call_function -> ID LPAREN RPAREN .)
    INT             reduce using rule 19 (call_function -> ID LPAREN RPAREN .)
    DOUBLE          reduce using rule 19 (call_function -> ID LPAREN RPAREN .)
    BOOL            reduce using rule 19 (call_function -> ID LPAREN RPAREN .)
    IF              reduce using rule 19 (call_function -> ID LPAREN RPAREN .)
    FOR             reduce using rule 19 (call_function -> ID LPAREN RPAREN .)
    $end            reduce using rule 19 (call_function -> ID LPAREN RPAREN .)
    RBRACKET        reduce using rule 19 (call_function -> ID LPAREN RPAREN .)


state 69

    (18) call_function -> ID LPAREN argument_list . RPAREN
    (25) argument_list -> argument_list . COMMA expression

    RPAREN          shift and go to state 127
    COMMA           shift and go to state 128


state 70

    (112) constructor_parenthesis_content -> THIS . DOT ID
    (113) constructor_parenthesis_content -> THIS . DOT ID COMMA constructor_parenthesis_content

    DOT             shift and go to state 129


state 71

    (24) argument_list -> expression .
    (40) expression -> expression . PLUS expression
    (41) expression -> expression . MINUS expression
    (42) expression -> expression . TIMES expression
    (43) expression -> expression . DIVIDE expression
    (44) expression -> expression . AND expression
    (45) expression -> expression . OR expression

    RPAREN          reduce using rule 24 (argument_list -> expression .)
    COMMA           reduce using rule 24 (argument_list -> expression .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    TIMES           shift and go to state 114
    DIVIDE          shift and go to state 115
    AND             shift and go to state 116
    OR              shift and go to state 117


state 72

    (46) expression -> value . comparator value
    (47) expression -> value . PLUS value
    (48) expression -> value .
    (63) comparator -> . GREATER
    (64) comparator -> . LESS
    (65) comparator -> . EQUALS
    (66) comparator -> . GREATER_EQUAL
    (67) comparator -> . LESS_EQUAL
    (68) comparator -> . NOT_EQUALS

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUALS resolved as shift
    PLUS            shift and go to state 104
    MINUS           reduce using rule 48 (expression -> value .)
    TIMES           reduce using rule 48 (expression -> value .)
    DIVIDE          reduce using rule 48 (expression -> value .)
    AND             reduce using rule 48 (expression -> value .)
    OR              reduce using rule 48 (expression -> value .)
    RPAREN          reduce using rule 48 (expression -> value .)
    COMMA           reduce using rule 48 (expression -> value .)
    SEMICOLON       reduce using rule 48 (expression -> value .)
    RSBRACKET       reduce using rule 48 (expression -> value .)
    RBRACKET        reduce using rule 48 (expression -> value .)
    GREATER         shift and go to state 105
    LESS            shift and go to state 106
    EQUALS          shift and go to state 107
    GREATER_EQUAL   shift and go to state 108
    LESS_EQUAL      shift and go to state 109
    NOT_EQUALS      shift and go to state 110

  ! PLUS            [ reduce using rule 48 (expression -> value .) ]
  ! GREATER         [ reduce using rule 48 (expression -> value .) ]
  ! LESS            [ reduce using rule 48 (expression -> value .) ]
  ! EQUALS          [ reduce using rule 48 (expression -> value .) ]
  ! GREATER_EQUAL   [ reduce using rule 48 (expression -> value .) ]
  ! LESS_EQUAL      [ reduce using rule 48 (expression -> value .) ]
  ! NOT_EQUALS      [ reduce using rule 48 (expression -> value .) ]

    comparator                     shift and go to state 103

state 73

    (84) value -> TEXT .
    (89) interpolated_string -> TEXT . PLUS ID
    (90) interpolated_string -> TEXT . PLUS expression

  ! shift/reduce conflict for PLUS resolved as shift
    GREATER         reduce using rule 84 (value -> TEXT .)
    LESS            reduce using rule 84 (value -> TEXT .)
    EQUALS          reduce using rule 84 (value -> TEXT .)
    GREATER_EQUAL   reduce using rule 84 (value -> TEXT .)
    LESS_EQUAL      reduce using rule 84 (value -> TEXT .)
    NOT_EQUALS      reduce using rule 84 (value -> TEXT .)
    MINUS           reduce using rule 84 (value -> TEXT .)
    TIMES           reduce using rule 84 (value -> TEXT .)
    DIVIDE          reduce using rule 84 (value -> TEXT .)
    AND             reduce using rule 84 (value -> TEXT .)
    OR              reduce using rule 84 (value -> TEXT .)
    RPAREN          reduce using rule 84 (value -> TEXT .)
    COMMA           reduce using rule 84 (value -> TEXT .)
    RSBRACKET       reduce using rule 84 (value -> TEXT .)
    SEMICOLON       reduce using rule 84 (value -> TEXT .)
    RBRACKET        reduce using rule 84 (value -> TEXT .)
    PLUS            shift and go to state 120

  ! PLUS            [ reduce using rule 84 (value -> TEXT .) ]


state 74

    (91) set -> VAR ID ASSIGN . LBRACKET value_list RBRACKET SEMICOLON
    (92) set -> VAR ID ASSIGN . LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (34) variable_definition -> VAR ID ASSIGN . expression SEMICOLON
    (40) expression -> . expression PLUS expression
    (41) expression -> . expression MINUS expression
    (42) expression -> . expression TIMES expression
    (43) expression -> . expression DIVIDE expression
    (44) expression -> . expression AND expression
    (45) expression -> . expression OR expression
    (46) expression -> . value comparator value
    (47) expression -> . value PLUS value
    (48) expression -> . value
    (82) value -> . NUMBER
    (83) value -> . NDOUBLE
    (84) value -> . TEXT
    (85) value -> . ID
    (86) value -> . interpolated_string
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) interpolated_string -> . TEXT PLUS ID
    (90) interpolated_string -> . TEXT PLUS expression

    LBRACKET        shift and go to state 130
    LESS            shift and go to state 131
    NUMBER          shift and go to state 56
    NDOUBLE         shift and go to state 57
    TEXT            shift and go to state 73
    ID              shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62

    expression                     shift and go to state 132
    value                          shift and go to state 72
    interpolated_string            shift and go to state 60

state 75

    (93) set -> FINAL ID ASSIGN . CONST LBRACKET value_list RBRACKET SEMICOLON

    CONST           shift and go to state 133


state 76

    (26) function -> type ID LPAREN . parameter_list RPAREN LBRACKET statement_list RBRACKET
    (28) function -> type ID LPAREN . RPAREN LBRACKET statement_list RBRACKET
    (69) parameter_list -> . parameter
    (70) parameter_list -> . parameter_list COMMA parameter
    (71) parameter -> . type ID
    (72) parameter -> . REQUIRED type ID
    (73) type -> . INT
    (74) type -> . DOUBLE
    (75) type -> . STRING
    (76) type -> . BOOL
    (77) type -> . LIST

    RPAREN          shift and go to state 136
    REQUIRED        shift and go to state 138
    INT             shift and go to state 81
    DOUBLE          shift and go to state 31
    STRING          shift and go to state 82
    BOOL            shift and go to state 32
    LIST            shift and go to state 79

    type                           shift and go to state 134
    parameter_list                 shift and go to state 135
    parameter                      shift and go to state 137

state 77

    (32) variable_definition -> type ID ASSIGN . expression SEMICOLON
    (40) expression -> . expression PLUS expression
    (41) expression -> . expression MINUS expression
    (42) expression -> . expression TIMES expression
    (43) expression -> . expression DIVIDE expression
    (44) expression -> . expression AND expression
    (45) expression -> . expression OR expression
    (46) expression -> . value comparator value
    (47) expression -> . value PLUS value
    (48) expression -> . value
    (82) value -> . NUMBER
    (83) value -> . NDOUBLE
    (84) value -> . TEXT
    (85) value -> . ID
    (86) value -> . interpolated_string
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) interpolated_string -> . TEXT PLUS ID
    (90) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 56
    NDOUBLE         shift and go to state 57
    TEXT            shift and go to state 73
    ID              shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62

    expression                     shift and go to state 139
    value                          shift and go to state 72
    interpolated_string            shift and go to state 60

state 78

    (27) function -> VOID ID LPAREN . parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> VOID ID LPAREN . RPAREN LBRACKET statement_list RBRACKET
    (30) function -> VOID ID LPAREN . RPAREN LBRACKET RBRACKET
    (31) function -> VOID ID LPAREN . parameter_list RPAREN LBRACKET RBRACKET
    (69) parameter_list -> . parameter
    (70) parameter_list -> . parameter_list COMMA parameter
    (71) parameter -> . type ID
    (72) parameter -> . REQUIRED type ID
    (73) type -> . INT
    (74) type -> . DOUBLE
    (75) type -> . STRING
    (76) type -> . BOOL
    (77) type -> . LIST

    RPAREN          shift and go to state 141
    REQUIRED        shift and go to state 138
    INT             shift and go to state 81
    DOUBLE          shift and go to state 31
    STRING          shift and go to state 82
    BOOL            shift and go to state 32
    LIST            shift and go to state 79

    parameter_list                 shift and go to state 140
    parameter                      shift and go to state 137
    type                           shift and go to state 134

state 79

    (77) type -> LIST .

    GREATER         reduce using rule 77 (type -> LIST .)
    ID              reduce using rule 77 (type -> LIST .)


state 80

    (79) list_definition -> LIST LESS type . GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON

    GREATER         shift and go to state 142


state 81

    (73) type -> INT .

    GREATER         reduce using rule 73 (type -> INT .)
    ID              reduce using rule 73 (type -> INT .)


state 82

    (75) type -> STRING .

    GREATER         reduce using rule 75 (type -> STRING .)
    ID              reduce using rule 75 (type -> STRING .)


state 83

    (33) variable_definition -> DYNAMIC ID ASSIGN . expression SEMICOLON
    (40) expression -> . expression PLUS expression
    (41) expression -> . expression MINUS expression
    (42) expression -> . expression TIMES expression
    (43) expression -> . expression DIVIDE expression
    (44) expression -> . expression AND expression
    (45) expression -> . expression OR expression
    (46) expression -> . value comparator value
    (47) expression -> . value PLUS value
    (48) expression -> . value
    (82) value -> . NUMBER
    (83) value -> . NDOUBLE
    (84) value -> . TEXT
    (85) value -> . ID
    (86) value -> . interpolated_string
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) interpolated_string -> . TEXT PLUS ID
    (90) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 56
    NDOUBLE         shift and go to state 57
    TEXT            shift and go to state 73
    ID              shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62

    expression                     shift and go to state 143
    value                          shift and go to state 72
    interpolated_string            shift and go to state 60

state 84

    (35) variable_definition -> INT ID ASSIGN . length SEMICOLON
    (22) length -> . call_list DOT LENGTH
    (23) length -> . TEXT DOT LENGTH
    (78) call_list -> . LSBRACKET value_list RSBRACKET

    TEXT            shift and go to state 145
    LSBRACKET       shift and go to state 64

    length                         shift and go to state 144
    call_list                      shift and go to state 63

state 85

    (51) control_structures_if_else -> if_block else_if_blocks else_block .

    SEMICOLON       reduce using rule 51 (control_structures_if_else -> if_block else_if_blocks else_block .)
    PRINT           reduce using rule 51 (control_structures_if_else -> if_block else_if_blocks else_block .)
    STRING          reduce using rule 51 (control_structures_if_else -> if_block else_if_blocks else_block .)
    VAR             reduce using rule 51 (control_structures_if_else -> if_block else_if_blocks else_block .)
    FINAL           reduce using rule 51 (control_structures_if_else -> if_block else_if_blocks else_block .)
    ID              reduce using rule 51 (control_structures_if_else -> if_block else_if_blocks else_block .)
    VOID            reduce using rule 51 (control_structures_if_else -> if_block else_if_blocks else_block .)
    LIST            reduce using rule 51 (control_structures_if_else -> if_block else_if_blocks else_block .)
    DYNAMIC         reduce using rule 51 (control_structures_if_else -> if_block else_if_blocks else_block .)
    INT             reduce using rule 51 (control_structures_if_else -> if_block else_if_blocks else_block .)
    DOUBLE          reduce using rule 51 (control_structures_if_else -> if_block else_if_blocks else_block .)
    BOOL            reduce using rule 51 (control_structures_if_else -> if_block else_if_blocks else_block .)
    IF              reduce using rule 51 (control_structures_if_else -> if_block else_if_blocks else_block .)
    FOR             reduce using rule 51 (control_structures_if_else -> if_block else_if_blocks else_block .)
    $end            reduce using rule 51 (control_structures_if_else -> if_block else_if_blocks else_block .)
    RBRACKET        reduce using rule 51 (control_structures_if_else -> if_block else_if_blocks else_block .)


state 86

    (55) else_if_blocks -> else_if_blocks ELSE . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (56) else_block -> ELSE . LBRACKET statement_list RBRACKET

    IF              shift and go to state 146
    LBRACKET        shift and go to state 88


state 87

    (54) else_if_blocks -> ELSE IF . LPAREN conditions RPAREN LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 147


state 88

    (56) else_block -> ELSE LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . constructor
    (8) statement -> . control_structures
    (9) statement -> . function
    (10) statement -> . list_definition
    (11) statement -> . variable_definition
    (12) statement -> . variable_usage
    (13) statement -> . call_function
    (14) statement -> . SEMICOLON
    (36) print -> . PRINT LPAREN RPAREN SEMICOLON
    (37) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (38) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (39) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (20) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (21) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (91) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (92) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (93) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (114) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (15) control_structures -> . control_structures_if_else
    (16) control_structures -> . control_structures_for
    (26) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (27) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (28) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (31) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (79) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (32) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (33) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (34) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (17) variable_usage -> . ID
    (18) call_function -> . ID LPAREN argument_list RPAREN
    (19) call_function -> . ID LPAREN RPAREN
    (49) control_structures_if_else -> . if_block
    (50) control_structures_if_else -> . if_block else_if_blocks
    (51) control_structures_if_else -> . if_block else_if_blocks else_block
    (52) control_structures_if_else -> . if_block else_block
    (109) control_structures_for -> . for_classic
    (110) control_structures_for -> . for_in
    (111) control_structures_for -> . for_each
    (73) type -> . INT
    (74) type -> . DOUBLE
    (75) type -> . STRING
    (76) type -> . BOOL
    (77) type -> . LIST
    (53) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (102) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (104) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 14
    PRINT           shift and go to state 15
    STRING          shift and go to state 16
    VAR             shift and go to state 18
    FINAL           shift and go to state 19
    ID              shift and go to state 17
    VOID            shift and go to state 23
    LIST            shift and go to state 24
    DYNAMIC         shift and go to state 25
    INT             shift and go to state 26
    DOUBLE          shift and go to state 31
    BOOL            shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34

    statement_list                 shift and go to state 148
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    constructor                    shift and go to state 7
    control_structures             shift and go to state 8
    function                       shift and go to state 9
    list_definition                shift and go to state 10
    variable_definition            shift and go to state 11
    variable_usage                 shift and go to state 12
    call_function                  shift and go to state 13
    control_structures_if_else     shift and go to state 20
    control_structures_for         shift and go to state 21
    type                           shift and go to state 22
    if_block                       shift and go to state 27
    for_classic                    shift and go to state 28
    for_in                         shift and go to state 29
    for_each                       shift and go to state 30

state 89

    (62) condition -> LPAREN . conditions RPAREN
    (57) conditions -> . condition
    (58) conditions -> . conditions AND conditions
    (59) conditions -> . conditions OR conditions
    (60) condition -> . value comparator value
    (61) condition -> . NOT condition
    (62) condition -> . LPAREN conditions RPAREN
    (82) value -> . NUMBER
    (83) value -> . NDOUBLE
    (84) value -> . TEXT
    (85) value -> . ID
    (86) value -> . interpolated_string
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) interpolated_string -> . TEXT PLUS ID
    (90) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 93
    LPAREN          shift and go to state 89
    NUMBER          shift and go to state 56
    NDOUBLE         shift and go to state 57
    TEXT            shift and go to state 73
    ID              shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62

    conditions                     shift and go to state 149
    condition                      shift and go to state 91
    value                          shift and go to state 92
    interpolated_string            shift and go to state 60

state 90

    (53) if_block -> IF LPAREN conditions . RPAREN LBRACKET statement_list RBRACKET
    (58) conditions -> conditions . AND conditions
    (59) conditions -> conditions . OR conditions

    RPAREN          shift and go to state 150
    AND             shift and go to state 151
    OR              shift and go to state 152


state 91

    (57) conditions -> condition .

    RPAREN          reduce using rule 57 (conditions -> condition .)
    AND             reduce using rule 57 (conditions -> condition .)
    OR              reduce using rule 57 (conditions -> condition .)
    SEMICOLON       reduce using rule 57 (conditions -> condition .)


state 92

    (60) condition -> value . comparator value
    (63) comparator -> . GREATER
    (64) comparator -> . LESS
    (65) comparator -> . EQUALS
    (66) comparator -> . GREATER_EQUAL
    (67) comparator -> . LESS_EQUAL
    (68) comparator -> . NOT_EQUALS

    GREATER         shift and go to state 105
    LESS            shift and go to state 106
    EQUALS          shift and go to state 107
    GREATER_EQUAL   shift and go to state 108
    LESS_EQUAL      shift and go to state 109
    NOT_EQUALS      shift and go to state 110

    comparator                     shift and go to state 153

state 93

    (61) condition -> NOT . condition
    (60) condition -> . value comparator value
    (61) condition -> . NOT condition
    (62) condition -> . LPAREN conditions RPAREN
    (82) value -> . NUMBER
    (83) value -> . NDOUBLE
    (84) value -> . TEXT
    (85) value -> . ID
    (86) value -> . interpolated_string
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) interpolated_string -> . TEXT PLUS ID
    (90) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 93
    LPAREN          shift and go to state 89
    NUMBER          shift and go to state 56
    NDOUBLE         shift and go to state 57
    TEXT            shift and go to state 73
    ID              shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62

    condition                      shift and go to state 154
    value                          shift and go to state 92
    interpolated_string            shift and go to state 60

state 94

    (102) for_classic -> FOR LPAREN for_classic_parenthesis_content . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 155


state 95

    (104) for_in -> FOR LPAREN for_in_parenthesis_content . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 156


state 96

    (108) for_each -> FOR LPAREN for_each_parenthesis_content . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 157


state 97

    (101) for_classic_parenthesis_content -> for_classic_initialization . SEMICOLON for_classic_conditions SEMICOLON for_classic_changes

    SEMICOLON       shift and go to state 158


state 98

    (103) for_in_parenthesis_content -> FINAL . ID IN ID
    (107) for_each_parenthesis_content -> FINAL . ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID

    ID              shift and go to state 159


state 99

    (94) for_classic_initialization -> INT . ID ASSIGN NUMBER

    ID              shift and go to state 160


state 100

    (95) for_classic_initialization -> DOUBLE . ID ASSIGN NDOUBLE

    ID              shift and go to state 161


state 101

    (36) print -> PRINT LPAREN RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 36 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 36 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 36 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 36 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 36 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 36 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 36 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 36 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 36 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 36 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 36 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 36 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 36 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 36 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 36 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 36 (print -> PRINT LPAREN RPAREN SEMICOLON .)


state 102

    (37) print -> PRINT LPAREN value RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 162


state 103

    (46) expression -> value comparator . value
    (82) value -> . NUMBER
    (83) value -> . NDOUBLE
    (84) value -> . TEXT
    (85) value -> . ID
    (86) value -> . interpolated_string
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) interpolated_string -> . TEXT PLUS ID
    (90) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 56
    NDOUBLE         shift and go to state 57
    TEXT            shift and go to state 73
    ID              shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62

    value                          shift and go to state 163
    interpolated_string            shift and go to state 60

state 104

    (47) expression -> value PLUS . value
    (82) value -> . NUMBER
    (83) value -> . NDOUBLE
    (84) value -> . TEXT
    (85) value -> . ID
    (86) value -> . interpolated_string
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) interpolated_string -> . TEXT PLUS ID
    (90) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 56
    NDOUBLE         shift and go to state 57
    TEXT            shift and go to state 73
    ID              shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62

    value                          shift and go to state 164
    interpolated_string            shift and go to state 60

state 105

    (63) comparator -> GREATER .

    NUMBER          reduce using rule 63 (comparator -> GREATER .)
    NDOUBLE         reduce using rule 63 (comparator -> GREATER .)
    TEXT            reduce using rule 63 (comparator -> GREATER .)
    ID              reduce using rule 63 (comparator -> GREATER .)
    TRUE            reduce using rule 63 (comparator -> GREATER .)
    FALSE           reduce using rule 63 (comparator -> GREATER .)


state 106

    (64) comparator -> LESS .

    NUMBER          reduce using rule 64 (comparator -> LESS .)
    NDOUBLE         reduce using rule 64 (comparator -> LESS .)
    TEXT            reduce using rule 64 (comparator -> LESS .)
    ID              reduce using rule 64 (comparator -> LESS .)
    TRUE            reduce using rule 64 (comparator -> LESS .)
    FALSE           reduce using rule 64 (comparator -> LESS .)


state 107

    (65) comparator -> EQUALS .

    NUMBER          reduce using rule 65 (comparator -> EQUALS .)
    NDOUBLE         reduce using rule 65 (comparator -> EQUALS .)
    TEXT            reduce using rule 65 (comparator -> EQUALS .)
    ID              reduce using rule 65 (comparator -> EQUALS .)
    TRUE            reduce using rule 65 (comparator -> EQUALS .)
    FALSE           reduce using rule 65 (comparator -> EQUALS .)


state 108

    (66) comparator -> GREATER_EQUAL .

    NUMBER          reduce using rule 66 (comparator -> GREATER_EQUAL .)
    NDOUBLE         reduce using rule 66 (comparator -> GREATER_EQUAL .)
    TEXT            reduce using rule 66 (comparator -> GREATER_EQUAL .)
    ID              reduce using rule 66 (comparator -> GREATER_EQUAL .)
    TRUE            reduce using rule 66 (comparator -> GREATER_EQUAL .)
    FALSE           reduce using rule 66 (comparator -> GREATER_EQUAL .)


state 109

    (67) comparator -> LESS_EQUAL .

    NUMBER          reduce using rule 67 (comparator -> LESS_EQUAL .)
    NDOUBLE         reduce using rule 67 (comparator -> LESS_EQUAL .)
    TEXT            reduce using rule 67 (comparator -> LESS_EQUAL .)
    ID              reduce using rule 67 (comparator -> LESS_EQUAL .)
    TRUE            reduce using rule 67 (comparator -> LESS_EQUAL .)
    FALSE           reduce using rule 67 (comparator -> LESS_EQUAL .)


state 110

    (68) comparator -> NOT_EQUALS .

    NUMBER          reduce using rule 68 (comparator -> NOT_EQUALS .)
    NDOUBLE         reduce using rule 68 (comparator -> NOT_EQUALS .)
    TEXT            reduce using rule 68 (comparator -> NOT_EQUALS .)
    ID              reduce using rule 68 (comparator -> NOT_EQUALS .)
    TRUE            reduce using rule 68 (comparator -> NOT_EQUALS .)
    FALSE           reduce using rule 68 (comparator -> NOT_EQUALS .)


state 111

    (38) print -> PRINT LPAREN expression RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 165


state 112

    (40) expression -> expression PLUS . expression
    (40) expression -> . expression PLUS expression
    (41) expression -> . expression MINUS expression
    (42) expression -> . expression TIMES expression
    (43) expression -> . expression DIVIDE expression
    (44) expression -> . expression AND expression
    (45) expression -> . expression OR expression
    (46) expression -> . value comparator value
    (47) expression -> . value PLUS value
    (48) expression -> . value
    (82) value -> . NUMBER
    (83) value -> . NDOUBLE
    (84) value -> . TEXT
    (85) value -> . ID
    (86) value -> . interpolated_string
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) interpolated_string -> . TEXT PLUS ID
    (90) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 56
    NDOUBLE         shift and go to state 57
    TEXT            shift and go to state 73
    ID              shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62

    expression                     shift and go to state 166
    value                          shift and go to state 72
    interpolated_string            shift and go to state 60

state 113

    (41) expression -> expression MINUS . expression
    (40) expression -> . expression PLUS expression
    (41) expression -> . expression MINUS expression
    (42) expression -> . expression TIMES expression
    (43) expression -> . expression DIVIDE expression
    (44) expression -> . expression AND expression
    (45) expression -> . expression OR expression
    (46) expression -> . value comparator value
    (47) expression -> . value PLUS value
    (48) expression -> . value
    (82) value -> . NUMBER
    (83) value -> . NDOUBLE
    (84) value -> . TEXT
    (85) value -> . ID
    (86) value -> . interpolated_string
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) interpolated_string -> . TEXT PLUS ID
    (90) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 56
    NDOUBLE         shift and go to state 57
    TEXT            shift and go to state 73
    ID              shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62

    expression                     shift and go to state 167
    value                          shift and go to state 72
    interpolated_string            shift and go to state 60

state 114

    (42) expression -> expression TIMES . expression
    (40) expression -> . expression PLUS expression
    (41) expression -> . expression MINUS expression
    (42) expression -> . expression TIMES expression
    (43) expression -> . expression DIVIDE expression
    (44) expression -> . expression AND expression
    (45) expression -> . expression OR expression
    (46) expression -> . value comparator value
    (47) expression -> . value PLUS value
    (48) expression -> . value
    (82) value -> . NUMBER
    (83) value -> . NDOUBLE
    (84) value -> . TEXT
    (85) value -> . ID
    (86) value -> . interpolated_string
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) interpolated_string -> . TEXT PLUS ID
    (90) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 56
    NDOUBLE         shift and go to state 57
    TEXT            shift and go to state 73
    ID              shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62

    expression                     shift and go to state 168
    value                          shift and go to state 72
    interpolated_string            shift and go to state 60

state 115

    (43) expression -> expression DIVIDE . expression
    (40) expression -> . expression PLUS expression
    (41) expression -> . expression MINUS expression
    (42) expression -> . expression TIMES expression
    (43) expression -> . expression DIVIDE expression
    (44) expression -> . expression AND expression
    (45) expression -> . expression OR expression
    (46) expression -> . value comparator value
    (47) expression -> . value PLUS value
    (48) expression -> . value
    (82) value -> . NUMBER
    (83) value -> . NDOUBLE
    (84) value -> . TEXT
    (85) value -> . ID
    (86) value -> . interpolated_string
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) interpolated_string -> . TEXT PLUS ID
    (90) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 56
    NDOUBLE         shift and go to state 57
    TEXT            shift and go to state 73
    ID              shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62

    expression                     shift and go to state 169
    value                          shift and go to state 72
    interpolated_string            shift and go to state 60

state 116

    (44) expression -> expression AND . expression
    (40) expression -> . expression PLUS expression
    (41) expression -> . expression MINUS expression
    (42) expression -> . expression TIMES expression
    (43) expression -> . expression DIVIDE expression
    (44) expression -> . expression AND expression
    (45) expression -> . expression OR expression
    (46) expression -> . value comparator value
    (47) expression -> . value PLUS value
    (48) expression -> . value
    (82) value -> . NUMBER
    (83) value -> . NDOUBLE
    (84) value -> . TEXT
    (85) value -> . ID
    (86) value -> . interpolated_string
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) interpolated_string -> . TEXT PLUS ID
    (90) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 56
    NDOUBLE         shift and go to state 57
    TEXT            shift and go to state 73
    ID              shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62

    expression                     shift and go to state 170
    value                          shift and go to state 72
    interpolated_string            shift and go to state 60

state 117

    (45) expression -> expression OR . expression
    (40) expression -> . expression PLUS expression
    (41) expression -> . expression MINUS expression
    (42) expression -> . expression TIMES expression
    (43) expression -> . expression DIVIDE expression
    (44) expression -> . expression AND expression
    (45) expression -> . expression OR expression
    (46) expression -> . value comparator value
    (47) expression -> . value PLUS value
    (48) expression -> . value
    (82) value -> . NUMBER
    (83) value -> . NDOUBLE
    (84) value -> . TEXT
    (85) value -> . ID
    (86) value -> . interpolated_string
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) interpolated_string -> . TEXT PLUS ID
    (90) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 56
    NDOUBLE         shift and go to state 57
    TEXT            shift and go to state 73
    ID              shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62

    expression                     shift and go to state 171
    value                          shift and go to state 72
    interpolated_string            shift and go to state 60

state 118

    (39) print -> PRINT LPAREN length RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 172


state 119

    (23) length -> TEXT DOT . LENGTH

    LENGTH          shift and go to state 173


state 120

    (89) interpolated_string -> TEXT PLUS . ID
    (90) interpolated_string -> TEXT PLUS . expression
    (40) expression -> . expression PLUS expression
    (41) expression -> . expression MINUS expression
    (42) expression -> . expression TIMES expression
    (43) expression -> . expression DIVIDE expression
    (44) expression -> . expression AND expression
    (45) expression -> . expression OR expression
    (46) expression -> . value comparator value
    (47) expression -> . value PLUS value
    (48) expression -> . value
    (82) value -> . NUMBER
    (83) value -> . NDOUBLE
    (84) value -> . TEXT
    (85) value -> . ID
    (86) value -> . interpolated_string
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) interpolated_string -> . TEXT PLUS ID
    (90) interpolated_string -> . TEXT PLUS expression

    ID              shift and go to state 174
    NUMBER          shift and go to state 56
    NDOUBLE         shift and go to state 57
    TEXT            shift and go to state 73
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62

    expression                     shift and go to state 175
    value                          shift and go to state 72
    interpolated_string            shift and go to state 60

state 121

    (22) length -> call_list DOT . LENGTH

    LENGTH          shift and go to state 176


state 122

    (78) call_list -> LSBRACKET value_list . RSBRACKET
    (81) value_list -> value_list . COMMA value

    RSBRACKET       shift and go to state 177
    COMMA           shift and go to state 178


state 123

    (80) value_list -> value .

    RSBRACKET       reduce using rule 80 (value_list -> value .)
    COMMA           reduce using rule 80 (value_list -> value .)
    RBRACKET        reduce using rule 80 (value_list -> value .)


state 124

    (20) data_input -> STRING ID ASSIGN STDIN . DOT READLINESYNC LPAREN RPAREN SEMICOLON

    DOT             shift and go to state 179


state 125

    (21) data_input -> STRING QUESTION ID ASSIGN . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    STDIN           shift and go to state 180


state 126

    (114) constructor -> ID LPAREN constructor_parenthesis_content RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 181


state 127

    (18) call_function -> ID LPAREN argument_list RPAREN .

    SEMICOLON       reduce using rule 18 (call_function -> ID LPAREN argument_list RPAREN .)
    PRINT           reduce using rule 18 (call_function -> ID LPAREN argument_list RPAREN .)
    STRING          reduce using rule 18 (call_function -> ID LPAREN argument_list RPAREN .)
    VAR             reduce using rule 18 (call_function -> ID LPAREN argument_list RPAREN .)
    FINAL           reduce using rule 18 (call_function -> ID LPAREN argument_list RPAREN .)
    ID              reduce using rule 18 (call_function -> ID LPAREN argument_list RPAREN .)
    VOID            reduce using rule 18 (call_function -> ID LPAREN argument_list RPAREN .)
    LIST            reduce using rule 18 (call_function -> ID LPAREN argument_list RPAREN .)
    DYNAMIC         reduce using rule 18 (call_function -> ID LPAREN argument_list RPAREN .)
    INT             reduce using rule 18 (call_function -> ID LPAREN argument_list RPAREN .)
    DOUBLE          reduce using rule 18 (call_function -> ID LPAREN argument_list RPAREN .)
    BOOL            reduce using rule 18 (call_function -> ID LPAREN argument_list RPAREN .)
    IF              reduce using rule 18 (call_function -> ID LPAREN argument_list RPAREN .)
    FOR             reduce using rule 18 (call_function -> ID LPAREN argument_list RPAREN .)
    $end            reduce using rule 18 (call_function -> ID LPAREN argument_list RPAREN .)
    RBRACKET        reduce using rule 18 (call_function -> ID LPAREN argument_list RPAREN .)


state 128

    (25) argument_list -> argument_list COMMA . expression
    (40) expression -> . expression PLUS expression
    (41) expression -> . expression MINUS expression
    (42) expression -> . expression TIMES expression
    (43) expression -> . expression DIVIDE expression
    (44) expression -> . expression AND expression
    (45) expression -> . expression OR expression
    (46) expression -> . value comparator value
    (47) expression -> . value PLUS value
    (48) expression -> . value
    (82) value -> . NUMBER
    (83) value -> . NDOUBLE
    (84) value -> . TEXT
    (85) value -> . ID
    (86) value -> . interpolated_string
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) interpolated_string -> . TEXT PLUS ID
    (90) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 56
    NDOUBLE         shift and go to state 57
    TEXT            shift and go to state 73
    ID              shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62

    expression                     shift and go to state 182
    value                          shift and go to state 72
    interpolated_string            shift and go to state 60

state 129

    (112) constructor_parenthesis_content -> THIS DOT . ID
    (113) constructor_parenthesis_content -> THIS DOT . ID COMMA constructor_parenthesis_content

    ID              shift and go to state 183


state 130

    (91) set -> VAR ID ASSIGN LBRACKET . value_list RBRACKET SEMICOLON
    (80) value_list -> . value
    (81) value_list -> . value_list COMMA value
    (82) value -> . NUMBER
    (83) value -> . NDOUBLE
    (84) value -> . TEXT
    (85) value -> . ID
    (86) value -> . interpolated_string
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) interpolated_string -> . TEXT PLUS ID
    (90) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 56
    NDOUBLE         shift and go to state 57
    TEXT            shift and go to state 73
    ID              shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62

    value_list                     shift and go to state 184
    value                          shift and go to state 123
    interpolated_string            shift and go to state 60

state 131

    (92) set -> VAR ID ASSIGN LESS . STRING GREATER LBRACKET RBRACKET SEMICOLON

    STRING          shift and go to state 185


state 132

    (34) variable_definition -> VAR ID ASSIGN expression . SEMICOLON
    (40) expression -> expression . PLUS expression
    (41) expression -> expression . MINUS expression
    (42) expression -> expression . TIMES expression
    (43) expression -> expression . DIVIDE expression
    (44) expression -> expression . AND expression
    (45) expression -> expression . OR expression

    SEMICOLON       shift and go to state 186
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    TIMES           shift and go to state 114
    DIVIDE          shift and go to state 115
    AND             shift and go to state 116
    OR              shift and go to state 117


state 133

    (93) set -> FINAL ID ASSIGN CONST . LBRACKET value_list RBRACKET SEMICOLON

    LBRACKET        shift and go to state 187


state 134

    (71) parameter -> type . ID

    ID              shift and go to state 188


state 135

    (26) function -> type ID LPAREN parameter_list . RPAREN LBRACKET statement_list RBRACKET
    (70) parameter_list -> parameter_list . COMMA parameter

    RPAREN          shift and go to state 189
    COMMA           shift and go to state 190


state 136

    (28) function -> type ID LPAREN RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 191


state 137

    (69) parameter_list -> parameter .

    RPAREN          reduce using rule 69 (parameter_list -> parameter .)
    COMMA           reduce using rule 69 (parameter_list -> parameter .)


state 138

    (72) parameter -> REQUIRED . type ID
    (73) type -> . INT
    (74) type -> . DOUBLE
    (75) type -> . STRING
    (76) type -> . BOOL
    (77) type -> . LIST

    INT             shift and go to state 81
    DOUBLE          shift and go to state 31
    STRING          shift and go to state 82
    BOOL            shift and go to state 32
    LIST            shift and go to state 79

    type                           shift and go to state 192

state 139

    (32) variable_definition -> type ID ASSIGN expression . SEMICOLON
    (40) expression -> expression . PLUS expression
    (41) expression -> expression . MINUS expression
    (42) expression -> expression . TIMES expression
    (43) expression -> expression . DIVIDE expression
    (44) expression -> expression . AND expression
    (45) expression -> expression . OR expression

    SEMICOLON       shift and go to state 193
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    TIMES           shift and go to state 114
    DIVIDE          shift and go to state 115
    AND             shift and go to state 116
    OR              shift and go to state 117


state 140

    (27) function -> VOID ID LPAREN parameter_list . RPAREN LBRACKET statement_list RBRACKET
    (31) function -> VOID ID LPAREN parameter_list . RPAREN LBRACKET RBRACKET
    (70) parameter_list -> parameter_list . COMMA parameter

    RPAREN          shift and go to state 194
    COMMA           shift and go to state 190


state 141

    (29) function -> VOID ID LPAREN RPAREN . LBRACKET statement_list RBRACKET
    (30) function -> VOID ID LPAREN RPAREN . LBRACKET RBRACKET

    LBRACKET        shift and go to state 195


state 142

    (79) list_definition -> LIST LESS type GREATER . ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON

    ID              shift and go to state 196


state 143

    (33) variable_definition -> DYNAMIC ID ASSIGN expression . SEMICOLON
    (40) expression -> expression . PLUS expression
    (41) expression -> expression . MINUS expression
    (42) expression -> expression . TIMES expression
    (43) expression -> expression . DIVIDE expression
    (44) expression -> expression . AND expression
    (45) expression -> expression . OR expression

    SEMICOLON       shift and go to state 197
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    TIMES           shift and go to state 114
    DIVIDE          shift and go to state 115
    AND             shift and go to state 116
    OR              shift and go to state 117


state 144

    (35) variable_definition -> INT ID ASSIGN length . SEMICOLON

    SEMICOLON       shift and go to state 198


state 145

    (23) length -> TEXT . DOT LENGTH

    DOT             shift and go to state 119


state 146

    (55) else_if_blocks -> else_if_blocks ELSE IF . LPAREN conditions RPAREN LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 199


state 147

    (54) else_if_blocks -> ELSE IF LPAREN . conditions RPAREN LBRACKET statement_list RBRACKET
    (57) conditions -> . condition
    (58) conditions -> . conditions AND conditions
    (59) conditions -> . conditions OR conditions
    (60) condition -> . value comparator value
    (61) condition -> . NOT condition
    (62) condition -> . LPAREN conditions RPAREN
    (82) value -> . NUMBER
    (83) value -> . NDOUBLE
    (84) value -> . TEXT
    (85) value -> . ID
    (86) value -> . interpolated_string
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) interpolated_string -> . TEXT PLUS ID
    (90) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 93
    LPAREN          shift and go to state 89
    NUMBER          shift and go to state 56
    NDOUBLE         shift and go to state 57
    TEXT            shift and go to state 73
    ID              shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62

    conditions                     shift and go to state 200
    condition                      shift and go to state 91
    value                          shift and go to state 92
    interpolated_string            shift and go to state 60

state 148

    (56) else_block -> ELSE LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . constructor
    (8) statement -> . control_structures
    (9) statement -> . function
    (10) statement -> . list_definition
    (11) statement -> . variable_definition
    (12) statement -> . variable_usage
    (13) statement -> . call_function
    (14) statement -> . SEMICOLON
    (36) print -> . PRINT LPAREN RPAREN SEMICOLON
    (37) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (38) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (39) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (20) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (21) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (91) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (92) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (93) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (114) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (15) control_structures -> . control_structures_if_else
    (16) control_structures -> . control_structures_for
    (26) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (27) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (28) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (31) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (79) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (32) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (33) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (34) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (17) variable_usage -> . ID
    (18) call_function -> . ID LPAREN argument_list RPAREN
    (19) call_function -> . ID LPAREN RPAREN
    (49) control_structures_if_else -> . if_block
    (50) control_structures_if_else -> . if_block else_if_blocks
    (51) control_structures_if_else -> . if_block else_if_blocks else_block
    (52) control_structures_if_else -> . if_block else_block
    (109) control_structures_for -> . for_classic
    (110) control_structures_for -> . for_in
    (111) control_structures_for -> . for_each
    (73) type -> . INT
    (74) type -> . DOUBLE
    (75) type -> . STRING
    (76) type -> . BOOL
    (77) type -> . LIST
    (53) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (102) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (104) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 201
    SEMICOLON       shift and go to state 14
    PRINT           shift and go to state 15
    STRING          shift and go to state 16
    VAR             shift and go to state 18
    FINAL           shift and go to state 19
    ID              shift and go to state 17
    VOID            shift and go to state 23
    LIST            shift and go to state 24
    DYNAMIC         shift and go to state 25
    INT             shift and go to state 26
    DOUBLE          shift and go to state 31
    BOOL            shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34

    statement                      shift and go to state 35
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    constructor                    shift and go to state 7
    control_structures             shift and go to state 8
    function                       shift and go to state 9
    list_definition                shift and go to state 10
    variable_definition            shift and go to state 11
    variable_usage                 shift and go to state 12
    call_function                  shift and go to state 13
    control_structures_if_else     shift and go to state 20
    control_structures_for         shift and go to state 21
    type                           shift and go to state 22
    if_block                       shift and go to state 27
    for_classic                    shift and go to state 28
    for_in                         shift and go to state 29
    for_each                       shift and go to state 30

state 149

    (62) condition -> LPAREN conditions . RPAREN
    (58) conditions -> conditions . AND conditions
    (59) conditions -> conditions . OR conditions

    RPAREN          shift and go to state 202
    AND             shift and go to state 151
    OR              shift and go to state 152


state 150

    (53) if_block -> IF LPAREN conditions RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 203


state 151

    (58) conditions -> conditions AND . conditions
    (57) conditions -> . condition
    (58) conditions -> . conditions AND conditions
    (59) conditions -> . conditions OR conditions
    (60) condition -> . value comparator value
    (61) condition -> . NOT condition
    (62) condition -> . LPAREN conditions RPAREN
    (82) value -> . NUMBER
    (83) value -> . NDOUBLE
    (84) value -> . TEXT
    (85) value -> . ID
    (86) value -> . interpolated_string
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) interpolated_string -> . TEXT PLUS ID
    (90) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 93
    LPAREN          shift and go to state 89
    NUMBER          shift and go to state 56
    NDOUBLE         shift and go to state 57
    TEXT            shift and go to state 73
    ID              shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62

    conditions                     shift and go to state 204
    condition                      shift and go to state 91
    value                          shift and go to state 92
    interpolated_string            shift and go to state 60

state 152

    (59) conditions -> conditions OR . conditions
    (57) conditions -> . condition
    (58) conditions -> . conditions AND conditions
    (59) conditions -> . conditions OR conditions
    (60) condition -> . value comparator value
    (61) condition -> . NOT condition
    (62) condition -> . LPAREN conditions RPAREN
    (82) value -> . NUMBER
    (83) value -> . NDOUBLE
    (84) value -> . TEXT
    (85) value -> . ID
    (86) value -> . interpolated_string
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) interpolated_string -> . TEXT PLUS ID
    (90) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 93
    LPAREN          shift and go to state 89
    NUMBER          shift and go to state 56
    NDOUBLE         shift and go to state 57
    TEXT            shift and go to state 73
    ID              shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62

    conditions                     shift and go to state 205
    condition                      shift and go to state 91
    value                          shift and go to state 92
    interpolated_string            shift and go to state 60

state 153

    (60) condition -> value comparator . value
    (82) value -> . NUMBER
    (83) value -> . NDOUBLE
    (84) value -> . TEXT
    (85) value -> . ID
    (86) value -> . interpolated_string
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) interpolated_string -> . TEXT PLUS ID
    (90) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 56
    NDOUBLE         shift and go to state 57
    TEXT            shift and go to state 73
    ID              shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62

    value                          shift and go to state 206
    interpolated_string            shift and go to state 60

state 154

    (61) condition -> NOT condition .

    RPAREN          reduce using rule 61 (condition -> NOT condition .)
    AND             reduce using rule 61 (condition -> NOT condition .)
    OR              reduce using rule 61 (condition -> NOT condition .)
    SEMICOLON       reduce using rule 61 (condition -> NOT condition .)


state 155

    (102) for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 207


state 156

    (104) for_in -> FOR LPAREN for_in_parenthesis_content RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 208


state 157

    (108) for_each -> FOR LPAREN for_each_parenthesis_content RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 209


state 158

    (101) for_classic_parenthesis_content -> for_classic_initialization SEMICOLON . for_classic_conditions SEMICOLON for_classic_changes
    (96) for_classic_conditions -> . conditions
    (57) conditions -> . condition
    (58) conditions -> . conditions AND conditions
    (59) conditions -> . conditions OR conditions
    (60) condition -> . value comparator value
    (61) condition -> . NOT condition
    (62) condition -> . LPAREN conditions RPAREN
    (82) value -> . NUMBER
    (83) value -> . NDOUBLE
    (84) value -> . TEXT
    (85) value -> . ID
    (86) value -> . interpolated_string
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) interpolated_string -> . TEXT PLUS ID
    (90) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 93
    LPAREN          shift and go to state 89
    NUMBER          shift and go to state 56
    NDOUBLE         shift and go to state 57
    TEXT            shift and go to state 73
    ID              shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62

    for_classic_conditions         shift and go to state 210
    conditions                     shift and go to state 211
    condition                      shift and go to state 91
    value                          shift and go to state 92
    interpolated_string            shift and go to state 60

state 159

    (103) for_in_parenthesis_content -> FINAL ID . IN ID
    (107) for_each_parenthesis_content -> FINAL ID . LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID

    IN              shift and go to state 212
    LPAREN          shift and go to state 213


state 160

    (94) for_classic_initialization -> INT ID . ASSIGN NUMBER

    ASSIGN          shift and go to state 214


state 161

    (95) for_classic_initialization -> DOUBLE ID . ASSIGN NDOUBLE

    ASSIGN          shift and go to state 215


state 162

    (37) print -> PRINT LPAREN value RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 37 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    PRINT           reduce using rule 37 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    STRING          reduce using rule 37 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    VAR             reduce using rule 37 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    FINAL           reduce using rule 37 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    ID              reduce using rule 37 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    VOID            reduce using rule 37 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    LIST            reduce using rule 37 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 37 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    INT             reduce using rule 37 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 37 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    BOOL            reduce using rule 37 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    IF              reduce using rule 37 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    FOR             reduce using rule 37 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    $end            reduce using rule 37 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 37 (print -> PRINT LPAREN value RPAREN SEMICOLON .)


state 163

    (46) expression -> value comparator value .

    RPAREN          reduce using rule 46 (expression -> value comparator value .)
    PLUS            reduce using rule 46 (expression -> value comparator value .)
    MINUS           reduce using rule 46 (expression -> value comparator value .)
    TIMES           reduce using rule 46 (expression -> value comparator value .)
    DIVIDE          reduce using rule 46 (expression -> value comparator value .)
    AND             reduce using rule 46 (expression -> value comparator value .)
    OR              reduce using rule 46 (expression -> value comparator value .)
    COMMA           reduce using rule 46 (expression -> value comparator value .)
    SEMICOLON       reduce using rule 46 (expression -> value comparator value .)
    GREATER         reduce using rule 46 (expression -> value comparator value .)
    LESS            reduce using rule 46 (expression -> value comparator value .)
    EQUALS          reduce using rule 46 (expression -> value comparator value .)
    GREATER_EQUAL   reduce using rule 46 (expression -> value comparator value .)
    LESS_EQUAL      reduce using rule 46 (expression -> value comparator value .)
    NOT_EQUALS      reduce using rule 46 (expression -> value comparator value .)
    RSBRACKET       reduce using rule 46 (expression -> value comparator value .)
    RBRACKET        reduce using rule 46 (expression -> value comparator value .)


state 164

    (47) expression -> value PLUS value .

    RPAREN          reduce using rule 47 (expression -> value PLUS value .)
    PLUS            reduce using rule 47 (expression -> value PLUS value .)
    MINUS           reduce using rule 47 (expression -> value PLUS value .)
    TIMES           reduce using rule 47 (expression -> value PLUS value .)
    DIVIDE          reduce using rule 47 (expression -> value PLUS value .)
    AND             reduce using rule 47 (expression -> value PLUS value .)
    OR              reduce using rule 47 (expression -> value PLUS value .)
    COMMA           reduce using rule 47 (expression -> value PLUS value .)
    SEMICOLON       reduce using rule 47 (expression -> value PLUS value .)
    GREATER         reduce using rule 47 (expression -> value PLUS value .)
    LESS            reduce using rule 47 (expression -> value PLUS value .)
    EQUALS          reduce using rule 47 (expression -> value PLUS value .)
    GREATER_EQUAL   reduce using rule 47 (expression -> value PLUS value .)
    LESS_EQUAL      reduce using rule 47 (expression -> value PLUS value .)
    NOT_EQUALS      reduce using rule 47 (expression -> value PLUS value .)
    RSBRACKET       reduce using rule 47 (expression -> value PLUS value .)
    RBRACKET        reduce using rule 47 (expression -> value PLUS value .)


state 165

    (38) print -> PRINT LPAREN expression RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 38 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    PRINT           reduce using rule 38 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    STRING          reduce using rule 38 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    VAR             reduce using rule 38 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FINAL           reduce using rule 38 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    ID              reduce using rule 38 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    VOID            reduce using rule 38 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LIST            reduce using rule 38 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 38 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    INT             reduce using rule 38 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 38 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    BOOL            reduce using rule 38 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    IF              reduce using rule 38 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FOR             reduce using rule 38 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    $end            reduce using rule 38 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 38 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)


state 166

    (40) expression -> expression PLUS expression .
    (40) expression -> expression . PLUS expression
    (41) expression -> expression . MINUS expression
    (42) expression -> expression . TIMES expression
    (43) expression -> expression . DIVIDE expression
    (44) expression -> expression . AND expression
    (45) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 40 (expression -> expression PLUS expression .)
    COMMA           reduce using rule 40 (expression -> expression PLUS expression .)
    SEMICOLON       reduce using rule 40 (expression -> expression PLUS expression .)
    GREATER         reduce using rule 40 (expression -> expression PLUS expression .)
    LESS            reduce using rule 40 (expression -> expression PLUS expression .)
    EQUALS          reduce using rule 40 (expression -> expression PLUS expression .)
    GREATER_EQUAL   reduce using rule 40 (expression -> expression PLUS expression .)
    LESS_EQUAL      reduce using rule 40 (expression -> expression PLUS expression .)
    NOT_EQUALS      reduce using rule 40 (expression -> expression PLUS expression .)
    RSBRACKET       reduce using rule 40 (expression -> expression PLUS expression .)
    RBRACKET        reduce using rule 40 (expression -> expression PLUS expression .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    TIMES           shift and go to state 114
    DIVIDE          shift and go to state 115
    AND             shift and go to state 116
    OR              shift and go to state 117

  ! PLUS            [ reduce using rule 40 (expression -> expression PLUS expression .) ]
  ! MINUS           [ reduce using rule 40 (expression -> expression PLUS expression .) ]
  ! TIMES           [ reduce using rule 40 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 40 (expression -> expression PLUS expression .) ]
  ! AND             [ reduce using rule 40 (expression -> expression PLUS expression .) ]
  ! OR              [ reduce using rule 40 (expression -> expression PLUS expression .) ]


state 167

    (41) expression -> expression MINUS expression .
    (40) expression -> expression . PLUS expression
    (41) expression -> expression . MINUS expression
    (42) expression -> expression . TIMES expression
    (43) expression -> expression . DIVIDE expression
    (44) expression -> expression . AND expression
    (45) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 41 (expression -> expression MINUS expression .)
    COMMA           reduce using rule 41 (expression -> expression MINUS expression .)
    SEMICOLON       reduce using rule 41 (expression -> expression MINUS expression .)
    GREATER         reduce using rule 41 (expression -> expression MINUS expression .)
    LESS            reduce using rule 41 (expression -> expression MINUS expression .)
    EQUALS          reduce using rule 41 (expression -> expression MINUS expression .)
    GREATER_EQUAL   reduce using rule 41 (expression -> expression MINUS expression .)
    LESS_EQUAL      reduce using rule 41 (expression -> expression MINUS expression .)
    NOT_EQUALS      reduce using rule 41 (expression -> expression MINUS expression .)
    RSBRACKET       reduce using rule 41 (expression -> expression MINUS expression .)
    RBRACKET        reduce using rule 41 (expression -> expression MINUS expression .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    TIMES           shift and go to state 114
    DIVIDE          shift and go to state 115
    AND             shift and go to state 116
    OR              shift and go to state 117

  ! PLUS            [ reduce using rule 41 (expression -> expression MINUS expression .) ]
  ! MINUS           [ reduce using rule 41 (expression -> expression MINUS expression .) ]
  ! TIMES           [ reduce using rule 41 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 41 (expression -> expression MINUS expression .) ]
  ! AND             [ reduce using rule 41 (expression -> expression MINUS expression .) ]
  ! OR              [ reduce using rule 41 (expression -> expression MINUS expression .) ]


state 168

    (42) expression -> expression TIMES expression .
    (40) expression -> expression . PLUS expression
    (41) expression -> expression . MINUS expression
    (42) expression -> expression . TIMES expression
    (43) expression -> expression . DIVIDE expression
    (44) expression -> expression . AND expression
    (45) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 42 (expression -> expression TIMES expression .)
    COMMA           reduce using rule 42 (expression -> expression TIMES expression .)
    SEMICOLON       reduce using rule 42 (expression -> expression TIMES expression .)
    GREATER         reduce using rule 42 (expression -> expression TIMES expression .)
    LESS            reduce using rule 42 (expression -> expression TIMES expression .)
    EQUALS          reduce using rule 42 (expression -> expression TIMES expression .)
    GREATER_EQUAL   reduce using rule 42 (expression -> expression TIMES expression .)
    LESS_EQUAL      reduce using rule 42 (expression -> expression TIMES expression .)
    NOT_EQUALS      reduce using rule 42 (expression -> expression TIMES expression .)
    RSBRACKET       reduce using rule 42 (expression -> expression TIMES expression .)
    RBRACKET        reduce using rule 42 (expression -> expression TIMES expression .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    TIMES           shift and go to state 114
    DIVIDE          shift and go to state 115
    AND             shift and go to state 116
    OR              shift and go to state 117

  ! PLUS            [ reduce using rule 42 (expression -> expression TIMES expression .) ]
  ! MINUS           [ reduce using rule 42 (expression -> expression TIMES expression .) ]
  ! TIMES           [ reduce using rule 42 (expression -> expression TIMES expression .) ]
  ! DIVIDE          [ reduce using rule 42 (expression -> expression TIMES expression .) ]
  ! AND             [ reduce using rule 42 (expression -> expression TIMES expression .) ]
  ! OR              [ reduce using rule 42 (expression -> expression TIMES expression .) ]


state 169

    (43) expression -> expression DIVIDE expression .
    (40) expression -> expression . PLUS expression
    (41) expression -> expression . MINUS expression
    (42) expression -> expression . TIMES expression
    (43) expression -> expression . DIVIDE expression
    (44) expression -> expression . AND expression
    (45) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 43 (expression -> expression DIVIDE expression .)
    COMMA           reduce using rule 43 (expression -> expression DIVIDE expression .)
    SEMICOLON       reduce using rule 43 (expression -> expression DIVIDE expression .)
    GREATER         reduce using rule 43 (expression -> expression DIVIDE expression .)
    LESS            reduce using rule 43 (expression -> expression DIVIDE expression .)
    EQUALS          reduce using rule 43 (expression -> expression DIVIDE expression .)
    GREATER_EQUAL   reduce using rule 43 (expression -> expression DIVIDE expression .)
    LESS_EQUAL      reduce using rule 43 (expression -> expression DIVIDE expression .)
    NOT_EQUALS      reduce using rule 43 (expression -> expression DIVIDE expression .)
    RSBRACKET       reduce using rule 43 (expression -> expression DIVIDE expression .)
    RBRACKET        reduce using rule 43 (expression -> expression DIVIDE expression .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    TIMES           shift and go to state 114
    DIVIDE          shift and go to state 115
    AND             shift and go to state 116
    OR              shift and go to state 117

  ! PLUS            [ reduce using rule 43 (expression -> expression DIVIDE expression .) ]
  ! MINUS           [ reduce using rule 43 (expression -> expression DIVIDE expression .) ]
  ! TIMES           [ reduce using rule 43 (expression -> expression DIVIDE expression .) ]
  ! DIVIDE          [ reduce using rule 43 (expression -> expression DIVIDE expression .) ]
  ! AND             [ reduce using rule 43 (expression -> expression DIVIDE expression .) ]
  ! OR              [ reduce using rule 43 (expression -> expression DIVIDE expression .) ]


state 170

    (44) expression -> expression AND expression .
    (40) expression -> expression . PLUS expression
    (41) expression -> expression . MINUS expression
    (42) expression -> expression . TIMES expression
    (43) expression -> expression . DIVIDE expression
    (44) expression -> expression . AND expression
    (45) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 44 (expression -> expression AND expression .)
    COMMA           reduce using rule 44 (expression -> expression AND expression .)
    SEMICOLON       reduce using rule 44 (expression -> expression AND expression .)
    GREATER         reduce using rule 44 (expression -> expression AND expression .)
    LESS            reduce using rule 44 (expression -> expression AND expression .)
    EQUALS          reduce using rule 44 (expression -> expression AND expression .)
    GREATER_EQUAL   reduce using rule 44 (expression -> expression AND expression .)
    LESS_EQUAL      reduce using rule 44 (expression -> expression AND expression .)
    NOT_EQUALS      reduce using rule 44 (expression -> expression AND expression .)
    RSBRACKET       reduce using rule 44 (expression -> expression AND expression .)
    RBRACKET        reduce using rule 44 (expression -> expression AND expression .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    TIMES           shift and go to state 114
    DIVIDE          shift and go to state 115
    AND             shift and go to state 116
    OR              shift and go to state 117

  ! PLUS            [ reduce using rule 44 (expression -> expression AND expression .) ]
  ! MINUS           [ reduce using rule 44 (expression -> expression AND expression .) ]
  ! TIMES           [ reduce using rule 44 (expression -> expression AND expression .) ]
  ! DIVIDE          [ reduce using rule 44 (expression -> expression AND expression .) ]
  ! AND             [ reduce using rule 44 (expression -> expression AND expression .) ]
  ! OR              [ reduce using rule 44 (expression -> expression AND expression .) ]


state 171

    (45) expression -> expression OR expression .
    (40) expression -> expression . PLUS expression
    (41) expression -> expression . MINUS expression
    (42) expression -> expression . TIMES expression
    (43) expression -> expression . DIVIDE expression
    (44) expression -> expression . AND expression
    (45) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 45 (expression -> expression OR expression .)
    COMMA           reduce using rule 45 (expression -> expression OR expression .)
    SEMICOLON       reduce using rule 45 (expression -> expression OR expression .)
    GREATER         reduce using rule 45 (expression -> expression OR expression .)
    LESS            reduce using rule 45 (expression -> expression OR expression .)
    EQUALS          reduce using rule 45 (expression -> expression OR expression .)
    GREATER_EQUAL   reduce using rule 45 (expression -> expression OR expression .)
    LESS_EQUAL      reduce using rule 45 (expression -> expression OR expression .)
    NOT_EQUALS      reduce using rule 45 (expression -> expression OR expression .)
    RSBRACKET       reduce using rule 45 (expression -> expression OR expression .)
    RBRACKET        reduce using rule 45 (expression -> expression OR expression .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    TIMES           shift and go to state 114
    DIVIDE          shift and go to state 115
    AND             shift and go to state 116
    OR              shift and go to state 117

  ! PLUS            [ reduce using rule 45 (expression -> expression OR expression .) ]
  ! MINUS           [ reduce using rule 45 (expression -> expression OR expression .) ]
  ! TIMES           [ reduce using rule 45 (expression -> expression OR expression .) ]
  ! DIVIDE          [ reduce using rule 45 (expression -> expression OR expression .) ]
  ! AND             [ reduce using rule 45 (expression -> expression OR expression .) ]
  ! OR              [ reduce using rule 45 (expression -> expression OR expression .) ]


state 172

    (39) print -> PRINT LPAREN length RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 39 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    PRINT           reduce using rule 39 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    STRING          reduce using rule 39 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    VAR             reduce using rule 39 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    FINAL           reduce using rule 39 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    ID              reduce using rule 39 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    VOID            reduce using rule 39 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    LIST            reduce using rule 39 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 39 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    INT             reduce using rule 39 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 39 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    BOOL            reduce using rule 39 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    IF              reduce using rule 39 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    FOR             reduce using rule 39 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    $end            reduce using rule 39 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 39 (print -> PRINT LPAREN length RPAREN SEMICOLON .)


state 173

    (23) length -> TEXT DOT LENGTH .

    RPAREN          reduce using rule 23 (length -> TEXT DOT LENGTH .)
    SEMICOLON       reduce using rule 23 (length -> TEXT DOT LENGTH .)


state 174

    (89) interpolated_string -> TEXT PLUS ID .
    (85) value -> ID .

  ! reduce/reduce conflict for RPAREN resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for COMMA resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for LESS resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for EQUALS resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUALS resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for RSBRACKET resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 85 (value -> ID .)
    RPAREN          reduce using rule 85 (value -> ID .)
    PLUS            reduce using rule 85 (value -> ID .)
    MINUS           reduce using rule 85 (value -> ID .)
    TIMES           reduce using rule 85 (value -> ID .)
    DIVIDE          reduce using rule 85 (value -> ID .)
    AND             reduce using rule 85 (value -> ID .)
    OR              reduce using rule 85 (value -> ID .)
    COMMA           reduce using rule 85 (value -> ID .)
    SEMICOLON       reduce using rule 85 (value -> ID .)
    GREATER         reduce using rule 85 (value -> ID .)
    LESS            reduce using rule 85 (value -> ID .)
    EQUALS          reduce using rule 85 (value -> ID .)
    GREATER_EQUAL   reduce using rule 85 (value -> ID .)
    LESS_EQUAL      reduce using rule 85 (value -> ID .)
    NOT_EQUALS      reduce using rule 85 (value -> ID .)
    RSBRACKET       reduce using rule 85 (value -> ID .)
    RBRACKET        reduce using rule 85 (value -> ID .)

  ! RPAREN          [ reduce using rule 89 (interpolated_string -> TEXT PLUS ID .) ]
  ! PLUS            [ reduce using rule 89 (interpolated_string -> TEXT PLUS ID .) ]
  ! GREATER         [ reduce using rule 89 (interpolated_string -> TEXT PLUS ID .) ]
  ! LESS            [ reduce using rule 89 (interpolated_string -> TEXT PLUS ID .) ]
  ! EQUALS          [ reduce using rule 89 (interpolated_string -> TEXT PLUS ID .) ]
  ! GREATER_EQUAL   [ reduce using rule 89 (interpolated_string -> TEXT PLUS ID .) ]
  ! LESS_EQUAL      [ reduce using rule 89 (interpolated_string -> TEXT PLUS ID .) ]
  ! NOT_EQUALS      [ reduce using rule 89 (interpolated_string -> TEXT PLUS ID .) ]
  ! MINUS           [ reduce using rule 89 (interpolated_string -> TEXT PLUS ID .) ]
  ! TIMES           [ reduce using rule 89 (interpolated_string -> TEXT PLUS ID .) ]
  ! DIVIDE          [ reduce using rule 89 (interpolated_string -> TEXT PLUS ID .) ]
  ! AND             [ reduce using rule 89 (interpolated_string -> TEXT PLUS ID .) ]
  ! OR              [ reduce using rule 89 (interpolated_string -> TEXT PLUS ID .) ]
  ! COMMA           [ reduce using rule 89 (interpolated_string -> TEXT PLUS ID .) ]
  ! RSBRACKET       [ reduce using rule 89 (interpolated_string -> TEXT PLUS ID .) ]
  ! SEMICOLON       [ reduce using rule 89 (interpolated_string -> TEXT PLUS ID .) ]
  ! RBRACKET        [ reduce using rule 89 (interpolated_string -> TEXT PLUS ID .) ]


state 175

    (90) interpolated_string -> TEXT PLUS expression .
    (40) expression -> expression . PLUS expression
    (41) expression -> expression . MINUS expression
    (42) expression -> expression . TIMES expression
    (43) expression -> expression . DIVIDE expression
    (44) expression -> expression . AND expression
    (45) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 90 (interpolated_string -> TEXT PLUS expression .)
    GREATER         reduce using rule 90 (interpolated_string -> TEXT PLUS expression .)
    LESS            reduce using rule 90 (interpolated_string -> TEXT PLUS expression .)
    EQUALS          reduce using rule 90 (interpolated_string -> TEXT PLUS expression .)
    GREATER_EQUAL   reduce using rule 90 (interpolated_string -> TEXT PLUS expression .)
    LESS_EQUAL      reduce using rule 90 (interpolated_string -> TEXT PLUS expression .)
    NOT_EQUALS      reduce using rule 90 (interpolated_string -> TEXT PLUS expression .)
    COMMA           reduce using rule 90 (interpolated_string -> TEXT PLUS expression .)
    RSBRACKET       reduce using rule 90 (interpolated_string -> TEXT PLUS expression .)
    SEMICOLON       reduce using rule 90 (interpolated_string -> TEXT PLUS expression .)
    RBRACKET        reduce using rule 90 (interpolated_string -> TEXT PLUS expression .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    TIMES           shift and go to state 114
    DIVIDE          shift and go to state 115
    AND             shift and go to state 116
    OR              shift and go to state 117

  ! PLUS            [ reduce using rule 90 (interpolated_string -> TEXT PLUS expression .) ]
  ! MINUS           [ reduce using rule 90 (interpolated_string -> TEXT PLUS expression .) ]
  ! TIMES           [ reduce using rule 90 (interpolated_string -> TEXT PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 90 (interpolated_string -> TEXT PLUS expression .) ]
  ! AND             [ reduce using rule 90 (interpolated_string -> TEXT PLUS expression .) ]
  ! OR              [ reduce using rule 90 (interpolated_string -> TEXT PLUS expression .) ]


state 176

    (22) length -> call_list DOT LENGTH .

    RPAREN          reduce using rule 22 (length -> call_list DOT LENGTH .)
    SEMICOLON       reduce using rule 22 (length -> call_list DOT LENGTH .)


state 177

    (78) call_list -> LSBRACKET value_list RSBRACKET .

    DOT             reduce using rule 78 (call_list -> LSBRACKET value_list RSBRACKET .)


state 178

    (81) value_list -> value_list COMMA . value
    (82) value -> . NUMBER
    (83) value -> . NDOUBLE
    (84) value -> . TEXT
    (85) value -> . ID
    (86) value -> . interpolated_string
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) interpolated_string -> . TEXT PLUS ID
    (90) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 56
    NDOUBLE         shift and go to state 57
    TEXT            shift and go to state 73
    ID              shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62

    value                          shift and go to state 216
    interpolated_string            shift and go to state 60

state 179

    (20) data_input -> STRING ID ASSIGN STDIN DOT . READLINESYNC LPAREN RPAREN SEMICOLON

    READLINESYNC    shift and go to state 217


state 180

    (21) data_input -> STRING QUESTION ID ASSIGN STDIN . DOT READLINESYNC LPAREN RPAREN SEMICOLON

    DOT             shift and go to state 218


state 181

    (114) constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 114 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    PRINT           reduce using rule 114 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    STRING          reduce using rule 114 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    VAR             reduce using rule 114 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    FINAL           reduce using rule 114 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    ID              reduce using rule 114 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    VOID            reduce using rule 114 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    LIST            reduce using rule 114 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 114 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    INT             reduce using rule 114 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 114 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    BOOL            reduce using rule 114 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    IF              reduce using rule 114 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    FOR             reduce using rule 114 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    $end            reduce using rule 114 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 114 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)


state 182

    (25) argument_list -> argument_list COMMA expression .
    (40) expression -> expression . PLUS expression
    (41) expression -> expression . MINUS expression
    (42) expression -> expression . TIMES expression
    (43) expression -> expression . DIVIDE expression
    (44) expression -> expression . AND expression
    (45) expression -> expression . OR expression

    RPAREN          reduce using rule 25 (argument_list -> argument_list COMMA expression .)
    COMMA           reduce using rule 25 (argument_list -> argument_list COMMA expression .)
    PLUS            shift and go to state 112
    MINUS           shift and go to state 113
    TIMES           shift and go to state 114
    DIVIDE          shift and go to state 115
    AND             shift and go to state 116
    OR              shift and go to state 117


state 183

    (112) constructor_parenthesis_content -> THIS DOT ID .
    (113) constructor_parenthesis_content -> THIS DOT ID . COMMA constructor_parenthesis_content

    RPAREN          reduce using rule 112 (constructor_parenthesis_content -> THIS DOT ID .)
    COMMA           shift and go to state 219


state 184

    (91) set -> VAR ID ASSIGN LBRACKET value_list . RBRACKET SEMICOLON
    (81) value_list -> value_list . COMMA value

    RBRACKET        shift and go to state 220
    COMMA           shift and go to state 178


state 185

    (92) set -> VAR ID ASSIGN LESS STRING . GREATER LBRACKET RBRACKET SEMICOLON

    GREATER         shift and go to state 221


state 186

    (34) variable_definition -> VAR ID ASSIGN expression SEMICOLON .

    SEMICOLON       reduce using rule 34 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 34 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 34 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 34 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 34 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 34 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 34 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 34 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    DYNAMIC         reduce using rule 34 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 34 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 34 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 34 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 34 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 34 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 34 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    RBRACKET        reduce using rule 34 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)


state 187

    (93) set -> FINAL ID ASSIGN CONST LBRACKET . value_list RBRACKET SEMICOLON
    (80) value_list -> . value
    (81) value_list -> . value_list COMMA value
    (82) value -> . NUMBER
    (83) value -> . NDOUBLE
    (84) value -> . TEXT
    (85) value -> . ID
    (86) value -> . interpolated_string
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) interpolated_string -> . TEXT PLUS ID
    (90) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 56
    NDOUBLE         shift and go to state 57
    TEXT            shift and go to state 73
    ID              shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62

    value_list                     shift and go to state 222
    value                          shift and go to state 123
    interpolated_string            shift and go to state 60

state 188

    (71) parameter -> type ID .

    RPAREN          reduce using rule 71 (parameter -> type ID .)
    COMMA           reduce using rule 71 (parameter -> type ID .)


state 189

    (26) function -> type ID LPAREN parameter_list RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 223


state 190

    (70) parameter_list -> parameter_list COMMA . parameter
    (71) parameter -> . type ID
    (72) parameter -> . REQUIRED type ID
    (73) type -> . INT
    (74) type -> . DOUBLE
    (75) type -> . STRING
    (76) type -> . BOOL
    (77) type -> . LIST

    REQUIRED        shift and go to state 138
    INT             shift and go to state 81
    DOUBLE          shift and go to state 31
    STRING          shift and go to state 82
    BOOL            shift and go to state 32
    LIST            shift and go to state 79

    parameter                      shift and go to state 224
    type                           shift and go to state 134

state 191

    (28) function -> type ID LPAREN RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . constructor
    (8) statement -> . control_structures
    (9) statement -> . function
    (10) statement -> . list_definition
    (11) statement -> . variable_definition
    (12) statement -> . variable_usage
    (13) statement -> . call_function
    (14) statement -> . SEMICOLON
    (36) print -> . PRINT LPAREN RPAREN SEMICOLON
    (37) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (38) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (39) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (20) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (21) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (91) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (92) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (93) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (114) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (15) control_structures -> . control_structures_if_else
    (16) control_structures -> . control_structures_for
    (26) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (27) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (28) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (31) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (79) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (32) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (33) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (34) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (17) variable_usage -> . ID
    (18) call_function -> . ID LPAREN argument_list RPAREN
    (19) call_function -> . ID LPAREN RPAREN
    (49) control_structures_if_else -> . if_block
    (50) control_structures_if_else -> . if_block else_if_blocks
    (51) control_structures_if_else -> . if_block else_if_blocks else_block
    (52) control_structures_if_else -> . if_block else_block
    (109) control_structures_for -> . for_classic
    (110) control_structures_for -> . for_in
    (111) control_structures_for -> . for_each
    (73) type -> . INT
    (74) type -> . DOUBLE
    (75) type -> . STRING
    (76) type -> . BOOL
    (77) type -> . LIST
    (53) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (102) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (104) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 14
    PRINT           shift and go to state 15
    STRING          shift and go to state 16
    VAR             shift and go to state 18
    FINAL           shift and go to state 19
    ID              shift and go to state 17
    VOID            shift and go to state 23
    LIST            shift and go to state 24
    DYNAMIC         shift and go to state 25
    INT             shift and go to state 26
    DOUBLE          shift and go to state 31
    BOOL            shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34

    type                           shift and go to state 22
    statement_list                 shift and go to state 225
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    constructor                    shift and go to state 7
    control_structures             shift and go to state 8
    function                       shift and go to state 9
    list_definition                shift and go to state 10
    variable_definition            shift and go to state 11
    variable_usage                 shift and go to state 12
    call_function                  shift and go to state 13
    control_structures_if_else     shift and go to state 20
    control_structures_for         shift and go to state 21
    if_block                       shift and go to state 27
    for_classic                    shift and go to state 28
    for_in                         shift and go to state 29
    for_each                       shift and go to state 30

state 192

    (72) parameter -> REQUIRED type . ID

    ID              shift and go to state 226


state 193

    (32) variable_definition -> type ID ASSIGN expression SEMICOLON .

    SEMICOLON       reduce using rule 32 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 32 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 32 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 32 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 32 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 32 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 32 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 32 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    DYNAMIC         reduce using rule 32 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 32 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 32 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 32 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 32 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 32 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 32 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    RBRACKET        reduce using rule 32 (variable_definition -> type ID ASSIGN expression SEMICOLON .)


state 194

    (27) function -> VOID ID LPAREN parameter_list RPAREN . LBRACKET statement_list RBRACKET
    (31) function -> VOID ID LPAREN parameter_list RPAREN . LBRACKET RBRACKET

    LBRACKET        shift and go to state 227


state 195

    (29) function -> VOID ID LPAREN RPAREN LBRACKET . statement_list RBRACKET
    (30) function -> VOID ID LPAREN RPAREN LBRACKET . RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . constructor
    (8) statement -> . control_structures
    (9) statement -> . function
    (10) statement -> . list_definition
    (11) statement -> . variable_definition
    (12) statement -> . variable_usage
    (13) statement -> . call_function
    (14) statement -> . SEMICOLON
    (36) print -> . PRINT LPAREN RPAREN SEMICOLON
    (37) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (38) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (39) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (20) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (21) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (91) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (92) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (93) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (114) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (15) control_structures -> . control_structures_if_else
    (16) control_structures -> . control_structures_for
    (26) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (27) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (28) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (31) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (79) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (32) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (33) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (34) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (17) variable_usage -> . ID
    (18) call_function -> . ID LPAREN argument_list RPAREN
    (19) call_function -> . ID LPAREN RPAREN
    (49) control_structures_if_else -> . if_block
    (50) control_structures_if_else -> . if_block else_if_blocks
    (51) control_structures_if_else -> . if_block else_if_blocks else_block
    (52) control_structures_if_else -> . if_block else_block
    (109) control_structures_for -> . for_classic
    (110) control_structures_for -> . for_in
    (111) control_structures_for -> . for_each
    (73) type -> . INT
    (74) type -> . DOUBLE
    (75) type -> . STRING
    (76) type -> . BOOL
    (77) type -> . LIST
    (53) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (102) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (104) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 229
    SEMICOLON       shift and go to state 14
    PRINT           shift and go to state 15
    STRING          shift and go to state 16
    VAR             shift and go to state 18
    FINAL           shift and go to state 19
    ID              shift and go to state 17
    VOID            shift and go to state 23
    LIST            shift and go to state 24
    DYNAMIC         shift and go to state 25
    INT             shift and go to state 26
    DOUBLE          shift and go to state 31
    BOOL            shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34

    statement_list                 shift and go to state 228
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    constructor                    shift and go to state 7
    control_structures             shift and go to state 8
    function                       shift and go to state 9
    list_definition                shift and go to state 10
    variable_definition            shift and go to state 11
    variable_usage                 shift and go to state 12
    call_function                  shift and go to state 13
    control_structures_if_else     shift and go to state 20
    control_structures_for         shift and go to state 21
    type                           shift and go to state 22
    if_block                       shift and go to state 27
    for_classic                    shift and go to state 28
    for_in                         shift and go to state 29
    for_each                       shift and go to state 30

state 196

    (79) list_definition -> LIST LESS type GREATER ID . ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON

    ASSIGN          shift and go to state 230


state 197

    (33) variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .

    SEMICOLON       reduce using rule 33 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 33 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 33 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 33 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 33 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 33 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 33 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 33 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    DYNAMIC         reduce using rule 33 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 33 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 33 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 33 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 33 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 33 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 33 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    RBRACKET        reduce using rule 33 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)


state 198

    (35) variable_definition -> INT ID ASSIGN length SEMICOLON .

    SEMICOLON       reduce using rule 35 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    PRINT           reduce using rule 35 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    STRING          reduce using rule 35 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    VAR             reduce using rule 35 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    FINAL           reduce using rule 35 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    ID              reduce using rule 35 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    VOID            reduce using rule 35 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    LIST            reduce using rule 35 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    DYNAMIC         reduce using rule 35 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    INT             reduce using rule 35 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    DOUBLE          reduce using rule 35 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    BOOL            reduce using rule 35 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    IF              reduce using rule 35 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    FOR             reduce using rule 35 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    $end            reduce using rule 35 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    RBRACKET        reduce using rule 35 (variable_definition -> INT ID ASSIGN length SEMICOLON .)


state 199

    (55) else_if_blocks -> else_if_blocks ELSE IF LPAREN . conditions RPAREN LBRACKET statement_list RBRACKET
    (57) conditions -> . condition
    (58) conditions -> . conditions AND conditions
    (59) conditions -> . conditions OR conditions
    (60) condition -> . value comparator value
    (61) condition -> . NOT condition
    (62) condition -> . LPAREN conditions RPAREN
    (82) value -> . NUMBER
    (83) value -> . NDOUBLE
    (84) value -> . TEXT
    (85) value -> . ID
    (86) value -> . interpolated_string
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) interpolated_string -> . TEXT PLUS ID
    (90) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 93
    LPAREN          shift and go to state 89
    NUMBER          shift and go to state 56
    NDOUBLE         shift and go to state 57
    TEXT            shift and go to state 73
    ID              shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62

    conditions                     shift and go to state 231
    condition                      shift and go to state 91
    value                          shift and go to state 92
    interpolated_string            shift and go to state 60

state 200

    (54) else_if_blocks -> ELSE IF LPAREN conditions . RPAREN LBRACKET statement_list RBRACKET
    (58) conditions -> conditions . AND conditions
    (59) conditions -> conditions . OR conditions

    RPAREN          shift and go to state 232
    AND             shift and go to state 151
    OR              shift and go to state 152


state 201

    (56) else_block -> ELSE LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 56 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 56 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 56 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 56 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 56 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 56 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 56 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 56 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 56 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 56 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 56 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 56 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 56 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 56 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 56 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 56 (else_block -> ELSE LBRACKET statement_list RBRACKET .)


state 202

    (62) condition -> LPAREN conditions RPAREN .

    RPAREN          reduce using rule 62 (condition -> LPAREN conditions RPAREN .)
    AND             reduce using rule 62 (condition -> LPAREN conditions RPAREN .)
    OR              reduce using rule 62 (condition -> LPAREN conditions RPAREN .)
    SEMICOLON       reduce using rule 62 (condition -> LPAREN conditions RPAREN .)


state 203

    (53) if_block -> IF LPAREN conditions RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . constructor
    (8) statement -> . control_structures
    (9) statement -> . function
    (10) statement -> . list_definition
    (11) statement -> . variable_definition
    (12) statement -> . variable_usage
    (13) statement -> . call_function
    (14) statement -> . SEMICOLON
    (36) print -> . PRINT LPAREN RPAREN SEMICOLON
    (37) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (38) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (39) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (20) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (21) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (91) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (92) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (93) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (114) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (15) control_structures -> . control_structures_if_else
    (16) control_structures -> . control_structures_for
    (26) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (27) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (28) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (31) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (79) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (32) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (33) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (34) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (17) variable_usage -> . ID
    (18) call_function -> . ID LPAREN argument_list RPAREN
    (19) call_function -> . ID LPAREN RPAREN
    (49) control_structures_if_else -> . if_block
    (50) control_structures_if_else -> . if_block else_if_blocks
    (51) control_structures_if_else -> . if_block else_if_blocks else_block
    (52) control_structures_if_else -> . if_block else_block
    (109) control_structures_for -> . for_classic
    (110) control_structures_for -> . for_in
    (111) control_structures_for -> . for_each
    (73) type -> . INT
    (74) type -> . DOUBLE
    (75) type -> . STRING
    (76) type -> . BOOL
    (77) type -> . LIST
    (53) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (102) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (104) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 14
    PRINT           shift and go to state 15
    STRING          shift and go to state 16
    VAR             shift and go to state 18
    FINAL           shift and go to state 19
    ID              shift and go to state 17
    VOID            shift and go to state 23
    LIST            shift and go to state 24
    DYNAMIC         shift and go to state 25
    INT             shift and go to state 26
    DOUBLE          shift and go to state 31
    BOOL            shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34

    statement_list                 shift and go to state 233
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    constructor                    shift and go to state 7
    control_structures             shift and go to state 8
    function                       shift and go to state 9
    list_definition                shift and go to state 10
    variable_definition            shift and go to state 11
    variable_usage                 shift and go to state 12
    call_function                  shift and go to state 13
    control_structures_if_else     shift and go to state 20
    control_structures_for         shift and go to state 21
    type                           shift and go to state 22
    if_block                       shift and go to state 27
    for_classic                    shift and go to state 28
    for_in                         shift and go to state 29
    for_each                       shift and go to state 30

state 204

    (58) conditions -> conditions AND conditions .
    (58) conditions -> conditions . AND conditions
    (59) conditions -> conditions . OR conditions

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 58 (conditions -> conditions AND conditions .)
    SEMICOLON       reduce using rule 58 (conditions -> conditions AND conditions .)
    AND             shift and go to state 151
    OR              shift and go to state 152

  ! AND             [ reduce using rule 58 (conditions -> conditions AND conditions .) ]
  ! OR              [ reduce using rule 58 (conditions -> conditions AND conditions .) ]


state 205

    (59) conditions -> conditions OR conditions .
    (58) conditions -> conditions . AND conditions
    (59) conditions -> conditions . OR conditions

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 59 (conditions -> conditions OR conditions .)
    SEMICOLON       reduce using rule 59 (conditions -> conditions OR conditions .)
    AND             shift and go to state 151
    OR              shift and go to state 152

  ! AND             [ reduce using rule 59 (conditions -> conditions OR conditions .) ]
  ! OR              [ reduce using rule 59 (conditions -> conditions OR conditions .) ]


state 206

    (60) condition -> value comparator value .

    RPAREN          reduce using rule 60 (condition -> value comparator value .)
    AND             reduce using rule 60 (condition -> value comparator value .)
    OR              reduce using rule 60 (condition -> value comparator value .)
    SEMICOLON       reduce using rule 60 (condition -> value comparator value .)


state 207

    (102) for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . constructor
    (8) statement -> . control_structures
    (9) statement -> . function
    (10) statement -> . list_definition
    (11) statement -> . variable_definition
    (12) statement -> . variable_usage
    (13) statement -> . call_function
    (14) statement -> . SEMICOLON
    (36) print -> . PRINT LPAREN RPAREN SEMICOLON
    (37) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (38) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (39) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (20) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (21) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (91) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (92) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (93) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (114) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (15) control_structures -> . control_structures_if_else
    (16) control_structures -> . control_structures_for
    (26) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (27) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (28) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (31) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (79) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (32) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (33) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (34) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (17) variable_usage -> . ID
    (18) call_function -> . ID LPAREN argument_list RPAREN
    (19) call_function -> . ID LPAREN RPAREN
    (49) control_structures_if_else -> . if_block
    (50) control_structures_if_else -> . if_block else_if_blocks
    (51) control_structures_if_else -> . if_block else_if_blocks else_block
    (52) control_structures_if_else -> . if_block else_block
    (109) control_structures_for -> . for_classic
    (110) control_structures_for -> . for_in
    (111) control_structures_for -> . for_each
    (73) type -> . INT
    (74) type -> . DOUBLE
    (75) type -> . STRING
    (76) type -> . BOOL
    (77) type -> . LIST
    (53) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (102) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (104) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 14
    PRINT           shift and go to state 15
    STRING          shift and go to state 16
    VAR             shift and go to state 18
    FINAL           shift and go to state 19
    ID              shift and go to state 17
    VOID            shift and go to state 23
    LIST            shift and go to state 24
    DYNAMIC         shift and go to state 25
    INT             shift and go to state 26
    DOUBLE          shift and go to state 31
    BOOL            shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34

    statement_list                 shift and go to state 234
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    constructor                    shift and go to state 7
    control_structures             shift and go to state 8
    function                       shift and go to state 9
    list_definition                shift and go to state 10
    variable_definition            shift and go to state 11
    variable_usage                 shift and go to state 12
    call_function                  shift and go to state 13
    control_structures_if_else     shift and go to state 20
    control_structures_for         shift and go to state 21
    type                           shift and go to state 22
    if_block                       shift and go to state 27
    for_classic                    shift and go to state 28
    for_in                         shift and go to state 29
    for_each                       shift and go to state 30

state 208

    (104) for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . constructor
    (8) statement -> . control_structures
    (9) statement -> . function
    (10) statement -> . list_definition
    (11) statement -> . variable_definition
    (12) statement -> . variable_usage
    (13) statement -> . call_function
    (14) statement -> . SEMICOLON
    (36) print -> . PRINT LPAREN RPAREN SEMICOLON
    (37) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (38) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (39) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (20) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (21) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (91) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (92) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (93) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (114) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (15) control_structures -> . control_structures_if_else
    (16) control_structures -> . control_structures_for
    (26) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (27) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (28) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (31) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (79) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (32) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (33) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (34) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (17) variable_usage -> . ID
    (18) call_function -> . ID LPAREN argument_list RPAREN
    (19) call_function -> . ID LPAREN RPAREN
    (49) control_structures_if_else -> . if_block
    (50) control_structures_if_else -> . if_block else_if_blocks
    (51) control_structures_if_else -> . if_block else_if_blocks else_block
    (52) control_structures_if_else -> . if_block else_block
    (109) control_structures_for -> . for_classic
    (110) control_structures_for -> . for_in
    (111) control_structures_for -> . for_each
    (73) type -> . INT
    (74) type -> . DOUBLE
    (75) type -> . STRING
    (76) type -> . BOOL
    (77) type -> . LIST
    (53) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (102) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (104) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 14
    PRINT           shift and go to state 15
    STRING          shift and go to state 16
    VAR             shift and go to state 18
    FINAL           shift and go to state 19
    ID              shift and go to state 17
    VOID            shift and go to state 23
    LIST            shift and go to state 24
    DYNAMIC         shift and go to state 25
    INT             shift and go to state 26
    DOUBLE          shift and go to state 31
    BOOL            shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34

    statement_list                 shift and go to state 235
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    constructor                    shift and go to state 7
    control_structures             shift and go to state 8
    function                       shift and go to state 9
    list_definition                shift and go to state 10
    variable_definition            shift and go to state 11
    variable_usage                 shift and go to state 12
    call_function                  shift and go to state 13
    control_structures_if_else     shift and go to state 20
    control_structures_for         shift and go to state 21
    type                           shift and go to state 22
    if_block                       shift and go to state 27
    for_classic                    shift and go to state 28
    for_in                         shift and go to state 29
    for_each                       shift and go to state 30

state 209

    (108) for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . constructor
    (8) statement -> . control_structures
    (9) statement -> . function
    (10) statement -> . list_definition
    (11) statement -> . variable_definition
    (12) statement -> . variable_usage
    (13) statement -> . call_function
    (14) statement -> . SEMICOLON
    (36) print -> . PRINT LPAREN RPAREN SEMICOLON
    (37) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (38) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (39) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (20) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (21) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (91) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (92) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (93) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (114) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (15) control_structures -> . control_structures_if_else
    (16) control_structures -> . control_structures_for
    (26) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (27) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (28) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (31) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (79) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (32) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (33) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (34) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (17) variable_usage -> . ID
    (18) call_function -> . ID LPAREN argument_list RPAREN
    (19) call_function -> . ID LPAREN RPAREN
    (49) control_structures_if_else -> . if_block
    (50) control_structures_if_else -> . if_block else_if_blocks
    (51) control_structures_if_else -> . if_block else_if_blocks else_block
    (52) control_structures_if_else -> . if_block else_block
    (109) control_structures_for -> . for_classic
    (110) control_structures_for -> . for_in
    (111) control_structures_for -> . for_each
    (73) type -> . INT
    (74) type -> . DOUBLE
    (75) type -> . STRING
    (76) type -> . BOOL
    (77) type -> . LIST
    (53) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (102) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (104) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 14
    PRINT           shift and go to state 15
    STRING          shift and go to state 16
    VAR             shift and go to state 18
    FINAL           shift and go to state 19
    ID              shift and go to state 17
    VOID            shift and go to state 23
    LIST            shift and go to state 24
    DYNAMIC         shift and go to state 25
    INT             shift and go to state 26
    DOUBLE          shift and go to state 31
    BOOL            shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34

    statement_list                 shift and go to state 236
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    constructor                    shift and go to state 7
    control_structures             shift and go to state 8
    function                       shift and go to state 9
    list_definition                shift and go to state 10
    variable_definition            shift and go to state 11
    variable_usage                 shift and go to state 12
    call_function                  shift and go to state 13
    control_structures_if_else     shift and go to state 20
    control_structures_for         shift and go to state 21
    type                           shift and go to state 22
    if_block                       shift and go to state 27
    for_classic                    shift and go to state 28
    for_in                         shift and go to state 29
    for_each                       shift and go to state 30

state 210

    (101) for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions . SEMICOLON for_classic_changes

    SEMICOLON       shift and go to state 237


state 211

    (96) for_classic_conditions -> conditions .
    (58) conditions -> conditions . AND conditions
    (59) conditions -> conditions . OR conditions

    SEMICOLON       reduce using rule 96 (for_classic_conditions -> conditions .)
    AND             shift and go to state 151
    OR              shift and go to state 152


state 212

    (103) for_in_parenthesis_content -> FINAL ID IN . ID

    ID              shift and go to state 238


state 213

    (107) for_each_parenthesis_content -> FINAL ID LPAREN . for_each_parenthesis_parenthesis_content RPAREN IN ID
    (105) for_each_parenthesis_parenthesis_content -> . COLON ID
    (106) for_each_parenthesis_parenthesis_content -> . COLON ID COMMA for_each_parenthesis_parenthesis_content

    COLON           shift and go to state 240

    for_each_parenthesis_parenthesis_content shift and go to state 239

state 214

    (94) for_classic_initialization -> INT ID ASSIGN . NUMBER

    NUMBER          shift and go to state 241


state 215

    (95) for_classic_initialization -> DOUBLE ID ASSIGN . NDOUBLE

    NDOUBLE         shift and go to state 242


state 216

    (81) value_list -> value_list COMMA value .

    RSBRACKET       reduce using rule 81 (value_list -> value_list COMMA value .)
    COMMA           reduce using rule 81 (value_list -> value_list COMMA value .)
    RBRACKET        reduce using rule 81 (value_list -> value_list COMMA value .)


state 217

    (20) data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 243


state 218

    (21) data_input -> STRING QUESTION ID ASSIGN STDIN DOT . READLINESYNC LPAREN RPAREN SEMICOLON

    READLINESYNC    shift and go to state 244


state 219

    (113) constructor_parenthesis_content -> THIS DOT ID COMMA . constructor_parenthesis_content
    (112) constructor_parenthesis_content -> . THIS DOT ID
    (113) constructor_parenthesis_content -> . THIS DOT ID COMMA constructor_parenthesis_content

    THIS            shift and go to state 70

    constructor_parenthesis_content shift and go to state 245

state 220

    (91) set -> VAR ID ASSIGN LBRACKET value_list RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 246


state 221

    (92) set -> VAR ID ASSIGN LESS STRING GREATER . LBRACKET RBRACKET SEMICOLON

    LBRACKET        shift and go to state 247


state 222

    (93) set -> FINAL ID ASSIGN CONST LBRACKET value_list . RBRACKET SEMICOLON
    (81) value_list -> value_list . COMMA value

    RBRACKET        shift and go to state 248
    COMMA           shift and go to state 178


state 223

    (26) function -> type ID LPAREN parameter_list RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . constructor
    (8) statement -> . control_structures
    (9) statement -> . function
    (10) statement -> . list_definition
    (11) statement -> . variable_definition
    (12) statement -> . variable_usage
    (13) statement -> . call_function
    (14) statement -> . SEMICOLON
    (36) print -> . PRINT LPAREN RPAREN SEMICOLON
    (37) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (38) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (39) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (20) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (21) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (91) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (92) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (93) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (114) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (15) control_structures -> . control_structures_if_else
    (16) control_structures -> . control_structures_for
    (26) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (27) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (28) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (31) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (79) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (32) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (33) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (34) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (17) variable_usage -> . ID
    (18) call_function -> . ID LPAREN argument_list RPAREN
    (19) call_function -> . ID LPAREN RPAREN
    (49) control_structures_if_else -> . if_block
    (50) control_structures_if_else -> . if_block else_if_blocks
    (51) control_structures_if_else -> . if_block else_if_blocks else_block
    (52) control_structures_if_else -> . if_block else_block
    (109) control_structures_for -> . for_classic
    (110) control_structures_for -> . for_in
    (111) control_structures_for -> . for_each
    (73) type -> . INT
    (74) type -> . DOUBLE
    (75) type -> . STRING
    (76) type -> . BOOL
    (77) type -> . LIST
    (53) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (102) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (104) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 14
    PRINT           shift and go to state 15
    STRING          shift and go to state 16
    VAR             shift and go to state 18
    FINAL           shift and go to state 19
    ID              shift and go to state 17
    VOID            shift and go to state 23
    LIST            shift and go to state 24
    DYNAMIC         shift and go to state 25
    INT             shift and go to state 26
    DOUBLE          shift and go to state 31
    BOOL            shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34

    type                           shift and go to state 22
    statement_list                 shift and go to state 249
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    constructor                    shift and go to state 7
    control_structures             shift and go to state 8
    function                       shift and go to state 9
    list_definition                shift and go to state 10
    variable_definition            shift and go to state 11
    variable_usage                 shift and go to state 12
    call_function                  shift and go to state 13
    control_structures_if_else     shift and go to state 20
    control_structures_for         shift and go to state 21
    if_block                       shift and go to state 27
    for_classic                    shift and go to state 28
    for_in                         shift and go to state 29
    for_each                       shift and go to state 30

state 224

    (70) parameter_list -> parameter_list COMMA parameter .

    RPAREN          reduce using rule 70 (parameter_list -> parameter_list COMMA parameter .)
    COMMA           reduce using rule 70 (parameter_list -> parameter_list COMMA parameter .)


state 225

    (28) function -> type ID LPAREN RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . constructor
    (8) statement -> . control_structures
    (9) statement -> . function
    (10) statement -> . list_definition
    (11) statement -> . variable_definition
    (12) statement -> . variable_usage
    (13) statement -> . call_function
    (14) statement -> . SEMICOLON
    (36) print -> . PRINT LPAREN RPAREN SEMICOLON
    (37) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (38) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (39) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (20) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (21) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (91) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (92) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (93) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (114) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (15) control_structures -> . control_structures_if_else
    (16) control_structures -> . control_structures_for
    (26) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (27) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (28) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (31) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (79) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (32) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (33) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (34) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (17) variable_usage -> . ID
    (18) call_function -> . ID LPAREN argument_list RPAREN
    (19) call_function -> . ID LPAREN RPAREN
    (49) control_structures_if_else -> . if_block
    (50) control_structures_if_else -> . if_block else_if_blocks
    (51) control_structures_if_else -> . if_block else_if_blocks else_block
    (52) control_structures_if_else -> . if_block else_block
    (109) control_structures_for -> . for_classic
    (110) control_structures_for -> . for_in
    (111) control_structures_for -> . for_each
    (73) type -> . INT
    (74) type -> . DOUBLE
    (75) type -> . STRING
    (76) type -> . BOOL
    (77) type -> . LIST
    (53) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (102) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (104) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 250
    SEMICOLON       shift and go to state 14
    PRINT           shift and go to state 15
    STRING          shift and go to state 16
    VAR             shift and go to state 18
    FINAL           shift and go to state 19
    ID              shift and go to state 17
    VOID            shift and go to state 23
    LIST            shift and go to state 24
    DYNAMIC         shift and go to state 25
    INT             shift and go to state 26
    DOUBLE          shift and go to state 31
    BOOL            shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34

    type                           shift and go to state 22
    statement                      shift and go to state 35
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    constructor                    shift and go to state 7
    control_structures             shift and go to state 8
    function                       shift and go to state 9
    list_definition                shift and go to state 10
    variable_definition            shift and go to state 11
    variable_usage                 shift and go to state 12
    call_function                  shift and go to state 13
    control_structures_if_else     shift and go to state 20
    control_structures_for         shift and go to state 21
    if_block                       shift and go to state 27
    for_classic                    shift and go to state 28
    for_in                         shift and go to state 29
    for_each                       shift and go to state 30

state 226

    (72) parameter -> REQUIRED type ID .

    RPAREN          reduce using rule 72 (parameter -> REQUIRED type ID .)
    COMMA           reduce using rule 72 (parameter -> REQUIRED type ID .)


state 227

    (27) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET . statement_list RBRACKET
    (31) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET . RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . constructor
    (8) statement -> . control_structures
    (9) statement -> . function
    (10) statement -> . list_definition
    (11) statement -> . variable_definition
    (12) statement -> . variable_usage
    (13) statement -> . call_function
    (14) statement -> . SEMICOLON
    (36) print -> . PRINT LPAREN RPAREN SEMICOLON
    (37) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (38) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (39) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (20) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (21) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (91) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (92) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (93) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (114) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (15) control_structures -> . control_structures_if_else
    (16) control_structures -> . control_structures_for
    (26) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (27) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (28) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (31) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (79) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (32) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (33) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (34) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (17) variable_usage -> . ID
    (18) call_function -> . ID LPAREN argument_list RPAREN
    (19) call_function -> . ID LPAREN RPAREN
    (49) control_structures_if_else -> . if_block
    (50) control_structures_if_else -> . if_block else_if_blocks
    (51) control_structures_if_else -> . if_block else_if_blocks else_block
    (52) control_structures_if_else -> . if_block else_block
    (109) control_structures_for -> . for_classic
    (110) control_structures_for -> . for_in
    (111) control_structures_for -> . for_each
    (73) type -> . INT
    (74) type -> . DOUBLE
    (75) type -> . STRING
    (76) type -> . BOOL
    (77) type -> . LIST
    (53) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (102) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (104) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 252
    SEMICOLON       shift and go to state 14
    PRINT           shift and go to state 15
    STRING          shift and go to state 16
    VAR             shift and go to state 18
    FINAL           shift and go to state 19
    ID              shift and go to state 17
    VOID            shift and go to state 23
    LIST            shift and go to state 24
    DYNAMIC         shift and go to state 25
    INT             shift and go to state 26
    DOUBLE          shift and go to state 31
    BOOL            shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34

    statement_list                 shift and go to state 251
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    constructor                    shift and go to state 7
    control_structures             shift and go to state 8
    function                       shift and go to state 9
    list_definition                shift and go to state 10
    variable_definition            shift and go to state 11
    variable_usage                 shift and go to state 12
    call_function                  shift and go to state 13
    control_structures_if_else     shift and go to state 20
    control_structures_for         shift and go to state 21
    type                           shift and go to state 22
    if_block                       shift and go to state 27
    for_classic                    shift and go to state 28
    for_in                         shift and go to state 29
    for_each                       shift and go to state 30

state 228

    (29) function -> VOID ID LPAREN RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . constructor
    (8) statement -> . control_structures
    (9) statement -> . function
    (10) statement -> . list_definition
    (11) statement -> . variable_definition
    (12) statement -> . variable_usage
    (13) statement -> . call_function
    (14) statement -> . SEMICOLON
    (36) print -> . PRINT LPAREN RPAREN SEMICOLON
    (37) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (38) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (39) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (20) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (21) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (91) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (92) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (93) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (114) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (15) control_structures -> . control_structures_if_else
    (16) control_structures -> . control_structures_for
    (26) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (27) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (28) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (31) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (79) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (32) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (33) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (34) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (17) variable_usage -> . ID
    (18) call_function -> . ID LPAREN argument_list RPAREN
    (19) call_function -> . ID LPAREN RPAREN
    (49) control_structures_if_else -> . if_block
    (50) control_structures_if_else -> . if_block else_if_blocks
    (51) control_structures_if_else -> . if_block else_if_blocks else_block
    (52) control_structures_if_else -> . if_block else_block
    (109) control_structures_for -> . for_classic
    (110) control_structures_for -> . for_in
    (111) control_structures_for -> . for_each
    (73) type -> . INT
    (74) type -> . DOUBLE
    (75) type -> . STRING
    (76) type -> . BOOL
    (77) type -> . LIST
    (53) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (102) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (104) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 253
    SEMICOLON       shift and go to state 14
    PRINT           shift and go to state 15
    STRING          shift and go to state 16
    VAR             shift and go to state 18
    FINAL           shift and go to state 19
    ID              shift and go to state 17
    VOID            shift and go to state 23
    LIST            shift and go to state 24
    DYNAMIC         shift and go to state 25
    INT             shift and go to state 26
    DOUBLE          shift and go to state 31
    BOOL            shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34

    statement                      shift and go to state 35
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    constructor                    shift and go to state 7
    control_structures             shift and go to state 8
    function                       shift and go to state 9
    list_definition                shift and go to state 10
    variable_definition            shift and go to state 11
    variable_usage                 shift and go to state 12
    call_function                  shift and go to state 13
    control_structures_if_else     shift and go to state 20
    control_structures_for         shift and go to state 21
    type                           shift and go to state 22
    if_block                       shift and go to state 27
    for_classic                    shift and go to state 28
    for_in                         shift and go to state 29
    for_each                       shift and go to state 30

state 229

    (30) function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .

    SEMICOLON       reduce using rule 30 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    PRINT           reduce using rule 30 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    STRING          reduce using rule 30 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    VAR             reduce using rule 30 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    FINAL           reduce using rule 30 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    ID              reduce using rule 30 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    VOID            reduce using rule 30 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    LIST            reduce using rule 30 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    DYNAMIC         reduce using rule 30 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    INT             reduce using rule 30 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    DOUBLE          reduce using rule 30 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    BOOL            reduce using rule 30 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    IF              reduce using rule 30 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    FOR             reduce using rule 30 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    $end            reduce using rule 30 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 30 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)


state 230

    (79) list_definition -> LIST LESS type GREATER ID ASSIGN . LSBRACKET value_list RSBRACKET SEMICOLON

    LSBRACKET       shift and go to state 254


state 231

    (55) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions . RPAREN LBRACKET statement_list RBRACKET
    (58) conditions -> conditions . AND conditions
    (59) conditions -> conditions . OR conditions

    RPAREN          shift and go to state 255
    AND             shift and go to state 151
    OR              shift and go to state 152


state 232

    (54) else_if_blocks -> ELSE IF LPAREN conditions RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 256


state 233

    (53) if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . constructor
    (8) statement -> . control_structures
    (9) statement -> . function
    (10) statement -> . list_definition
    (11) statement -> . variable_definition
    (12) statement -> . variable_usage
    (13) statement -> . call_function
    (14) statement -> . SEMICOLON
    (36) print -> . PRINT LPAREN RPAREN SEMICOLON
    (37) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (38) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (39) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (20) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (21) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (91) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (92) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (93) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (114) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (15) control_structures -> . control_structures_if_else
    (16) control_structures -> . control_structures_for
    (26) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (27) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (28) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (31) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (79) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (32) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (33) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (34) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (17) variable_usage -> . ID
    (18) call_function -> . ID LPAREN argument_list RPAREN
    (19) call_function -> . ID LPAREN RPAREN
    (49) control_structures_if_else -> . if_block
    (50) control_structures_if_else -> . if_block else_if_blocks
    (51) control_structures_if_else -> . if_block else_if_blocks else_block
    (52) control_structures_if_else -> . if_block else_block
    (109) control_structures_for -> . for_classic
    (110) control_structures_for -> . for_in
    (111) control_structures_for -> . for_each
    (73) type -> . INT
    (74) type -> . DOUBLE
    (75) type -> . STRING
    (76) type -> . BOOL
    (77) type -> . LIST
    (53) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (102) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (104) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 257
    SEMICOLON       shift and go to state 14
    PRINT           shift and go to state 15
    STRING          shift and go to state 16
    VAR             shift and go to state 18
    FINAL           shift and go to state 19
    ID              shift and go to state 17
    VOID            shift and go to state 23
    LIST            shift and go to state 24
    DYNAMIC         shift and go to state 25
    INT             shift and go to state 26
    DOUBLE          shift and go to state 31
    BOOL            shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34

    statement                      shift and go to state 35
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    constructor                    shift and go to state 7
    control_structures             shift and go to state 8
    function                       shift and go to state 9
    list_definition                shift and go to state 10
    variable_definition            shift and go to state 11
    variable_usage                 shift and go to state 12
    call_function                  shift and go to state 13
    control_structures_if_else     shift and go to state 20
    control_structures_for         shift and go to state 21
    type                           shift and go to state 22
    if_block                       shift and go to state 27
    for_classic                    shift and go to state 28
    for_in                         shift and go to state 29
    for_each                       shift and go to state 30

state 234

    (102) for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . constructor
    (8) statement -> . control_structures
    (9) statement -> . function
    (10) statement -> . list_definition
    (11) statement -> . variable_definition
    (12) statement -> . variable_usage
    (13) statement -> . call_function
    (14) statement -> . SEMICOLON
    (36) print -> . PRINT LPAREN RPAREN SEMICOLON
    (37) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (38) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (39) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (20) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (21) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (91) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (92) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (93) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (114) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (15) control_structures -> . control_structures_if_else
    (16) control_structures -> . control_structures_for
    (26) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (27) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (28) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (31) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (79) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (32) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (33) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (34) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (17) variable_usage -> . ID
    (18) call_function -> . ID LPAREN argument_list RPAREN
    (19) call_function -> . ID LPAREN RPAREN
    (49) control_structures_if_else -> . if_block
    (50) control_structures_if_else -> . if_block else_if_blocks
    (51) control_structures_if_else -> . if_block else_if_blocks else_block
    (52) control_structures_if_else -> . if_block else_block
    (109) control_structures_for -> . for_classic
    (110) control_structures_for -> . for_in
    (111) control_structures_for -> . for_each
    (73) type -> . INT
    (74) type -> . DOUBLE
    (75) type -> . STRING
    (76) type -> . BOOL
    (77) type -> . LIST
    (53) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (102) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (104) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 258
    SEMICOLON       shift and go to state 14
    PRINT           shift and go to state 15
    STRING          shift and go to state 16
    VAR             shift and go to state 18
    FINAL           shift and go to state 19
    ID              shift and go to state 17
    VOID            shift and go to state 23
    LIST            shift and go to state 24
    DYNAMIC         shift and go to state 25
    INT             shift and go to state 26
    DOUBLE          shift and go to state 31
    BOOL            shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34

    statement                      shift and go to state 35
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    constructor                    shift and go to state 7
    control_structures             shift and go to state 8
    function                       shift and go to state 9
    list_definition                shift and go to state 10
    variable_definition            shift and go to state 11
    variable_usage                 shift and go to state 12
    call_function                  shift and go to state 13
    control_structures_if_else     shift and go to state 20
    control_structures_for         shift and go to state 21
    type                           shift and go to state 22
    if_block                       shift and go to state 27
    for_classic                    shift and go to state 28
    for_in                         shift and go to state 29
    for_each                       shift and go to state 30

state 235

    (104) for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . constructor
    (8) statement -> . control_structures
    (9) statement -> . function
    (10) statement -> . list_definition
    (11) statement -> . variable_definition
    (12) statement -> . variable_usage
    (13) statement -> . call_function
    (14) statement -> . SEMICOLON
    (36) print -> . PRINT LPAREN RPAREN SEMICOLON
    (37) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (38) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (39) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (20) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (21) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (91) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (92) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (93) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (114) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (15) control_structures -> . control_structures_if_else
    (16) control_structures -> . control_structures_for
    (26) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (27) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (28) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (31) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (79) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (32) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (33) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (34) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (17) variable_usage -> . ID
    (18) call_function -> . ID LPAREN argument_list RPAREN
    (19) call_function -> . ID LPAREN RPAREN
    (49) control_structures_if_else -> . if_block
    (50) control_structures_if_else -> . if_block else_if_blocks
    (51) control_structures_if_else -> . if_block else_if_blocks else_block
    (52) control_structures_if_else -> . if_block else_block
    (109) control_structures_for -> . for_classic
    (110) control_structures_for -> . for_in
    (111) control_structures_for -> . for_each
    (73) type -> . INT
    (74) type -> . DOUBLE
    (75) type -> . STRING
    (76) type -> . BOOL
    (77) type -> . LIST
    (53) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (102) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (104) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 259
    SEMICOLON       shift and go to state 14
    PRINT           shift and go to state 15
    STRING          shift and go to state 16
    VAR             shift and go to state 18
    FINAL           shift and go to state 19
    ID              shift and go to state 17
    VOID            shift and go to state 23
    LIST            shift and go to state 24
    DYNAMIC         shift and go to state 25
    INT             shift and go to state 26
    DOUBLE          shift and go to state 31
    BOOL            shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34

    statement                      shift and go to state 35
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    constructor                    shift and go to state 7
    control_structures             shift and go to state 8
    function                       shift and go to state 9
    list_definition                shift and go to state 10
    variable_definition            shift and go to state 11
    variable_usage                 shift and go to state 12
    call_function                  shift and go to state 13
    control_structures_if_else     shift and go to state 20
    control_structures_for         shift and go to state 21
    type                           shift and go to state 22
    if_block                       shift and go to state 27
    for_classic                    shift and go to state 28
    for_in                         shift and go to state 29
    for_each                       shift and go to state 30

state 236

    (108) for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . constructor
    (8) statement -> . control_structures
    (9) statement -> . function
    (10) statement -> . list_definition
    (11) statement -> . variable_definition
    (12) statement -> . variable_usage
    (13) statement -> . call_function
    (14) statement -> . SEMICOLON
    (36) print -> . PRINT LPAREN RPAREN SEMICOLON
    (37) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (38) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (39) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (20) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (21) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (91) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (92) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (93) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (114) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (15) control_structures -> . control_structures_if_else
    (16) control_structures -> . control_structures_for
    (26) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (27) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (28) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (31) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (79) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (32) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (33) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (34) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (17) variable_usage -> . ID
    (18) call_function -> . ID LPAREN argument_list RPAREN
    (19) call_function -> . ID LPAREN RPAREN
    (49) control_structures_if_else -> . if_block
    (50) control_structures_if_else -> . if_block else_if_blocks
    (51) control_structures_if_else -> . if_block else_if_blocks else_block
    (52) control_structures_if_else -> . if_block else_block
    (109) control_structures_for -> . for_classic
    (110) control_structures_for -> . for_in
    (111) control_structures_for -> . for_each
    (73) type -> . INT
    (74) type -> . DOUBLE
    (75) type -> . STRING
    (76) type -> . BOOL
    (77) type -> . LIST
    (53) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (102) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (104) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 260
    SEMICOLON       shift and go to state 14
    PRINT           shift and go to state 15
    STRING          shift and go to state 16
    VAR             shift and go to state 18
    FINAL           shift and go to state 19
    ID              shift and go to state 17
    VOID            shift and go to state 23
    LIST            shift and go to state 24
    DYNAMIC         shift and go to state 25
    INT             shift and go to state 26
    DOUBLE          shift and go to state 31
    BOOL            shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34

    statement                      shift and go to state 35
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    constructor                    shift and go to state 7
    control_structures             shift and go to state 8
    function                       shift and go to state 9
    list_definition                shift and go to state 10
    variable_definition            shift and go to state 11
    variable_usage                 shift and go to state 12
    call_function                  shift and go to state 13
    control_structures_if_else     shift and go to state 20
    control_structures_for         shift and go to state 21
    type                           shift and go to state 22
    if_block                       shift and go to state 27
    for_classic                    shift and go to state 28
    for_in                         shift and go to state 29
    for_each                       shift and go to state 30

state 237

    (101) for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON . for_classic_changes
    (97) for_classic_changes -> . ID comparator value
    (98) for_classic_changes -> . ID INCREMENT
    (99) for_classic_changes -> . ID DECREMENT
    (100) for_classic_changes -> . ID comparator value COMMA for_classic_changes

    ID              shift and go to state 262

    for_classic_changes            shift and go to state 261

state 238

    (103) for_in_parenthesis_content -> FINAL ID IN ID .

    RPAREN          reduce using rule 103 (for_in_parenthesis_content -> FINAL ID IN ID .)


state 239

    (107) for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content . RPAREN IN ID

    RPAREN          shift and go to state 263


state 240

    (105) for_each_parenthesis_parenthesis_content -> COLON . ID
    (106) for_each_parenthesis_parenthesis_content -> COLON . ID COMMA for_each_parenthesis_parenthesis_content

    ID              shift and go to state 264


state 241

    (94) for_classic_initialization -> INT ID ASSIGN NUMBER .

    SEMICOLON       reduce using rule 94 (for_classic_initialization -> INT ID ASSIGN NUMBER .)


state 242

    (95) for_classic_initialization -> DOUBLE ID ASSIGN NDOUBLE .

    SEMICOLON       reduce using rule 95 (for_classic_initialization -> DOUBLE ID ASSIGN NDOUBLE .)


state 243

    (20) data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 265


state 244

    (21) data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 266


state 245

    (113) constructor_parenthesis_content -> THIS DOT ID COMMA constructor_parenthesis_content .

    RPAREN          reduce using rule 113 (constructor_parenthesis_content -> THIS DOT ID COMMA constructor_parenthesis_content .)


state 246

    (91) set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .

    SEMICOLON       reduce using rule 91 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    PRINT           reduce using rule 91 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    STRING          reduce using rule 91 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    VAR             reduce using rule 91 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    FINAL           reduce using rule 91 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    ID              reduce using rule 91 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    VOID            reduce using rule 91 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    LIST            reduce using rule 91 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 91 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    INT             reduce using rule 91 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 91 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    BOOL            reduce using rule 91 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    IF              reduce using rule 91 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    FOR             reduce using rule 91 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    $end            reduce using rule 91 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    RBRACKET        reduce using rule 91 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)


state 247

    (92) set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 267


state 248

    (93) set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 268


state 249

    (26) function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . constructor
    (8) statement -> . control_structures
    (9) statement -> . function
    (10) statement -> . list_definition
    (11) statement -> . variable_definition
    (12) statement -> . variable_usage
    (13) statement -> . call_function
    (14) statement -> . SEMICOLON
    (36) print -> . PRINT LPAREN RPAREN SEMICOLON
    (37) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (38) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (39) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (20) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (21) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (91) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (92) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (93) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (114) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (15) control_structures -> . control_structures_if_else
    (16) control_structures -> . control_structures_for
    (26) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (27) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (28) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (31) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (79) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (32) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (33) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (34) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (17) variable_usage -> . ID
    (18) call_function -> . ID LPAREN argument_list RPAREN
    (19) call_function -> . ID LPAREN RPAREN
    (49) control_structures_if_else -> . if_block
    (50) control_structures_if_else -> . if_block else_if_blocks
    (51) control_structures_if_else -> . if_block else_if_blocks else_block
    (52) control_structures_if_else -> . if_block else_block
    (109) control_structures_for -> . for_classic
    (110) control_structures_for -> . for_in
    (111) control_structures_for -> . for_each
    (73) type -> . INT
    (74) type -> . DOUBLE
    (75) type -> . STRING
    (76) type -> . BOOL
    (77) type -> . LIST
    (53) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (102) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (104) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 269
    SEMICOLON       shift and go to state 14
    PRINT           shift and go to state 15
    STRING          shift and go to state 16
    VAR             shift and go to state 18
    FINAL           shift and go to state 19
    ID              shift and go to state 17
    VOID            shift and go to state 23
    LIST            shift and go to state 24
    DYNAMIC         shift and go to state 25
    INT             shift and go to state 26
    DOUBLE          shift and go to state 31
    BOOL            shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34

    type                           shift and go to state 22
    statement                      shift and go to state 35
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    constructor                    shift and go to state 7
    control_structures             shift and go to state 8
    function                       shift and go to state 9
    list_definition                shift and go to state 10
    variable_definition            shift and go to state 11
    variable_usage                 shift and go to state 12
    call_function                  shift and go to state 13
    control_structures_if_else     shift and go to state 20
    control_structures_for         shift and go to state 21
    if_block                       shift and go to state 27
    for_classic                    shift and go to state 28
    for_in                         shift and go to state 29
    for_each                       shift and go to state 30

state 250

    (28) function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 28 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 28 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 28 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 28 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 28 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 28 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 28 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 28 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 28 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 28 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 28 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 28 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 28 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 28 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 28 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 28 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)


state 251

    (27) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . constructor
    (8) statement -> . control_structures
    (9) statement -> . function
    (10) statement -> . list_definition
    (11) statement -> . variable_definition
    (12) statement -> . variable_usage
    (13) statement -> . call_function
    (14) statement -> . SEMICOLON
    (36) print -> . PRINT LPAREN RPAREN SEMICOLON
    (37) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (38) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (39) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (20) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (21) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (91) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (92) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (93) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (114) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (15) control_structures -> . control_structures_if_else
    (16) control_structures -> . control_structures_for
    (26) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (27) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (28) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (31) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (79) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (32) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (33) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (34) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (17) variable_usage -> . ID
    (18) call_function -> . ID LPAREN argument_list RPAREN
    (19) call_function -> . ID LPAREN RPAREN
    (49) control_structures_if_else -> . if_block
    (50) control_structures_if_else -> . if_block else_if_blocks
    (51) control_structures_if_else -> . if_block else_if_blocks else_block
    (52) control_structures_if_else -> . if_block else_block
    (109) control_structures_for -> . for_classic
    (110) control_structures_for -> . for_in
    (111) control_structures_for -> . for_each
    (73) type -> . INT
    (74) type -> . DOUBLE
    (75) type -> . STRING
    (76) type -> . BOOL
    (77) type -> . LIST
    (53) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (102) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (104) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 270
    SEMICOLON       shift and go to state 14
    PRINT           shift and go to state 15
    STRING          shift and go to state 16
    VAR             shift and go to state 18
    FINAL           shift and go to state 19
    ID              shift and go to state 17
    VOID            shift and go to state 23
    LIST            shift and go to state 24
    DYNAMIC         shift and go to state 25
    INT             shift and go to state 26
    DOUBLE          shift and go to state 31
    BOOL            shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34

    statement                      shift and go to state 35
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    constructor                    shift and go to state 7
    control_structures             shift and go to state 8
    function                       shift and go to state 9
    list_definition                shift and go to state 10
    variable_definition            shift and go to state 11
    variable_usage                 shift and go to state 12
    call_function                  shift and go to state 13
    control_structures_if_else     shift and go to state 20
    control_structures_for         shift and go to state 21
    type                           shift and go to state 22
    if_block                       shift and go to state 27
    for_classic                    shift and go to state 28
    for_in                         shift and go to state 29
    for_each                       shift and go to state 30

state 252

    (31) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .

    SEMICOLON       reduce using rule 31 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    PRINT           reduce using rule 31 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    STRING          reduce using rule 31 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    VAR             reduce using rule 31 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    FINAL           reduce using rule 31 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    ID              reduce using rule 31 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    VOID            reduce using rule 31 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    LIST            reduce using rule 31 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    DYNAMIC         reduce using rule 31 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    INT             reduce using rule 31 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    DOUBLE          reduce using rule 31 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    BOOL            reduce using rule 31 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    IF              reduce using rule 31 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    FOR             reduce using rule 31 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    $end            reduce using rule 31 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 31 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)


state 253

    (29) function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 29 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 29 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 29 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 29 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 29 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 29 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 29 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 29 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 29 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 29 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 29 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 29 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 29 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 29 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 29 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 29 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)


state 254

    (79) list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET . value_list RSBRACKET SEMICOLON
    (80) value_list -> . value
    (81) value_list -> . value_list COMMA value
    (82) value -> . NUMBER
    (83) value -> . NDOUBLE
    (84) value -> . TEXT
    (85) value -> . ID
    (86) value -> . interpolated_string
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) interpolated_string -> . TEXT PLUS ID
    (90) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 56
    NDOUBLE         shift and go to state 57
    TEXT            shift and go to state 73
    ID              shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62

    value_list                     shift and go to state 271
    value                          shift and go to state 123
    interpolated_string            shift and go to state 60

state 255

    (55) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 272


state 256

    (54) else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . constructor
    (8) statement -> . control_structures
    (9) statement -> . function
    (10) statement -> . list_definition
    (11) statement -> . variable_definition
    (12) statement -> . variable_usage
    (13) statement -> . call_function
    (14) statement -> . SEMICOLON
    (36) print -> . PRINT LPAREN RPAREN SEMICOLON
    (37) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (38) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (39) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (20) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (21) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (91) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (92) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (93) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (114) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (15) control_structures -> . control_structures_if_else
    (16) control_structures -> . control_structures_for
    (26) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (27) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (28) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (31) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (79) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (32) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (33) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (34) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (17) variable_usage -> . ID
    (18) call_function -> . ID LPAREN argument_list RPAREN
    (19) call_function -> . ID LPAREN RPAREN
    (49) control_structures_if_else -> . if_block
    (50) control_structures_if_else -> . if_block else_if_blocks
    (51) control_structures_if_else -> . if_block else_if_blocks else_block
    (52) control_structures_if_else -> . if_block else_block
    (109) control_structures_for -> . for_classic
    (110) control_structures_for -> . for_in
    (111) control_structures_for -> . for_each
    (73) type -> . INT
    (74) type -> . DOUBLE
    (75) type -> . STRING
    (76) type -> . BOOL
    (77) type -> . LIST
    (53) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (102) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (104) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 14
    PRINT           shift and go to state 15
    STRING          shift and go to state 16
    VAR             shift and go to state 18
    FINAL           shift and go to state 19
    ID              shift and go to state 17
    VOID            shift and go to state 23
    LIST            shift and go to state 24
    DYNAMIC         shift and go to state 25
    INT             shift and go to state 26
    DOUBLE          shift and go to state 31
    BOOL            shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34

    statement_list                 shift and go to state 273
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    constructor                    shift and go to state 7
    control_structures             shift and go to state 8
    function                       shift and go to state 9
    list_definition                shift and go to state 10
    variable_definition            shift and go to state 11
    variable_usage                 shift and go to state 12
    call_function                  shift and go to state 13
    control_structures_if_else     shift and go to state 20
    control_structures_for         shift and go to state 21
    type                           shift and go to state 22
    if_block                       shift and go to state 27
    for_classic                    shift and go to state 28
    for_in                         shift and go to state 29
    for_each                       shift and go to state 30

state 257

    (53) if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .

    ELSE            reduce using rule 53 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 53 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 53 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 53 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 53 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 53 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 53 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 53 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 53 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 53 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 53 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 53 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 53 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 53 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 53 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 53 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 53 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)


state 258

    (102) for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 102 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 102 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 102 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 102 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 102 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 102 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 102 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 102 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 102 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 102 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 102 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 102 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 102 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 102 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 102 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 102 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)


state 259

    (104) for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 104 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 104 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 104 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 104 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 104 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 104 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 104 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 104 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 104 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 104 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 104 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 104 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 104 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 104 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 104 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 104 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)


state 260

    (108) for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 108 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 108 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 108 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 108 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 108 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 108 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 108 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 108 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 108 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 108 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 108 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 108 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 108 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 108 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 108 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 108 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)


state 261

    (101) for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON for_classic_changes .

    RPAREN          reduce using rule 101 (for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON for_classic_changes .)


state 262

    (97) for_classic_changes -> ID . comparator value
    (98) for_classic_changes -> ID . INCREMENT
    (99) for_classic_changes -> ID . DECREMENT
    (100) for_classic_changes -> ID . comparator value COMMA for_classic_changes
    (63) comparator -> . GREATER
    (64) comparator -> . LESS
    (65) comparator -> . EQUALS
    (66) comparator -> . GREATER_EQUAL
    (67) comparator -> . LESS_EQUAL
    (68) comparator -> . NOT_EQUALS

    INCREMENT       shift and go to state 275
    DECREMENT       shift and go to state 276
    GREATER         shift and go to state 105
    LESS            shift and go to state 106
    EQUALS          shift and go to state 107
    GREATER_EQUAL   shift and go to state 108
    LESS_EQUAL      shift and go to state 109
    NOT_EQUALS      shift and go to state 110

    comparator                     shift and go to state 274

state 263

    (107) for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN . IN ID

    IN              shift and go to state 277


state 264

    (105) for_each_parenthesis_parenthesis_content -> COLON ID .
    (106) for_each_parenthesis_parenthesis_content -> COLON ID . COMMA for_each_parenthesis_parenthesis_content

    RPAREN          reduce using rule 105 (for_each_parenthesis_parenthesis_content -> COLON ID .)
    COMMA           shift and go to state 278


state 265

    (20) data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 279


state 266

    (21) data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 280


state 267

    (92) set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 281


state 268

    (93) set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .

    SEMICOLON       reduce using rule 93 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    PRINT           reduce using rule 93 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    STRING          reduce using rule 93 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    VAR             reduce using rule 93 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    FINAL           reduce using rule 93 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    ID              reduce using rule 93 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    VOID            reduce using rule 93 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    LIST            reduce using rule 93 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 93 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    INT             reduce using rule 93 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 93 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    BOOL            reduce using rule 93 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    IF              reduce using rule 93 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    FOR             reduce using rule 93 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    $end            reduce using rule 93 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    RBRACKET        reduce using rule 93 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)


state 269

    (26) function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 26 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 26 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 26 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 26 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 26 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 26 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 26 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 26 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 26 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 26 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 26 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 26 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 26 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 26 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 26 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 26 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)


state 270

    (27) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 27 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 27 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 27 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 27 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 27 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 27 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 27 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 27 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 27 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 27 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 27 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 27 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 27 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 27 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 27 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 27 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)


state 271

    (79) list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list . RSBRACKET SEMICOLON
    (81) value_list -> value_list . COMMA value

    RSBRACKET       shift and go to state 282
    COMMA           shift and go to state 178


state 272

    (55) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . constructor
    (8) statement -> . control_structures
    (9) statement -> . function
    (10) statement -> . list_definition
    (11) statement -> . variable_definition
    (12) statement -> . variable_usage
    (13) statement -> . call_function
    (14) statement -> . SEMICOLON
    (36) print -> . PRINT LPAREN RPAREN SEMICOLON
    (37) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (38) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (39) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (20) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (21) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (91) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (92) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (93) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (114) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (15) control_structures -> . control_structures_if_else
    (16) control_structures -> . control_structures_for
    (26) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (27) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (28) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (31) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (79) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (32) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (33) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (34) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (17) variable_usage -> . ID
    (18) call_function -> . ID LPAREN argument_list RPAREN
    (19) call_function -> . ID LPAREN RPAREN
    (49) control_structures_if_else -> . if_block
    (50) control_structures_if_else -> . if_block else_if_blocks
    (51) control_structures_if_else -> . if_block else_if_blocks else_block
    (52) control_structures_if_else -> . if_block else_block
    (109) control_structures_for -> . for_classic
    (110) control_structures_for -> . for_in
    (111) control_structures_for -> . for_each
    (73) type -> . INT
    (74) type -> . DOUBLE
    (75) type -> . STRING
    (76) type -> . BOOL
    (77) type -> . LIST
    (53) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (102) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (104) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 14
    PRINT           shift and go to state 15
    STRING          shift and go to state 16
    VAR             shift and go to state 18
    FINAL           shift and go to state 19
    ID              shift and go to state 17
    VOID            shift and go to state 23
    LIST            shift and go to state 24
    DYNAMIC         shift and go to state 25
    INT             shift and go to state 26
    DOUBLE          shift and go to state 31
    BOOL            shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34

    statement_list                 shift and go to state 283
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    constructor                    shift and go to state 7
    control_structures             shift and go to state 8
    function                       shift and go to state 9
    list_definition                shift and go to state 10
    variable_definition            shift and go to state 11
    variable_usage                 shift and go to state 12
    call_function                  shift and go to state 13
    control_structures_if_else     shift and go to state 20
    control_structures_for         shift and go to state 21
    type                           shift and go to state 22
    if_block                       shift and go to state 27
    for_classic                    shift and go to state 28
    for_in                         shift and go to state 29
    for_each                       shift and go to state 30

state 273

    (54) else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . constructor
    (8) statement -> . control_structures
    (9) statement -> . function
    (10) statement -> . list_definition
    (11) statement -> . variable_definition
    (12) statement -> . variable_usage
    (13) statement -> . call_function
    (14) statement -> . SEMICOLON
    (36) print -> . PRINT LPAREN RPAREN SEMICOLON
    (37) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (38) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (39) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (20) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (21) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (91) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (92) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (93) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (114) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (15) control_structures -> . control_structures_if_else
    (16) control_structures -> . control_structures_for
    (26) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (27) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (28) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (31) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (79) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (32) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (33) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (34) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (17) variable_usage -> . ID
    (18) call_function -> . ID LPAREN argument_list RPAREN
    (19) call_function -> . ID LPAREN RPAREN
    (49) control_structures_if_else -> . if_block
    (50) control_structures_if_else -> . if_block else_if_blocks
    (51) control_structures_if_else -> . if_block else_if_blocks else_block
    (52) control_structures_if_else -> . if_block else_block
    (109) control_structures_for -> . for_classic
    (110) control_structures_for -> . for_in
    (111) control_structures_for -> . for_each
    (73) type -> . INT
    (74) type -> . DOUBLE
    (75) type -> . STRING
    (76) type -> . BOOL
    (77) type -> . LIST
    (53) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (102) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (104) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 284
    SEMICOLON       shift and go to state 14
    PRINT           shift and go to state 15
    STRING          shift and go to state 16
    VAR             shift and go to state 18
    FINAL           shift and go to state 19
    ID              shift and go to state 17
    VOID            shift and go to state 23
    LIST            shift and go to state 24
    DYNAMIC         shift and go to state 25
    INT             shift and go to state 26
    DOUBLE          shift and go to state 31
    BOOL            shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34

    statement                      shift and go to state 35
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    constructor                    shift and go to state 7
    control_structures             shift and go to state 8
    function                       shift and go to state 9
    list_definition                shift and go to state 10
    variable_definition            shift and go to state 11
    variable_usage                 shift and go to state 12
    call_function                  shift and go to state 13
    control_structures_if_else     shift and go to state 20
    control_structures_for         shift and go to state 21
    type                           shift and go to state 22
    if_block                       shift and go to state 27
    for_classic                    shift and go to state 28
    for_in                         shift and go to state 29
    for_each                       shift and go to state 30

state 274

    (97) for_classic_changes -> ID comparator . value
    (100) for_classic_changes -> ID comparator . value COMMA for_classic_changes
    (82) value -> . NUMBER
    (83) value -> . NDOUBLE
    (84) value -> . TEXT
    (85) value -> . ID
    (86) value -> . interpolated_string
    (87) value -> . TRUE
    (88) value -> . FALSE
    (89) interpolated_string -> . TEXT PLUS ID
    (90) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 56
    NDOUBLE         shift and go to state 57
    TEXT            shift and go to state 73
    ID              shift and go to state 59
    TRUE            shift and go to state 61
    FALSE           shift and go to state 62

    value                          shift and go to state 285
    interpolated_string            shift and go to state 60

state 275

    (98) for_classic_changes -> ID INCREMENT .

    RPAREN          reduce using rule 98 (for_classic_changes -> ID INCREMENT .)


state 276

    (99) for_classic_changes -> ID DECREMENT .

    RPAREN          reduce using rule 99 (for_classic_changes -> ID DECREMENT .)


state 277

    (107) for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN . ID

    ID              shift and go to state 286


state 278

    (106) for_each_parenthesis_parenthesis_content -> COLON ID COMMA . for_each_parenthesis_parenthesis_content
    (105) for_each_parenthesis_parenthesis_content -> . COLON ID
    (106) for_each_parenthesis_parenthesis_content -> . COLON ID COMMA for_each_parenthesis_parenthesis_content

    COLON           shift and go to state 240

    for_each_parenthesis_parenthesis_content shift and go to state 287

state 279

    (20) data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 20 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 20 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 20 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 20 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 20 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 20 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 20 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 20 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 20 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 20 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 20 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 20 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 20 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 20 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 20 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 20 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)


state 280

    (21) data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 288


state 281

    (92) set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .

    SEMICOLON       reduce using rule 92 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    PRINT           reduce using rule 92 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    STRING          reduce using rule 92 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    VAR             reduce using rule 92 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    FINAL           reduce using rule 92 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    ID              reduce using rule 92 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    VOID            reduce using rule 92 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    LIST            reduce using rule 92 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 92 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    INT             reduce using rule 92 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 92 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    BOOL            reduce using rule 92 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    IF              reduce using rule 92 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    FOR             reduce using rule 92 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    $end            reduce using rule 92 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    RBRACKET        reduce using rule 92 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)


state 282

    (79) list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 289


state 283

    (55) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . constructor
    (8) statement -> . control_structures
    (9) statement -> . function
    (10) statement -> . list_definition
    (11) statement -> . variable_definition
    (12) statement -> . variable_usage
    (13) statement -> . call_function
    (14) statement -> . SEMICOLON
    (36) print -> . PRINT LPAREN RPAREN SEMICOLON
    (37) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (38) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (39) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (20) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (21) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (91) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (92) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (93) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (114) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (15) control_structures -> . control_structures_if_else
    (16) control_structures -> . control_structures_for
    (26) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (27) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (28) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (31) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (79) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (32) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (33) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (34) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (17) variable_usage -> . ID
    (18) call_function -> . ID LPAREN argument_list RPAREN
    (19) call_function -> . ID LPAREN RPAREN
    (49) control_structures_if_else -> . if_block
    (50) control_structures_if_else -> . if_block else_if_blocks
    (51) control_structures_if_else -> . if_block else_if_blocks else_block
    (52) control_structures_if_else -> . if_block else_block
    (109) control_structures_for -> . for_classic
    (110) control_structures_for -> . for_in
    (111) control_structures_for -> . for_each
    (73) type -> . INT
    (74) type -> . DOUBLE
    (75) type -> . STRING
    (76) type -> . BOOL
    (77) type -> . LIST
    (53) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (102) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (104) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (108) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 290
    SEMICOLON       shift and go to state 14
    PRINT           shift and go to state 15
    STRING          shift and go to state 16
    VAR             shift and go to state 18
    FINAL           shift and go to state 19
    ID              shift and go to state 17
    VOID            shift and go to state 23
    LIST            shift and go to state 24
    DYNAMIC         shift and go to state 25
    INT             shift and go to state 26
    DOUBLE          shift and go to state 31
    BOOL            shift and go to state 32
    IF              shift and go to state 33
    FOR             shift and go to state 34

    statement                      shift and go to state 35
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    constructor                    shift and go to state 7
    control_structures             shift and go to state 8
    function                       shift and go to state 9
    list_definition                shift and go to state 10
    variable_definition            shift and go to state 11
    variable_usage                 shift and go to state 12
    call_function                  shift and go to state 13
    control_structures_if_else     shift and go to state 20
    control_structures_for         shift and go to state 21
    type                           shift and go to state 22
    if_block                       shift and go to state 27
    for_classic                    shift and go to state 28
    for_in                         shift and go to state 29
    for_each                       shift and go to state 30

state 284

    (54) else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .

    ELSE            reduce using rule 54 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 54 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 54 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 54 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 54 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 54 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 54 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 54 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 54 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 54 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 54 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 54 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 54 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 54 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 54 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 54 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 54 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)


state 285

    (97) for_classic_changes -> ID comparator value .
    (100) for_classic_changes -> ID comparator value . COMMA for_classic_changes

    RPAREN          reduce using rule 97 (for_classic_changes -> ID comparator value .)
    COMMA           shift and go to state 291


state 286

    (107) for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID .

    RPAREN          reduce using rule 107 (for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID .)


state 287

    (106) for_each_parenthesis_parenthesis_content -> COLON ID COMMA for_each_parenthesis_parenthesis_content .

    RPAREN          reduce using rule 106 (for_each_parenthesis_parenthesis_content -> COLON ID COMMA for_each_parenthesis_parenthesis_content .)


state 288

    (21) data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 21 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 21 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 21 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 21 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 21 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 21 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 21 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 21 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 21 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 21 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 21 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 21 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 21 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 21 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 21 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 21 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)


state 289

    (79) list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .

    SEMICOLON       reduce using rule 79 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    PRINT           reduce using rule 79 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    STRING          reduce using rule 79 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    VAR             reduce using rule 79 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    FINAL           reduce using rule 79 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    ID              reduce using rule 79 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    VOID            reduce using rule 79 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    LIST            reduce using rule 79 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 79 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    INT             reduce using rule 79 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 79 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    BOOL            reduce using rule 79 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    IF              reduce using rule 79 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    FOR             reduce using rule 79 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    $end            reduce using rule 79 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    RBRACKET        reduce using rule 79 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)


state 290

    (55) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .

    ELSE            reduce using rule 55 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 55 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 55 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 55 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 55 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 55 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 55 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 55 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 55 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 55 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 55 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 55 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 55 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 55 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 55 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 55 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 55 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)


state 291

    (100) for_classic_changes -> ID comparator value COMMA . for_classic_changes
    (97) for_classic_changes -> . ID comparator value
    (98) for_classic_changes -> . ID INCREMENT
    (99) for_classic_changes -> . ID DECREMENT
    (100) for_classic_changes -> . ID comparator value COMMA for_classic_changes

    ID              shift and go to state 262

    for_classic_changes            shift and go to state 292

state 292

    (100) for_classic_changes -> ID comparator value COMMA for_classic_changes .

    RPAREN          reduce using rule 100 (for_classic_changes -> ID comparator value COMMA for_classic_changes .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 16 resolved as shift
WARNING: shift/reduce conflict for ID in state 26 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 53 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 53 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 58 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 72 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 72 resolved as shift
WARNING: shift/reduce conflict for LESS in state 72 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 72 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 72 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 72 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUALS in state 72 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 73 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 166 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 166 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 166 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 166 resolved as shift
WARNING: shift/reduce conflict for AND in state 166 resolved as shift
WARNING: shift/reduce conflict for OR in state 166 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 167 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 167 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 167 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 167 resolved as shift
WARNING: shift/reduce conflict for AND in state 167 resolved as shift
WARNING: shift/reduce conflict for OR in state 167 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 168 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 168 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 168 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 168 resolved as shift
WARNING: shift/reduce conflict for AND in state 168 resolved as shift
WARNING: shift/reduce conflict for OR in state 168 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 169 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 169 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 169 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 169 resolved as shift
WARNING: shift/reduce conflict for AND in state 169 resolved as shift
WARNING: shift/reduce conflict for OR in state 169 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 170 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 170 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 170 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 170 resolved as shift
WARNING: shift/reduce conflict for AND in state 170 resolved as shift
WARNING: shift/reduce conflict for OR in state 170 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 171 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 171 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 171 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 171 resolved as shift
WARNING: shift/reduce conflict for AND in state 171 resolved as shift
WARNING: shift/reduce conflict for OR in state 171 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 175 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 175 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 175 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 175 resolved as shift
WARNING: shift/reduce conflict for AND in state 175 resolved as shift
WARNING: shift/reduce conflict for OR in state 175 resolved as shift
WARNING: shift/reduce conflict for AND in state 204 resolved as shift
WARNING: shift/reduce conflict for OR in state 204 resolved as shift
WARNING: shift/reduce conflict for AND in state 205 resolved as shift
WARNING: shift/reduce conflict for OR in state 205 resolved as shift
WARNING: reduce/reduce conflict in state 174 resolved using rule (value -> ID)
WARNING: rejected rule (interpolated_string -> TEXT PLUS ID) in state 174
WARNING: Rule (interpolated_string -> TEXT PLUS ID) is never reduced
