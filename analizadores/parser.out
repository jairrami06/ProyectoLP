Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AS
    ASSERT
    ASYNC
    AWAIT
    BREAK
    CASE
    CATCH
    CLASS
    CONTINUE
    COVARIANT
    DEFAULT
    DEFERRED
    DO
    DOLLARSIGN
    DOUBLE_COLON
    ENUM
    EXPORT
    EXTENDS
    EXTENSION
    EXTERNAL
    FACTORY
    FINALLY
    FUNCTION
    GET
    HIDE
    IMPLEMENTS
    IMPORT
    INTERFACE
    IS
    LATE
    LIBRARY
    MIXIN
    MODULE
    NEW
    NULL
    NUM
    NUMERAL
    OBJECT
    ON
    OPERATOR
    PART
    RETHROW
    RETURN
    SET
    SHOW
    STATIC
    SUPER
    SWITCH
    SYNC
    THROW
    TRY
    TYPEDEF
    WITH
    YIELD

Grammar

Rule 0     S' -> program
Rule 1     program -> statement_list
Rule 2     statement_list -> statement
Rule 3     statement_list -> statement_list statement
Rule 4     statement -> print
Rule 5     statement -> data_input
Rule 6     statement -> set
Rule 7     statement -> map
Rule 8     statement -> constructor
Rule 9     statement -> control_structures
Rule 10    statement -> function
Rule 11    statement -> list_definition
Rule 12    statement -> variable_definition
Rule 13    statement -> variable_usage
Rule 14    statement -> call_function
Rule 15    statement -> SEMICOLON
Rule 16    control_structures -> control_structures_if_else
Rule 17    control_structures -> control_structures_for
Rule 18    control_structures -> control_structures_while
Rule 19    variable_usage -> ID
Rule 20    call_function -> ID LPAREN argument_list RPAREN
Rule 21    call_function -> ID LPAREN RPAREN
Rule 22    data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
Rule 23    data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
Rule 24    length -> call_list DOT LENGTH
Rule 25    length -> TEXT DOT LENGTH
Rule 26    argument_list -> expression
Rule 27    argument_list -> argument_list COMMA expression
Rule 28    function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
Rule 29    function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
Rule 30    function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
Rule 31    function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
Rule 32    function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET
Rule 33    function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
Rule 34    variable_definition -> type ID ASSIGN expression SEMICOLON
Rule 35    variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON
Rule 36    variable_definition -> VAR ID ASSIGN expression SEMICOLON
Rule 37    variable_definition -> INT ID ASSIGN length SEMICOLON
Rule 38    variable_definition -> INT ID ASSIGN NUMBER SEMICOLON
Rule 39    variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON
Rule 40    variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
Rule 41    print -> PRINT LPAREN RPAREN SEMICOLON
Rule 42    print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
Rule 43    print -> PRINT LPAREN value RPAREN SEMICOLON
Rule 44    print -> PRINT LPAREN expression RPAREN SEMICOLON
Rule 45    print -> PRINT LPAREN length RPAREN SEMICOLON
Rule 46    list_numbers -> NUMBER
Rule 47    list_numbers -> NDOUBLE
Rule 48    simple_operators_arithmetics -> MINUS
Rule 49    simple_operators_arithmetics -> PLUS
Rule 50    simple_operators_arithmetics -> DIVIDE
Rule 51    simple_operators_arithmetics -> TIMES
Rule 52    simple_operations_arithmetics -> list_numbers simple_operators_arithmetics list_numbers
Rule 53    simple_operations_arithmetics -> list_numbers simple_operators_arithmetics list_numbers simple_operators_arithmetics simple_operations_arithmetics
Rule 54    expression -> expression PLUS expression
Rule 55    expression -> expression MINUS expression
Rule 56    expression -> expression TIMES expression
Rule 57    expression -> expression DIVIDE expression
Rule 58    expression -> expression AND expression
Rule 59    expression -> expression OR expression
Rule 60    expression -> value comparator value
Rule 61    expression -> value PLUS value
Rule 62    expression -> value
Rule 63    control_structures_if_else -> if_block
Rule 64    control_structures_if_else -> if_block else_if_blocks
Rule 65    control_structures_if_else -> if_block else_if_blocks else_block
Rule 66    control_structures_if_else -> if_block else_block
Rule 67    if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
Rule 68    else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
Rule 69    else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
Rule 70    else_block -> ELSE LBRACKET statement_list RBRACKET
Rule 71    conditions -> condition
Rule 72    conditions -> conditions AND conditions
Rule 73    conditions -> conditions OR conditions
Rule 74    condition -> value comparator value
Rule 75    condition -> NOT condition
Rule 76    condition -> LPAREN conditions RPAREN
Rule 77    comparator -> GREATER
Rule 78    comparator -> LESS
Rule 79    comparator -> EQUALS
Rule 80    comparator -> GREATER_EQUAL
Rule 81    comparator -> LESS_EQUAL
Rule 82    comparator -> NOT_EQUALS
Rule 83    parameter_list -> parameter
Rule 84    parameter_list -> parameter_list COMMA parameter
Rule 85    parameter -> type ID
Rule 86    parameter -> REQUIRED type ID
Rule 87    type -> INT
Rule 88    type -> DOUBLE
Rule 89    type -> STRING
Rule 90    type -> BOOL
Rule 91    type -> LIST
Rule 92    call_list -> LSBRACKET value_list RSBRACKET
Rule 93    list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
Rule 94    value_list -> value
Rule 95    value_list -> value_list COMMA value
Rule 96    value -> NUMBER
Rule 97    value -> NDOUBLE
Rule 98    value -> TEXT
Rule 99    value -> ID
Rule 100   value -> interpolated_string
Rule 101   value -> TRUE
Rule 102   value -> FALSE
Rule 103   interpolated_string -> TEXT PLUS ID
Rule 104   interpolated_string -> TEXT PLUS expression
Rule 105   set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
Rule 106   set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
Rule 107   set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
Rule 108   for_classic_initialization -> INT ID ASSIGN NUMBER
Rule 109   for_classic_initialization -> DOUBLE ID ASSIGN NDOUBLE
Rule 110   for_classic_conditions -> conditions
Rule 111   for_classic_changes -> ID comparator value
Rule 112   for_classic_changes -> ID INCREMENT
Rule 113   for_classic_changes -> ID DECREMENT
Rule 114   for_classic_changes -> ID comparator value COMMA for_classic_changes
Rule 115   for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON for_classic_changes
Rule 116   for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
Rule 117   for_in_parenthesis_content -> FINAL ID IN ID
Rule 118   for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
Rule 119   for_each_parenthesis_parenthesis_content -> COLON ID
Rule 120   for_each_parenthesis_parenthesis_content -> COLON ID COMMA for_each_parenthesis_parenthesis_content
Rule 121   for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID
Rule 122   for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
Rule 123   control_structures_for -> for_classic
Rule 124   control_structures_for -> for_in
Rule 125   control_structures_for -> for_each
Rule 126   constructor_parenthesis_content -> THIS DOT ID
Rule 127   constructor_parenthesis_content -> THIS DOT ID COMMA constructor_parenthesis_content
Rule 128   constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
Rule 129   function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
Rule 130   control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET
Rule 131   map -> map_declaration map_assignment
Rule 132   map_declaration -> MAP LESS key_type COMMA type GREATER ID ASSIGN
Rule 133   map_assignment -> LBRACKET map_contents RBRACKET
Rule 134   map_contents -> map_content
Rule 135   map_contents -> map_content COMMA map_contents
Rule 136   map_content -> key_value COLON value
Rule 137   key_value -> TEXT
Rule 138   key_type -> STRING

Terminals, with rules where they appear

ABSTRACT             : 
AND                  : 58 72
AS                   : 
ASSERT               : 
ASSIGN               : 22 23 34 35 36 37 38 39 40 93 105 106 107 108 109 129 132
ASYNC                : 
AWAIT                : 
BOOL                 : 90
BREAK                : 
CASE                 : 
CATCH                : 
CLASS                : 
COLON                : 119 120 136
COMMA                : 27 84 95 114 120 127 132 135
CONST                : 107
CONTINUE             : 
COVARIANT            : 
DECREMENT            : 113
DEFAULT              : 
DEFERRED             : 
DIVIDE               : 50 57
DO                   : 
DOLLARSIGN           : 
DOT                  : 22 23 24 25 126 127
DOUBLE               : 39 40 88 109
DOUBLE_COLON         : 
DYNAMIC              : 35
ELSE                 : 68 69 70
ENUM                 : 
EQUALS               : 79
EXPORT               : 
EXTENDS              : 
EXTENSION            : 
EXTERNAL             : 
FACTORY              : 
FALSE                : 102
FINAL                : 107 117 121
FINALLY              : 
FOR                  : 116 118 122
FUNCTION             : 
GET                  : 
GREATER              : 77 93 106 129 132
GREATER_EQUAL        : 80
HIDE                 : 
ID                   : 19 20 21 22 23 28 29 30 31 32 33 34 35 36 37 38 39 40 85 86 93 99 103 105 106 107 108 109 111 112 113 114 117 117 119 120 121 121 126 127 128 129 132
IF                   : 67 68 69
IMPLEMENTS           : 
IMPORT               : 
IN                   : 117 121
INCREMENT            : 112
INT                  : 37 38 87 108
INTERFACE            : 
IS                   : 
LATE                 : 
LBRACKET             : 28 29 30 31 32 33 67 68 69 70 105 106 107 116 118 122 130 133
LENGTH               : 24 25
LESS                 : 78 93 106 132
LESS_EQUAL           : 81
LIBRARY              : 
LIST                 : 91 93
LPAREN               : 20 21 22 23 28 29 30 31 32 33 41 42 43 44 45 67 68 69 76 116 118 121 122 128 129 130
LSBRACKET            : 92 93
MAP                  : 132
MINUS                : 48 55
MIXIN                : 
MODULE               : 
NDOUBLE              : 39 47 97 109
NEW                  : 
NOT                  : 75
NOT_EQUALS           : 82
NULL                 : 
NUM                  : 
NUMBER               : 38 46 96 108
NUMERAL              : 
OBJECT               : 
ON                   : 
OPERATOR             : 
OR                   : 59 73
PART                 : 
PLUS                 : 49 54 61 103 104
PRINT                : 41 42 43 44 45
QUESTION             : 23
RBRACKET             : 28 29 30 31 32 33 67 68 69 70 105 106 107 116 118 122 130 133
READLINESYNC         : 22 23
REQUIRED             : 86
RETHROW              : 
RETURN               : 
RPAREN               : 20 21 22 23 28 29 30 31 32 33 41 42 43 44 45 67 68 69 76 116 118 121 122 128 129
RSBRACKET            : 92 93
SEMICOLON            : 15 22 23 34 35 36 37 38 39 40 41 42 43 44 45 93 105 106 107 115 115 128
SET                  : 
SHOW                 : 
STATIC               : 
STDIN                : 22 23
STRING               : 22 23 89 106 138
SUPER                : 
SWITCH               : 
SYNC                 : 
TEXT                 : 25 98 103 104 137
THIS                 : 126 127
THROW                : 
TIMES                : 51 56
TRUE                 : 101
TRY                  : 
TYPEDEF              : 
VAR                  : 36 105 106
VOID                 : 29 31 32 33
WHILE                : 130
WITH                 : 
YIELD                : 
error                : 

Nonterminals, with rules where they appear

argument_list        : 20 27
call_function        : 14
call_list            : 24
comparator           : 60 74 111 114
condition            : 71 75
conditions           : 67 68 69 72 72 73 73 76 110 130
constructor          : 8
constructor_parenthesis_content : 127 128
control_structures   : 9
control_structures_for : 17
control_structures_if_else : 16
control_structures_while : 18
data_input           : 5
else_block           : 65 66
else_if_blocks       : 64 65 69
expression           : 26 27 34 35 36 44 54 54 55 55 56 56 57 57 58 58 59 59 104 129
for_classic          : 123
for_classic_changes  : 114 115
for_classic_conditions : 115
for_classic_initialization : 115
for_classic_parenthesis_content : 116
for_each             : 125
for_each_parenthesis_content : 122
for_each_parenthesis_parenthesis_content : 120 121
for_in               : 124
for_in_parenthesis_content : 118
function             : 10
if_block             : 63 64 65 66
interpolated_string  : 100
key_type             : 132
key_value            : 136
length               : 37 45
list_definition      : 11
list_numbers         : 52 52 53 53
map                  : 7
map_assignment       : 131
map_content          : 134 135
map_contents         : 133 135
map_declaration      : 131
parameter            : 83 84
parameter_list       : 28 29 33 84 129
print                : 4
program              : 0
set                  : 6
simple_operations_arithmetics : 40 42 53
simple_operators_arithmetics : 52 53 53
statement            : 2 3
statement_list       : 1 3 28 29 30 31 67 68 69 70 116 118 122 130
type                 : 28 30 34 85 86 93 129 132
value                : 43 60 60 61 61 62 74 74 94 95 111 114 136
value_list           : 92 93 95 105 107
variable_definition  : 12
variable_usage       : 13

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement_list
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    program                        shift and go to state 1
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 1

    (0) S' -> program .



state 2

    (1) program -> statement_list .
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    $end            reduce using rule 1 (program -> statement_list .)
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement                      shift and go to state 40
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 3

    (2) statement_list -> statement .

    SEMICOLON       reduce using rule 2 (statement_list -> statement .)
    PRINT           reduce using rule 2 (statement_list -> statement .)
    STRING          reduce using rule 2 (statement_list -> statement .)
    VAR             reduce using rule 2 (statement_list -> statement .)
    FINAL           reduce using rule 2 (statement_list -> statement .)
    ID              reduce using rule 2 (statement_list -> statement .)
    VOID            reduce using rule 2 (statement_list -> statement .)
    LIST            reduce using rule 2 (statement_list -> statement .)
    DYNAMIC         reduce using rule 2 (statement_list -> statement .)
    INT             reduce using rule 2 (statement_list -> statement .)
    DOUBLE          reduce using rule 2 (statement_list -> statement .)
    MAP             reduce using rule 2 (statement_list -> statement .)
    WHILE           reduce using rule 2 (statement_list -> statement .)
    BOOL            reduce using rule 2 (statement_list -> statement .)
    IF              reduce using rule 2 (statement_list -> statement .)
    FOR             reduce using rule 2 (statement_list -> statement .)
    $end            reduce using rule 2 (statement_list -> statement .)
    RBRACKET        reduce using rule 2 (statement_list -> statement .)


state 4

    (4) statement -> print .

    SEMICOLON       reduce using rule 4 (statement -> print .)
    PRINT           reduce using rule 4 (statement -> print .)
    STRING          reduce using rule 4 (statement -> print .)
    VAR             reduce using rule 4 (statement -> print .)
    FINAL           reduce using rule 4 (statement -> print .)
    ID              reduce using rule 4 (statement -> print .)
    VOID            reduce using rule 4 (statement -> print .)
    LIST            reduce using rule 4 (statement -> print .)
    DYNAMIC         reduce using rule 4 (statement -> print .)
    INT             reduce using rule 4 (statement -> print .)
    DOUBLE          reduce using rule 4 (statement -> print .)
    MAP             reduce using rule 4 (statement -> print .)
    WHILE           reduce using rule 4 (statement -> print .)
    BOOL            reduce using rule 4 (statement -> print .)
    IF              reduce using rule 4 (statement -> print .)
    FOR             reduce using rule 4 (statement -> print .)
    $end            reduce using rule 4 (statement -> print .)
    RBRACKET        reduce using rule 4 (statement -> print .)


state 5

    (5) statement -> data_input .

    SEMICOLON       reduce using rule 5 (statement -> data_input .)
    PRINT           reduce using rule 5 (statement -> data_input .)
    STRING          reduce using rule 5 (statement -> data_input .)
    VAR             reduce using rule 5 (statement -> data_input .)
    FINAL           reduce using rule 5 (statement -> data_input .)
    ID              reduce using rule 5 (statement -> data_input .)
    VOID            reduce using rule 5 (statement -> data_input .)
    LIST            reduce using rule 5 (statement -> data_input .)
    DYNAMIC         reduce using rule 5 (statement -> data_input .)
    INT             reduce using rule 5 (statement -> data_input .)
    DOUBLE          reduce using rule 5 (statement -> data_input .)
    MAP             reduce using rule 5 (statement -> data_input .)
    WHILE           reduce using rule 5 (statement -> data_input .)
    BOOL            reduce using rule 5 (statement -> data_input .)
    IF              reduce using rule 5 (statement -> data_input .)
    FOR             reduce using rule 5 (statement -> data_input .)
    $end            reduce using rule 5 (statement -> data_input .)
    RBRACKET        reduce using rule 5 (statement -> data_input .)


state 6

    (6) statement -> set .

    SEMICOLON       reduce using rule 6 (statement -> set .)
    PRINT           reduce using rule 6 (statement -> set .)
    STRING          reduce using rule 6 (statement -> set .)
    VAR             reduce using rule 6 (statement -> set .)
    FINAL           reduce using rule 6 (statement -> set .)
    ID              reduce using rule 6 (statement -> set .)
    VOID            reduce using rule 6 (statement -> set .)
    LIST            reduce using rule 6 (statement -> set .)
    DYNAMIC         reduce using rule 6 (statement -> set .)
    INT             reduce using rule 6 (statement -> set .)
    DOUBLE          reduce using rule 6 (statement -> set .)
    MAP             reduce using rule 6 (statement -> set .)
    WHILE           reduce using rule 6 (statement -> set .)
    BOOL            reduce using rule 6 (statement -> set .)
    IF              reduce using rule 6 (statement -> set .)
    FOR             reduce using rule 6 (statement -> set .)
    $end            reduce using rule 6 (statement -> set .)
    RBRACKET        reduce using rule 6 (statement -> set .)


state 7

    (7) statement -> map .

    SEMICOLON       reduce using rule 7 (statement -> map .)
    PRINT           reduce using rule 7 (statement -> map .)
    STRING          reduce using rule 7 (statement -> map .)
    VAR             reduce using rule 7 (statement -> map .)
    FINAL           reduce using rule 7 (statement -> map .)
    ID              reduce using rule 7 (statement -> map .)
    VOID            reduce using rule 7 (statement -> map .)
    LIST            reduce using rule 7 (statement -> map .)
    DYNAMIC         reduce using rule 7 (statement -> map .)
    INT             reduce using rule 7 (statement -> map .)
    DOUBLE          reduce using rule 7 (statement -> map .)
    MAP             reduce using rule 7 (statement -> map .)
    WHILE           reduce using rule 7 (statement -> map .)
    BOOL            reduce using rule 7 (statement -> map .)
    IF              reduce using rule 7 (statement -> map .)
    FOR             reduce using rule 7 (statement -> map .)
    $end            reduce using rule 7 (statement -> map .)
    RBRACKET        reduce using rule 7 (statement -> map .)


state 8

    (8) statement -> constructor .

    SEMICOLON       reduce using rule 8 (statement -> constructor .)
    PRINT           reduce using rule 8 (statement -> constructor .)
    STRING          reduce using rule 8 (statement -> constructor .)
    VAR             reduce using rule 8 (statement -> constructor .)
    FINAL           reduce using rule 8 (statement -> constructor .)
    ID              reduce using rule 8 (statement -> constructor .)
    VOID            reduce using rule 8 (statement -> constructor .)
    LIST            reduce using rule 8 (statement -> constructor .)
    DYNAMIC         reduce using rule 8 (statement -> constructor .)
    INT             reduce using rule 8 (statement -> constructor .)
    DOUBLE          reduce using rule 8 (statement -> constructor .)
    MAP             reduce using rule 8 (statement -> constructor .)
    WHILE           reduce using rule 8 (statement -> constructor .)
    BOOL            reduce using rule 8 (statement -> constructor .)
    IF              reduce using rule 8 (statement -> constructor .)
    FOR             reduce using rule 8 (statement -> constructor .)
    $end            reduce using rule 8 (statement -> constructor .)
    RBRACKET        reduce using rule 8 (statement -> constructor .)


state 9

    (9) statement -> control_structures .

    SEMICOLON       reduce using rule 9 (statement -> control_structures .)
    PRINT           reduce using rule 9 (statement -> control_structures .)
    STRING          reduce using rule 9 (statement -> control_structures .)
    VAR             reduce using rule 9 (statement -> control_structures .)
    FINAL           reduce using rule 9 (statement -> control_structures .)
    ID              reduce using rule 9 (statement -> control_structures .)
    VOID            reduce using rule 9 (statement -> control_structures .)
    LIST            reduce using rule 9 (statement -> control_structures .)
    DYNAMIC         reduce using rule 9 (statement -> control_structures .)
    INT             reduce using rule 9 (statement -> control_structures .)
    DOUBLE          reduce using rule 9 (statement -> control_structures .)
    MAP             reduce using rule 9 (statement -> control_structures .)
    WHILE           reduce using rule 9 (statement -> control_structures .)
    BOOL            reduce using rule 9 (statement -> control_structures .)
    IF              reduce using rule 9 (statement -> control_structures .)
    FOR             reduce using rule 9 (statement -> control_structures .)
    $end            reduce using rule 9 (statement -> control_structures .)
    RBRACKET        reduce using rule 9 (statement -> control_structures .)


state 10

    (10) statement -> function .

    SEMICOLON       reduce using rule 10 (statement -> function .)
    PRINT           reduce using rule 10 (statement -> function .)
    STRING          reduce using rule 10 (statement -> function .)
    VAR             reduce using rule 10 (statement -> function .)
    FINAL           reduce using rule 10 (statement -> function .)
    ID              reduce using rule 10 (statement -> function .)
    VOID            reduce using rule 10 (statement -> function .)
    LIST            reduce using rule 10 (statement -> function .)
    DYNAMIC         reduce using rule 10 (statement -> function .)
    INT             reduce using rule 10 (statement -> function .)
    DOUBLE          reduce using rule 10 (statement -> function .)
    MAP             reduce using rule 10 (statement -> function .)
    WHILE           reduce using rule 10 (statement -> function .)
    BOOL            reduce using rule 10 (statement -> function .)
    IF              reduce using rule 10 (statement -> function .)
    FOR             reduce using rule 10 (statement -> function .)
    $end            reduce using rule 10 (statement -> function .)
    RBRACKET        reduce using rule 10 (statement -> function .)


state 11

    (11) statement -> list_definition .

    SEMICOLON       reduce using rule 11 (statement -> list_definition .)
    PRINT           reduce using rule 11 (statement -> list_definition .)
    STRING          reduce using rule 11 (statement -> list_definition .)
    VAR             reduce using rule 11 (statement -> list_definition .)
    FINAL           reduce using rule 11 (statement -> list_definition .)
    ID              reduce using rule 11 (statement -> list_definition .)
    VOID            reduce using rule 11 (statement -> list_definition .)
    LIST            reduce using rule 11 (statement -> list_definition .)
    DYNAMIC         reduce using rule 11 (statement -> list_definition .)
    INT             reduce using rule 11 (statement -> list_definition .)
    DOUBLE          reduce using rule 11 (statement -> list_definition .)
    MAP             reduce using rule 11 (statement -> list_definition .)
    WHILE           reduce using rule 11 (statement -> list_definition .)
    BOOL            reduce using rule 11 (statement -> list_definition .)
    IF              reduce using rule 11 (statement -> list_definition .)
    FOR             reduce using rule 11 (statement -> list_definition .)
    $end            reduce using rule 11 (statement -> list_definition .)
    RBRACKET        reduce using rule 11 (statement -> list_definition .)


state 12

    (12) statement -> variable_definition .

    SEMICOLON       reduce using rule 12 (statement -> variable_definition .)
    PRINT           reduce using rule 12 (statement -> variable_definition .)
    STRING          reduce using rule 12 (statement -> variable_definition .)
    VAR             reduce using rule 12 (statement -> variable_definition .)
    FINAL           reduce using rule 12 (statement -> variable_definition .)
    ID              reduce using rule 12 (statement -> variable_definition .)
    VOID            reduce using rule 12 (statement -> variable_definition .)
    LIST            reduce using rule 12 (statement -> variable_definition .)
    DYNAMIC         reduce using rule 12 (statement -> variable_definition .)
    INT             reduce using rule 12 (statement -> variable_definition .)
    DOUBLE          reduce using rule 12 (statement -> variable_definition .)
    MAP             reduce using rule 12 (statement -> variable_definition .)
    WHILE           reduce using rule 12 (statement -> variable_definition .)
    BOOL            reduce using rule 12 (statement -> variable_definition .)
    IF              reduce using rule 12 (statement -> variable_definition .)
    FOR             reduce using rule 12 (statement -> variable_definition .)
    $end            reduce using rule 12 (statement -> variable_definition .)
    RBRACKET        reduce using rule 12 (statement -> variable_definition .)


state 13

    (13) statement -> variable_usage .

    SEMICOLON       reduce using rule 13 (statement -> variable_usage .)
    PRINT           reduce using rule 13 (statement -> variable_usage .)
    STRING          reduce using rule 13 (statement -> variable_usage .)
    VAR             reduce using rule 13 (statement -> variable_usage .)
    FINAL           reduce using rule 13 (statement -> variable_usage .)
    ID              reduce using rule 13 (statement -> variable_usage .)
    VOID            reduce using rule 13 (statement -> variable_usage .)
    LIST            reduce using rule 13 (statement -> variable_usage .)
    DYNAMIC         reduce using rule 13 (statement -> variable_usage .)
    INT             reduce using rule 13 (statement -> variable_usage .)
    DOUBLE          reduce using rule 13 (statement -> variable_usage .)
    MAP             reduce using rule 13 (statement -> variable_usage .)
    WHILE           reduce using rule 13 (statement -> variable_usage .)
    BOOL            reduce using rule 13 (statement -> variable_usage .)
    IF              reduce using rule 13 (statement -> variable_usage .)
    FOR             reduce using rule 13 (statement -> variable_usage .)
    $end            reduce using rule 13 (statement -> variable_usage .)
    RBRACKET        reduce using rule 13 (statement -> variable_usage .)


state 14

    (14) statement -> call_function .

    SEMICOLON       reduce using rule 14 (statement -> call_function .)
    PRINT           reduce using rule 14 (statement -> call_function .)
    STRING          reduce using rule 14 (statement -> call_function .)
    VAR             reduce using rule 14 (statement -> call_function .)
    FINAL           reduce using rule 14 (statement -> call_function .)
    ID              reduce using rule 14 (statement -> call_function .)
    VOID            reduce using rule 14 (statement -> call_function .)
    LIST            reduce using rule 14 (statement -> call_function .)
    DYNAMIC         reduce using rule 14 (statement -> call_function .)
    INT             reduce using rule 14 (statement -> call_function .)
    DOUBLE          reduce using rule 14 (statement -> call_function .)
    MAP             reduce using rule 14 (statement -> call_function .)
    WHILE           reduce using rule 14 (statement -> call_function .)
    BOOL            reduce using rule 14 (statement -> call_function .)
    IF              reduce using rule 14 (statement -> call_function .)
    FOR             reduce using rule 14 (statement -> call_function .)
    $end            reduce using rule 14 (statement -> call_function .)
    RBRACKET        reduce using rule 14 (statement -> call_function .)


state 15

    (15) statement -> SEMICOLON .

    SEMICOLON       reduce using rule 15 (statement -> SEMICOLON .)
    PRINT           reduce using rule 15 (statement -> SEMICOLON .)
    STRING          reduce using rule 15 (statement -> SEMICOLON .)
    VAR             reduce using rule 15 (statement -> SEMICOLON .)
    FINAL           reduce using rule 15 (statement -> SEMICOLON .)
    ID              reduce using rule 15 (statement -> SEMICOLON .)
    VOID            reduce using rule 15 (statement -> SEMICOLON .)
    LIST            reduce using rule 15 (statement -> SEMICOLON .)
    DYNAMIC         reduce using rule 15 (statement -> SEMICOLON .)
    INT             reduce using rule 15 (statement -> SEMICOLON .)
    DOUBLE          reduce using rule 15 (statement -> SEMICOLON .)
    MAP             reduce using rule 15 (statement -> SEMICOLON .)
    WHILE           reduce using rule 15 (statement -> SEMICOLON .)
    BOOL            reduce using rule 15 (statement -> SEMICOLON .)
    IF              reduce using rule 15 (statement -> SEMICOLON .)
    FOR             reduce using rule 15 (statement -> SEMICOLON .)
    $end            reduce using rule 15 (statement -> SEMICOLON .)
    RBRACKET        reduce using rule 15 (statement -> SEMICOLON .)


state 16

    (41) print -> PRINT . LPAREN RPAREN SEMICOLON
    (42) print -> PRINT . LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> PRINT . LPAREN value RPAREN SEMICOLON
    (44) print -> PRINT . LPAREN expression RPAREN SEMICOLON
    (45) print -> PRINT . LPAREN length RPAREN SEMICOLON

    LPAREN          shift and go to state 41


state 17

    (22) data_input -> STRING . ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> STRING . QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (89) type -> STRING .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 42
    QUESTION        shift and go to state 43

  ! ID              [ reduce using rule 89 (type -> STRING .) ]


state 18

    (128) constructor -> ID . LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (19) variable_usage -> ID .
    (20) call_function -> ID . LPAREN argument_list RPAREN
    (21) call_function -> ID . LPAREN RPAREN

    LPAREN          shift and go to state 44
    SEMICOLON       reduce using rule 19 (variable_usage -> ID .)
    PRINT           reduce using rule 19 (variable_usage -> ID .)
    STRING          reduce using rule 19 (variable_usage -> ID .)
    VAR             reduce using rule 19 (variable_usage -> ID .)
    FINAL           reduce using rule 19 (variable_usage -> ID .)
    ID              reduce using rule 19 (variable_usage -> ID .)
    VOID            reduce using rule 19 (variable_usage -> ID .)
    LIST            reduce using rule 19 (variable_usage -> ID .)
    DYNAMIC         reduce using rule 19 (variable_usage -> ID .)
    INT             reduce using rule 19 (variable_usage -> ID .)
    DOUBLE          reduce using rule 19 (variable_usage -> ID .)
    MAP             reduce using rule 19 (variable_usage -> ID .)
    WHILE           reduce using rule 19 (variable_usage -> ID .)
    BOOL            reduce using rule 19 (variable_usage -> ID .)
    IF              reduce using rule 19 (variable_usage -> ID .)
    FOR             reduce using rule 19 (variable_usage -> ID .)
    $end            reduce using rule 19 (variable_usage -> ID .)
    RBRACKET        reduce using rule 19 (variable_usage -> ID .)


state 19

    (105) set -> VAR . ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> VAR . ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (36) variable_definition -> VAR . ID ASSIGN expression SEMICOLON

    ID              shift and go to state 45


state 20

    (107) set -> FINAL . ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON

    ID              shift and go to state 46


state 21

    (131) map -> map_declaration . map_assignment
    (133) map_assignment -> . LBRACKET map_contents RBRACKET

    LBRACKET        shift and go to state 48

    map_assignment                 shift and go to state 47

state 22

    (16) control_structures -> control_structures_if_else .

    SEMICOLON       reduce using rule 16 (control_structures -> control_structures_if_else .)
    PRINT           reduce using rule 16 (control_structures -> control_structures_if_else .)
    STRING          reduce using rule 16 (control_structures -> control_structures_if_else .)
    VAR             reduce using rule 16 (control_structures -> control_structures_if_else .)
    FINAL           reduce using rule 16 (control_structures -> control_structures_if_else .)
    ID              reduce using rule 16 (control_structures -> control_structures_if_else .)
    VOID            reduce using rule 16 (control_structures -> control_structures_if_else .)
    LIST            reduce using rule 16 (control_structures -> control_structures_if_else .)
    DYNAMIC         reduce using rule 16 (control_structures -> control_structures_if_else .)
    INT             reduce using rule 16 (control_structures -> control_structures_if_else .)
    DOUBLE          reduce using rule 16 (control_structures -> control_structures_if_else .)
    MAP             reduce using rule 16 (control_structures -> control_structures_if_else .)
    WHILE           reduce using rule 16 (control_structures -> control_structures_if_else .)
    BOOL            reduce using rule 16 (control_structures -> control_structures_if_else .)
    IF              reduce using rule 16 (control_structures -> control_structures_if_else .)
    FOR             reduce using rule 16 (control_structures -> control_structures_if_else .)
    $end            reduce using rule 16 (control_structures -> control_structures_if_else .)
    RBRACKET        reduce using rule 16 (control_structures -> control_structures_if_else .)


state 23

    (17) control_structures -> control_structures_for .

    SEMICOLON       reduce using rule 17 (control_structures -> control_structures_for .)
    PRINT           reduce using rule 17 (control_structures -> control_structures_for .)
    STRING          reduce using rule 17 (control_structures -> control_structures_for .)
    VAR             reduce using rule 17 (control_structures -> control_structures_for .)
    FINAL           reduce using rule 17 (control_structures -> control_structures_for .)
    ID              reduce using rule 17 (control_structures -> control_structures_for .)
    VOID            reduce using rule 17 (control_structures -> control_structures_for .)
    LIST            reduce using rule 17 (control_structures -> control_structures_for .)
    DYNAMIC         reduce using rule 17 (control_structures -> control_structures_for .)
    INT             reduce using rule 17 (control_structures -> control_structures_for .)
    DOUBLE          reduce using rule 17 (control_structures -> control_structures_for .)
    MAP             reduce using rule 17 (control_structures -> control_structures_for .)
    WHILE           reduce using rule 17 (control_structures -> control_structures_for .)
    BOOL            reduce using rule 17 (control_structures -> control_structures_for .)
    IF              reduce using rule 17 (control_structures -> control_structures_for .)
    FOR             reduce using rule 17 (control_structures -> control_structures_for .)
    $end            reduce using rule 17 (control_structures -> control_structures_for .)
    RBRACKET        reduce using rule 17 (control_structures -> control_structures_for .)


state 24

    (18) control_structures -> control_structures_while .

    SEMICOLON       reduce using rule 18 (control_structures -> control_structures_while .)
    PRINT           reduce using rule 18 (control_structures -> control_structures_while .)
    STRING          reduce using rule 18 (control_structures -> control_structures_while .)
    VAR             reduce using rule 18 (control_structures -> control_structures_while .)
    FINAL           reduce using rule 18 (control_structures -> control_structures_while .)
    ID              reduce using rule 18 (control_structures -> control_structures_while .)
    VOID            reduce using rule 18 (control_structures -> control_structures_while .)
    LIST            reduce using rule 18 (control_structures -> control_structures_while .)
    DYNAMIC         reduce using rule 18 (control_structures -> control_structures_while .)
    INT             reduce using rule 18 (control_structures -> control_structures_while .)
    DOUBLE          reduce using rule 18 (control_structures -> control_structures_while .)
    MAP             reduce using rule 18 (control_structures -> control_structures_while .)
    WHILE           reduce using rule 18 (control_structures -> control_structures_while .)
    BOOL            reduce using rule 18 (control_structures -> control_structures_while .)
    IF              reduce using rule 18 (control_structures -> control_structures_while .)
    FOR             reduce using rule 18 (control_structures -> control_structures_while .)
    $end            reduce using rule 18 (control_structures -> control_structures_while .)
    RBRACKET        reduce using rule 18 (control_structures -> control_structures_while .)


state 25

    (28) function -> type . ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> type . ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (129) function -> type . ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (34) variable_definition -> type . ID ASSIGN expression SEMICOLON

    ID              shift and go to state 49


state 26

    (29) function -> VOID . ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (31) function -> VOID . ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> VOID . ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> VOID . ID LPAREN parameter_list RPAREN LBRACKET RBRACKET

    ID              shift and go to state 50


state 27

    (93) list_definition -> LIST . LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (91) type -> LIST .

    LESS            shift and go to state 51
    ID              reduce using rule 91 (type -> LIST .)


state 28

    (35) variable_definition -> DYNAMIC . ID ASSIGN expression SEMICOLON

    ID              shift and go to state 52


state 29

    (37) variable_definition -> INT . ID ASSIGN length SEMICOLON
    (38) variable_definition -> INT . ID ASSIGN NUMBER SEMICOLON
    (87) type -> INT .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 53

  ! ID              [ reduce using rule 87 (type -> INT .) ]


state 30

    (39) variable_definition -> DOUBLE . ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> DOUBLE . ID ASSIGN simple_operations_arithmetics SEMICOLON
    (88) type -> DOUBLE .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 54

  ! ID              [ reduce using rule 88 (type -> DOUBLE .) ]


state 31

    (132) map_declaration -> MAP . LESS key_type COMMA type GREATER ID ASSIGN

    LESS            shift and go to state 55


state 32

    (63) control_structures_if_else -> if_block .
    (64) control_structures_if_else -> if_block . else_if_blocks
    (65) control_structures_if_else -> if_block . else_if_blocks else_block
    (66) control_structures_if_else -> if_block . else_block
    (68) else_if_blocks -> . ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (69) else_if_blocks -> . else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (70) else_block -> . ELSE LBRACKET statement_list RBRACKET

    SEMICOLON       reduce using rule 63 (control_structures_if_else -> if_block .)
    PRINT           reduce using rule 63 (control_structures_if_else -> if_block .)
    STRING          reduce using rule 63 (control_structures_if_else -> if_block .)
    VAR             reduce using rule 63 (control_structures_if_else -> if_block .)
    FINAL           reduce using rule 63 (control_structures_if_else -> if_block .)
    ID              reduce using rule 63 (control_structures_if_else -> if_block .)
    VOID            reduce using rule 63 (control_structures_if_else -> if_block .)
    LIST            reduce using rule 63 (control_structures_if_else -> if_block .)
    DYNAMIC         reduce using rule 63 (control_structures_if_else -> if_block .)
    INT             reduce using rule 63 (control_structures_if_else -> if_block .)
    DOUBLE          reduce using rule 63 (control_structures_if_else -> if_block .)
    MAP             reduce using rule 63 (control_structures_if_else -> if_block .)
    WHILE           reduce using rule 63 (control_structures_if_else -> if_block .)
    BOOL            reduce using rule 63 (control_structures_if_else -> if_block .)
    IF              reduce using rule 63 (control_structures_if_else -> if_block .)
    FOR             reduce using rule 63 (control_structures_if_else -> if_block .)
    $end            reduce using rule 63 (control_structures_if_else -> if_block .)
    RBRACKET        reduce using rule 63 (control_structures_if_else -> if_block .)
    ELSE            shift and go to state 58

    else_if_blocks                 shift and go to state 56
    else_block                     shift and go to state 57

state 33

    (123) control_structures_for -> for_classic .

    SEMICOLON       reduce using rule 123 (control_structures_for -> for_classic .)
    PRINT           reduce using rule 123 (control_structures_for -> for_classic .)
    STRING          reduce using rule 123 (control_structures_for -> for_classic .)
    VAR             reduce using rule 123 (control_structures_for -> for_classic .)
    FINAL           reduce using rule 123 (control_structures_for -> for_classic .)
    ID              reduce using rule 123 (control_structures_for -> for_classic .)
    VOID            reduce using rule 123 (control_structures_for -> for_classic .)
    LIST            reduce using rule 123 (control_structures_for -> for_classic .)
    DYNAMIC         reduce using rule 123 (control_structures_for -> for_classic .)
    INT             reduce using rule 123 (control_structures_for -> for_classic .)
    DOUBLE          reduce using rule 123 (control_structures_for -> for_classic .)
    MAP             reduce using rule 123 (control_structures_for -> for_classic .)
    WHILE           reduce using rule 123 (control_structures_for -> for_classic .)
    BOOL            reduce using rule 123 (control_structures_for -> for_classic .)
    IF              reduce using rule 123 (control_structures_for -> for_classic .)
    FOR             reduce using rule 123 (control_structures_for -> for_classic .)
    $end            reduce using rule 123 (control_structures_for -> for_classic .)
    RBRACKET        reduce using rule 123 (control_structures_for -> for_classic .)


state 34

    (124) control_structures_for -> for_in .

    SEMICOLON       reduce using rule 124 (control_structures_for -> for_in .)
    PRINT           reduce using rule 124 (control_structures_for -> for_in .)
    STRING          reduce using rule 124 (control_structures_for -> for_in .)
    VAR             reduce using rule 124 (control_structures_for -> for_in .)
    FINAL           reduce using rule 124 (control_structures_for -> for_in .)
    ID              reduce using rule 124 (control_structures_for -> for_in .)
    VOID            reduce using rule 124 (control_structures_for -> for_in .)
    LIST            reduce using rule 124 (control_structures_for -> for_in .)
    DYNAMIC         reduce using rule 124 (control_structures_for -> for_in .)
    INT             reduce using rule 124 (control_structures_for -> for_in .)
    DOUBLE          reduce using rule 124 (control_structures_for -> for_in .)
    MAP             reduce using rule 124 (control_structures_for -> for_in .)
    WHILE           reduce using rule 124 (control_structures_for -> for_in .)
    BOOL            reduce using rule 124 (control_structures_for -> for_in .)
    IF              reduce using rule 124 (control_structures_for -> for_in .)
    FOR             reduce using rule 124 (control_structures_for -> for_in .)
    $end            reduce using rule 124 (control_structures_for -> for_in .)
    RBRACKET        reduce using rule 124 (control_structures_for -> for_in .)


state 35

    (125) control_structures_for -> for_each .

    SEMICOLON       reduce using rule 125 (control_structures_for -> for_each .)
    PRINT           reduce using rule 125 (control_structures_for -> for_each .)
    STRING          reduce using rule 125 (control_structures_for -> for_each .)
    VAR             reduce using rule 125 (control_structures_for -> for_each .)
    FINAL           reduce using rule 125 (control_structures_for -> for_each .)
    ID              reduce using rule 125 (control_structures_for -> for_each .)
    VOID            reduce using rule 125 (control_structures_for -> for_each .)
    LIST            reduce using rule 125 (control_structures_for -> for_each .)
    DYNAMIC         reduce using rule 125 (control_structures_for -> for_each .)
    INT             reduce using rule 125 (control_structures_for -> for_each .)
    DOUBLE          reduce using rule 125 (control_structures_for -> for_each .)
    MAP             reduce using rule 125 (control_structures_for -> for_each .)
    WHILE           reduce using rule 125 (control_structures_for -> for_each .)
    BOOL            reduce using rule 125 (control_structures_for -> for_each .)
    IF              reduce using rule 125 (control_structures_for -> for_each .)
    FOR             reduce using rule 125 (control_structures_for -> for_each .)
    $end            reduce using rule 125 (control_structures_for -> for_each .)
    RBRACKET        reduce using rule 125 (control_structures_for -> for_each .)


state 36

    (130) control_structures_while -> WHILE . LPAREN conditions LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 59


state 37

    (90) type -> BOOL .

    ID              reduce using rule 90 (type -> BOOL .)
    GREATER         reduce using rule 90 (type -> BOOL .)


state 38

    (67) if_block -> IF . LPAREN conditions RPAREN LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 60


state 39

    (116) for_classic -> FOR . LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> FOR . LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> FOR . LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 61


state 40

    (3) statement_list -> statement_list statement .

    SEMICOLON       reduce using rule 3 (statement_list -> statement_list statement .)
    PRINT           reduce using rule 3 (statement_list -> statement_list statement .)
    STRING          reduce using rule 3 (statement_list -> statement_list statement .)
    VAR             reduce using rule 3 (statement_list -> statement_list statement .)
    FINAL           reduce using rule 3 (statement_list -> statement_list statement .)
    ID              reduce using rule 3 (statement_list -> statement_list statement .)
    VOID            reduce using rule 3 (statement_list -> statement_list statement .)
    LIST            reduce using rule 3 (statement_list -> statement_list statement .)
    DYNAMIC         reduce using rule 3 (statement_list -> statement_list statement .)
    INT             reduce using rule 3 (statement_list -> statement_list statement .)
    DOUBLE          reduce using rule 3 (statement_list -> statement_list statement .)
    MAP             reduce using rule 3 (statement_list -> statement_list statement .)
    WHILE           reduce using rule 3 (statement_list -> statement_list statement .)
    BOOL            reduce using rule 3 (statement_list -> statement_list statement .)
    IF              reduce using rule 3 (statement_list -> statement_list statement .)
    FOR             reduce using rule 3 (statement_list -> statement_list statement .)
    $end            reduce using rule 3 (statement_list -> statement_list statement .)
    RBRACKET        reduce using rule 3 (statement_list -> statement_list statement .)


state 41

    (41) print -> PRINT LPAREN . RPAREN SEMICOLON
    (42) print -> PRINT LPAREN . simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> PRINT LPAREN . value RPAREN SEMICOLON
    (44) print -> PRINT LPAREN . expression RPAREN SEMICOLON
    (45) print -> PRINT LPAREN . length RPAREN SEMICOLON
    (52) simple_operations_arithmetics -> . list_numbers simple_operators_arithmetics list_numbers
    (53) simple_operations_arithmetics -> . list_numbers simple_operators_arithmetics list_numbers simple_operators_arithmetics simple_operations_arithmetics
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (54) expression -> . expression PLUS expression
    (55) expression -> . expression MINUS expression
    (56) expression -> . expression TIMES expression
    (57) expression -> . expression DIVIDE expression
    (58) expression -> . expression AND expression
    (59) expression -> . expression OR expression
    (60) expression -> . value comparator value
    (61) expression -> . value PLUS value
    (62) expression -> . value
    (24) length -> . call_list DOT LENGTH
    (25) length -> . TEXT DOT LENGTH
    (46) list_numbers -> . NUMBER
    (47) list_numbers -> . NDOUBLE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression
    (92) call_list -> . LSBRACKET value_list RSBRACKET

    RPAREN          shift and go to state 62
    NUMBER          shift and go to state 68
    NDOUBLE         shift and go to state 69
    TEXT            shift and go to state 70
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    LSBRACKET       shift and go to state 76

    simple_operations_arithmetics  shift and go to state 63
    value                          shift and go to state 64
    expression                     shift and go to state 65
    length                         shift and go to state 66
    list_numbers                   shift and go to state 67
    interpolated_string            shift and go to state 72
    call_list                      shift and go to state 75

state 42

    (22) data_input -> STRING ID . ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    ASSIGN          shift and go to state 77


state 43

    (23) data_input -> STRING QUESTION . ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    ID              shift and go to state 78


state 44

    (128) constructor -> ID LPAREN . constructor_parenthesis_content RPAREN SEMICOLON
    (20) call_function -> ID LPAREN . argument_list RPAREN
    (21) call_function -> ID LPAREN . RPAREN
    (126) constructor_parenthesis_content -> . THIS DOT ID
    (127) constructor_parenthesis_content -> . THIS DOT ID COMMA constructor_parenthesis_content
    (26) argument_list -> . expression
    (27) argument_list -> . argument_list COMMA expression
    (54) expression -> . expression PLUS expression
    (55) expression -> . expression MINUS expression
    (56) expression -> . expression TIMES expression
    (57) expression -> . expression DIVIDE expression
    (58) expression -> . expression AND expression
    (59) expression -> . expression OR expression
    (60) expression -> . value comparator value
    (61) expression -> . value PLUS value
    (62) expression -> . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    RPAREN          shift and go to state 80
    THIS            shift and go to state 82
    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    constructor_parenthesis_content shift and go to state 79
    argument_list                  shift and go to state 81
    expression                     shift and go to state 83
    value                          shift and go to state 84
    interpolated_string            shift and go to state 72

state 45

    (105) set -> VAR ID . ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> VAR ID . ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (36) variable_definition -> VAR ID . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 88


state 46

    (107) set -> FINAL ID . ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON

    ASSIGN          shift and go to state 89


state 47

    (131) map -> map_declaration map_assignment .

    SEMICOLON       reduce using rule 131 (map -> map_declaration map_assignment .)
    PRINT           reduce using rule 131 (map -> map_declaration map_assignment .)
    STRING          reduce using rule 131 (map -> map_declaration map_assignment .)
    VAR             reduce using rule 131 (map -> map_declaration map_assignment .)
    FINAL           reduce using rule 131 (map -> map_declaration map_assignment .)
    ID              reduce using rule 131 (map -> map_declaration map_assignment .)
    VOID            reduce using rule 131 (map -> map_declaration map_assignment .)
    LIST            reduce using rule 131 (map -> map_declaration map_assignment .)
    DYNAMIC         reduce using rule 131 (map -> map_declaration map_assignment .)
    INT             reduce using rule 131 (map -> map_declaration map_assignment .)
    DOUBLE          reduce using rule 131 (map -> map_declaration map_assignment .)
    MAP             reduce using rule 131 (map -> map_declaration map_assignment .)
    WHILE           reduce using rule 131 (map -> map_declaration map_assignment .)
    BOOL            reduce using rule 131 (map -> map_declaration map_assignment .)
    IF              reduce using rule 131 (map -> map_declaration map_assignment .)
    FOR             reduce using rule 131 (map -> map_declaration map_assignment .)
    $end            reduce using rule 131 (map -> map_declaration map_assignment .)
    RBRACKET        reduce using rule 131 (map -> map_declaration map_assignment .)


state 48

    (133) map_assignment -> LBRACKET . map_contents RBRACKET
    (134) map_contents -> . map_content
    (135) map_contents -> . map_content COMMA map_contents
    (136) map_content -> . key_value COLON value
    (137) key_value -> . TEXT

    TEXT            shift and go to state 93

    map_contents                   shift and go to state 90
    map_content                    shift and go to state 91
    key_value                      shift and go to state 92

state 49

    (28) function -> type ID . LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> type ID . LPAREN RPAREN LBRACKET statement_list RBRACKET
    (129) function -> type ID . LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (34) variable_definition -> type ID . ASSIGN expression SEMICOLON

    LPAREN          shift and go to state 94
    ASSIGN          shift and go to state 95


state 50

    (29) function -> VOID ID . LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (31) function -> VOID ID . LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> VOID ID . LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> VOID ID . LPAREN parameter_list RPAREN LBRACKET RBRACKET

    LPAREN          shift and go to state 96


state 51

    (93) list_definition -> LIST LESS . type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST

    INT             shift and go to state 99
    DOUBLE          shift and go to state 100
    STRING          shift and go to state 101
    BOOL            shift and go to state 37
    LIST            shift and go to state 97

    type                           shift and go to state 98

state 52

    (35) variable_definition -> DYNAMIC ID . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 102


state 53

    (37) variable_definition -> INT ID . ASSIGN length SEMICOLON
    (38) variable_definition -> INT ID . ASSIGN NUMBER SEMICOLON

    ASSIGN          shift and go to state 103


state 54

    (39) variable_definition -> DOUBLE ID . ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> DOUBLE ID . ASSIGN simple_operations_arithmetics SEMICOLON

    ASSIGN          shift and go to state 104


state 55

    (132) map_declaration -> MAP LESS . key_type COMMA type GREATER ID ASSIGN
    (138) key_type -> . STRING

    STRING          shift and go to state 106

    key_type                       shift and go to state 105

state 56

    (64) control_structures_if_else -> if_block else_if_blocks .
    (65) control_structures_if_else -> if_block else_if_blocks . else_block
    (69) else_if_blocks -> else_if_blocks . ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (70) else_block -> . ELSE LBRACKET statement_list RBRACKET

    SEMICOLON       reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    PRINT           reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    STRING          reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    VAR             reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    FINAL           reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    ID              reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    VOID            reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    LIST            reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    DYNAMIC         reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    INT             reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    DOUBLE          reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    MAP             reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    WHILE           reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    BOOL            reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    IF              reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    FOR             reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    $end            reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    RBRACKET        reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    ELSE            shift and go to state 108

    else_block                     shift and go to state 107

state 57

    (66) control_structures_if_else -> if_block else_block .

    SEMICOLON       reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    PRINT           reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    STRING          reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    VAR             reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    FINAL           reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    ID              reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    VOID            reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    LIST            reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    DYNAMIC         reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    INT             reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    DOUBLE          reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    MAP             reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    WHILE           reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    BOOL            reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    IF              reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    FOR             reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    $end            reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    RBRACKET        reduce using rule 66 (control_structures_if_else -> if_block else_block .)


state 58

    (68) else_if_blocks -> ELSE . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (70) else_block -> ELSE . LBRACKET statement_list RBRACKET

    IF              shift and go to state 109
    LBRACKET        shift and go to state 110


state 59

    (130) control_structures_while -> WHILE LPAREN . conditions LBRACKET statement_list RBRACKET
    (71) conditions -> . condition
    (72) conditions -> . conditions AND conditions
    (73) conditions -> . conditions OR conditions
    (74) condition -> . value comparator value
    (75) condition -> . NOT condition
    (76) condition -> . LPAREN conditions RPAREN
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 115
    LPAREN          shift and go to state 111
    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    conditions                     shift and go to state 112
    condition                      shift and go to state 113
    value                          shift and go to state 114
    interpolated_string            shift and go to state 72

state 60

    (67) if_block -> IF LPAREN . conditions RPAREN LBRACKET statement_list RBRACKET
    (71) conditions -> . condition
    (72) conditions -> . conditions AND conditions
    (73) conditions -> . conditions OR conditions
    (74) condition -> . value comparator value
    (75) condition -> . NOT condition
    (76) condition -> . LPAREN conditions RPAREN
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 115
    LPAREN          shift and go to state 111
    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    conditions                     shift and go to state 116
    condition                      shift and go to state 113
    value                          shift and go to state 114
    interpolated_string            shift and go to state 72

state 61

    (116) for_classic -> FOR LPAREN . for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> FOR LPAREN . for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> FOR LPAREN . for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (115) for_classic_parenthesis_content -> . for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON for_classic_changes
    (117) for_in_parenthesis_content -> . FINAL ID IN ID
    (121) for_each_parenthesis_content -> . FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID
    (108) for_classic_initialization -> . INT ID ASSIGN NUMBER
    (109) for_classic_initialization -> . DOUBLE ID ASSIGN NDOUBLE

    FINAL           shift and go to state 121
    INT             shift and go to state 122
    DOUBLE          shift and go to state 123

    for_classic_parenthesis_content shift and go to state 117
    for_in_parenthesis_content     shift and go to state 118
    for_each_parenthesis_content   shift and go to state 119
    for_classic_initialization     shift and go to state 120

state 62

    (41) print -> PRINT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 124


state 63

    (42) print -> PRINT LPAREN simple_operations_arithmetics . RPAREN SEMICOLON

    RPAREN          shift and go to state 125


state 64

    (43) print -> PRINT LPAREN value . RPAREN SEMICOLON
    (60) expression -> value . comparator value
    (61) expression -> value . PLUS value
    (62) expression -> value .
    (77) comparator -> . GREATER
    (78) comparator -> . LESS
    (79) comparator -> . EQUALS
    (80) comparator -> . GREATER_EQUAL
    (81) comparator -> . LESS_EQUAL
    (82) comparator -> . NOT_EQUALS

  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
    RPAREN          shift and go to state 126
    PLUS            shift and go to state 128
    MINUS           reduce using rule 62 (expression -> value .)
    TIMES           reduce using rule 62 (expression -> value .)
    DIVIDE          reduce using rule 62 (expression -> value .)
    AND             reduce using rule 62 (expression -> value .)
    OR              reduce using rule 62 (expression -> value .)
    GREATER         shift and go to state 129
    LESS            shift and go to state 130
    EQUALS          shift and go to state 131
    GREATER_EQUAL   shift and go to state 132
    LESS_EQUAL      shift and go to state 133
    NOT_EQUALS      shift and go to state 134

  ! RPAREN          [ reduce using rule 62 (expression -> value .) ]
  ! PLUS            [ reduce using rule 62 (expression -> value .) ]

    comparator                     shift and go to state 127

state 65

    (44) print -> PRINT LPAREN expression . RPAREN SEMICOLON
    (54) expression -> expression . PLUS expression
    (55) expression -> expression . MINUS expression
    (56) expression -> expression . TIMES expression
    (57) expression -> expression . DIVIDE expression
    (58) expression -> expression . AND expression
    (59) expression -> expression . OR expression

    RPAREN          shift and go to state 135
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    AND             shift and go to state 140
    OR              shift and go to state 141


state 66

    (45) print -> PRINT LPAREN length . RPAREN SEMICOLON

    RPAREN          shift and go to state 142


state 67

    (52) simple_operations_arithmetics -> list_numbers . simple_operators_arithmetics list_numbers
    (53) simple_operations_arithmetics -> list_numbers . simple_operators_arithmetics list_numbers simple_operators_arithmetics simple_operations_arithmetics
    (48) simple_operators_arithmetics -> . MINUS
    (49) simple_operators_arithmetics -> . PLUS
    (50) simple_operators_arithmetics -> . DIVIDE
    (51) simple_operators_arithmetics -> . TIMES

    MINUS           shift and go to state 144
    PLUS            shift and go to state 145
    DIVIDE          shift and go to state 146
    TIMES           shift and go to state 147

    simple_operators_arithmetics   shift and go to state 143

state 68

    (96) value -> NUMBER .
    (46) list_numbers -> NUMBER .

  ! reduce/reduce conflict for MINUS resolved using rule 46 (list_numbers -> NUMBER .)
  ! reduce/reduce conflict for PLUS resolved using rule 46 (list_numbers -> NUMBER .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 46 (list_numbers -> NUMBER .)
  ! reduce/reduce conflict for TIMES resolved using rule 46 (list_numbers -> NUMBER .)
    RPAREN          reduce using rule 96 (value -> NUMBER .)
    GREATER         reduce using rule 96 (value -> NUMBER .)
    LESS            reduce using rule 96 (value -> NUMBER .)
    EQUALS          reduce using rule 96 (value -> NUMBER .)
    GREATER_EQUAL   reduce using rule 96 (value -> NUMBER .)
    LESS_EQUAL      reduce using rule 96 (value -> NUMBER .)
    NOT_EQUALS      reduce using rule 96 (value -> NUMBER .)
    AND             reduce using rule 96 (value -> NUMBER .)
    OR              reduce using rule 96 (value -> NUMBER .)
    MINUS           reduce using rule 46 (list_numbers -> NUMBER .)
    PLUS            reduce using rule 46 (list_numbers -> NUMBER .)
    DIVIDE          reduce using rule 46 (list_numbers -> NUMBER .)
    TIMES           reduce using rule 46 (list_numbers -> NUMBER .)

  ! PLUS            [ reduce using rule 96 (value -> NUMBER .) ]
  ! MINUS           [ reduce using rule 96 (value -> NUMBER .) ]
  ! TIMES           [ reduce using rule 96 (value -> NUMBER .) ]
  ! DIVIDE          [ reduce using rule 96 (value -> NUMBER .) ]


state 69

    (97) value -> NDOUBLE .
    (47) list_numbers -> NDOUBLE .

  ! reduce/reduce conflict for MINUS resolved using rule 47 (list_numbers -> NDOUBLE .)
  ! reduce/reduce conflict for PLUS resolved using rule 47 (list_numbers -> NDOUBLE .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 47 (list_numbers -> NDOUBLE .)
  ! reduce/reduce conflict for TIMES resolved using rule 47 (list_numbers -> NDOUBLE .)
    RPAREN          reduce using rule 97 (value -> NDOUBLE .)
    GREATER         reduce using rule 97 (value -> NDOUBLE .)
    LESS            reduce using rule 97 (value -> NDOUBLE .)
    EQUALS          reduce using rule 97 (value -> NDOUBLE .)
    GREATER_EQUAL   reduce using rule 97 (value -> NDOUBLE .)
    LESS_EQUAL      reduce using rule 97 (value -> NDOUBLE .)
    NOT_EQUALS      reduce using rule 97 (value -> NDOUBLE .)
    AND             reduce using rule 97 (value -> NDOUBLE .)
    OR              reduce using rule 97 (value -> NDOUBLE .)
    MINUS           reduce using rule 47 (list_numbers -> NDOUBLE .)
    PLUS            reduce using rule 47 (list_numbers -> NDOUBLE .)
    DIVIDE          reduce using rule 47 (list_numbers -> NDOUBLE .)
    TIMES           reduce using rule 47 (list_numbers -> NDOUBLE .)

  ! PLUS            [ reduce using rule 97 (value -> NDOUBLE .) ]
  ! MINUS           [ reduce using rule 97 (value -> NDOUBLE .) ]
  ! TIMES           [ reduce using rule 97 (value -> NDOUBLE .) ]
  ! DIVIDE          [ reduce using rule 97 (value -> NDOUBLE .) ]


state 70

    (98) value -> TEXT .
    (25) length -> TEXT . DOT LENGTH
    (103) interpolated_string -> TEXT . PLUS ID
    (104) interpolated_string -> TEXT . PLUS expression

  ! shift/reduce conflict for PLUS resolved as shift
    RPAREN          reduce using rule 98 (value -> TEXT .)
    GREATER         reduce using rule 98 (value -> TEXT .)
    LESS            reduce using rule 98 (value -> TEXT .)
    EQUALS          reduce using rule 98 (value -> TEXT .)
    GREATER_EQUAL   reduce using rule 98 (value -> TEXT .)
    LESS_EQUAL      reduce using rule 98 (value -> TEXT .)
    NOT_EQUALS      reduce using rule 98 (value -> TEXT .)
    MINUS           reduce using rule 98 (value -> TEXT .)
    TIMES           reduce using rule 98 (value -> TEXT .)
    DIVIDE          reduce using rule 98 (value -> TEXT .)
    AND             reduce using rule 98 (value -> TEXT .)
    OR              reduce using rule 98 (value -> TEXT .)
    DOT             shift and go to state 148
    PLUS            shift and go to state 149

  ! PLUS            [ reduce using rule 98 (value -> TEXT .) ]


state 71

    (99) value -> ID .

    RPAREN          reduce using rule 99 (value -> ID .)
    PLUS            reduce using rule 99 (value -> ID .)
    GREATER         reduce using rule 99 (value -> ID .)
    LESS            reduce using rule 99 (value -> ID .)
    EQUALS          reduce using rule 99 (value -> ID .)
    GREATER_EQUAL   reduce using rule 99 (value -> ID .)
    LESS_EQUAL      reduce using rule 99 (value -> ID .)
    NOT_EQUALS      reduce using rule 99 (value -> ID .)
    MINUS           reduce using rule 99 (value -> ID .)
    TIMES           reduce using rule 99 (value -> ID .)
    DIVIDE          reduce using rule 99 (value -> ID .)
    AND             reduce using rule 99 (value -> ID .)
    OR              reduce using rule 99 (value -> ID .)
    COMMA           reduce using rule 99 (value -> ID .)
    RSBRACKET       reduce using rule 99 (value -> ID .)
    SEMICOLON       reduce using rule 99 (value -> ID .)
    PRINT           reduce using rule 99 (value -> ID .)
    STRING          reduce using rule 99 (value -> ID .)
    VAR             reduce using rule 99 (value -> ID .)
    FINAL           reduce using rule 99 (value -> ID .)
    ID              reduce using rule 99 (value -> ID .)
    VOID            reduce using rule 99 (value -> ID .)
    LIST            reduce using rule 99 (value -> ID .)
    DYNAMIC         reduce using rule 99 (value -> ID .)
    INT             reduce using rule 99 (value -> ID .)
    DOUBLE          reduce using rule 99 (value -> ID .)
    MAP             reduce using rule 99 (value -> ID .)
    WHILE           reduce using rule 99 (value -> ID .)
    BOOL            reduce using rule 99 (value -> ID .)
    IF              reduce using rule 99 (value -> ID .)
    FOR             reduce using rule 99 (value -> ID .)
    $end            reduce using rule 99 (value -> ID .)
    RBRACKET        reduce using rule 99 (value -> ID .)
    LBRACKET        reduce using rule 99 (value -> ID .)


state 72

    (100) value -> interpolated_string .

    RPAREN          reduce using rule 100 (value -> interpolated_string .)
    PLUS            reduce using rule 100 (value -> interpolated_string .)
    GREATER         reduce using rule 100 (value -> interpolated_string .)
    LESS            reduce using rule 100 (value -> interpolated_string .)
    EQUALS          reduce using rule 100 (value -> interpolated_string .)
    GREATER_EQUAL   reduce using rule 100 (value -> interpolated_string .)
    LESS_EQUAL      reduce using rule 100 (value -> interpolated_string .)
    NOT_EQUALS      reduce using rule 100 (value -> interpolated_string .)
    MINUS           reduce using rule 100 (value -> interpolated_string .)
    TIMES           reduce using rule 100 (value -> interpolated_string .)
    DIVIDE          reduce using rule 100 (value -> interpolated_string .)
    AND             reduce using rule 100 (value -> interpolated_string .)
    OR              reduce using rule 100 (value -> interpolated_string .)
    COMMA           reduce using rule 100 (value -> interpolated_string .)
    RSBRACKET       reduce using rule 100 (value -> interpolated_string .)
    SEMICOLON       reduce using rule 100 (value -> interpolated_string .)
    PRINT           reduce using rule 100 (value -> interpolated_string .)
    STRING          reduce using rule 100 (value -> interpolated_string .)
    VAR             reduce using rule 100 (value -> interpolated_string .)
    FINAL           reduce using rule 100 (value -> interpolated_string .)
    ID              reduce using rule 100 (value -> interpolated_string .)
    VOID            reduce using rule 100 (value -> interpolated_string .)
    LIST            reduce using rule 100 (value -> interpolated_string .)
    DYNAMIC         reduce using rule 100 (value -> interpolated_string .)
    INT             reduce using rule 100 (value -> interpolated_string .)
    DOUBLE          reduce using rule 100 (value -> interpolated_string .)
    MAP             reduce using rule 100 (value -> interpolated_string .)
    WHILE           reduce using rule 100 (value -> interpolated_string .)
    BOOL            reduce using rule 100 (value -> interpolated_string .)
    IF              reduce using rule 100 (value -> interpolated_string .)
    FOR             reduce using rule 100 (value -> interpolated_string .)
    $end            reduce using rule 100 (value -> interpolated_string .)
    RBRACKET        reduce using rule 100 (value -> interpolated_string .)
    LBRACKET        reduce using rule 100 (value -> interpolated_string .)


state 73

    (101) value -> TRUE .

    RPAREN          reduce using rule 101 (value -> TRUE .)
    PLUS            reduce using rule 101 (value -> TRUE .)
    GREATER         reduce using rule 101 (value -> TRUE .)
    LESS            reduce using rule 101 (value -> TRUE .)
    EQUALS          reduce using rule 101 (value -> TRUE .)
    GREATER_EQUAL   reduce using rule 101 (value -> TRUE .)
    LESS_EQUAL      reduce using rule 101 (value -> TRUE .)
    NOT_EQUALS      reduce using rule 101 (value -> TRUE .)
    MINUS           reduce using rule 101 (value -> TRUE .)
    TIMES           reduce using rule 101 (value -> TRUE .)
    DIVIDE          reduce using rule 101 (value -> TRUE .)
    AND             reduce using rule 101 (value -> TRUE .)
    OR              reduce using rule 101 (value -> TRUE .)
    COMMA           reduce using rule 101 (value -> TRUE .)
    RSBRACKET       reduce using rule 101 (value -> TRUE .)
    SEMICOLON       reduce using rule 101 (value -> TRUE .)
    PRINT           reduce using rule 101 (value -> TRUE .)
    STRING          reduce using rule 101 (value -> TRUE .)
    VAR             reduce using rule 101 (value -> TRUE .)
    FINAL           reduce using rule 101 (value -> TRUE .)
    ID              reduce using rule 101 (value -> TRUE .)
    VOID            reduce using rule 101 (value -> TRUE .)
    LIST            reduce using rule 101 (value -> TRUE .)
    DYNAMIC         reduce using rule 101 (value -> TRUE .)
    INT             reduce using rule 101 (value -> TRUE .)
    DOUBLE          reduce using rule 101 (value -> TRUE .)
    MAP             reduce using rule 101 (value -> TRUE .)
    WHILE           reduce using rule 101 (value -> TRUE .)
    BOOL            reduce using rule 101 (value -> TRUE .)
    IF              reduce using rule 101 (value -> TRUE .)
    FOR             reduce using rule 101 (value -> TRUE .)
    $end            reduce using rule 101 (value -> TRUE .)
    RBRACKET        reduce using rule 101 (value -> TRUE .)
    LBRACKET        reduce using rule 101 (value -> TRUE .)


state 74

    (102) value -> FALSE .

    RPAREN          reduce using rule 102 (value -> FALSE .)
    PLUS            reduce using rule 102 (value -> FALSE .)
    GREATER         reduce using rule 102 (value -> FALSE .)
    LESS            reduce using rule 102 (value -> FALSE .)
    EQUALS          reduce using rule 102 (value -> FALSE .)
    GREATER_EQUAL   reduce using rule 102 (value -> FALSE .)
    LESS_EQUAL      reduce using rule 102 (value -> FALSE .)
    NOT_EQUALS      reduce using rule 102 (value -> FALSE .)
    MINUS           reduce using rule 102 (value -> FALSE .)
    TIMES           reduce using rule 102 (value -> FALSE .)
    DIVIDE          reduce using rule 102 (value -> FALSE .)
    AND             reduce using rule 102 (value -> FALSE .)
    OR              reduce using rule 102 (value -> FALSE .)
    COMMA           reduce using rule 102 (value -> FALSE .)
    RSBRACKET       reduce using rule 102 (value -> FALSE .)
    SEMICOLON       reduce using rule 102 (value -> FALSE .)
    PRINT           reduce using rule 102 (value -> FALSE .)
    STRING          reduce using rule 102 (value -> FALSE .)
    VAR             reduce using rule 102 (value -> FALSE .)
    FINAL           reduce using rule 102 (value -> FALSE .)
    ID              reduce using rule 102 (value -> FALSE .)
    VOID            reduce using rule 102 (value -> FALSE .)
    LIST            reduce using rule 102 (value -> FALSE .)
    DYNAMIC         reduce using rule 102 (value -> FALSE .)
    INT             reduce using rule 102 (value -> FALSE .)
    DOUBLE          reduce using rule 102 (value -> FALSE .)
    MAP             reduce using rule 102 (value -> FALSE .)
    WHILE           reduce using rule 102 (value -> FALSE .)
    BOOL            reduce using rule 102 (value -> FALSE .)
    IF              reduce using rule 102 (value -> FALSE .)
    FOR             reduce using rule 102 (value -> FALSE .)
    $end            reduce using rule 102 (value -> FALSE .)
    RBRACKET        reduce using rule 102 (value -> FALSE .)
    LBRACKET        reduce using rule 102 (value -> FALSE .)


state 75

    (24) length -> call_list . DOT LENGTH

    DOT             shift and go to state 150


state 76

    (92) call_list -> LSBRACKET . value_list RSBRACKET
    (94) value_list -> . value
    (95) value_list -> . value_list COMMA value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    value_list                     shift and go to state 151
    value                          shift and go to state 152
    interpolated_string            shift and go to state 72

state 77

    (22) data_input -> STRING ID ASSIGN . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    STDIN           shift and go to state 153


state 78

    (23) data_input -> STRING QUESTION ID . ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    ASSIGN          shift and go to state 154


state 79

    (128) constructor -> ID LPAREN constructor_parenthesis_content . RPAREN SEMICOLON

    RPAREN          shift and go to state 155


state 80

    (21) call_function -> ID LPAREN RPAREN .

    SEMICOLON       reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    PRINT           reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    STRING          reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    VAR             reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    FINAL           reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    ID              reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    VOID            reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    LIST            reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    DYNAMIC         reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    INT             reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    DOUBLE          reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    MAP             reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    WHILE           reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    BOOL            reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    IF              reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    FOR             reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    $end            reduce using rule 21 (call_function -> ID LPAREN RPAREN .)
    RBRACKET        reduce using rule 21 (call_function -> ID LPAREN RPAREN .)


state 81

    (20) call_function -> ID LPAREN argument_list . RPAREN
    (27) argument_list -> argument_list . COMMA expression

    RPAREN          shift and go to state 156
    COMMA           shift and go to state 157


state 82

    (126) constructor_parenthesis_content -> THIS . DOT ID
    (127) constructor_parenthesis_content -> THIS . DOT ID COMMA constructor_parenthesis_content

    DOT             shift and go to state 158


state 83

    (26) argument_list -> expression .
    (54) expression -> expression . PLUS expression
    (55) expression -> expression . MINUS expression
    (56) expression -> expression . TIMES expression
    (57) expression -> expression . DIVIDE expression
    (58) expression -> expression . AND expression
    (59) expression -> expression . OR expression

    RPAREN          reduce using rule 26 (argument_list -> expression .)
    COMMA           reduce using rule 26 (argument_list -> expression .)
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    AND             shift and go to state 140
    OR              shift and go to state 141


state 84

    (60) expression -> value . comparator value
    (61) expression -> value . PLUS value
    (62) expression -> value .
    (77) comparator -> . GREATER
    (78) comparator -> . LESS
    (79) comparator -> . EQUALS
    (80) comparator -> . GREATER_EQUAL
    (81) comparator -> . LESS_EQUAL
    (82) comparator -> . NOT_EQUALS

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUALS resolved as shift
    PLUS            shift and go to state 128
    MINUS           reduce using rule 62 (expression -> value .)
    TIMES           reduce using rule 62 (expression -> value .)
    DIVIDE          reduce using rule 62 (expression -> value .)
    AND             reduce using rule 62 (expression -> value .)
    OR              reduce using rule 62 (expression -> value .)
    RPAREN          reduce using rule 62 (expression -> value .)
    COMMA           reduce using rule 62 (expression -> value .)
    SEMICOLON       reduce using rule 62 (expression -> value .)
    RSBRACKET       reduce using rule 62 (expression -> value .)
    PRINT           reduce using rule 62 (expression -> value .)
    STRING          reduce using rule 62 (expression -> value .)
    VAR             reduce using rule 62 (expression -> value .)
    FINAL           reduce using rule 62 (expression -> value .)
    ID              reduce using rule 62 (expression -> value .)
    VOID            reduce using rule 62 (expression -> value .)
    LIST            reduce using rule 62 (expression -> value .)
    DYNAMIC         reduce using rule 62 (expression -> value .)
    INT             reduce using rule 62 (expression -> value .)
    DOUBLE          reduce using rule 62 (expression -> value .)
    MAP             reduce using rule 62 (expression -> value .)
    WHILE           reduce using rule 62 (expression -> value .)
    BOOL            reduce using rule 62 (expression -> value .)
    IF              reduce using rule 62 (expression -> value .)
    FOR             reduce using rule 62 (expression -> value .)
    $end            reduce using rule 62 (expression -> value .)
    RBRACKET        reduce using rule 62 (expression -> value .)
    LBRACKET        reduce using rule 62 (expression -> value .)
    GREATER         shift and go to state 129
    LESS            shift and go to state 130
    EQUALS          shift and go to state 131
    GREATER_EQUAL   shift and go to state 132
    LESS_EQUAL      shift and go to state 133
    NOT_EQUALS      shift and go to state 134

  ! PLUS            [ reduce using rule 62 (expression -> value .) ]
  ! GREATER         [ reduce using rule 62 (expression -> value .) ]
  ! LESS            [ reduce using rule 62 (expression -> value .) ]
  ! EQUALS          [ reduce using rule 62 (expression -> value .) ]
  ! GREATER_EQUAL   [ reduce using rule 62 (expression -> value .) ]
  ! LESS_EQUAL      [ reduce using rule 62 (expression -> value .) ]
  ! NOT_EQUALS      [ reduce using rule 62 (expression -> value .) ]

    comparator                     shift and go to state 127

state 85

    (96) value -> NUMBER .

    PLUS            reduce using rule 96 (value -> NUMBER .)
    GREATER         reduce using rule 96 (value -> NUMBER .)
    LESS            reduce using rule 96 (value -> NUMBER .)
    EQUALS          reduce using rule 96 (value -> NUMBER .)
    GREATER_EQUAL   reduce using rule 96 (value -> NUMBER .)
    LESS_EQUAL      reduce using rule 96 (value -> NUMBER .)
    NOT_EQUALS      reduce using rule 96 (value -> NUMBER .)
    MINUS           reduce using rule 96 (value -> NUMBER .)
    TIMES           reduce using rule 96 (value -> NUMBER .)
    DIVIDE          reduce using rule 96 (value -> NUMBER .)
    AND             reduce using rule 96 (value -> NUMBER .)
    OR              reduce using rule 96 (value -> NUMBER .)
    RPAREN          reduce using rule 96 (value -> NUMBER .)
    COMMA           reduce using rule 96 (value -> NUMBER .)
    RSBRACKET       reduce using rule 96 (value -> NUMBER .)
    SEMICOLON       reduce using rule 96 (value -> NUMBER .)
    PRINT           reduce using rule 96 (value -> NUMBER .)
    STRING          reduce using rule 96 (value -> NUMBER .)
    VAR             reduce using rule 96 (value -> NUMBER .)
    FINAL           reduce using rule 96 (value -> NUMBER .)
    ID              reduce using rule 96 (value -> NUMBER .)
    VOID            reduce using rule 96 (value -> NUMBER .)
    LIST            reduce using rule 96 (value -> NUMBER .)
    DYNAMIC         reduce using rule 96 (value -> NUMBER .)
    INT             reduce using rule 96 (value -> NUMBER .)
    DOUBLE          reduce using rule 96 (value -> NUMBER .)
    MAP             reduce using rule 96 (value -> NUMBER .)
    WHILE           reduce using rule 96 (value -> NUMBER .)
    BOOL            reduce using rule 96 (value -> NUMBER .)
    IF              reduce using rule 96 (value -> NUMBER .)
    FOR             reduce using rule 96 (value -> NUMBER .)
    $end            reduce using rule 96 (value -> NUMBER .)
    RBRACKET        reduce using rule 96 (value -> NUMBER .)
    LBRACKET        reduce using rule 96 (value -> NUMBER .)


state 86

    (97) value -> NDOUBLE .

    PLUS            reduce using rule 97 (value -> NDOUBLE .)
    GREATER         reduce using rule 97 (value -> NDOUBLE .)
    LESS            reduce using rule 97 (value -> NDOUBLE .)
    EQUALS          reduce using rule 97 (value -> NDOUBLE .)
    GREATER_EQUAL   reduce using rule 97 (value -> NDOUBLE .)
    LESS_EQUAL      reduce using rule 97 (value -> NDOUBLE .)
    NOT_EQUALS      reduce using rule 97 (value -> NDOUBLE .)
    MINUS           reduce using rule 97 (value -> NDOUBLE .)
    TIMES           reduce using rule 97 (value -> NDOUBLE .)
    DIVIDE          reduce using rule 97 (value -> NDOUBLE .)
    AND             reduce using rule 97 (value -> NDOUBLE .)
    OR              reduce using rule 97 (value -> NDOUBLE .)
    RPAREN          reduce using rule 97 (value -> NDOUBLE .)
    COMMA           reduce using rule 97 (value -> NDOUBLE .)
    RSBRACKET       reduce using rule 97 (value -> NDOUBLE .)
    SEMICOLON       reduce using rule 97 (value -> NDOUBLE .)
    PRINT           reduce using rule 97 (value -> NDOUBLE .)
    STRING          reduce using rule 97 (value -> NDOUBLE .)
    VAR             reduce using rule 97 (value -> NDOUBLE .)
    FINAL           reduce using rule 97 (value -> NDOUBLE .)
    ID              reduce using rule 97 (value -> NDOUBLE .)
    VOID            reduce using rule 97 (value -> NDOUBLE .)
    LIST            reduce using rule 97 (value -> NDOUBLE .)
    DYNAMIC         reduce using rule 97 (value -> NDOUBLE .)
    INT             reduce using rule 97 (value -> NDOUBLE .)
    DOUBLE          reduce using rule 97 (value -> NDOUBLE .)
    MAP             reduce using rule 97 (value -> NDOUBLE .)
    WHILE           reduce using rule 97 (value -> NDOUBLE .)
    BOOL            reduce using rule 97 (value -> NDOUBLE .)
    IF              reduce using rule 97 (value -> NDOUBLE .)
    FOR             reduce using rule 97 (value -> NDOUBLE .)
    $end            reduce using rule 97 (value -> NDOUBLE .)
    RBRACKET        reduce using rule 97 (value -> NDOUBLE .)
    LBRACKET        reduce using rule 97 (value -> NDOUBLE .)


state 87

    (98) value -> TEXT .
    (103) interpolated_string -> TEXT . PLUS ID
    (104) interpolated_string -> TEXT . PLUS expression

  ! shift/reduce conflict for PLUS resolved as shift
    GREATER         reduce using rule 98 (value -> TEXT .)
    LESS            reduce using rule 98 (value -> TEXT .)
    EQUALS          reduce using rule 98 (value -> TEXT .)
    GREATER_EQUAL   reduce using rule 98 (value -> TEXT .)
    LESS_EQUAL      reduce using rule 98 (value -> TEXT .)
    NOT_EQUALS      reduce using rule 98 (value -> TEXT .)
    MINUS           reduce using rule 98 (value -> TEXT .)
    TIMES           reduce using rule 98 (value -> TEXT .)
    DIVIDE          reduce using rule 98 (value -> TEXT .)
    AND             reduce using rule 98 (value -> TEXT .)
    OR              reduce using rule 98 (value -> TEXT .)
    RPAREN          reduce using rule 98 (value -> TEXT .)
    COMMA           reduce using rule 98 (value -> TEXT .)
    RSBRACKET       reduce using rule 98 (value -> TEXT .)
    SEMICOLON       reduce using rule 98 (value -> TEXT .)
    PRINT           reduce using rule 98 (value -> TEXT .)
    STRING          reduce using rule 98 (value -> TEXT .)
    VAR             reduce using rule 98 (value -> TEXT .)
    FINAL           reduce using rule 98 (value -> TEXT .)
    ID              reduce using rule 98 (value -> TEXT .)
    VOID            reduce using rule 98 (value -> TEXT .)
    LIST            reduce using rule 98 (value -> TEXT .)
    DYNAMIC         reduce using rule 98 (value -> TEXT .)
    INT             reduce using rule 98 (value -> TEXT .)
    DOUBLE          reduce using rule 98 (value -> TEXT .)
    MAP             reduce using rule 98 (value -> TEXT .)
    WHILE           reduce using rule 98 (value -> TEXT .)
    BOOL            reduce using rule 98 (value -> TEXT .)
    IF              reduce using rule 98 (value -> TEXT .)
    FOR             reduce using rule 98 (value -> TEXT .)
    $end            reduce using rule 98 (value -> TEXT .)
    RBRACKET        reduce using rule 98 (value -> TEXT .)
    LBRACKET        reduce using rule 98 (value -> TEXT .)
    PLUS            shift and go to state 149

  ! PLUS            [ reduce using rule 98 (value -> TEXT .) ]


state 88

    (105) set -> VAR ID ASSIGN . LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> VAR ID ASSIGN . LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (36) variable_definition -> VAR ID ASSIGN . expression SEMICOLON
    (54) expression -> . expression PLUS expression
    (55) expression -> . expression MINUS expression
    (56) expression -> . expression TIMES expression
    (57) expression -> . expression DIVIDE expression
    (58) expression -> . expression AND expression
    (59) expression -> . expression OR expression
    (60) expression -> . value comparator value
    (61) expression -> . value PLUS value
    (62) expression -> . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    LBRACKET        shift and go to state 159
    LESS            shift and go to state 160
    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    expression                     shift and go to state 161
    value                          shift and go to state 84
    interpolated_string            shift and go to state 72

state 89

    (107) set -> FINAL ID ASSIGN . CONST LBRACKET value_list RBRACKET SEMICOLON

    CONST           shift and go to state 162


state 90

    (133) map_assignment -> LBRACKET map_contents . RBRACKET

    RBRACKET        shift and go to state 163


state 91

    (134) map_contents -> map_content .
    (135) map_contents -> map_content . COMMA map_contents

    RBRACKET        reduce using rule 134 (map_contents -> map_content .)
    COMMA           shift and go to state 164


state 92

    (136) map_content -> key_value . COLON value

    COLON           shift and go to state 165


state 93

    (137) key_value -> TEXT .

    COLON           reduce using rule 137 (key_value -> TEXT .)


state 94

    (28) function -> type ID LPAREN . parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> type ID LPAREN . RPAREN LBRACKET statement_list RBRACKET
    (129) function -> type ID LPAREN . parameter_list RPAREN ASSIGN GREATER expression
    (83) parameter_list -> . parameter
    (84) parameter_list -> . parameter_list COMMA parameter
    (85) parameter -> . type ID
    (86) parameter -> . REQUIRED type ID
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST

    RPAREN          shift and go to state 168
    REQUIRED        shift and go to state 170
    INT             shift and go to state 99
    DOUBLE          shift and go to state 100
    STRING          shift and go to state 101
    BOOL            shift and go to state 37
    LIST            shift and go to state 97

    type                           shift and go to state 166
    parameter_list                 shift and go to state 167
    parameter                      shift and go to state 169

state 95

    (34) variable_definition -> type ID ASSIGN . expression SEMICOLON
    (54) expression -> . expression PLUS expression
    (55) expression -> . expression MINUS expression
    (56) expression -> . expression TIMES expression
    (57) expression -> . expression DIVIDE expression
    (58) expression -> . expression AND expression
    (59) expression -> . expression OR expression
    (60) expression -> . value comparator value
    (61) expression -> . value PLUS value
    (62) expression -> . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    expression                     shift and go to state 171
    value                          shift and go to state 84
    interpolated_string            shift and go to state 72

state 96

    (29) function -> VOID ID LPAREN . parameter_list RPAREN LBRACKET statement_list RBRACKET
    (31) function -> VOID ID LPAREN . RPAREN LBRACKET statement_list RBRACKET
    (32) function -> VOID ID LPAREN . RPAREN LBRACKET RBRACKET
    (33) function -> VOID ID LPAREN . parameter_list RPAREN LBRACKET RBRACKET
    (83) parameter_list -> . parameter
    (84) parameter_list -> . parameter_list COMMA parameter
    (85) parameter -> . type ID
    (86) parameter -> . REQUIRED type ID
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST

    RPAREN          shift and go to state 173
    REQUIRED        shift and go to state 170
    INT             shift and go to state 99
    DOUBLE          shift and go to state 100
    STRING          shift and go to state 101
    BOOL            shift and go to state 37
    LIST            shift and go to state 97

    parameter_list                 shift and go to state 172
    parameter                      shift and go to state 169
    type                           shift and go to state 166

state 97

    (91) type -> LIST .

    GREATER         reduce using rule 91 (type -> LIST .)
    ID              reduce using rule 91 (type -> LIST .)


state 98

    (93) list_definition -> LIST LESS type . GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON

    GREATER         shift and go to state 174


state 99

    (87) type -> INT .

    GREATER         reduce using rule 87 (type -> INT .)
    ID              reduce using rule 87 (type -> INT .)


state 100

    (88) type -> DOUBLE .

    GREATER         reduce using rule 88 (type -> DOUBLE .)
    ID              reduce using rule 88 (type -> DOUBLE .)


state 101

    (89) type -> STRING .

    GREATER         reduce using rule 89 (type -> STRING .)
    ID              reduce using rule 89 (type -> STRING .)


state 102

    (35) variable_definition -> DYNAMIC ID ASSIGN . expression SEMICOLON
    (54) expression -> . expression PLUS expression
    (55) expression -> . expression MINUS expression
    (56) expression -> . expression TIMES expression
    (57) expression -> . expression DIVIDE expression
    (58) expression -> . expression AND expression
    (59) expression -> . expression OR expression
    (60) expression -> . value comparator value
    (61) expression -> . value PLUS value
    (62) expression -> . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    expression                     shift and go to state 175
    value                          shift and go to state 84
    interpolated_string            shift and go to state 72

state 103

    (37) variable_definition -> INT ID ASSIGN . length SEMICOLON
    (38) variable_definition -> INT ID ASSIGN . NUMBER SEMICOLON
    (24) length -> . call_list DOT LENGTH
    (25) length -> . TEXT DOT LENGTH
    (92) call_list -> . LSBRACKET value_list RSBRACKET

    NUMBER          shift and go to state 177
    TEXT            shift and go to state 178
    LSBRACKET       shift and go to state 76

    length                         shift and go to state 176
    call_list                      shift and go to state 75

state 104

    (39) variable_definition -> DOUBLE ID ASSIGN . NDOUBLE SEMICOLON
    (40) variable_definition -> DOUBLE ID ASSIGN . simple_operations_arithmetics SEMICOLON
    (52) simple_operations_arithmetics -> . list_numbers simple_operators_arithmetics list_numbers
    (53) simple_operations_arithmetics -> . list_numbers simple_operators_arithmetics list_numbers simple_operators_arithmetics simple_operations_arithmetics
    (46) list_numbers -> . NUMBER
    (47) list_numbers -> . NDOUBLE

    NDOUBLE         shift and go to state 179
    NUMBER          shift and go to state 181

    simple_operations_arithmetics  shift and go to state 180
    list_numbers                   shift and go to state 67

state 105

    (132) map_declaration -> MAP LESS key_type . COMMA type GREATER ID ASSIGN

    COMMA           shift and go to state 182


state 106

    (138) key_type -> STRING .

    COMMA           reduce using rule 138 (key_type -> STRING .)


state 107

    (65) control_structures_if_else -> if_block else_if_blocks else_block .

    SEMICOLON       reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    PRINT           reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    STRING          reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    VAR             reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    FINAL           reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    ID              reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    VOID            reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    LIST            reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    DYNAMIC         reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    INT             reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    DOUBLE          reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    MAP             reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    WHILE           reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    BOOL            reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    IF              reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    FOR             reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    $end            reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    RBRACKET        reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)


state 108

    (69) else_if_blocks -> else_if_blocks ELSE . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (70) else_block -> ELSE . LBRACKET statement_list RBRACKET

    IF              shift and go to state 183
    LBRACKET        shift and go to state 110


state 109

    (68) else_if_blocks -> ELSE IF . LPAREN conditions RPAREN LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 184


state 110

    (70) else_block -> ELSE LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement_list                 shift and go to state 185
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 111

    (76) condition -> LPAREN . conditions RPAREN
    (71) conditions -> . condition
    (72) conditions -> . conditions AND conditions
    (73) conditions -> . conditions OR conditions
    (74) condition -> . value comparator value
    (75) condition -> . NOT condition
    (76) condition -> . LPAREN conditions RPAREN
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 115
    LPAREN          shift and go to state 111
    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    conditions                     shift and go to state 186
    condition                      shift and go to state 113
    value                          shift and go to state 114
    interpolated_string            shift and go to state 72

state 112

    (130) control_structures_while -> WHILE LPAREN conditions . LBRACKET statement_list RBRACKET
    (72) conditions -> conditions . AND conditions
    (73) conditions -> conditions . OR conditions

    LBRACKET        shift and go to state 187
    AND             shift and go to state 188
    OR              shift and go to state 189


state 113

    (71) conditions -> condition .

    LBRACKET        reduce using rule 71 (conditions -> condition .)
    AND             reduce using rule 71 (conditions -> condition .)
    OR              reduce using rule 71 (conditions -> condition .)
    RPAREN          reduce using rule 71 (conditions -> condition .)
    SEMICOLON       reduce using rule 71 (conditions -> condition .)


state 114

    (74) condition -> value . comparator value
    (77) comparator -> . GREATER
    (78) comparator -> . LESS
    (79) comparator -> . EQUALS
    (80) comparator -> . GREATER_EQUAL
    (81) comparator -> . LESS_EQUAL
    (82) comparator -> . NOT_EQUALS

    GREATER         shift and go to state 129
    LESS            shift and go to state 130
    EQUALS          shift and go to state 131
    GREATER_EQUAL   shift and go to state 132
    LESS_EQUAL      shift and go to state 133
    NOT_EQUALS      shift and go to state 134

    comparator                     shift and go to state 190

state 115

    (75) condition -> NOT . condition
    (74) condition -> . value comparator value
    (75) condition -> . NOT condition
    (76) condition -> . LPAREN conditions RPAREN
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 115
    LPAREN          shift and go to state 111
    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    condition                      shift and go to state 191
    value                          shift and go to state 114
    interpolated_string            shift and go to state 72

state 116

    (67) if_block -> IF LPAREN conditions . RPAREN LBRACKET statement_list RBRACKET
    (72) conditions -> conditions . AND conditions
    (73) conditions -> conditions . OR conditions

    RPAREN          shift and go to state 192
    AND             shift and go to state 188
    OR              shift and go to state 189


state 117

    (116) for_classic -> FOR LPAREN for_classic_parenthesis_content . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 193


state 118

    (118) for_in -> FOR LPAREN for_in_parenthesis_content . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 194


state 119

    (122) for_each -> FOR LPAREN for_each_parenthesis_content . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 195


state 120

    (115) for_classic_parenthesis_content -> for_classic_initialization . SEMICOLON for_classic_conditions SEMICOLON for_classic_changes

    SEMICOLON       shift and go to state 196


state 121

    (117) for_in_parenthesis_content -> FINAL . ID IN ID
    (121) for_each_parenthesis_content -> FINAL . ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID

    ID              shift and go to state 197


state 122

    (108) for_classic_initialization -> INT . ID ASSIGN NUMBER

    ID              shift and go to state 198


state 123

    (109) for_classic_initialization -> DOUBLE . ID ASSIGN NDOUBLE

    ID              shift and go to state 199


state 124

    (41) print -> PRINT LPAREN RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)


state 125

    (42) print -> PRINT LPAREN simple_operations_arithmetics RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 200


state 126

    (43) print -> PRINT LPAREN value RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 201


state 127

    (60) expression -> value comparator . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    value                          shift and go to state 202
    interpolated_string            shift and go to state 72

state 128

    (61) expression -> value PLUS . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    value                          shift and go to state 203
    interpolated_string            shift and go to state 72

state 129

    (77) comparator -> GREATER .

    NUMBER          reduce using rule 77 (comparator -> GREATER .)
    NDOUBLE         reduce using rule 77 (comparator -> GREATER .)
    TEXT            reduce using rule 77 (comparator -> GREATER .)
    ID              reduce using rule 77 (comparator -> GREATER .)
    TRUE            reduce using rule 77 (comparator -> GREATER .)
    FALSE           reduce using rule 77 (comparator -> GREATER .)


state 130

    (78) comparator -> LESS .

    NUMBER          reduce using rule 78 (comparator -> LESS .)
    NDOUBLE         reduce using rule 78 (comparator -> LESS .)
    TEXT            reduce using rule 78 (comparator -> LESS .)
    ID              reduce using rule 78 (comparator -> LESS .)
    TRUE            reduce using rule 78 (comparator -> LESS .)
    FALSE           reduce using rule 78 (comparator -> LESS .)


state 131

    (79) comparator -> EQUALS .

    NUMBER          reduce using rule 79 (comparator -> EQUALS .)
    NDOUBLE         reduce using rule 79 (comparator -> EQUALS .)
    TEXT            reduce using rule 79 (comparator -> EQUALS .)
    ID              reduce using rule 79 (comparator -> EQUALS .)
    TRUE            reduce using rule 79 (comparator -> EQUALS .)
    FALSE           reduce using rule 79 (comparator -> EQUALS .)


state 132

    (80) comparator -> GREATER_EQUAL .

    NUMBER          reduce using rule 80 (comparator -> GREATER_EQUAL .)
    NDOUBLE         reduce using rule 80 (comparator -> GREATER_EQUAL .)
    TEXT            reduce using rule 80 (comparator -> GREATER_EQUAL .)
    ID              reduce using rule 80 (comparator -> GREATER_EQUAL .)
    TRUE            reduce using rule 80 (comparator -> GREATER_EQUAL .)
    FALSE           reduce using rule 80 (comparator -> GREATER_EQUAL .)


state 133

    (81) comparator -> LESS_EQUAL .

    NUMBER          reduce using rule 81 (comparator -> LESS_EQUAL .)
    NDOUBLE         reduce using rule 81 (comparator -> LESS_EQUAL .)
    TEXT            reduce using rule 81 (comparator -> LESS_EQUAL .)
    ID              reduce using rule 81 (comparator -> LESS_EQUAL .)
    TRUE            reduce using rule 81 (comparator -> LESS_EQUAL .)
    FALSE           reduce using rule 81 (comparator -> LESS_EQUAL .)


state 134

    (82) comparator -> NOT_EQUALS .

    NUMBER          reduce using rule 82 (comparator -> NOT_EQUALS .)
    NDOUBLE         reduce using rule 82 (comparator -> NOT_EQUALS .)
    TEXT            reduce using rule 82 (comparator -> NOT_EQUALS .)
    ID              reduce using rule 82 (comparator -> NOT_EQUALS .)
    TRUE            reduce using rule 82 (comparator -> NOT_EQUALS .)
    FALSE           reduce using rule 82 (comparator -> NOT_EQUALS .)


state 135

    (44) print -> PRINT LPAREN expression RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 204


state 136

    (54) expression -> expression PLUS . expression
    (54) expression -> . expression PLUS expression
    (55) expression -> . expression MINUS expression
    (56) expression -> . expression TIMES expression
    (57) expression -> . expression DIVIDE expression
    (58) expression -> . expression AND expression
    (59) expression -> . expression OR expression
    (60) expression -> . value comparator value
    (61) expression -> . value PLUS value
    (62) expression -> . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    expression                     shift and go to state 205
    value                          shift and go to state 84
    interpolated_string            shift and go to state 72

state 137

    (55) expression -> expression MINUS . expression
    (54) expression -> . expression PLUS expression
    (55) expression -> . expression MINUS expression
    (56) expression -> . expression TIMES expression
    (57) expression -> . expression DIVIDE expression
    (58) expression -> . expression AND expression
    (59) expression -> . expression OR expression
    (60) expression -> . value comparator value
    (61) expression -> . value PLUS value
    (62) expression -> . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    expression                     shift and go to state 206
    value                          shift and go to state 84
    interpolated_string            shift and go to state 72

state 138

    (56) expression -> expression TIMES . expression
    (54) expression -> . expression PLUS expression
    (55) expression -> . expression MINUS expression
    (56) expression -> . expression TIMES expression
    (57) expression -> . expression DIVIDE expression
    (58) expression -> . expression AND expression
    (59) expression -> . expression OR expression
    (60) expression -> . value comparator value
    (61) expression -> . value PLUS value
    (62) expression -> . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    expression                     shift and go to state 207
    value                          shift and go to state 84
    interpolated_string            shift and go to state 72

state 139

    (57) expression -> expression DIVIDE . expression
    (54) expression -> . expression PLUS expression
    (55) expression -> . expression MINUS expression
    (56) expression -> . expression TIMES expression
    (57) expression -> . expression DIVIDE expression
    (58) expression -> . expression AND expression
    (59) expression -> . expression OR expression
    (60) expression -> . value comparator value
    (61) expression -> . value PLUS value
    (62) expression -> . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    expression                     shift and go to state 208
    value                          shift and go to state 84
    interpolated_string            shift and go to state 72

state 140

    (58) expression -> expression AND . expression
    (54) expression -> . expression PLUS expression
    (55) expression -> . expression MINUS expression
    (56) expression -> . expression TIMES expression
    (57) expression -> . expression DIVIDE expression
    (58) expression -> . expression AND expression
    (59) expression -> . expression OR expression
    (60) expression -> . value comparator value
    (61) expression -> . value PLUS value
    (62) expression -> . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    expression                     shift and go to state 209
    value                          shift and go to state 84
    interpolated_string            shift and go to state 72

state 141

    (59) expression -> expression OR . expression
    (54) expression -> . expression PLUS expression
    (55) expression -> . expression MINUS expression
    (56) expression -> . expression TIMES expression
    (57) expression -> . expression DIVIDE expression
    (58) expression -> . expression AND expression
    (59) expression -> . expression OR expression
    (60) expression -> . value comparator value
    (61) expression -> . value PLUS value
    (62) expression -> . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    expression                     shift and go to state 210
    value                          shift and go to state 84
    interpolated_string            shift and go to state 72

state 142

    (45) print -> PRINT LPAREN length RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 211


state 143

    (52) simple_operations_arithmetics -> list_numbers simple_operators_arithmetics . list_numbers
    (53) simple_operations_arithmetics -> list_numbers simple_operators_arithmetics . list_numbers simple_operators_arithmetics simple_operations_arithmetics
    (46) list_numbers -> . NUMBER
    (47) list_numbers -> . NDOUBLE

    NUMBER          shift and go to state 181
    NDOUBLE         shift and go to state 213

    list_numbers                   shift and go to state 212

state 144

    (48) simple_operators_arithmetics -> MINUS .

    NUMBER          reduce using rule 48 (simple_operators_arithmetics -> MINUS .)
    NDOUBLE         reduce using rule 48 (simple_operators_arithmetics -> MINUS .)


state 145

    (49) simple_operators_arithmetics -> PLUS .

    NUMBER          reduce using rule 49 (simple_operators_arithmetics -> PLUS .)
    NDOUBLE         reduce using rule 49 (simple_operators_arithmetics -> PLUS .)


state 146

    (50) simple_operators_arithmetics -> DIVIDE .

    NUMBER          reduce using rule 50 (simple_operators_arithmetics -> DIVIDE .)
    NDOUBLE         reduce using rule 50 (simple_operators_arithmetics -> DIVIDE .)


state 147

    (51) simple_operators_arithmetics -> TIMES .

    NUMBER          reduce using rule 51 (simple_operators_arithmetics -> TIMES .)
    NDOUBLE         reduce using rule 51 (simple_operators_arithmetics -> TIMES .)


state 148

    (25) length -> TEXT DOT . LENGTH

    LENGTH          shift and go to state 214


state 149

    (103) interpolated_string -> TEXT PLUS . ID
    (104) interpolated_string -> TEXT PLUS . expression
    (54) expression -> . expression PLUS expression
    (55) expression -> . expression MINUS expression
    (56) expression -> . expression TIMES expression
    (57) expression -> . expression DIVIDE expression
    (58) expression -> . expression AND expression
    (59) expression -> . expression OR expression
    (60) expression -> . value comparator value
    (61) expression -> . value PLUS value
    (62) expression -> . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    ID              shift and go to state 215
    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    expression                     shift and go to state 216
    value                          shift and go to state 84
    interpolated_string            shift and go to state 72

state 150

    (24) length -> call_list DOT . LENGTH

    LENGTH          shift and go to state 217


state 151

    (92) call_list -> LSBRACKET value_list . RSBRACKET
    (95) value_list -> value_list . COMMA value

    RSBRACKET       shift and go to state 218
    COMMA           shift and go to state 219


state 152

    (94) value_list -> value .

    RSBRACKET       reduce using rule 94 (value_list -> value .)
    COMMA           reduce using rule 94 (value_list -> value .)
    RBRACKET        reduce using rule 94 (value_list -> value .)


state 153

    (22) data_input -> STRING ID ASSIGN STDIN . DOT READLINESYNC LPAREN RPAREN SEMICOLON

    DOT             shift and go to state 220


state 154

    (23) data_input -> STRING QUESTION ID ASSIGN . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    STDIN           shift and go to state 221


state 155

    (128) constructor -> ID LPAREN constructor_parenthesis_content RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 222


state 156

    (20) call_function -> ID LPAREN argument_list RPAREN .

    SEMICOLON       reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    PRINT           reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    STRING          reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    VAR             reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    FINAL           reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    ID              reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    VOID            reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    LIST            reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    DYNAMIC         reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    INT             reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    DOUBLE          reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    MAP             reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    WHILE           reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    BOOL            reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    IF              reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    FOR             reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    $end            reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)
    RBRACKET        reduce using rule 20 (call_function -> ID LPAREN argument_list RPAREN .)


state 157

    (27) argument_list -> argument_list COMMA . expression
    (54) expression -> . expression PLUS expression
    (55) expression -> . expression MINUS expression
    (56) expression -> . expression TIMES expression
    (57) expression -> . expression DIVIDE expression
    (58) expression -> . expression AND expression
    (59) expression -> . expression OR expression
    (60) expression -> . value comparator value
    (61) expression -> . value PLUS value
    (62) expression -> . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    expression                     shift and go to state 223
    value                          shift and go to state 84
    interpolated_string            shift and go to state 72

state 158

    (126) constructor_parenthesis_content -> THIS DOT . ID
    (127) constructor_parenthesis_content -> THIS DOT . ID COMMA constructor_parenthesis_content

    ID              shift and go to state 224


state 159

    (105) set -> VAR ID ASSIGN LBRACKET . value_list RBRACKET SEMICOLON
    (94) value_list -> . value
    (95) value_list -> . value_list COMMA value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    value_list                     shift and go to state 225
    value                          shift and go to state 152
    interpolated_string            shift and go to state 72

state 160

    (106) set -> VAR ID ASSIGN LESS . STRING GREATER LBRACKET RBRACKET SEMICOLON

    STRING          shift and go to state 226


state 161

    (36) variable_definition -> VAR ID ASSIGN expression . SEMICOLON
    (54) expression -> expression . PLUS expression
    (55) expression -> expression . MINUS expression
    (56) expression -> expression . TIMES expression
    (57) expression -> expression . DIVIDE expression
    (58) expression -> expression . AND expression
    (59) expression -> expression . OR expression

    SEMICOLON       shift and go to state 227
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    AND             shift and go to state 140
    OR              shift and go to state 141


state 162

    (107) set -> FINAL ID ASSIGN CONST . LBRACKET value_list RBRACKET SEMICOLON

    LBRACKET        shift and go to state 228


state 163

    (133) map_assignment -> LBRACKET map_contents RBRACKET .

    SEMICOLON       reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    PRINT           reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    STRING          reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    VAR             reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    FINAL           reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    ID              reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    VOID            reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    LIST            reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    DYNAMIC         reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    INT             reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    DOUBLE          reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    MAP             reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    WHILE           reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    BOOL            reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    IF              reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    FOR             reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    $end            reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    RBRACKET        reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)


state 164

    (135) map_contents -> map_content COMMA . map_contents
    (134) map_contents -> . map_content
    (135) map_contents -> . map_content COMMA map_contents
    (136) map_content -> . key_value COLON value
    (137) key_value -> . TEXT

    TEXT            shift and go to state 93

    map_content                    shift and go to state 91
    map_contents                   shift and go to state 229
    key_value                      shift and go to state 92

state 165

    (136) map_content -> key_value COLON . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    value                          shift and go to state 230
    interpolated_string            shift and go to state 72

state 166

    (85) parameter -> type . ID

    ID              shift and go to state 231


state 167

    (28) function -> type ID LPAREN parameter_list . RPAREN LBRACKET statement_list RBRACKET
    (129) function -> type ID LPAREN parameter_list . RPAREN ASSIGN GREATER expression
    (84) parameter_list -> parameter_list . COMMA parameter

    RPAREN          shift and go to state 232
    COMMA           shift and go to state 233


state 168

    (30) function -> type ID LPAREN RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 234


state 169

    (83) parameter_list -> parameter .

    RPAREN          reduce using rule 83 (parameter_list -> parameter .)
    COMMA           reduce using rule 83 (parameter_list -> parameter .)


state 170

    (86) parameter -> REQUIRED . type ID
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST

    INT             shift and go to state 99
    DOUBLE          shift and go to state 100
    STRING          shift and go to state 101
    BOOL            shift and go to state 37
    LIST            shift and go to state 97

    type                           shift and go to state 235

state 171

    (34) variable_definition -> type ID ASSIGN expression . SEMICOLON
    (54) expression -> expression . PLUS expression
    (55) expression -> expression . MINUS expression
    (56) expression -> expression . TIMES expression
    (57) expression -> expression . DIVIDE expression
    (58) expression -> expression . AND expression
    (59) expression -> expression . OR expression

    SEMICOLON       shift and go to state 236
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    AND             shift and go to state 140
    OR              shift and go to state 141


state 172

    (29) function -> VOID ID LPAREN parameter_list . RPAREN LBRACKET statement_list RBRACKET
    (33) function -> VOID ID LPAREN parameter_list . RPAREN LBRACKET RBRACKET
    (84) parameter_list -> parameter_list . COMMA parameter

    RPAREN          shift and go to state 237
    COMMA           shift and go to state 233


state 173

    (31) function -> VOID ID LPAREN RPAREN . LBRACKET statement_list RBRACKET
    (32) function -> VOID ID LPAREN RPAREN . LBRACKET RBRACKET

    LBRACKET        shift and go to state 238


state 174

    (93) list_definition -> LIST LESS type GREATER . ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON

    ID              shift and go to state 239


state 175

    (35) variable_definition -> DYNAMIC ID ASSIGN expression . SEMICOLON
    (54) expression -> expression . PLUS expression
    (55) expression -> expression . MINUS expression
    (56) expression -> expression . TIMES expression
    (57) expression -> expression . DIVIDE expression
    (58) expression -> expression . AND expression
    (59) expression -> expression . OR expression

    SEMICOLON       shift and go to state 240
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    AND             shift and go to state 140
    OR              shift and go to state 141


state 176

    (37) variable_definition -> INT ID ASSIGN length . SEMICOLON

    SEMICOLON       shift and go to state 241


state 177

    (38) variable_definition -> INT ID ASSIGN NUMBER . SEMICOLON

    SEMICOLON       shift and go to state 242


state 178

    (25) length -> TEXT . DOT LENGTH

    DOT             shift and go to state 148


state 179

    (39) variable_definition -> DOUBLE ID ASSIGN NDOUBLE . SEMICOLON
    (47) list_numbers -> NDOUBLE .

    SEMICOLON       shift and go to state 243
    MINUS           reduce using rule 47 (list_numbers -> NDOUBLE .)
    PLUS            reduce using rule 47 (list_numbers -> NDOUBLE .)
    DIVIDE          reduce using rule 47 (list_numbers -> NDOUBLE .)
    TIMES           reduce using rule 47 (list_numbers -> NDOUBLE .)


state 180

    (40) variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics . SEMICOLON

    SEMICOLON       shift and go to state 244


state 181

    (46) list_numbers -> NUMBER .

    MINUS           reduce using rule 46 (list_numbers -> NUMBER .)
    PLUS            reduce using rule 46 (list_numbers -> NUMBER .)
    DIVIDE          reduce using rule 46 (list_numbers -> NUMBER .)
    TIMES           reduce using rule 46 (list_numbers -> NUMBER .)
    RPAREN          reduce using rule 46 (list_numbers -> NUMBER .)
    SEMICOLON       reduce using rule 46 (list_numbers -> NUMBER .)


state 182

    (132) map_declaration -> MAP LESS key_type COMMA . type GREATER ID ASSIGN
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST

    INT             shift and go to state 99
    DOUBLE          shift and go to state 100
    STRING          shift and go to state 101
    BOOL            shift and go to state 37
    LIST            shift and go to state 97

    type                           shift and go to state 245

state 183

    (69) else_if_blocks -> else_if_blocks ELSE IF . LPAREN conditions RPAREN LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 246


state 184

    (68) else_if_blocks -> ELSE IF LPAREN . conditions RPAREN LBRACKET statement_list RBRACKET
    (71) conditions -> . condition
    (72) conditions -> . conditions AND conditions
    (73) conditions -> . conditions OR conditions
    (74) condition -> . value comparator value
    (75) condition -> . NOT condition
    (76) condition -> . LPAREN conditions RPAREN
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 115
    LPAREN          shift and go to state 111
    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    conditions                     shift and go to state 247
    condition                      shift and go to state 113
    value                          shift and go to state 114
    interpolated_string            shift and go to state 72

state 185

    (70) else_block -> ELSE LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 248
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement                      shift and go to state 40
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 186

    (76) condition -> LPAREN conditions . RPAREN
    (72) conditions -> conditions . AND conditions
    (73) conditions -> conditions . OR conditions

    RPAREN          shift and go to state 249
    AND             shift and go to state 188
    OR              shift and go to state 189


state 187

    (130) control_structures_while -> WHILE LPAREN conditions LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement_list                 shift and go to state 250
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 188

    (72) conditions -> conditions AND . conditions
    (71) conditions -> . condition
    (72) conditions -> . conditions AND conditions
    (73) conditions -> . conditions OR conditions
    (74) condition -> . value comparator value
    (75) condition -> . NOT condition
    (76) condition -> . LPAREN conditions RPAREN
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 115
    LPAREN          shift and go to state 111
    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    conditions                     shift and go to state 251
    condition                      shift and go to state 113
    value                          shift and go to state 114
    interpolated_string            shift and go to state 72

state 189

    (73) conditions -> conditions OR . conditions
    (71) conditions -> . condition
    (72) conditions -> . conditions AND conditions
    (73) conditions -> . conditions OR conditions
    (74) condition -> . value comparator value
    (75) condition -> . NOT condition
    (76) condition -> . LPAREN conditions RPAREN
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 115
    LPAREN          shift and go to state 111
    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    conditions                     shift and go to state 252
    condition                      shift and go to state 113
    value                          shift and go to state 114
    interpolated_string            shift and go to state 72

state 190

    (74) condition -> value comparator . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    value                          shift and go to state 253
    interpolated_string            shift and go to state 72

state 191

    (75) condition -> NOT condition .

    LBRACKET        reduce using rule 75 (condition -> NOT condition .)
    AND             reduce using rule 75 (condition -> NOT condition .)
    OR              reduce using rule 75 (condition -> NOT condition .)
    RPAREN          reduce using rule 75 (condition -> NOT condition .)
    SEMICOLON       reduce using rule 75 (condition -> NOT condition .)


state 192

    (67) if_block -> IF LPAREN conditions RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 254


state 193

    (116) for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 255


state 194

    (118) for_in -> FOR LPAREN for_in_parenthesis_content RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 256


state 195

    (122) for_each -> FOR LPAREN for_each_parenthesis_content RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 257


state 196

    (115) for_classic_parenthesis_content -> for_classic_initialization SEMICOLON . for_classic_conditions SEMICOLON for_classic_changes
    (110) for_classic_conditions -> . conditions
    (71) conditions -> . condition
    (72) conditions -> . conditions AND conditions
    (73) conditions -> . conditions OR conditions
    (74) condition -> . value comparator value
    (75) condition -> . NOT condition
    (76) condition -> . LPAREN conditions RPAREN
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 115
    LPAREN          shift and go to state 111
    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    for_classic_conditions         shift and go to state 258
    conditions                     shift and go to state 259
    condition                      shift and go to state 113
    value                          shift and go to state 114
    interpolated_string            shift and go to state 72

state 197

    (117) for_in_parenthesis_content -> FINAL ID . IN ID
    (121) for_each_parenthesis_content -> FINAL ID . LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID

    IN              shift and go to state 260
    LPAREN          shift and go to state 261


state 198

    (108) for_classic_initialization -> INT ID . ASSIGN NUMBER

    ASSIGN          shift and go to state 262


state 199

    (109) for_classic_initialization -> DOUBLE ID . ASSIGN NDOUBLE

    ASSIGN          shift and go to state 263


state 200

    (42) print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    PRINT           reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    STRING          reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    VAR             reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    FINAL           reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    ID              reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    VOID            reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    LIST            reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    INT             reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    MAP             reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    WHILE           reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    BOOL            reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    IF              reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    FOR             reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    $end            reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)


state 201

    (43) print -> PRINT LPAREN value RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    PRINT           reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    STRING          reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    VAR             reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    FINAL           reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    ID              reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    VOID            reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    LIST            reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    INT             reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    MAP             reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    WHILE           reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    BOOL            reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    IF              reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    FOR             reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    $end            reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)


state 202

    (60) expression -> value comparator value .

    RPAREN          reduce using rule 60 (expression -> value comparator value .)
    PLUS            reduce using rule 60 (expression -> value comparator value .)
    MINUS           reduce using rule 60 (expression -> value comparator value .)
    TIMES           reduce using rule 60 (expression -> value comparator value .)
    DIVIDE          reduce using rule 60 (expression -> value comparator value .)
    AND             reduce using rule 60 (expression -> value comparator value .)
    OR              reduce using rule 60 (expression -> value comparator value .)
    COMMA           reduce using rule 60 (expression -> value comparator value .)
    SEMICOLON       reduce using rule 60 (expression -> value comparator value .)
    GREATER         reduce using rule 60 (expression -> value comparator value .)
    LESS            reduce using rule 60 (expression -> value comparator value .)
    EQUALS          reduce using rule 60 (expression -> value comparator value .)
    GREATER_EQUAL   reduce using rule 60 (expression -> value comparator value .)
    LESS_EQUAL      reduce using rule 60 (expression -> value comparator value .)
    NOT_EQUALS      reduce using rule 60 (expression -> value comparator value .)
    RSBRACKET       reduce using rule 60 (expression -> value comparator value .)
    PRINT           reduce using rule 60 (expression -> value comparator value .)
    STRING          reduce using rule 60 (expression -> value comparator value .)
    VAR             reduce using rule 60 (expression -> value comparator value .)
    FINAL           reduce using rule 60 (expression -> value comparator value .)
    ID              reduce using rule 60 (expression -> value comparator value .)
    VOID            reduce using rule 60 (expression -> value comparator value .)
    LIST            reduce using rule 60 (expression -> value comparator value .)
    DYNAMIC         reduce using rule 60 (expression -> value comparator value .)
    INT             reduce using rule 60 (expression -> value comparator value .)
    DOUBLE          reduce using rule 60 (expression -> value comparator value .)
    MAP             reduce using rule 60 (expression -> value comparator value .)
    WHILE           reduce using rule 60 (expression -> value comparator value .)
    BOOL            reduce using rule 60 (expression -> value comparator value .)
    IF              reduce using rule 60 (expression -> value comparator value .)
    FOR             reduce using rule 60 (expression -> value comparator value .)
    $end            reduce using rule 60 (expression -> value comparator value .)
    RBRACKET        reduce using rule 60 (expression -> value comparator value .)
    LBRACKET        reduce using rule 60 (expression -> value comparator value .)


state 203

    (61) expression -> value PLUS value .

    RPAREN          reduce using rule 61 (expression -> value PLUS value .)
    PLUS            reduce using rule 61 (expression -> value PLUS value .)
    MINUS           reduce using rule 61 (expression -> value PLUS value .)
    TIMES           reduce using rule 61 (expression -> value PLUS value .)
    DIVIDE          reduce using rule 61 (expression -> value PLUS value .)
    AND             reduce using rule 61 (expression -> value PLUS value .)
    OR              reduce using rule 61 (expression -> value PLUS value .)
    COMMA           reduce using rule 61 (expression -> value PLUS value .)
    SEMICOLON       reduce using rule 61 (expression -> value PLUS value .)
    GREATER         reduce using rule 61 (expression -> value PLUS value .)
    LESS            reduce using rule 61 (expression -> value PLUS value .)
    EQUALS          reduce using rule 61 (expression -> value PLUS value .)
    GREATER_EQUAL   reduce using rule 61 (expression -> value PLUS value .)
    LESS_EQUAL      reduce using rule 61 (expression -> value PLUS value .)
    NOT_EQUALS      reduce using rule 61 (expression -> value PLUS value .)
    RSBRACKET       reduce using rule 61 (expression -> value PLUS value .)
    PRINT           reduce using rule 61 (expression -> value PLUS value .)
    STRING          reduce using rule 61 (expression -> value PLUS value .)
    VAR             reduce using rule 61 (expression -> value PLUS value .)
    FINAL           reduce using rule 61 (expression -> value PLUS value .)
    ID              reduce using rule 61 (expression -> value PLUS value .)
    VOID            reduce using rule 61 (expression -> value PLUS value .)
    LIST            reduce using rule 61 (expression -> value PLUS value .)
    DYNAMIC         reduce using rule 61 (expression -> value PLUS value .)
    INT             reduce using rule 61 (expression -> value PLUS value .)
    DOUBLE          reduce using rule 61 (expression -> value PLUS value .)
    MAP             reduce using rule 61 (expression -> value PLUS value .)
    WHILE           reduce using rule 61 (expression -> value PLUS value .)
    BOOL            reduce using rule 61 (expression -> value PLUS value .)
    IF              reduce using rule 61 (expression -> value PLUS value .)
    FOR             reduce using rule 61 (expression -> value PLUS value .)
    $end            reduce using rule 61 (expression -> value PLUS value .)
    RBRACKET        reduce using rule 61 (expression -> value PLUS value .)
    LBRACKET        reduce using rule 61 (expression -> value PLUS value .)


state 204

    (44) print -> PRINT LPAREN expression RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    PRINT           reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    STRING          reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    VAR             reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FINAL           reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    ID              reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    VOID            reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LIST            reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    INT             reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    MAP             reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    WHILE           reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    BOOL            reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    IF              reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FOR             reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    $end            reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)


state 205

    (54) expression -> expression PLUS expression .
    (54) expression -> expression . PLUS expression
    (55) expression -> expression . MINUS expression
    (56) expression -> expression . TIMES expression
    (57) expression -> expression . DIVIDE expression
    (58) expression -> expression . AND expression
    (59) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 54 (expression -> expression PLUS expression .)
    COMMA           reduce using rule 54 (expression -> expression PLUS expression .)
    SEMICOLON       reduce using rule 54 (expression -> expression PLUS expression .)
    GREATER         reduce using rule 54 (expression -> expression PLUS expression .)
    LESS            reduce using rule 54 (expression -> expression PLUS expression .)
    EQUALS          reduce using rule 54 (expression -> expression PLUS expression .)
    GREATER_EQUAL   reduce using rule 54 (expression -> expression PLUS expression .)
    LESS_EQUAL      reduce using rule 54 (expression -> expression PLUS expression .)
    NOT_EQUALS      reduce using rule 54 (expression -> expression PLUS expression .)
    RSBRACKET       reduce using rule 54 (expression -> expression PLUS expression .)
    PRINT           reduce using rule 54 (expression -> expression PLUS expression .)
    STRING          reduce using rule 54 (expression -> expression PLUS expression .)
    VAR             reduce using rule 54 (expression -> expression PLUS expression .)
    FINAL           reduce using rule 54 (expression -> expression PLUS expression .)
    ID              reduce using rule 54 (expression -> expression PLUS expression .)
    VOID            reduce using rule 54 (expression -> expression PLUS expression .)
    LIST            reduce using rule 54 (expression -> expression PLUS expression .)
    DYNAMIC         reduce using rule 54 (expression -> expression PLUS expression .)
    INT             reduce using rule 54 (expression -> expression PLUS expression .)
    DOUBLE          reduce using rule 54 (expression -> expression PLUS expression .)
    MAP             reduce using rule 54 (expression -> expression PLUS expression .)
    WHILE           reduce using rule 54 (expression -> expression PLUS expression .)
    BOOL            reduce using rule 54 (expression -> expression PLUS expression .)
    IF              reduce using rule 54 (expression -> expression PLUS expression .)
    FOR             reduce using rule 54 (expression -> expression PLUS expression .)
    $end            reduce using rule 54 (expression -> expression PLUS expression .)
    RBRACKET        reduce using rule 54 (expression -> expression PLUS expression .)
    LBRACKET        reduce using rule 54 (expression -> expression PLUS expression .)
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    AND             shift and go to state 140
    OR              shift and go to state 141

  ! PLUS            [ reduce using rule 54 (expression -> expression PLUS expression .) ]
  ! MINUS           [ reduce using rule 54 (expression -> expression PLUS expression .) ]
  ! TIMES           [ reduce using rule 54 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 54 (expression -> expression PLUS expression .) ]
  ! AND             [ reduce using rule 54 (expression -> expression PLUS expression .) ]
  ! OR              [ reduce using rule 54 (expression -> expression PLUS expression .) ]


state 206

    (55) expression -> expression MINUS expression .
    (54) expression -> expression . PLUS expression
    (55) expression -> expression . MINUS expression
    (56) expression -> expression . TIMES expression
    (57) expression -> expression . DIVIDE expression
    (58) expression -> expression . AND expression
    (59) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 55 (expression -> expression MINUS expression .)
    COMMA           reduce using rule 55 (expression -> expression MINUS expression .)
    SEMICOLON       reduce using rule 55 (expression -> expression MINUS expression .)
    GREATER         reduce using rule 55 (expression -> expression MINUS expression .)
    LESS            reduce using rule 55 (expression -> expression MINUS expression .)
    EQUALS          reduce using rule 55 (expression -> expression MINUS expression .)
    GREATER_EQUAL   reduce using rule 55 (expression -> expression MINUS expression .)
    LESS_EQUAL      reduce using rule 55 (expression -> expression MINUS expression .)
    NOT_EQUALS      reduce using rule 55 (expression -> expression MINUS expression .)
    RSBRACKET       reduce using rule 55 (expression -> expression MINUS expression .)
    PRINT           reduce using rule 55 (expression -> expression MINUS expression .)
    STRING          reduce using rule 55 (expression -> expression MINUS expression .)
    VAR             reduce using rule 55 (expression -> expression MINUS expression .)
    FINAL           reduce using rule 55 (expression -> expression MINUS expression .)
    ID              reduce using rule 55 (expression -> expression MINUS expression .)
    VOID            reduce using rule 55 (expression -> expression MINUS expression .)
    LIST            reduce using rule 55 (expression -> expression MINUS expression .)
    DYNAMIC         reduce using rule 55 (expression -> expression MINUS expression .)
    INT             reduce using rule 55 (expression -> expression MINUS expression .)
    DOUBLE          reduce using rule 55 (expression -> expression MINUS expression .)
    MAP             reduce using rule 55 (expression -> expression MINUS expression .)
    WHILE           reduce using rule 55 (expression -> expression MINUS expression .)
    BOOL            reduce using rule 55 (expression -> expression MINUS expression .)
    IF              reduce using rule 55 (expression -> expression MINUS expression .)
    FOR             reduce using rule 55 (expression -> expression MINUS expression .)
    $end            reduce using rule 55 (expression -> expression MINUS expression .)
    RBRACKET        reduce using rule 55 (expression -> expression MINUS expression .)
    LBRACKET        reduce using rule 55 (expression -> expression MINUS expression .)
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    AND             shift and go to state 140
    OR              shift and go to state 141

  ! PLUS            [ reduce using rule 55 (expression -> expression MINUS expression .) ]
  ! MINUS           [ reduce using rule 55 (expression -> expression MINUS expression .) ]
  ! TIMES           [ reduce using rule 55 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 55 (expression -> expression MINUS expression .) ]
  ! AND             [ reduce using rule 55 (expression -> expression MINUS expression .) ]
  ! OR              [ reduce using rule 55 (expression -> expression MINUS expression .) ]


state 207

    (56) expression -> expression TIMES expression .
    (54) expression -> expression . PLUS expression
    (55) expression -> expression . MINUS expression
    (56) expression -> expression . TIMES expression
    (57) expression -> expression . DIVIDE expression
    (58) expression -> expression . AND expression
    (59) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 56 (expression -> expression TIMES expression .)
    COMMA           reduce using rule 56 (expression -> expression TIMES expression .)
    SEMICOLON       reduce using rule 56 (expression -> expression TIMES expression .)
    GREATER         reduce using rule 56 (expression -> expression TIMES expression .)
    LESS            reduce using rule 56 (expression -> expression TIMES expression .)
    EQUALS          reduce using rule 56 (expression -> expression TIMES expression .)
    GREATER_EQUAL   reduce using rule 56 (expression -> expression TIMES expression .)
    LESS_EQUAL      reduce using rule 56 (expression -> expression TIMES expression .)
    NOT_EQUALS      reduce using rule 56 (expression -> expression TIMES expression .)
    RSBRACKET       reduce using rule 56 (expression -> expression TIMES expression .)
    PRINT           reduce using rule 56 (expression -> expression TIMES expression .)
    STRING          reduce using rule 56 (expression -> expression TIMES expression .)
    VAR             reduce using rule 56 (expression -> expression TIMES expression .)
    FINAL           reduce using rule 56 (expression -> expression TIMES expression .)
    ID              reduce using rule 56 (expression -> expression TIMES expression .)
    VOID            reduce using rule 56 (expression -> expression TIMES expression .)
    LIST            reduce using rule 56 (expression -> expression TIMES expression .)
    DYNAMIC         reduce using rule 56 (expression -> expression TIMES expression .)
    INT             reduce using rule 56 (expression -> expression TIMES expression .)
    DOUBLE          reduce using rule 56 (expression -> expression TIMES expression .)
    MAP             reduce using rule 56 (expression -> expression TIMES expression .)
    WHILE           reduce using rule 56 (expression -> expression TIMES expression .)
    BOOL            reduce using rule 56 (expression -> expression TIMES expression .)
    IF              reduce using rule 56 (expression -> expression TIMES expression .)
    FOR             reduce using rule 56 (expression -> expression TIMES expression .)
    $end            reduce using rule 56 (expression -> expression TIMES expression .)
    RBRACKET        reduce using rule 56 (expression -> expression TIMES expression .)
    LBRACKET        reduce using rule 56 (expression -> expression TIMES expression .)
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    AND             shift and go to state 140
    OR              shift and go to state 141

  ! PLUS            [ reduce using rule 56 (expression -> expression TIMES expression .) ]
  ! MINUS           [ reduce using rule 56 (expression -> expression TIMES expression .) ]
  ! TIMES           [ reduce using rule 56 (expression -> expression TIMES expression .) ]
  ! DIVIDE          [ reduce using rule 56 (expression -> expression TIMES expression .) ]
  ! AND             [ reduce using rule 56 (expression -> expression TIMES expression .) ]
  ! OR              [ reduce using rule 56 (expression -> expression TIMES expression .) ]


state 208

    (57) expression -> expression DIVIDE expression .
    (54) expression -> expression . PLUS expression
    (55) expression -> expression . MINUS expression
    (56) expression -> expression . TIMES expression
    (57) expression -> expression . DIVIDE expression
    (58) expression -> expression . AND expression
    (59) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 57 (expression -> expression DIVIDE expression .)
    COMMA           reduce using rule 57 (expression -> expression DIVIDE expression .)
    SEMICOLON       reduce using rule 57 (expression -> expression DIVIDE expression .)
    GREATER         reduce using rule 57 (expression -> expression DIVIDE expression .)
    LESS            reduce using rule 57 (expression -> expression DIVIDE expression .)
    EQUALS          reduce using rule 57 (expression -> expression DIVIDE expression .)
    GREATER_EQUAL   reduce using rule 57 (expression -> expression DIVIDE expression .)
    LESS_EQUAL      reduce using rule 57 (expression -> expression DIVIDE expression .)
    NOT_EQUALS      reduce using rule 57 (expression -> expression DIVIDE expression .)
    RSBRACKET       reduce using rule 57 (expression -> expression DIVIDE expression .)
    PRINT           reduce using rule 57 (expression -> expression DIVIDE expression .)
    STRING          reduce using rule 57 (expression -> expression DIVIDE expression .)
    VAR             reduce using rule 57 (expression -> expression DIVIDE expression .)
    FINAL           reduce using rule 57 (expression -> expression DIVIDE expression .)
    ID              reduce using rule 57 (expression -> expression DIVIDE expression .)
    VOID            reduce using rule 57 (expression -> expression DIVIDE expression .)
    LIST            reduce using rule 57 (expression -> expression DIVIDE expression .)
    DYNAMIC         reduce using rule 57 (expression -> expression DIVIDE expression .)
    INT             reduce using rule 57 (expression -> expression DIVIDE expression .)
    DOUBLE          reduce using rule 57 (expression -> expression DIVIDE expression .)
    MAP             reduce using rule 57 (expression -> expression DIVIDE expression .)
    WHILE           reduce using rule 57 (expression -> expression DIVIDE expression .)
    BOOL            reduce using rule 57 (expression -> expression DIVIDE expression .)
    IF              reduce using rule 57 (expression -> expression DIVIDE expression .)
    FOR             reduce using rule 57 (expression -> expression DIVIDE expression .)
    $end            reduce using rule 57 (expression -> expression DIVIDE expression .)
    RBRACKET        reduce using rule 57 (expression -> expression DIVIDE expression .)
    LBRACKET        reduce using rule 57 (expression -> expression DIVIDE expression .)
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    AND             shift and go to state 140
    OR              shift and go to state 141

  ! PLUS            [ reduce using rule 57 (expression -> expression DIVIDE expression .) ]
  ! MINUS           [ reduce using rule 57 (expression -> expression DIVIDE expression .) ]
  ! TIMES           [ reduce using rule 57 (expression -> expression DIVIDE expression .) ]
  ! DIVIDE          [ reduce using rule 57 (expression -> expression DIVIDE expression .) ]
  ! AND             [ reduce using rule 57 (expression -> expression DIVIDE expression .) ]
  ! OR              [ reduce using rule 57 (expression -> expression DIVIDE expression .) ]


state 209

    (58) expression -> expression AND expression .
    (54) expression -> expression . PLUS expression
    (55) expression -> expression . MINUS expression
    (56) expression -> expression . TIMES expression
    (57) expression -> expression . DIVIDE expression
    (58) expression -> expression . AND expression
    (59) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 58 (expression -> expression AND expression .)
    COMMA           reduce using rule 58 (expression -> expression AND expression .)
    SEMICOLON       reduce using rule 58 (expression -> expression AND expression .)
    GREATER         reduce using rule 58 (expression -> expression AND expression .)
    LESS            reduce using rule 58 (expression -> expression AND expression .)
    EQUALS          reduce using rule 58 (expression -> expression AND expression .)
    GREATER_EQUAL   reduce using rule 58 (expression -> expression AND expression .)
    LESS_EQUAL      reduce using rule 58 (expression -> expression AND expression .)
    NOT_EQUALS      reduce using rule 58 (expression -> expression AND expression .)
    RSBRACKET       reduce using rule 58 (expression -> expression AND expression .)
    PRINT           reduce using rule 58 (expression -> expression AND expression .)
    STRING          reduce using rule 58 (expression -> expression AND expression .)
    VAR             reduce using rule 58 (expression -> expression AND expression .)
    FINAL           reduce using rule 58 (expression -> expression AND expression .)
    ID              reduce using rule 58 (expression -> expression AND expression .)
    VOID            reduce using rule 58 (expression -> expression AND expression .)
    LIST            reduce using rule 58 (expression -> expression AND expression .)
    DYNAMIC         reduce using rule 58 (expression -> expression AND expression .)
    INT             reduce using rule 58 (expression -> expression AND expression .)
    DOUBLE          reduce using rule 58 (expression -> expression AND expression .)
    MAP             reduce using rule 58 (expression -> expression AND expression .)
    WHILE           reduce using rule 58 (expression -> expression AND expression .)
    BOOL            reduce using rule 58 (expression -> expression AND expression .)
    IF              reduce using rule 58 (expression -> expression AND expression .)
    FOR             reduce using rule 58 (expression -> expression AND expression .)
    $end            reduce using rule 58 (expression -> expression AND expression .)
    RBRACKET        reduce using rule 58 (expression -> expression AND expression .)
    LBRACKET        reduce using rule 58 (expression -> expression AND expression .)
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    AND             shift and go to state 140
    OR              shift and go to state 141

  ! PLUS            [ reduce using rule 58 (expression -> expression AND expression .) ]
  ! MINUS           [ reduce using rule 58 (expression -> expression AND expression .) ]
  ! TIMES           [ reduce using rule 58 (expression -> expression AND expression .) ]
  ! DIVIDE          [ reduce using rule 58 (expression -> expression AND expression .) ]
  ! AND             [ reduce using rule 58 (expression -> expression AND expression .) ]
  ! OR              [ reduce using rule 58 (expression -> expression AND expression .) ]


state 210

    (59) expression -> expression OR expression .
    (54) expression -> expression . PLUS expression
    (55) expression -> expression . MINUS expression
    (56) expression -> expression . TIMES expression
    (57) expression -> expression . DIVIDE expression
    (58) expression -> expression . AND expression
    (59) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 59 (expression -> expression OR expression .)
    COMMA           reduce using rule 59 (expression -> expression OR expression .)
    SEMICOLON       reduce using rule 59 (expression -> expression OR expression .)
    GREATER         reduce using rule 59 (expression -> expression OR expression .)
    LESS            reduce using rule 59 (expression -> expression OR expression .)
    EQUALS          reduce using rule 59 (expression -> expression OR expression .)
    GREATER_EQUAL   reduce using rule 59 (expression -> expression OR expression .)
    LESS_EQUAL      reduce using rule 59 (expression -> expression OR expression .)
    NOT_EQUALS      reduce using rule 59 (expression -> expression OR expression .)
    RSBRACKET       reduce using rule 59 (expression -> expression OR expression .)
    PRINT           reduce using rule 59 (expression -> expression OR expression .)
    STRING          reduce using rule 59 (expression -> expression OR expression .)
    VAR             reduce using rule 59 (expression -> expression OR expression .)
    FINAL           reduce using rule 59 (expression -> expression OR expression .)
    ID              reduce using rule 59 (expression -> expression OR expression .)
    VOID            reduce using rule 59 (expression -> expression OR expression .)
    LIST            reduce using rule 59 (expression -> expression OR expression .)
    DYNAMIC         reduce using rule 59 (expression -> expression OR expression .)
    INT             reduce using rule 59 (expression -> expression OR expression .)
    DOUBLE          reduce using rule 59 (expression -> expression OR expression .)
    MAP             reduce using rule 59 (expression -> expression OR expression .)
    WHILE           reduce using rule 59 (expression -> expression OR expression .)
    BOOL            reduce using rule 59 (expression -> expression OR expression .)
    IF              reduce using rule 59 (expression -> expression OR expression .)
    FOR             reduce using rule 59 (expression -> expression OR expression .)
    $end            reduce using rule 59 (expression -> expression OR expression .)
    RBRACKET        reduce using rule 59 (expression -> expression OR expression .)
    LBRACKET        reduce using rule 59 (expression -> expression OR expression .)
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    AND             shift and go to state 140
    OR              shift and go to state 141

  ! PLUS            [ reduce using rule 59 (expression -> expression OR expression .) ]
  ! MINUS           [ reduce using rule 59 (expression -> expression OR expression .) ]
  ! TIMES           [ reduce using rule 59 (expression -> expression OR expression .) ]
  ! DIVIDE          [ reduce using rule 59 (expression -> expression OR expression .) ]
  ! AND             [ reduce using rule 59 (expression -> expression OR expression .) ]
  ! OR              [ reduce using rule 59 (expression -> expression OR expression .) ]


state 211

    (45) print -> PRINT LPAREN length RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    PRINT           reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    STRING          reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    VAR             reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    FINAL           reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    ID              reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    VOID            reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    LIST            reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    INT             reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    MAP             reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    WHILE           reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    BOOL            reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    IF              reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    FOR             reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    $end            reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)


state 212

    (52) simple_operations_arithmetics -> list_numbers simple_operators_arithmetics list_numbers .
    (53) simple_operations_arithmetics -> list_numbers simple_operators_arithmetics list_numbers . simple_operators_arithmetics simple_operations_arithmetics
    (48) simple_operators_arithmetics -> . MINUS
    (49) simple_operators_arithmetics -> . PLUS
    (50) simple_operators_arithmetics -> . DIVIDE
    (51) simple_operators_arithmetics -> . TIMES

    RPAREN          reduce using rule 52 (simple_operations_arithmetics -> list_numbers simple_operators_arithmetics list_numbers .)
    SEMICOLON       reduce using rule 52 (simple_operations_arithmetics -> list_numbers simple_operators_arithmetics list_numbers .)
    MINUS           shift and go to state 144
    PLUS            shift and go to state 145
    DIVIDE          shift and go to state 146
    TIMES           shift and go to state 147

    simple_operators_arithmetics   shift and go to state 264

state 213

    (47) list_numbers -> NDOUBLE .

    MINUS           reduce using rule 47 (list_numbers -> NDOUBLE .)
    PLUS            reduce using rule 47 (list_numbers -> NDOUBLE .)
    DIVIDE          reduce using rule 47 (list_numbers -> NDOUBLE .)
    TIMES           reduce using rule 47 (list_numbers -> NDOUBLE .)
    RPAREN          reduce using rule 47 (list_numbers -> NDOUBLE .)
    SEMICOLON       reduce using rule 47 (list_numbers -> NDOUBLE .)


state 214

    (25) length -> TEXT DOT LENGTH .

    RPAREN          reduce using rule 25 (length -> TEXT DOT LENGTH .)
    SEMICOLON       reduce using rule 25 (length -> TEXT DOT LENGTH .)


state 215

    (103) interpolated_string -> TEXT PLUS ID .
    (99) value -> ID .

  ! reduce/reduce conflict for RPAREN resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for COMMA resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for LESS resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for EQUALS resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUALS resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for RSBRACKET resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for PRINT resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for STRING resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for VAR resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for FINAL resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for ID resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for VOID resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for LIST resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for DYNAMIC resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for INT resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for DOUBLE resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for MAP resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for WHILE resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for BOOL resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for IF resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for FOR resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 99 (value -> ID .)
    RPAREN          reduce using rule 99 (value -> ID .)
    PLUS            reduce using rule 99 (value -> ID .)
    MINUS           reduce using rule 99 (value -> ID .)
    TIMES           reduce using rule 99 (value -> ID .)
    DIVIDE          reduce using rule 99 (value -> ID .)
    AND             reduce using rule 99 (value -> ID .)
    OR              reduce using rule 99 (value -> ID .)
    COMMA           reduce using rule 99 (value -> ID .)
    SEMICOLON       reduce using rule 99 (value -> ID .)
    GREATER         reduce using rule 99 (value -> ID .)
    LESS            reduce using rule 99 (value -> ID .)
    EQUALS          reduce using rule 99 (value -> ID .)
    GREATER_EQUAL   reduce using rule 99 (value -> ID .)
    LESS_EQUAL      reduce using rule 99 (value -> ID .)
    NOT_EQUALS      reduce using rule 99 (value -> ID .)
    RSBRACKET       reduce using rule 99 (value -> ID .)
    PRINT           reduce using rule 99 (value -> ID .)
    STRING          reduce using rule 99 (value -> ID .)
    VAR             reduce using rule 99 (value -> ID .)
    FINAL           reduce using rule 99 (value -> ID .)
    ID              reduce using rule 99 (value -> ID .)
    VOID            reduce using rule 99 (value -> ID .)
    LIST            reduce using rule 99 (value -> ID .)
    DYNAMIC         reduce using rule 99 (value -> ID .)
    INT             reduce using rule 99 (value -> ID .)
    DOUBLE          reduce using rule 99 (value -> ID .)
    MAP             reduce using rule 99 (value -> ID .)
    WHILE           reduce using rule 99 (value -> ID .)
    BOOL            reduce using rule 99 (value -> ID .)
    IF              reduce using rule 99 (value -> ID .)
    FOR             reduce using rule 99 (value -> ID .)
    $end            reduce using rule 99 (value -> ID .)
    RBRACKET        reduce using rule 99 (value -> ID .)
    LBRACKET        reduce using rule 99 (value -> ID .)

  ! RPAREN          [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! PLUS            [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! GREATER         [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! LESS            [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! EQUALS          [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! GREATER_EQUAL   [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! LESS_EQUAL      [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! NOT_EQUALS      [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! MINUS           [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! TIMES           [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! DIVIDE          [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! AND             [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! OR              [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! COMMA           [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! RSBRACKET       [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! SEMICOLON       [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! PRINT           [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! STRING          [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! VAR             [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! FINAL           [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! ID              [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! VOID            [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! LIST            [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! DYNAMIC         [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! INT             [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! DOUBLE          [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! MAP             [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! WHILE           [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! BOOL            [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! IF              [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! FOR             [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! $end            [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! RBRACKET        [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! LBRACKET        [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]


state 216

    (104) interpolated_string -> TEXT PLUS expression .
    (54) expression -> expression . PLUS expression
    (55) expression -> expression . MINUS expression
    (56) expression -> expression . TIMES expression
    (57) expression -> expression . DIVIDE expression
    (58) expression -> expression . AND expression
    (59) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    GREATER         reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    LESS            reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    EQUALS          reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    GREATER_EQUAL   reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    LESS_EQUAL      reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    NOT_EQUALS      reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    COMMA           reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    RSBRACKET       reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    SEMICOLON       reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    PRINT           reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    STRING          reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    VAR             reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    FINAL           reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    ID              reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    VOID            reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    LIST            reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    DYNAMIC         reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    INT             reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    DOUBLE          reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    MAP             reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    WHILE           reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    BOOL            reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    IF              reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    FOR             reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    $end            reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    RBRACKET        reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    LBRACKET        reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    AND             shift and go to state 140
    OR              shift and go to state 141

  ! PLUS            [ reduce using rule 104 (interpolated_string -> TEXT PLUS expression .) ]
  ! MINUS           [ reduce using rule 104 (interpolated_string -> TEXT PLUS expression .) ]
  ! TIMES           [ reduce using rule 104 (interpolated_string -> TEXT PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 104 (interpolated_string -> TEXT PLUS expression .) ]
  ! AND             [ reduce using rule 104 (interpolated_string -> TEXT PLUS expression .) ]
  ! OR              [ reduce using rule 104 (interpolated_string -> TEXT PLUS expression .) ]


state 217

    (24) length -> call_list DOT LENGTH .

    RPAREN          reduce using rule 24 (length -> call_list DOT LENGTH .)
    SEMICOLON       reduce using rule 24 (length -> call_list DOT LENGTH .)


state 218

    (92) call_list -> LSBRACKET value_list RSBRACKET .

    DOT             reduce using rule 92 (call_list -> LSBRACKET value_list RSBRACKET .)


state 219

    (95) value_list -> value_list COMMA . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    value                          shift and go to state 265
    interpolated_string            shift and go to state 72

state 220

    (22) data_input -> STRING ID ASSIGN STDIN DOT . READLINESYNC LPAREN RPAREN SEMICOLON

    READLINESYNC    shift and go to state 266


state 221

    (23) data_input -> STRING QUESTION ID ASSIGN STDIN . DOT READLINESYNC LPAREN RPAREN SEMICOLON

    DOT             shift and go to state 267


state 222

    (128) constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    PRINT           reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    STRING          reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    VAR             reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    FINAL           reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    ID              reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    VOID            reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    LIST            reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    INT             reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    MAP             reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    WHILE           reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    BOOL            reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    IF              reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    FOR             reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    $end            reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)


state 223

    (27) argument_list -> argument_list COMMA expression .
    (54) expression -> expression . PLUS expression
    (55) expression -> expression . MINUS expression
    (56) expression -> expression . TIMES expression
    (57) expression -> expression . DIVIDE expression
    (58) expression -> expression . AND expression
    (59) expression -> expression . OR expression

    RPAREN          reduce using rule 27 (argument_list -> argument_list COMMA expression .)
    COMMA           reduce using rule 27 (argument_list -> argument_list COMMA expression .)
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    AND             shift and go to state 140
    OR              shift and go to state 141


state 224

    (126) constructor_parenthesis_content -> THIS DOT ID .
    (127) constructor_parenthesis_content -> THIS DOT ID . COMMA constructor_parenthesis_content

    RPAREN          reduce using rule 126 (constructor_parenthesis_content -> THIS DOT ID .)
    COMMA           shift and go to state 268


state 225

    (105) set -> VAR ID ASSIGN LBRACKET value_list . RBRACKET SEMICOLON
    (95) value_list -> value_list . COMMA value

    RBRACKET        shift and go to state 269
    COMMA           shift and go to state 219


state 226

    (106) set -> VAR ID ASSIGN LESS STRING . GREATER LBRACKET RBRACKET SEMICOLON

    GREATER         shift and go to state 270


state 227

    (36) variable_definition -> VAR ID ASSIGN expression SEMICOLON .

    SEMICOLON       reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    DYNAMIC         reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    RBRACKET        reduce using rule 36 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)


state 228

    (107) set -> FINAL ID ASSIGN CONST LBRACKET . value_list RBRACKET SEMICOLON
    (94) value_list -> . value
    (95) value_list -> . value_list COMMA value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    value_list                     shift and go to state 271
    value                          shift and go to state 152
    interpolated_string            shift and go to state 72

state 229

    (135) map_contents -> map_content COMMA map_contents .

    RBRACKET        reduce using rule 135 (map_contents -> map_content COMMA map_contents .)


state 230

    (136) map_content -> key_value COLON value .

    COMMA           reduce using rule 136 (map_content -> key_value COLON value .)
    RBRACKET        reduce using rule 136 (map_content -> key_value COLON value .)


state 231

    (85) parameter -> type ID .

    RPAREN          reduce using rule 85 (parameter -> type ID .)
    COMMA           reduce using rule 85 (parameter -> type ID .)


state 232

    (28) function -> type ID LPAREN parameter_list RPAREN . LBRACKET statement_list RBRACKET
    (129) function -> type ID LPAREN parameter_list RPAREN . ASSIGN GREATER expression

    LBRACKET        shift and go to state 272
    ASSIGN          shift and go to state 273


state 233

    (84) parameter_list -> parameter_list COMMA . parameter
    (85) parameter -> . type ID
    (86) parameter -> . REQUIRED type ID
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST

    REQUIRED        shift and go to state 170
    INT             shift and go to state 99
    DOUBLE          shift and go to state 100
    STRING          shift and go to state 101
    BOOL            shift and go to state 37
    LIST            shift and go to state 97

    parameter                      shift and go to state 274
    type                           shift and go to state 166

state 234

    (30) function -> type ID LPAREN RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    type                           shift and go to state 25
    statement_list                 shift and go to state 275
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 235

    (86) parameter -> REQUIRED type . ID

    ID              shift and go to state 276


state 236

    (34) variable_definition -> type ID ASSIGN expression SEMICOLON .

    SEMICOLON       reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    DYNAMIC         reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    RBRACKET        reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)


state 237

    (29) function -> VOID ID LPAREN parameter_list RPAREN . LBRACKET statement_list RBRACKET
    (33) function -> VOID ID LPAREN parameter_list RPAREN . LBRACKET RBRACKET

    LBRACKET        shift and go to state 277


state 238

    (31) function -> VOID ID LPAREN RPAREN LBRACKET . statement_list RBRACKET
    (32) function -> VOID ID LPAREN RPAREN LBRACKET . RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 279
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement_list                 shift and go to state 278
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 239

    (93) list_definition -> LIST LESS type GREATER ID . ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON

    ASSIGN          shift and go to state 280


state 240

    (35) variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .

    SEMICOLON       reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    DYNAMIC         reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    RBRACKET        reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)


state 241

    (37) variable_definition -> INT ID ASSIGN length SEMICOLON .

    SEMICOLON       reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    PRINT           reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    STRING          reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    VAR             reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    FINAL           reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    ID              reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    VOID            reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    LIST            reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    DYNAMIC         reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    INT             reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    DOUBLE          reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    MAP             reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    WHILE           reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    BOOL            reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    IF              reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    FOR             reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    $end            reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    RBRACKET        reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)


state 242

    (38) variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .

    SEMICOLON       reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    PRINT           reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    STRING          reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    VAR             reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    FINAL           reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    ID              reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    VOID            reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    LIST            reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    DYNAMIC         reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    INT             reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    DOUBLE          reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    MAP             reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    WHILE           reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    BOOL            reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    IF              reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    FOR             reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    $end            reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    RBRACKET        reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)


state 243

    (39) variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .

    SEMICOLON       reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    PRINT           reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    STRING          reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    VAR             reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    FINAL           reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    ID              reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    VOID            reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    LIST            reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    DYNAMIC         reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    INT             reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    DOUBLE          reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    MAP             reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    WHILE           reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    BOOL            reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    IF              reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    FOR             reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    $end            reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    RBRACKET        reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)


state 244

    (40) variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .

    SEMICOLON       reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    PRINT           reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    STRING          reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    VAR             reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    FINAL           reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    ID              reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    VOID            reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    LIST            reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    DYNAMIC         reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    INT             reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    DOUBLE          reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    MAP             reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    WHILE           reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    BOOL            reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    IF              reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    FOR             reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    $end            reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    RBRACKET        reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)


state 245

    (132) map_declaration -> MAP LESS key_type COMMA type . GREATER ID ASSIGN

    GREATER         shift and go to state 281


state 246

    (69) else_if_blocks -> else_if_blocks ELSE IF LPAREN . conditions RPAREN LBRACKET statement_list RBRACKET
    (71) conditions -> . condition
    (72) conditions -> . conditions AND conditions
    (73) conditions -> . conditions OR conditions
    (74) condition -> . value comparator value
    (75) condition -> . NOT condition
    (76) condition -> . LPAREN conditions RPAREN
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 115
    LPAREN          shift and go to state 111
    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    conditions                     shift and go to state 282
    condition                      shift and go to state 113
    value                          shift and go to state 114
    interpolated_string            shift and go to state 72

state 247

    (68) else_if_blocks -> ELSE IF LPAREN conditions . RPAREN LBRACKET statement_list RBRACKET
    (72) conditions -> conditions . AND conditions
    (73) conditions -> conditions . OR conditions

    RPAREN          shift and go to state 283
    AND             shift and go to state 188
    OR              shift and go to state 189


state 248

    (70) else_block -> ELSE LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)


state 249

    (76) condition -> LPAREN conditions RPAREN .

    LBRACKET        reduce using rule 76 (condition -> LPAREN conditions RPAREN .)
    AND             reduce using rule 76 (condition -> LPAREN conditions RPAREN .)
    OR              reduce using rule 76 (condition -> LPAREN conditions RPAREN .)
    RPAREN          reduce using rule 76 (condition -> LPAREN conditions RPAREN .)
    SEMICOLON       reduce using rule 76 (condition -> LPAREN conditions RPAREN .)


state 250

    (130) control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 284
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement                      shift and go to state 40
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 251

    (72) conditions -> conditions AND conditions .
    (72) conditions -> conditions . AND conditions
    (73) conditions -> conditions . OR conditions

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    LBRACKET        reduce using rule 72 (conditions -> conditions AND conditions .)
    RPAREN          reduce using rule 72 (conditions -> conditions AND conditions .)
    SEMICOLON       reduce using rule 72 (conditions -> conditions AND conditions .)
    AND             shift and go to state 188
    OR              shift and go to state 189

  ! AND             [ reduce using rule 72 (conditions -> conditions AND conditions .) ]
  ! OR              [ reduce using rule 72 (conditions -> conditions AND conditions .) ]


state 252

    (73) conditions -> conditions OR conditions .
    (72) conditions -> conditions . AND conditions
    (73) conditions -> conditions . OR conditions

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    LBRACKET        reduce using rule 73 (conditions -> conditions OR conditions .)
    RPAREN          reduce using rule 73 (conditions -> conditions OR conditions .)
    SEMICOLON       reduce using rule 73 (conditions -> conditions OR conditions .)
    AND             shift and go to state 188
    OR              shift and go to state 189

  ! AND             [ reduce using rule 73 (conditions -> conditions OR conditions .) ]
  ! OR              [ reduce using rule 73 (conditions -> conditions OR conditions .) ]


state 253

    (74) condition -> value comparator value .

    LBRACKET        reduce using rule 74 (condition -> value comparator value .)
    AND             reduce using rule 74 (condition -> value comparator value .)
    OR              reduce using rule 74 (condition -> value comparator value .)
    RPAREN          reduce using rule 74 (condition -> value comparator value .)
    SEMICOLON       reduce using rule 74 (condition -> value comparator value .)


state 254

    (67) if_block -> IF LPAREN conditions RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement_list                 shift and go to state 285
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 255

    (116) for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement_list                 shift and go to state 286
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 256

    (118) for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement_list                 shift and go to state 287
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 257

    (122) for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement_list                 shift and go to state 288
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 258

    (115) for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions . SEMICOLON for_classic_changes

    SEMICOLON       shift and go to state 289


state 259

    (110) for_classic_conditions -> conditions .
    (72) conditions -> conditions . AND conditions
    (73) conditions -> conditions . OR conditions

    SEMICOLON       reduce using rule 110 (for_classic_conditions -> conditions .)
    AND             shift and go to state 188
    OR              shift and go to state 189


state 260

    (117) for_in_parenthesis_content -> FINAL ID IN . ID

    ID              shift and go to state 290


state 261

    (121) for_each_parenthesis_content -> FINAL ID LPAREN . for_each_parenthesis_parenthesis_content RPAREN IN ID
    (119) for_each_parenthesis_parenthesis_content -> . COLON ID
    (120) for_each_parenthesis_parenthesis_content -> . COLON ID COMMA for_each_parenthesis_parenthesis_content

    COLON           shift and go to state 292

    for_each_parenthesis_parenthesis_content shift and go to state 291

state 262

    (108) for_classic_initialization -> INT ID ASSIGN . NUMBER

    NUMBER          shift and go to state 293


state 263

    (109) for_classic_initialization -> DOUBLE ID ASSIGN . NDOUBLE

    NDOUBLE         shift and go to state 294


state 264

    (53) simple_operations_arithmetics -> list_numbers simple_operators_arithmetics list_numbers simple_operators_arithmetics . simple_operations_arithmetics
    (52) simple_operations_arithmetics -> . list_numbers simple_operators_arithmetics list_numbers
    (53) simple_operations_arithmetics -> . list_numbers simple_operators_arithmetics list_numbers simple_operators_arithmetics simple_operations_arithmetics
    (46) list_numbers -> . NUMBER
    (47) list_numbers -> . NDOUBLE

    NUMBER          shift and go to state 181
    NDOUBLE         shift and go to state 213

    list_numbers                   shift and go to state 67
    simple_operations_arithmetics  shift and go to state 295

state 265

    (95) value_list -> value_list COMMA value .

    RSBRACKET       reduce using rule 95 (value_list -> value_list COMMA value .)
    COMMA           reduce using rule 95 (value_list -> value_list COMMA value .)
    RBRACKET        reduce using rule 95 (value_list -> value_list COMMA value .)


state 266

    (22) data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 296


state 267

    (23) data_input -> STRING QUESTION ID ASSIGN STDIN DOT . READLINESYNC LPAREN RPAREN SEMICOLON

    READLINESYNC    shift and go to state 297


state 268

    (127) constructor_parenthesis_content -> THIS DOT ID COMMA . constructor_parenthesis_content
    (126) constructor_parenthesis_content -> . THIS DOT ID
    (127) constructor_parenthesis_content -> . THIS DOT ID COMMA constructor_parenthesis_content

    THIS            shift and go to state 82

    constructor_parenthesis_content shift and go to state 298

state 269

    (105) set -> VAR ID ASSIGN LBRACKET value_list RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 299


state 270

    (106) set -> VAR ID ASSIGN LESS STRING GREATER . LBRACKET RBRACKET SEMICOLON

    LBRACKET        shift and go to state 300


state 271

    (107) set -> FINAL ID ASSIGN CONST LBRACKET value_list . RBRACKET SEMICOLON
    (95) value_list -> value_list . COMMA value

    RBRACKET        shift and go to state 301
    COMMA           shift and go to state 219


state 272

    (28) function -> type ID LPAREN parameter_list RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    type                           shift and go to state 25
    statement_list                 shift and go to state 302
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 273

    (129) function -> type ID LPAREN parameter_list RPAREN ASSIGN . GREATER expression

    GREATER         shift and go to state 303


state 274

    (84) parameter_list -> parameter_list COMMA parameter .

    RPAREN          reduce using rule 84 (parameter_list -> parameter_list COMMA parameter .)
    COMMA           reduce using rule 84 (parameter_list -> parameter_list COMMA parameter .)


state 275

    (30) function -> type ID LPAREN RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 304
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    type                           shift and go to state 25
    statement                      shift and go to state 40
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 276

    (86) parameter -> REQUIRED type ID .

    RPAREN          reduce using rule 86 (parameter -> REQUIRED type ID .)
    COMMA           reduce using rule 86 (parameter -> REQUIRED type ID .)


state 277

    (29) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET . statement_list RBRACKET
    (33) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET . RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 306
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement_list                 shift and go to state 305
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 278

    (31) function -> VOID ID LPAREN RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 307
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement                      shift and go to state 40
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 279

    (32) function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .

    SEMICOLON       reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    PRINT           reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    STRING          reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    VAR             reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    FINAL           reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    ID              reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    VOID            reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    LIST            reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    DYNAMIC         reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    INT             reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    DOUBLE          reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    MAP             reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    WHILE           reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    BOOL            reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    IF              reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    FOR             reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    $end            reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 32 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)


state 280

    (93) list_definition -> LIST LESS type GREATER ID ASSIGN . LSBRACKET value_list RSBRACKET SEMICOLON

    LSBRACKET       shift and go to state 308


state 281

    (132) map_declaration -> MAP LESS key_type COMMA type GREATER . ID ASSIGN

    ID              shift and go to state 309


state 282

    (69) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions . RPAREN LBRACKET statement_list RBRACKET
    (72) conditions -> conditions . AND conditions
    (73) conditions -> conditions . OR conditions

    RPAREN          shift and go to state 310
    AND             shift and go to state 188
    OR              shift and go to state 189


state 283

    (68) else_if_blocks -> ELSE IF LPAREN conditions RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 311


state 284

    (130) control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)


state 285

    (67) if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 312
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement                      shift and go to state 40
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 286

    (116) for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 313
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement                      shift and go to state 40
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 287

    (118) for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 314
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement                      shift and go to state 40
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 288

    (122) for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 315
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement                      shift and go to state 40
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 289

    (115) for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON . for_classic_changes
    (111) for_classic_changes -> . ID comparator value
    (112) for_classic_changes -> . ID INCREMENT
    (113) for_classic_changes -> . ID DECREMENT
    (114) for_classic_changes -> . ID comparator value COMMA for_classic_changes

    ID              shift and go to state 317

    for_classic_changes            shift and go to state 316

state 290

    (117) for_in_parenthesis_content -> FINAL ID IN ID .

    RPAREN          reduce using rule 117 (for_in_parenthesis_content -> FINAL ID IN ID .)


state 291

    (121) for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content . RPAREN IN ID

    RPAREN          shift and go to state 318


state 292

    (119) for_each_parenthesis_parenthesis_content -> COLON . ID
    (120) for_each_parenthesis_parenthesis_content -> COLON . ID COMMA for_each_parenthesis_parenthesis_content

    ID              shift and go to state 319


state 293

    (108) for_classic_initialization -> INT ID ASSIGN NUMBER .

    SEMICOLON       reduce using rule 108 (for_classic_initialization -> INT ID ASSIGN NUMBER .)


state 294

    (109) for_classic_initialization -> DOUBLE ID ASSIGN NDOUBLE .

    SEMICOLON       reduce using rule 109 (for_classic_initialization -> DOUBLE ID ASSIGN NDOUBLE .)


state 295

    (53) simple_operations_arithmetics -> list_numbers simple_operators_arithmetics list_numbers simple_operators_arithmetics simple_operations_arithmetics .

    RPAREN          reduce using rule 53 (simple_operations_arithmetics -> list_numbers simple_operators_arithmetics list_numbers simple_operators_arithmetics simple_operations_arithmetics .)
    SEMICOLON       reduce using rule 53 (simple_operations_arithmetics -> list_numbers simple_operators_arithmetics list_numbers simple_operators_arithmetics simple_operations_arithmetics .)


state 296

    (22) data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 320


state 297

    (23) data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 321


state 298

    (127) constructor_parenthesis_content -> THIS DOT ID COMMA constructor_parenthesis_content .

    RPAREN          reduce using rule 127 (constructor_parenthesis_content -> THIS DOT ID COMMA constructor_parenthesis_content .)


state 299

    (105) set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .

    SEMICOLON       reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    PRINT           reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    STRING          reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    VAR             reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    FINAL           reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    ID              reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    VOID            reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    LIST            reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    INT             reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    MAP             reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    WHILE           reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    BOOL            reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    IF              reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    FOR             reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    $end            reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    RBRACKET        reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)


state 300

    (106) set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 322


state 301

    (107) set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 323


state 302

    (28) function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 324
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    type                           shift and go to state 25
    statement                      shift and go to state 40
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 303

    (129) function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER . expression
    (54) expression -> . expression PLUS expression
    (55) expression -> . expression MINUS expression
    (56) expression -> . expression TIMES expression
    (57) expression -> . expression DIVIDE expression
    (58) expression -> . expression AND expression
    (59) expression -> . expression OR expression
    (60) expression -> . value comparator value
    (61) expression -> . value PLUS value
    (62) expression -> . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    expression                     shift and go to state 325
    value                          shift and go to state 84
    interpolated_string            shift and go to state 72

state 304

    (30) function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)


state 305

    (29) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 326
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement                      shift and go to state 40
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 306

    (33) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .

    SEMICOLON       reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    PRINT           reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    STRING          reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    VAR             reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    FINAL           reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    ID              reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    VOID            reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    LIST            reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    DYNAMIC         reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    INT             reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    DOUBLE          reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    MAP             reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    WHILE           reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    BOOL            reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    IF              reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    FOR             reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    $end            reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 33 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)


state 307

    (31) function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 31 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)


state 308

    (93) list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET . value_list RSBRACKET SEMICOLON
    (94) value_list -> . value
    (95) value_list -> . value_list COMMA value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    value_list                     shift and go to state 327
    value                          shift and go to state 152
    interpolated_string            shift and go to state 72

state 309

    (132) map_declaration -> MAP LESS key_type COMMA type GREATER ID . ASSIGN

    ASSIGN          shift and go to state 328


state 310

    (69) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 329


state 311

    (68) else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement_list                 shift and go to state 330
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 312

    (67) if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .

    ELSE            reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)


state 313

    (116) for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)


state 314

    (118) for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)


state 315

    (122) for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)


state 316

    (115) for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON for_classic_changes .

    RPAREN          reduce using rule 115 (for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON for_classic_changes .)


state 317

    (111) for_classic_changes -> ID . comparator value
    (112) for_classic_changes -> ID . INCREMENT
    (113) for_classic_changes -> ID . DECREMENT
    (114) for_classic_changes -> ID . comparator value COMMA for_classic_changes
    (77) comparator -> . GREATER
    (78) comparator -> . LESS
    (79) comparator -> . EQUALS
    (80) comparator -> . GREATER_EQUAL
    (81) comparator -> . LESS_EQUAL
    (82) comparator -> . NOT_EQUALS

    INCREMENT       shift and go to state 332
    DECREMENT       shift and go to state 333
    GREATER         shift and go to state 129
    LESS            shift and go to state 130
    EQUALS          shift and go to state 131
    GREATER_EQUAL   shift and go to state 132
    LESS_EQUAL      shift and go to state 133
    NOT_EQUALS      shift and go to state 134

    comparator                     shift and go to state 331

state 318

    (121) for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN . IN ID

    IN              shift and go to state 334


state 319

    (119) for_each_parenthesis_parenthesis_content -> COLON ID .
    (120) for_each_parenthesis_parenthesis_content -> COLON ID . COMMA for_each_parenthesis_parenthesis_content

    RPAREN          reduce using rule 119 (for_each_parenthesis_parenthesis_content -> COLON ID .)
    COMMA           shift and go to state 335


state 320

    (22) data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 336


state 321

    (23) data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 337


state 322

    (106) set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 338


state 323

    (107) set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .

    SEMICOLON       reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    PRINT           reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    STRING          reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    VAR             reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    FINAL           reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    ID              reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    VOID            reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    LIST            reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    INT             reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    MAP             reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    WHILE           reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    BOOL            reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    IF              reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    FOR             reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    $end            reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    RBRACKET        reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)


state 324

    (28) function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)


state 325

    (129) function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .
    (54) expression -> expression . PLUS expression
    (55) expression -> expression . MINUS expression
    (56) expression -> expression . TIMES expression
    (57) expression -> expression . DIVIDE expression
    (58) expression -> expression . AND expression
    (59) expression -> expression . OR expression

    SEMICOLON       reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    PRINT           reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    STRING          reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    VAR             reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    FINAL           reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    ID              reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    VOID            reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    LIST            reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    DYNAMIC         reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    INT             reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    DOUBLE          reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    MAP             reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    WHILE           reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    BOOL            reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    IF              reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    FOR             reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    $end            reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    RBRACKET        reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    AND             shift and go to state 140
    OR              shift and go to state 141


state 326

    (29) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)


state 327

    (93) list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list . RSBRACKET SEMICOLON
    (95) value_list -> value_list . COMMA value

    RSBRACKET       shift and go to state 339
    COMMA           shift and go to state 219


state 328

    (132) map_declaration -> MAP LESS key_type COMMA type GREATER ID ASSIGN .

    LBRACKET        reduce using rule 132 (map_declaration -> MAP LESS key_type COMMA type GREATER ID ASSIGN .)


state 329

    (69) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement_list                 shift and go to state 340
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 330

    (68) else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 341
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement                      shift and go to state 40
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 331

    (111) for_classic_changes -> ID comparator . value
    (114) for_classic_changes -> ID comparator . value COMMA for_classic_changes
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    value                          shift and go to state 342
    interpolated_string            shift and go to state 72

state 332

    (112) for_classic_changes -> ID INCREMENT .

    RPAREN          reduce using rule 112 (for_classic_changes -> ID INCREMENT .)


state 333

    (113) for_classic_changes -> ID DECREMENT .

    RPAREN          reduce using rule 113 (for_classic_changes -> ID DECREMENT .)


state 334

    (121) for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN . ID

    ID              shift and go to state 343


state 335

    (120) for_each_parenthesis_parenthesis_content -> COLON ID COMMA . for_each_parenthesis_parenthesis_content
    (119) for_each_parenthesis_parenthesis_content -> . COLON ID
    (120) for_each_parenthesis_parenthesis_content -> . COLON ID COMMA for_each_parenthesis_parenthesis_content

    COLON           shift and go to state 292

    for_each_parenthesis_parenthesis_content shift and go to state 344

state 336

    (22) data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 22 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)


state 337

    (23) data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 345


state 338

    (106) set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .

    SEMICOLON       reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    PRINT           reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    STRING          reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    VAR             reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    FINAL           reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    ID              reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    VOID            reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    LIST            reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    INT             reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    MAP             reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    WHILE           reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    BOOL            reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    IF              reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    FOR             reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    $end            reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    RBRACKET        reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)


state 339

    (93) list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 346


state 340

    (69) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 347
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement                      shift and go to state 40
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 341

    (68) else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .

    ELSE            reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)


state 342

    (111) for_classic_changes -> ID comparator value .
    (114) for_classic_changes -> ID comparator value . COMMA for_classic_changes

    RPAREN          reduce using rule 111 (for_classic_changes -> ID comparator value .)
    COMMA           shift and go to state 348


state 343

    (121) for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID .

    RPAREN          reduce using rule 121 (for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID .)


state 344

    (120) for_each_parenthesis_parenthesis_content -> COLON ID COMMA for_each_parenthesis_parenthesis_content .

    RPAREN          reduce using rule 120 (for_each_parenthesis_parenthesis_content -> COLON ID COMMA for_each_parenthesis_parenthesis_content .)


state 345

    (23) data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)


state 346

    (93) list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .

    SEMICOLON       reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    PRINT           reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    STRING          reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    VAR             reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    FINAL           reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    ID              reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    VOID            reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    LIST            reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    INT             reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    MAP             reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    WHILE           reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    BOOL            reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    IF              reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    FOR             reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    $end            reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    RBRACKET        reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)


state 347

    (69) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .

    ELSE            reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)


state 348

    (114) for_classic_changes -> ID comparator value COMMA . for_classic_changes
    (111) for_classic_changes -> . ID comparator value
    (112) for_classic_changes -> . ID INCREMENT
    (113) for_classic_changes -> . ID DECREMENT
    (114) for_classic_changes -> . ID comparator value COMMA for_classic_changes

    ID              shift and go to state 317

    for_classic_changes            shift and go to state 349

state 349

    (114) for_classic_changes -> ID comparator value COMMA for_classic_changes .

    RPAREN          reduce using rule 114 (for_classic_changes -> ID comparator value COMMA for_classic_changes .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 17 resolved as shift
WARNING: shift/reduce conflict for ID in state 29 resolved as shift
WARNING: shift/reduce conflict for ID in state 30 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 64 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 64 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 70 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 84 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 84 resolved as shift
WARNING: shift/reduce conflict for LESS in state 84 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 84 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 84 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 84 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUALS in state 84 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 87 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 205 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 205 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 205 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 205 resolved as shift
WARNING: shift/reduce conflict for AND in state 205 resolved as shift
WARNING: shift/reduce conflict for OR in state 205 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 206 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 206 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 206 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 206 resolved as shift
WARNING: shift/reduce conflict for AND in state 206 resolved as shift
WARNING: shift/reduce conflict for OR in state 206 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 207 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 207 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 207 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 207 resolved as shift
WARNING: shift/reduce conflict for AND in state 207 resolved as shift
WARNING: shift/reduce conflict for OR in state 207 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 208 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 208 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 208 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 208 resolved as shift
WARNING: shift/reduce conflict for AND in state 208 resolved as shift
WARNING: shift/reduce conflict for OR in state 208 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 209 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 209 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 209 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 209 resolved as shift
WARNING: shift/reduce conflict for AND in state 209 resolved as shift
WARNING: shift/reduce conflict for OR in state 209 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 210 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 210 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 210 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 210 resolved as shift
WARNING: shift/reduce conflict for AND in state 210 resolved as shift
WARNING: shift/reduce conflict for OR in state 210 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 216 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 216 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 216 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 216 resolved as shift
WARNING: shift/reduce conflict for AND in state 216 resolved as shift
WARNING: shift/reduce conflict for OR in state 216 resolved as shift
WARNING: shift/reduce conflict for AND in state 251 resolved as shift
WARNING: shift/reduce conflict for OR in state 251 resolved as shift
WARNING: shift/reduce conflict for AND in state 252 resolved as shift
WARNING: shift/reduce conflict for OR in state 252 resolved as shift
WARNING: reduce/reduce conflict in state 68 resolved using rule (list_numbers -> NUMBER)
WARNING: rejected rule (value -> NUMBER) in state 68
WARNING: reduce/reduce conflict in state 69 resolved using rule (list_numbers -> NDOUBLE)
WARNING: rejected rule (value -> NDOUBLE) in state 69
WARNING: reduce/reduce conflict in state 215 resolved using rule (value -> ID)
WARNING: rejected rule (interpolated_string -> TEXT PLUS ID) in state 215
WARNING: Rule (interpolated_string -> TEXT PLUS ID) is never reduced
