Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AS
    ASSERT
    ASYNC
    AWAIT
    BREAK
    CASE
    CATCH
    CLASS
    CONTINUE
    COVARIANT
    DEFAULT
    DEFERRED
    DO
    DOLLARSIGN
    DOUBLE_COLON
    ENUM
    EXPORT
    EXTENDS
    EXTENSION
    EXTERNAL
    FACTORY
    FINALLY
    FUNCTION
    GET
    HIDE
    IMPLEMENTS
    IMPORT
    INTERFACE
    IS
    LATE
    LIBRARY
    MIXIN
    MODULE
    NEW
    NULL
    NUM
    NUMERAL
    OBJECT
    ON
    OPERATOR
    PART
    RETHROW
    RETURN
    SET
    SHOW
    STATIC
    SUPER
    SWITCH
    SYNC
    THROW
    TRY
    TYPEDEF
    WITH
    YIELD

Grammar

Rule 0     S' -> program
Rule 1     program -> statement_list
Rule 2     statement_list -> statement
Rule 3     statement_list -> statement_list statement
Rule 4     statement -> print
Rule 5     statement -> data_input
Rule 6     statement -> set
Rule 7     statement -> map
Rule 8     statement -> constructor
Rule 9     statement -> control_structures
Rule 10    statement -> function
Rule 11    statement -> list_definition
Rule 12    statement -> variable_definition
Rule 13    statement -> variable_usage
Rule 14    statement -> call_function
<<<<<<< HEAD
Rule 15    statement -> COMMENT_MULTI
Rule 16    statement -> COMMENT_SINGLE
Rule 17    statement -> SEMICOLON
Rule 18    control_structures -> control_structures_if_else
Rule 19    control_structures -> control_structures_for
Rule 20    control_structures -> control_structures_while
Rule 21    variable_usage -> ID SEMICOLON
Rule 22    variable_usage -> ID ASSIGN value SEMICOLON
Rule 23    call_function -> ID LPAREN argument_list RPAREN
Rule 24    call_function -> ID LPAREN RPAREN
Rule 25    data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
Rule 26    data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
Rule 27    length -> call_list DOT LENGTH
Rule 28    length -> TEXT DOT LENGTH
Rule 29    argument_list -> expression
Rule 30    argument_list -> argument_list COMMA expression
Rule 31    function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
Rule 32    function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
Rule 33    function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
Rule 34    function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
Rule 35    function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET
Rule 36    function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
Rule 37    variable_definition -> type ID ASSIGN expression SEMICOLON
Rule 38    variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON
Rule 39    variable_definition -> VAR ID ASSIGN expression SEMICOLON
Rule 40    print -> PRINT LPAREN RPAREN SEMICOLON
Rule 41    print -> PRINT LPAREN print_options RPAREN SEMICOLON
Rule 42    print_options -> interpolated_string
Rule 43    print_options -> expression
Rule 44    print_options -> length
Rule 45    print_options -> call_function
Rule 46    expression -> operations
Rule 47    operations -> operation
Rule 48    operations -> operation operand operations
Rule 49    operation -> operand operator operand
Rule 50    operand -> NUMBER
Rule 51    operand -> DOUBLE
Rule 52    operator -> PLUS
Rule 53    operator -> MINUS
Rule 54    operator -> TIMES
Rule 55    operator -> DIVIDE
Rule 56    expression -> conditions
Rule 57    expression -> value
Rule 58    control_structures_if_else -> if_block
Rule 59    control_structures_if_else -> if_block else_if_blocks
Rule 60    control_structures_if_else -> if_block else_if_blocks else_block
Rule 61    control_structures_if_else -> if_block else_block
Rule 62    if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
Rule 63    else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
Rule 64    else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
Rule 65    else_block -> ELSE LBRACKET statement_list RBRACKET
Rule 66    conditions -> condition
Rule 67    conditions -> condition AND conditions
Rule 68    conditions -> condition OR conditions
Rule 69    condition -> value comparator value
Rule 70    condition -> NOT condition
Rule 71    comparator -> GREATER
Rule 72    comparator -> LESS
Rule 73    comparator -> EQUALS
Rule 74    comparator -> GREATER_EQUAL
Rule 75    comparator -> LESS_EQUAL
Rule 76    comparator -> NOT_EQUALS
Rule 77    parameter_list -> parameter
Rule 78    parameter_list -> parameter_list COMMA parameter
Rule 79    parameter -> type ID
Rule 80    parameter -> REQUIRED type ID
Rule 81    call_list -> LSBRACKET value_list RSBRACKET
Rule 82    list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
Rule 83    value_list -> value
Rule 84    value_list -> value COMMA value_list
Rule 85    interpolated_string -> string_part
Rule 86    interpolated_string -> string_part PLUS interpolated_string
Rule 87    string_part -> TEXT
Rule 88    string_part -> TEXT PLUS value
Rule 89    type -> INT
Rule 90    type -> DOUBLE
Rule 91    type -> STRING
Rule 92    type -> BOOL
Rule 93    type -> LIST
Rule 94    value -> NUMBER
Rule 95    value -> NDOUBLE
Rule 96    value -> TEXT
Rule 97    value -> ID
Rule 98    value -> TRUE
Rule 99    value -> FALSE
Rule 100   set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
Rule 101   set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
Rule 102   set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
Rule 103   for_classic_initialization -> INT ID ASSIGN NUMBER
Rule 104   for_classic_initialization -> DOUBLE ID ASSIGN NDOUBLE
Rule 105   for_classic_conditions -> conditions
Rule 106   for_classic_changes -> ID comparator value
Rule 107   for_classic_changes -> ID INCREMENT
Rule 108   for_classic_changes -> ID DECREMENT
Rule 109   for_classic_changes -> ID comparator value COMMA for_classic_changes
Rule 110   for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON for_classic_changes
Rule 111   for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
Rule 112   for_in_parenthesis_content -> FINAL ID IN ID
Rule 113   for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
Rule 114   for_each_parenthesis_parenthesis_content -> COLON ID
Rule 115   for_each_parenthesis_parenthesis_content -> COLON ID COMMA for_each_parenthesis_parenthesis_content
Rule 116   for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID
Rule 117   for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
Rule 118   control_structures_for -> for_classic
Rule 119   control_structures_for -> for_in
Rule 120   control_structures_for -> for_each
Rule 121   constructor_parenthesis_content -> THIS DOT ID
Rule 122   constructor_parenthesis_content -> THIS DOT ID COMMA constructor_parenthesis_content
Rule 123   constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
Rule 124   function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
Rule 125   control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET
Rule 126   map -> map_declaration map_assignment
Rule 127   map_declaration -> MAP LESS key_type COMMA type GREATER ID ASSIGN
Rule 128   map_assignment -> LBRACKET map_contents RBRACKET
Rule 129   map_contents -> map_content
Rule 130   map_contents -> map_content COMMA map_contents
Rule 131   map_content -> key_value COLON value
Rule 132   key_value -> TEXT
Rule 133   key_type -> STRING
=======
Rule 15    statement -> SEMICOLON
Rule 16    control_structures -> control_structures_if_else
Rule 17    control_structures -> control_structures_for
Rule 18    control_structures -> control_structures_while
Rule 19    variable_usage -> ID
Rule 20    call_function -> ID LPAREN argument_list RPAREN
Rule 21    call_function -> ID LPAREN RPAREN
Rule 22    data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
Rule 23    data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
Rule 24    length -> call_list DOT LENGTH
Rule 25    length -> TEXT DOT LENGTH
Rule 26    argument_list -> expression
Rule 27    argument_list -> argument_list COMMA expression
Rule 28    function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
Rule 29    function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
Rule 30    function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
Rule 31    function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
Rule 32    function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET
Rule 33    function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
Rule 34    variable_definition -> type ID ASSIGN expression SEMICOLON
Rule 35    variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON
Rule 36    variable_definition -> VAR ID ASSIGN expression SEMICOLON
Rule 37    variable_definition -> INT ID ASSIGN length SEMICOLON
Rule 38    variable_definition -> INT ID ASSIGN NUMBER SEMICOLON
Rule 39    variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON
Rule 40    variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
Rule 41    print -> PRINT LPAREN RPAREN SEMICOLON
Rule 42    print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
Rule 43    print -> PRINT LPAREN value RPAREN SEMICOLON
Rule 44    print -> PRINT LPAREN expression RPAREN SEMICOLON
Rule 45    print -> PRINT LPAREN length RPAREN SEMICOLON
Rule 46    list_numbers -> NUMBER
Rule 47    list_numbers -> NDOUBLE
Rule 48    simple_operators_arithmetics -> MINUS
Rule 49    simple_operators_arithmetics -> PLUS
Rule 50    simple_operators_arithmetics -> DIVIDE
Rule 51    simple_operators_arithmetics -> TIMES
Rule 52    simple_operations_arithmetics -> list_numbers simple_operators_arithmetics list_numbers
Rule 53    simple_operations_arithmetics -> list_numbers simple_operators_arithmetics list_numbers simple_operators_arithmetics simple_operations_arithmetics
Rule 54    expression -> expression PLUS expression
Rule 55    expression -> expression MINUS expression
Rule 56    expression -> expression TIMES expression
Rule 57    expression -> expression DIVIDE expression
Rule 58    expression -> expression AND expression
Rule 59    expression -> expression OR expression
Rule 60    expression -> value comparator value
Rule 61    expression -> value PLUS value
Rule 62    expression -> value
Rule 63    control_structures_if_else -> if_block
Rule 64    control_structures_if_else -> if_block else_if_blocks
Rule 65    control_structures_if_else -> if_block else_if_blocks else_block
Rule 66    control_structures_if_else -> if_block else_block
Rule 67    if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
Rule 68    else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
Rule 69    else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
Rule 70    else_block -> ELSE LBRACKET statement_list RBRACKET
Rule 71    conditions -> condition
Rule 72    conditions -> conditions AND conditions
Rule 73    conditions -> conditions OR conditions
Rule 74    condition -> value comparator value
Rule 75    condition -> NOT condition
Rule 76    condition -> LPAREN conditions RPAREN
Rule 77    comparator -> GREATER
Rule 78    comparator -> LESS
Rule 79    comparator -> EQUALS
Rule 80    comparator -> GREATER_EQUAL
Rule 81    comparator -> LESS_EQUAL
Rule 82    comparator -> NOT_EQUALS
Rule 83    parameter_list -> parameter
Rule 84    parameter_list -> parameter_list COMMA parameter
Rule 85    parameter -> type ID
Rule 86    parameter -> REQUIRED type ID
Rule 87    type -> INT
Rule 88    type -> DOUBLE
Rule 89    type -> STRING
Rule 90    type -> BOOL
Rule 91    type -> LIST
Rule 92    call_list -> LSBRACKET value_list RSBRACKET
Rule 93    list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
Rule 94    value_list -> value
Rule 95    value_list -> value_list COMMA value
Rule 96    value -> NUMBER
Rule 97    value -> NDOUBLE
Rule 98    value -> TEXT
Rule 99    value -> ID
Rule 100   value -> interpolated_string
Rule 101   value -> TRUE
Rule 102   value -> FALSE
Rule 103   interpolated_string -> TEXT PLUS ID
Rule 104   interpolated_string -> TEXT PLUS expression
Rule 105   set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
Rule 106   set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
Rule 107   set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
Rule 108   for_classic_initialization -> INT ID ASSIGN NUMBER
Rule 109   for_classic_initialization -> DOUBLE ID ASSIGN NDOUBLE
Rule 110   for_classic_conditions -> conditions
Rule 111   for_classic_changes -> ID comparator value
Rule 112   for_classic_changes -> ID INCREMENT
Rule 113   for_classic_changes -> ID DECREMENT
Rule 114   for_classic_changes -> ID comparator value COMMA for_classic_changes
Rule 115   for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON for_classic_changes
Rule 116   for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
Rule 117   for_in_parenthesis_content -> FINAL ID IN ID
Rule 118   for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
Rule 119   for_each_parenthesis_parenthesis_content -> COLON ID
Rule 120   for_each_parenthesis_parenthesis_content -> COLON ID COMMA for_each_parenthesis_parenthesis_content
Rule 121   for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID
Rule 122   for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
Rule 123   control_structures_for -> for_classic
Rule 124   control_structures_for -> for_in
Rule 125   control_structures_for -> for_each
Rule 126   constructor_parenthesis_content -> THIS DOT ID
Rule 127   constructor_parenthesis_content -> THIS DOT ID COMMA constructor_parenthesis_content
Rule 128   constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
Rule 129   function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
Rule 130   control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET
Rule 131   map -> map_declaration map_assignment
Rule 132   map_declaration -> MAP LESS key_type COMMA type GREATER ID ASSIGN
Rule 133   map_assignment -> LBRACKET map_contents RBRACKET
Rule 134   map_contents -> map_content
Rule 135   map_contents -> map_content COMMA map_contents
Rule 136   map_content -> key_value COLON value
Rule 137   key_value -> TEXT
Rule 138   key_type -> STRING
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

Terminals, with rules where they appear

ABSTRACT             : 
<<<<<<< HEAD
AND                  : 67
AS                   : 
ASSERT               : 
ASSIGN               : 22 25 26 37 38 39 82 100 101 102 103 104 124 127
ASYNC                : 
AWAIT                : 
BOOL                 : 92
=======
AND                  : 58 72
AS                   : 
ASSERT               : 
ASSIGN               : 22 23 34 35 36 37 38 39 40 93 105 106 107 108 109 129 132
ASYNC                : 
AWAIT                : 
BOOL                 : 90
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
BREAK                : 
CASE                 : 
CATCH                : 
CLASS                : 
<<<<<<< HEAD
COLON                : 114 115 131
COMMA                : 30 78 84 109 115 122 127 130
COMMENT_MULTI        : 15
COMMENT_SINGLE       : 16
CONST                : 102
CONTINUE             : 
COVARIANT            : 
DECREMENT            : 108
DEFAULT              : 
DEFERRED             : 
DIVIDE               : 55
DO                   : 
DOLLARSIGN           : 
DOT                  : 25 26 27 28 121 122
DOUBLE               : 51 90 104
DOUBLE_COLON         : 
DYNAMIC              : 38
ELSE                 : 63 64 65
ENUM                 : 
EQUALS               : 73
=======
COLON                : 119 120 136
COMMA                : 27 84 95 114 120 127 132 135
CONST                : 107
CONTINUE             : 
COVARIANT            : 
DECREMENT            : 113
DEFAULT              : 
DEFERRED             : 
DIVIDE               : 50 57
DO                   : 
DOLLARSIGN           : 
DOT                  : 22 23 24 25 126 127
DOUBLE               : 39 40 88 109
DOUBLE_COLON         : 
DYNAMIC              : 35
ELSE                 : 68 69 70
ENUM                 : 
EQUALS               : 79
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
EXPORT               : 
EXTENDS              : 
EXTENSION            : 
EXTERNAL             : 
FACTORY              : 
<<<<<<< HEAD
FALSE                : 99
FINAL                : 102 112 116
FINALLY              : 
FOR                  : 111 113 117
FUNCTION             : 
GET                  : 
GREATER              : 71 82 101 124 127
GREATER_EQUAL        : 74
HIDE                 : 
ID                   : 21 22 23 24 25 26 31 32 33 34 35 36 37 38 39 79 80 82 97 100 101 102 103 104 106 107 108 109 112 112 114 115 116 116 121 122 123 124 127
IF                   : 62 63 64
IMPLEMENTS           : 
IMPORT               : 
IN                   : 112 116
INCREMENT            : 107
INT                  : 89 103
INTERFACE            : 
IS                   : 
LATE                 : 
LBRACKET             : 31 32 33 34 35 36 62 63 64 65 100 101 102 111 113 117 125 128
LENGTH               : 27 28
LESS                 : 72 82 101 127
LESS_EQUAL           : 75
LIBRARY              : 
LIST                 : 82 93
LPAREN               : 23 24 25 26 31 32 33 34 35 36 40 41 62 63 64 111 113 116 117 123 124 125
LSBRACKET            : 81 82
MAP                  : 127
MINUS                : 53
MIXIN                : 
MODULE               : 
NDOUBLE              : 95 104
NEW                  : 
NOT                  : 70
NOT_EQUALS           : 76
NULL                 : 
NUM                  : 
NUMBER               : 50 94 103
=======
FALSE                : 102
FINAL                : 107 117 121
FINALLY              : 
FOR                  : 116 118 122
FUNCTION             : 
GET                  : 
GREATER              : 77 93 106 129 132
GREATER_EQUAL        : 80
HIDE                 : 
ID                   : 19 20 21 22 23 28 29 30 31 32 33 34 35 36 37 38 39 40 85 86 93 99 103 105 106 107 108 109 111 112 113 114 117 117 119 120 121 121 126 127 128 129 132
IF                   : 67 68 69
IMPLEMENTS           : 
IMPORT               : 
IN                   : 117 121
INCREMENT            : 112
INT                  : 37 38 87 108
INTERFACE            : 
IS                   : 
LATE                 : 
LBRACKET             : 28 29 30 31 32 33 67 68 69 70 105 106 107 116 118 122 130 133
LENGTH               : 24 25
LESS                 : 78 93 106 132
LESS_EQUAL           : 81
LIBRARY              : 
LIST                 : 91 93
LPAREN               : 20 21 22 23 28 29 30 31 32 33 41 42 43 44 45 67 68 69 76 116 118 121 122 128 129 130
LSBRACKET            : 92 93
MAP                  : 132
MINUS                : 48 55
MIXIN                : 
MODULE               : 
NDOUBLE              : 39 47 97 109
NEW                  : 
NOT                  : 75
NOT_EQUALS           : 82
NULL                 : 
NUM                  : 
NUMBER               : 38 46 96 108
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
NUMERAL              : 
OBJECT               : 
ON                   : 
OPERATOR             : 
<<<<<<< HEAD
OR                   : 68
PART                 : 
PLUS                 : 52 86 88
PRINT                : 40 41
QUESTION             : 26
RBRACKET             : 31 32 33 34 35 36 62 63 64 65 100 101 102 111 113 117 125 128
READLINESYNC         : 25 26
REQUIRED             : 80
RETHROW              : 
RETURN               : 
RPAREN               : 23 24 25 26 31 32 33 34 35 36 40 41 62 63 64 111 113 116 117 123 124
RSBRACKET            : 81 82
SEMICOLON            : 17 21 22 25 26 37 38 39 40 41 82 100 101 102 110 110 123
SET                  : 
SHOW                 : 
STATIC               : 
STDIN                : 25 26
STRING               : 25 26 91 101 133
SUPER                : 
SWITCH               : 
SYNC                 : 
TEXT                 : 28 87 88 96 132
THIS                 : 121 122
THROW                : 
TIMES                : 54
TRUE                 : 98
TRY                  : 
TYPEDEF              : 
VAR                  : 39 100 101
VOID                 : 32 34 35 36
WHILE                : 125
=======
OR                   : 59 73
PART                 : 
PLUS                 : 49 54 61 103 104
PRINT                : 41 42 43 44 45
QUESTION             : 23
RBRACKET             : 28 29 30 31 32 33 67 68 69 70 105 106 107 116 118 122 130 133
READLINESYNC         : 22 23
REQUIRED             : 86
RETHROW              : 
RETURN               : 
RPAREN               : 20 21 22 23 28 29 30 31 32 33 41 42 43 44 45 67 68 69 76 116 118 121 122 128 129
RSBRACKET            : 92 93
SEMICOLON            : 15 22 23 34 35 36 37 38 39 40 41 42 43 44 45 93 105 106 107 115 115 128
SET                  : 
SHOW                 : 
STATIC               : 
STDIN                : 22 23
STRING               : 22 23 89 106 138
SUPER                : 
SWITCH               : 
SYNC                 : 
TEXT                 : 25 98 103 104 137
THIS                 : 126 127
THROW                : 
TIMES                : 51 56
TRUE                 : 101
TRY                  : 
TYPEDEF              : 
VAR                  : 36 105 106
VOID                 : 29 31 32 33
WHILE                : 130
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
WITH                 : 
YIELD                : 
error                : 

Nonterminals, with rules where they appear

<<<<<<< HEAD
argument_list        : 23 30
call_function        : 14 45
call_list            : 27
comparator           : 69 106 109
condition            : 66 67 68 70
conditions           : 56 62 63 64 67 68 105 125
constructor          : 8
constructor_parenthesis_content : 122 123
=======
argument_list        : 20 27
call_function        : 14
call_list            : 24
comparator           : 60 74 111 114
condition            : 71 75
conditions           : 67 68 69 72 72 73 73 76 110 130
constructor          : 8
constructor_parenthesis_content : 127 128
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
control_structures   : 9
control_structures_for : 19
control_structures_if_else : 18
control_structures_while : 20
data_input           : 5
<<<<<<< HEAD
else_block           : 60 61
else_if_blocks       : 59 60 64
expression           : 29 30 37 38 39 43 124
for_classic          : 118
for_classic_changes  : 109 110
for_classic_conditions : 110
for_classic_initialization : 110
for_classic_parenthesis_content : 111
for_each             : 120
for_each_parenthesis_content : 117
for_each_parenthesis_parenthesis_content : 115 116
for_in               : 119
for_in_parenthesis_content : 113
function             : 10
if_block             : 58 59 60 61
interpolated_string  : 42 86
key_type             : 127
key_value            : 131
length               : 44
=======
else_block           : 65 66
else_if_blocks       : 64 65 69
expression           : 26 27 34 35 36 44 54 54 55 55 56 56 57 57 58 58 59 59 104 129
for_classic          : 123
for_classic_changes  : 114 115
for_classic_conditions : 115
for_classic_initialization : 115
for_classic_parenthesis_content : 116
for_each             : 125
for_each_parenthesis_content : 122
for_each_parenthesis_parenthesis_content : 120 121
for_in               : 124
for_in_parenthesis_content : 118
function             : 10
if_block             : 63 64 65 66
interpolated_string  : 100
key_type             : 132
key_value            : 136
length               : 37 45
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
list_definition      : 11
list_numbers         : 52 52 53 53
map                  : 7
<<<<<<< HEAD
map_assignment       : 126
map_content          : 129 130
map_contents         : 128 130
map_declaration      : 126
operand              : 48 49 49
operation            : 47 48
operations           : 46 48
operator             : 49
parameter            : 77 78
parameter_list       : 31 32 36 78 124
=======
map_assignment       : 131
map_content          : 134 135
map_contents         : 133 135
map_declaration      : 131
parameter            : 83 84
parameter_list       : 28 29 33 84 129
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
print                : 4
print_options        : 41
program              : 0
set                  : 6
simple_operations_arithmetics : 40 42 53
simple_operators_arithmetics : 52 53 53
statement            : 2 3
<<<<<<< HEAD
statement_list       : 1 3 31 32 33 34 62 63 64 65 111 113 117 125
string_part          : 85 86
type                 : 31 33 37 79 80 82 124 127
value                : 22 57 69 69 83 84 88 106 109 131
value_list           : 81 82 84 100 102
=======
statement_list       : 1 3 28 29 30 31 67 68 69 70 116 118 122 130
type                 : 28 30 34 85 86 93 129 132
value                : 43 60 60 61 61 62 74 74 94 95 111 114 136
value_list           : 92 93 95 105 107
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
variable_definition  : 12
variable_usage       : 13

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement_list
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
<<<<<<< HEAD
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
=======
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    program                        shift and go to state 1
    statement_list                 shift and go to state 2
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 1

    (0) S' -> program .



state 2

    (1) program -> statement_list .
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
<<<<<<< HEAD
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
=======
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    $end            reduce using rule 1 (program -> statement_list .)
    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement                      shift and go to state 42
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 3

    (2) statement_list -> statement .

    COMMENT_MULTI   reduce using rule 2 (statement_list -> statement .)
    COMMENT_SINGLE  reduce using rule 2 (statement_list -> statement .)
    SEMICOLON       reduce using rule 2 (statement_list -> statement .)
    PRINT           reduce using rule 2 (statement_list -> statement .)
    STRING          reduce using rule 2 (statement_list -> statement .)
    VAR             reduce using rule 2 (statement_list -> statement .)
    FINAL           reduce using rule 2 (statement_list -> statement .)
    ID              reduce using rule 2 (statement_list -> statement .)
    VOID            reduce using rule 2 (statement_list -> statement .)
    LIST            reduce using rule 2 (statement_list -> statement .)
    DYNAMIC         reduce using rule 2 (statement_list -> statement .)
    MAP             reduce using rule 2 (statement_list -> statement .)
    WHILE           reduce using rule 2 (statement_list -> statement .)
    INT             reduce using rule 2 (statement_list -> statement .)
    DOUBLE          reduce using rule 2 (statement_list -> statement .)
    BOOL            reduce using rule 2 (statement_list -> statement .)
    IF              reduce using rule 2 (statement_list -> statement .)
    FOR             reduce using rule 2 (statement_list -> statement .)
    $end            reduce using rule 2 (statement_list -> statement .)
    RBRACKET        reduce using rule 2 (statement_list -> statement .)


state 4

    (4) statement -> print .

    COMMENT_MULTI   reduce using rule 4 (statement -> print .)
    COMMENT_SINGLE  reduce using rule 4 (statement -> print .)
    SEMICOLON       reduce using rule 4 (statement -> print .)
    PRINT           reduce using rule 4 (statement -> print .)
    STRING          reduce using rule 4 (statement -> print .)
    VAR             reduce using rule 4 (statement -> print .)
    FINAL           reduce using rule 4 (statement -> print .)
    ID              reduce using rule 4 (statement -> print .)
    VOID            reduce using rule 4 (statement -> print .)
    LIST            reduce using rule 4 (statement -> print .)
    DYNAMIC         reduce using rule 4 (statement -> print .)
    MAP             reduce using rule 4 (statement -> print .)
    WHILE           reduce using rule 4 (statement -> print .)
    INT             reduce using rule 4 (statement -> print .)
    DOUBLE          reduce using rule 4 (statement -> print .)
    BOOL            reduce using rule 4 (statement -> print .)
    IF              reduce using rule 4 (statement -> print .)
    FOR             reduce using rule 4 (statement -> print .)
    $end            reduce using rule 4 (statement -> print .)
    RBRACKET        reduce using rule 4 (statement -> print .)


state 5

    (5) statement -> data_input .

    COMMENT_MULTI   reduce using rule 5 (statement -> data_input .)
    COMMENT_SINGLE  reduce using rule 5 (statement -> data_input .)
    SEMICOLON       reduce using rule 5 (statement -> data_input .)
    PRINT           reduce using rule 5 (statement -> data_input .)
    STRING          reduce using rule 5 (statement -> data_input .)
    VAR             reduce using rule 5 (statement -> data_input .)
    FINAL           reduce using rule 5 (statement -> data_input .)
    ID              reduce using rule 5 (statement -> data_input .)
    VOID            reduce using rule 5 (statement -> data_input .)
    LIST            reduce using rule 5 (statement -> data_input .)
    DYNAMIC         reduce using rule 5 (statement -> data_input .)
    MAP             reduce using rule 5 (statement -> data_input .)
    WHILE           reduce using rule 5 (statement -> data_input .)
    INT             reduce using rule 5 (statement -> data_input .)
    DOUBLE          reduce using rule 5 (statement -> data_input .)
    BOOL            reduce using rule 5 (statement -> data_input .)
    IF              reduce using rule 5 (statement -> data_input .)
    FOR             reduce using rule 5 (statement -> data_input .)
    $end            reduce using rule 5 (statement -> data_input .)
    RBRACKET        reduce using rule 5 (statement -> data_input .)


state 6

    (6) statement -> set .

    COMMENT_MULTI   reduce using rule 6 (statement -> set .)
    COMMENT_SINGLE  reduce using rule 6 (statement -> set .)
    SEMICOLON       reduce using rule 6 (statement -> set .)
    PRINT           reduce using rule 6 (statement -> set .)
    STRING          reduce using rule 6 (statement -> set .)
    VAR             reduce using rule 6 (statement -> set .)
    FINAL           reduce using rule 6 (statement -> set .)
    ID              reduce using rule 6 (statement -> set .)
    VOID            reduce using rule 6 (statement -> set .)
    LIST            reduce using rule 6 (statement -> set .)
    DYNAMIC         reduce using rule 6 (statement -> set .)
    MAP             reduce using rule 6 (statement -> set .)
    WHILE           reduce using rule 6 (statement -> set .)
    INT             reduce using rule 6 (statement -> set .)
    DOUBLE          reduce using rule 6 (statement -> set .)
    BOOL            reduce using rule 6 (statement -> set .)
    IF              reduce using rule 6 (statement -> set .)
    FOR             reduce using rule 6 (statement -> set .)
    $end            reduce using rule 6 (statement -> set .)
    RBRACKET        reduce using rule 6 (statement -> set .)


state 7

    (7) statement -> map .

    COMMENT_MULTI   reduce using rule 7 (statement -> map .)
    COMMENT_SINGLE  reduce using rule 7 (statement -> map .)
    SEMICOLON       reduce using rule 7 (statement -> map .)
    PRINT           reduce using rule 7 (statement -> map .)
    STRING          reduce using rule 7 (statement -> map .)
    VAR             reduce using rule 7 (statement -> map .)
    FINAL           reduce using rule 7 (statement -> map .)
    ID              reduce using rule 7 (statement -> map .)
    VOID            reduce using rule 7 (statement -> map .)
    LIST            reduce using rule 7 (statement -> map .)
    DYNAMIC         reduce using rule 7 (statement -> map .)
    MAP             reduce using rule 7 (statement -> map .)
    WHILE           reduce using rule 7 (statement -> map .)
    INT             reduce using rule 7 (statement -> map .)
    DOUBLE          reduce using rule 7 (statement -> map .)
    BOOL            reduce using rule 7 (statement -> map .)
    IF              reduce using rule 7 (statement -> map .)
    FOR             reduce using rule 7 (statement -> map .)
    $end            reduce using rule 7 (statement -> map .)
    RBRACKET        reduce using rule 7 (statement -> map .)


state 8

    (8) statement -> constructor .

    COMMENT_MULTI   reduce using rule 8 (statement -> constructor .)
    COMMENT_SINGLE  reduce using rule 8 (statement -> constructor .)
    SEMICOLON       reduce using rule 8 (statement -> constructor .)
    PRINT           reduce using rule 8 (statement -> constructor .)
    STRING          reduce using rule 8 (statement -> constructor .)
    VAR             reduce using rule 8 (statement -> constructor .)
    FINAL           reduce using rule 8 (statement -> constructor .)
    ID              reduce using rule 8 (statement -> constructor .)
    VOID            reduce using rule 8 (statement -> constructor .)
    LIST            reduce using rule 8 (statement -> constructor .)
    DYNAMIC         reduce using rule 8 (statement -> constructor .)
    MAP             reduce using rule 8 (statement -> constructor .)
    WHILE           reduce using rule 8 (statement -> constructor .)
    INT             reduce using rule 8 (statement -> constructor .)
    DOUBLE          reduce using rule 8 (statement -> constructor .)
    BOOL            reduce using rule 8 (statement -> constructor .)
    IF              reduce using rule 8 (statement -> constructor .)
    FOR             reduce using rule 8 (statement -> constructor .)
    $end            reduce using rule 8 (statement -> constructor .)
    RBRACKET        reduce using rule 8 (statement -> constructor .)


state 9

    (9) statement -> control_structures .

    COMMENT_MULTI   reduce using rule 9 (statement -> control_structures .)
    COMMENT_SINGLE  reduce using rule 9 (statement -> control_structures .)
    SEMICOLON       reduce using rule 9 (statement -> control_structures .)
    PRINT           reduce using rule 9 (statement -> control_structures .)
    STRING          reduce using rule 9 (statement -> control_structures .)
    VAR             reduce using rule 9 (statement -> control_structures .)
    FINAL           reduce using rule 9 (statement -> control_structures .)
    ID              reduce using rule 9 (statement -> control_structures .)
    VOID            reduce using rule 9 (statement -> control_structures .)
    LIST            reduce using rule 9 (statement -> control_structures .)
    DYNAMIC         reduce using rule 9 (statement -> control_structures .)
    MAP             reduce using rule 9 (statement -> control_structures .)
    WHILE           reduce using rule 9 (statement -> control_structures .)
    INT             reduce using rule 9 (statement -> control_structures .)
    DOUBLE          reduce using rule 9 (statement -> control_structures .)
    BOOL            reduce using rule 9 (statement -> control_structures .)
    IF              reduce using rule 9 (statement -> control_structures .)
    FOR             reduce using rule 9 (statement -> control_structures .)
    $end            reduce using rule 9 (statement -> control_structures .)
    RBRACKET        reduce using rule 9 (statement -> control_structures .)


state 10

    (10) statement -> function .

    COMMENT_MULTI   reduce using rule 10 (statement -> function .)
    COMMENT_SINGLE  reduce using rule 10 (statement -> function .)
    SEMICOLON       reduce using rule 10 (statement -> function .)
    PRINT           reduce using rule 10 (statement -> function .)
    STRING          reduce using rule 10 (statement -> function .)
    VAR             reduce using rule 10 (statement -> function .)
    FINAL           reduce using rule 10 (statement -> function .)
    ID              reduce using rule 10 (statement -> function .)
    VOID            reduce using rule 10 (statement -> function .)
    LIST            reduce using rule 10 (statement -> function .)
    DYNAMIC         reduce using rule 10 (statement -> function .)
    MAP             reduce using rule 10 (statement -> function .)
    WHILE           reduce using rule 10 (statement -> function .)
    INT             reduce using rule 10 (statement -> function .)
    DOUBLE          reduce using rule 10 (statement -> function .)
    BOOL            reduce using rule 10 (statement -> function .)
    IF              reduce using rule 10 (statement -> function .)
    FOR             reduce using rule 10 (statement -> function .)
    $end            reduce using rule 10 (statement -> function .)
    RBRACKET        reduce using rule 10 (statement -> function .)


state 11

    (11) statement -> list_definition .

    COMMENT_MULTI   reduce using rule 11 (statement -> list_definition .)
    COMMENT_SINGLE  reduce using rule 11 (statement -> list_definition .)
    SEMICOLON       reduce using rule 11 (statement -> list_definition .)
    PRINT           reduce using rule 11 (statement -> list_definition .)
    STRING          reduce using rule 11 (statement -> list_definition .)
    VAR             reduce using rule 11 (statement -> list_definition .)
    FINAL           reduce using rule 11 (statement -> list_definition .)
    ID              reduce using rule 11 (statement -> list_definition .)
    VOID            reduce using rule 11 (statement -> list_definition .)
    LIST            reduce using rule 11 (statement -> list_definition .)
    DYNAMIC         reduce using rule 11 (statement -> list_definition .)
    MAP             reduce using rule 11 (statement -> list_definition .)
    WHILE           reduce using rule 11 (statement -> list_definition .)
    INT             reduce using rule 11 (statement -> list_definition .)
    DOUBLE          reduce using rule 11 (statement -> list_definition .)
    BOOL            reduce using rule 11 (statement -> list_definition .)
    IF              reduce using rule 11 (statement -> list_definition .)
    FOR             reduce using rule 11 (statement -> list_definition .)
    $end            reduce using rule 11 (statement -> list_definition .)
    RBRACKET        reduce using rule 11 (statement -> list_definition .)


state 12

    (12) statement -> variable_definition .

    COMMENT_MULTI   reduce using rule 12 (statement -> variable_definition .)
    COMMENT_SINGLE  reduce using rule 12 (statement -> variable_definition .)
    SEMICOLON       reduce using rule 12 (statement -> variable_definition .)
    PRINT           reduce using rule 12 (statement -> variable_definition .)
    STRING          reduce using rule 12 (statement -> variable_definition .)
    VAR             reduce using rule 12 (statement -> variable_definition .)
    FINAL           reduce using rule 12 (statement -> variable_definition .)
    ID              reduce using rule 12 (statement -> variable_definition .)
    VOID            reduce using rule 12 (statement -> variable_definition .)
    LIST            reduce using rule 12 (statement -> variable_definition .)
    DYNAMIC         reduce using rule 12 (statement -> variable_definition .)
    MAP             reduce using rule 12 (statement -> variable_definition .)
    WHILE           reduce using rule 12 (statement -> variable_definition .)
    INT             reduce using rule 12 (statement -> variable_definition .)
    DOUBLE          reduce using rule 12 (statement -> variable_definition .)
    BOOL            reduce using rule 12 (statement -> variable_definition .)
    IF              reduce using rule 12 (statement -> variable_definition .)
    FOR             reduce using rule 12 (statement -> variable_definition .)
    $end            reduce using rule 12 (statement -> variable_definition .)
    RBRACKET        reduce using rule 12 (statement -> variable_definition .)


state 13

    (13) statement -> variable_usage .

    COMMENT_MULTI   reduce using rule 13 (statement -> variable_usage .)
    COMMENT_SINGLE  reduce using rule 13 (statement -> variable_usage .)
    SEMICOLON       reduce using rule 13 (statement -> variable_usage .)
    PRINT           reduce using rule 13 (statement -> variable_usage .)
    STRING          reduce using rule 13 (statement -> variable_usage .)
    VAR             reduce using rule 13 (statement -> variable_usage .)
    FINAL           reduce using rule 13 (statement -> variable_usage .)
    ID              reduce using rule 13 (statement -> variable_usage .)
    VOID            reduce using rule 13 (statement -> variable_usage .)
    LIST            reduce using rule 13 (statement -> variable_usage .)
    DYNAMIC         reduce using rule 13 (statement -> variable_usage .)
    MAP             reduce using rule 13 (statement -> variable_usage .)
    WHILE           reduce using rule 13 (statement -> variable_usage .)
    INT             reduce using rule 13 (statement -> variable_usage .)
    DOUBLE          reduce using rule 13 (statement -> variable_usage .)
    BOOL            reduce using rule 13 (statement -> variable_usage .)
    IF              reduce using rule 13 (statement -> variable_usage .)
    FOR             reduce using rule 13 (statement -> variable_usage .)
    $end            reduce using rule 13 (statement -> variable_usage .)
    RBRACKET        reduce using rule 13 (statement -> variable_usage .)


state 14

    (14) statement -> call_function .

    COMMENT_MULTI   reduce using rule 14 (statement -> call_function .)
    COMMENT_SINGLE  reduce using rule 14 (statement -> call_function .)
    SEMICOLON       reduce using rule 14 (statement -> call_function .)
    PRINT           reduce using rule 14 (statement -> call_function .)
    STRING          reduce using rule 14 (statement -> call_function .)
    VAR             reduce using rule 14 (statement -> call_function .)
    FINAL           reduce using rule 14 (statement -> call_function .)
    ID              reduce using rule 14 (statement -> call_function .)
    VOID            reduce using rule 14 (statement -> call_function .)
    LIST            reduce using rule 14 (statement -> call_function .)
    DYNAMIC         reduce using rule 14 (statement -> call_function .)
    MAP             reduce using rule 14 (statement -> call_function .)
    WHILE           reduce using rule 14 (statement -> call_function .)
    INT             reduce using rule 14 (statement -> call_function .)
    DOUBLE          reduce using rule 14 (statement -> call_function .)
    BOOL            reduce using rule 14 (statement -> call_function .)
    IF              reduce using rule 14 (statement -> call_function .)
    FOR             reduce using rule 14 (statement -> call_function .)
    $end            reduce using rule 14 (statement -> call_function .)
    RBRACKET        reduce using rule 14 (statement -> call_function .)


state 15

    (15) statement -> COMMENT_MULTI .

    COMMENT_MULTI   reduce using rule 15 (statement -> COMMENT_MULTI .)
    COMMENT_SINGLE  reduce using rule 15 (statement -> COMMENT_MULTI .)
    SEMICOLON       reduce using rule 15 (statement -> COMMENT_MULTI .)
    PRINT           reduce using rule 15 (statement -> COMMENT_MULTI .)
    STRING          reduce using rule 15 (statement -> COMMENT_MULTI .)
    VAR             reduce using rule 15 (statement -> COMMENT_MULTI .)
    FINAL           reduce using rule 15 (statement -> COMMENT_MULTI .)
    ID              reduce using rule 15 (statement -> COMMENT_MULTI .)
    VOID            reduce using rule 15 (statement -> COMMENT_MULTI .)
    LIST            reduce using rule 15 (statement -> COMMENT_MULTI .)
    DYNAMIC         reduce using rule 15 (statement -> COMMENT_MULTI .)
    MAP             reduce using rule 15 (statement -> COMMENT_MULTI .)
    WHILE           reduce using rule 15 (statement -> COMMENT_MULTI .)
    INT             reduce using rule 15 (statement -> COMMENT_MULTI .)
    DOUBLE          reduce using rule 15 (statement -> COMMENT_MULTI .)
    BOOL            reduce using rule 15 (statement -> COMMENT_MULTI .)
    IF              reduce using rule 15 (statement -> COMMENT_MULTI .)
    FOR             reduce using rule 15 (statement -> COMMENT_MULTI .)
    $end            reduce using rule 15 (statement -> COMMENT_MULTI .)
    RBRACKET        reduce using rule 15 (statement -> COMMENT_MULTI .)


state 16

<<<<<<< HEAD
    (16) statement -> COMMENT_SINGLE .
=======
    (41) print -> PRINT . LPAREN RPAREN SEMICOLON
    (42) print -> PRINT . LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> PRINT . LPAREN value RPAREN SEMICOLON
    (44) print -> PRINT . LPAREN expression RPAREN SEMICOLON
    (45) print -> PRINT . LPAREN length RPAREN SEMICOLON
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    COMMENT_MULTI   reduce using rule 16 (statement -> COMMENT_SINGLE .)
    COMMENT_SINGLE  reduce using rule 16 (statement -> COMMENT_SINGLE .)
    SEMICOLON       reduce using rule 16 (statement -> COMMENT_SINGLE .)
    PRINT           reduce using rule 16 (statement -> COMMENT_SINGLE .)
    STRING          reduce using rule 16 (statement -> COMMENT_SINGLE .)
    VAR             reduce using rule 16 (statement -> COMMENT_SINGLE .)
    FINAL           reduce using rule 16 (statement -> COMMENT_SINGLE .)
    ID              reduce using rule 16 (statement -> COMMENT_SINGLE .)
    VOID            reduce using rule 16 (statement -> COMMENT_SINGLE .)
    LIST            reduce using rule 16 (statement -> COMMENT_SINGLE .)
    DYNAMIC         reduce using rule 16 (statement -> COMMENT_SINGLE .)
    MAP             reduce using rule 16 (statement -> COMMENT_SINGLE .)
    WHILE           reduce using rule 16 (statement -> COMMENT_SINGLE .)
    INT             reduce using rule 16 (statement -> COMMENT_SINGLE .)
    DOUBLE          reduce using rule 16 (statement -> COMMENT_SINGLE .)
    BOOL            reduce using rule 16 (statement -> COMMENT_SINGLE .)
    IF              reduce using rule 16 (statement -> COMMENT_SINGLE .)
    FOR             reduce using rule 16 (statement -> COMMENT_SINGLE .)
    $end            reduce using rule 16 (statement -> COMMENT_SINGLE .)
    RBRACKET        reduce using rule 16 (statement -> COMMENT_SINGLE .)


state 17

<<<<<<< HEAD
    (17) statement -> SEMICOLON .

    COMMENT_MULTI   reduce using rule 17 (statement -> SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 17 (statement -> SEMICOLON .)
    SEMICOLON       reduce using rule 17 (statement -> SEMICOLON .)
    PRINT           reduce using rule 17 (statement -> SEMICOLON .)
    STRING          reduce using rule 17 (statement -> SEMICOLON .)
    VAR             reduce using rule 17 (statement -> SEMICOLON .)
    FINAL           reduce using rule 17 (statement -> SEMICOLON .)
    ID              reduce using rule 17 (statement -> SEMICOLON .)
    VOID            reduce using rule 17 (statement -> SEMICOLON .)
    LIST            reduce using rule 17 (statement -> SEMICOLON .)
    DYNAMIC         reduce using rule 17 (statement -> SEMICOLON .)
    MAP             reduce using rule 17 (statement -> SEMICOLON .)
    WHILE           reduce using rule 17 (statement -> SEMICOLON .)
    INT             reduce using rule 17 (statement -> SEMICOLON .)
    DOUBLE          reduce using rule 17 (statement -> SEMICOLON .)
    BOOL            reduce using rule 17 (statement -> SEMICOLON .)
    IF              reduce using rule 17 (statement -> SEMICOLON .)
    FOR             reduce using rule 17 (statement -> SEMICOLON .)
    $end            reduce using rule 17 (statement -> SEMICOLON .)
    RBRACKET        reduce using rule 17 (statement -> SEMICOLON .)
=======
    (22) data_input -> STRING . ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> STRING . QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (89) type -> STRING .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 42
    QUESTION        shift and go to state 43

  ! ID              [ reduce using rule 89 (type -> STRING .) ]
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 18

<<<<<<< HEAD
    (40) print -> PRINT . LPAREN RPAREN SEMICOLON
    (41) print -> PRINT . LPAREN print_options RPAREN SEMICOLON
=======
    (128) constructor -> ID . LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (19) variable_usage -> ID .
    (20) call_function -> ID . LPAREN argument_list RPAREN
    (21) call_function -> ID . LPAREN RPAREN
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    LPAREN          shift and go to state 43


state 19

<<<<<<< HEAD
    (25) data_input -> STRING . ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> STRING . QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (91) type -> STRING .
=======
    (105) set -> VAR . ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> VAR . ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (36) variable_definition -> VAR . ID ASSIGN expression SEMICOLON
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 44
    QUESTION        shift and go to state 45

  ! ID              [ reduce using rule 91 (type -> STRING .) ]


state 20

<<<<<<< HEAD
    (123) constructor -> ID . LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (21) variable_usage -> ID . SEMICOLON
    (22) variable_usage -> ID . ASSIGN value SEMICOLON
    (23) call_function -> ID . LPAREN argument_list RPAREN
    (24) call_function -> ID . LPAREN RPAREN
=======
    (107) set -> FINAL . ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    LPAREN          shift and go to state 46
    SEMICOLON       shift and go to state 47
    ASSIGN          shift and go to state 48


state 21

<<<<<<< HEAD
    (100) set -> VAR . ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> VAR . ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (39) variable_definition -> VAR . ID ASSIGN expression SEMICOLON
=======
    (131) map -> map_declaration . map_assignment
    (133) map_assignment -> . LBRACKET map_contents RBRACKET

    LBRACKET        shift and go to state 48

    map_assignment                 shift and go to state 47

state 22

    (16) control_structures -> control_structures_if_else .

    SEMICOLON       reduce using rule 16 (control_structures -> control_structures_if_else .)
    PRINT           reduce using rule 16 (control_structures -> control_structures_if_else .)
    STRING          reduce using rule 16 (control_structures -> control_structures_if_else .)
    VAR             reduce using rule 16 (control_structures -> control_structures_if_else .)
    FINAL           reduce using rule 16 (control_structures -> control_structures_if_else .)
    ID              reduce using rule 16 (control_structures -> control_structures_if_else .)
    VOID            reduce using rule 16 (control_structures -> control_structures_if_else .)
    LIST            reduce using rule 16 (control_structures -> control_structures_if_else .)
    DYNAMIC         reduce using rule 16 (control_structures -> control_structures_if_else .)
    INT             reduce using rule 16 (control_structures -> control_structures_if_else .)
    DOUBLE          reduce using rule 16 (control_structures -> control_structures_if_else .)
    MAP             reduce using rule 16 (control_structures -> control_structures_if_else .)
    WHILE           reduce using rule 16 (control_structures -> control_structures_if_else .)
    BOOL            reduce using rule 16 (control_structures -> control_structures_if_else .)
    IF              reduce using rule 16 (control_structures -> control_structures_if_else .)
    FOR             reduce using rule 16 (control_structures -> control_structures_if_else .)
    $end            reduce using rule 16 (control_structures -> control_structures_if_else .)
    RBRACKET        reduce using rule 16 (control_structures -> control_structures_if_else .)


state 23

    (17) control_structures -> control_structures_for .

    SEMICOLON       reduce using rule 17 (control_structures -> control_structures_for .)
    PRINT           reduce using rule 17 (control_structures -> control_structures_for .)
    STRING          reduce using rule 17 (control_structures -> control_structures_for .)
    VAR             reduce using rule 17 (control_structures -> control_structures_for .)
    FINAL           reduce using rule 17 (control_structures -> control_structures_for .)
    ID              reduce using rule 17 (control_structures -> control_structures_for .)
    VOID            reduce using rule 17 (control_structures -> control_structures_for .)
    LIST            reduce using rule 17 (control_structures -> control_structures_for .)
    DYNAMIC         reduce using rule 17 (control_structures -> control_structures_for .)
    INT             reduce using rule 17 (control_structures -> control_structures_for .)
    DOUBLE          reduce using rule 17 (control_structures -> control_structures_for .)
    MAP             reduce using rule 17 (control_structures -> control_structures_for .)
    WHILE           reduce using rule 17 (control_structures -> control_structures_for .)
    BOOL            reduce using rule 17 (control_structures -> control_structures_for .)
    IF              reduce using rule 17 (control_structures -> control_structures_for .)
    FOR             reduce using rule 17 (control_structures -> control_structures_for .)
    $end            reduce using rule 17 (control_structures -> control_structures_for .)
    RBRACKET        reduce using rule 17 (control_structures -> control_structures_for .)


state 24

    (18) control_structures -> control_structures_while .

    SEMICOLON       reduce using rule 18 (control_structures -> control_structures_while .)
    PRINT           reduce using rule 18 (control_structures -> control_structures_while .)
    STRING          reduce using rule 18 (control_structures -> control_structures_while .)
    VAR             reduce using rule 18 (control_structures -> control_structures_while .)
    FINAL           reduce using rule 18 (control_structures -> control_structures_while .)
    ID              reduce using rule 18 (control_structures -> control_structures_while .)
    VOID            reduce using rule 18 (control_structures -> control_structures_while .)
    LIST            reduce using rule 18 (control_structures -> control_structures_while .)
    DYNAMIC         reduce using rule 18 (control_structures -> control_structures_while .)
    INT             reduce using rule 18 (control_structures -> control_structures_while .)
    DOUBLE          reduce using rule 18 (control_structures -> control_structures_while .)
    MAP             reduce using rule 18 (control_structures -> control_structures_while .)
    WHILE           reduce using rule 18 (control_structures -> control_structures_while .)
    BOOL            reduce using rule 18 (control_structures -> control_structures_while .)
    IF              reduce using rule 18 (control_structures -> control_structures_while .)
    FOR             reduce using rule 18 (control_structures -> control_structures_while .)
    $end            reduce using rule 18 (control_structures -> control_structures_while .)
    RBRACKET        reduce using rule 18 (control_structures -> control_structures_while .)


state 25

    (28) function -> type . ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> type . ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (129) function -> type . ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (34) variable_definition -> type . ID ASSIGN expression SEMICOLON
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    ID              shift and go to state 49


state 22

    (102) set -> FINAL . ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON

    ID              shift and go to state 50


state 23

    (126) map -> map_declaration . map_assignment
    (128) map_assignment -> . LBRACKET map_contents RBRACKET

    LBRACKET        shift and go to state 52

    map_assignment                 shift and go to state 51

state 24

    (18) control_structures -> control_structures_if_else .

    COMMENT_MULTI   reduce using rule 18 (control_structures -> control_structures_if_else .)
    COMMENT_SINGLE  reduce using rule 18 (control_structures -> control_structures_if_else .)
    SEMICOLON       reduce using rule 18 (control_structures -> control_structures_if_else .)
    PRINT           reduce using rule 18 (control_structures -> control_structures_if_else .)
    STRING          reduce using rule 18 (control_structures -> control_structures_if_else .)
    VAR             reduce using rule 18 (control_structures -> control_structures_if_else .)
    FINAL           reduce using rule 18 (control_structures -> control_structures_if_else .)
    ID              reduce using rule 18 (control_structures -> control_structures_if_else .)
    VOID            reduce using rule 18 (control_structures -> control_structures_if_else .)
    LIST            reduce using rule 18 (control_structures -> control_structures_if_else .)
    DYNAMIC         reduce using rule 18 (control_structures -> control_structures_if_else .)
    MAP             reduce using rule 18 (control_structures -> control_structures_if_else .)
    WHILE           reduce using rule 18 (control_structures -> control_structures_if_else .)
    INT             reduce using rule 18 (control_structures -> control_structures_if_else .)
    DOUBLE          reduce using rule 18 (control_structures -> control_structures_if_else .)
    BOOL            reduce using rule 18 (control_structures -> control_structures_if_else .)
    IF              reduce using rule 18 (control_structures -> control_structures_if_else .)
    FOR             reduce using rule 18 (control_structures -> control_structures_if_else .)
    $end            reduce using rule 18 (control_structures -> control_structures_if_else .)
    RBRACKET        reduce using rule 18 (control_structures -> control_structures_if_else .)


state 25

    (19) control_structures -> control_structures_for .

    COMMENT_MULTI   reduce using rule 19 (control_structures -> control_structures_for .)
    COMMENT_SINGLE  reduce using rule 19 (control_structures -> control_structures_for .)
    SEMICOLON       reduce using rule 19 (control_structures -> control_structures_for .)
    PRINT           reduce using rule 19 (control_structures -> control_structures_for .)
    STRING          reduce using rule 19 (control_structures -> control_structures_for .)
    VAR             reduce using rule 19 (control_structures -> control_structures_for .)
    FINAL           reduce using rule 19 (control_structures -> control_structures_for .)
    ID              reduce using rule 19 (control_structures -> control_structures_for .)
    VOID            reduce using rule 19 (control_structures -> control_structures_for .)
    LIST            reduce using rule 19 (control_structures -> control_structures_for .)
    DYNAMIC         reduce using rule 19 (control_structures -> control_structures_for .)
    MAP             reduce using rule 19 (control_structures -> control_structures_for .)
    WHILE           reduce using rule 19 (control_structures -> control_structures_for .)
    INT             reduce using rule 19 (control_structures -> control_structures_for .)
    DOUBLE          reduce using rule 19 (control_structures -> control_structures_for .)
    BOOL            reduce using rule 19 (control_structures -> control_structures_for .)
    IF              reduce using rule 19 (control_structures -> control_structures_for .)
    FOR             reduce using rule 19 (control_structures -> control_structures_for .)
    $end            reduce using rule 19 (control_structures -> control_structures_for .)
    RBRACKET        reduce using rule 19 (control_structures -> control_structures_for .)


state 26

    (20) control_structures -> control_structures_while .

    COMMENT_MULTI   reduce using rule 20 (control_structures -> control_structures_while .)
    COMMENT_SINGLE  reduce using rule 20 (control_structures -> control_structures_while .)
    SEMICOLON       reduce using rule 20 (control_structures -> control_structures_while .)
    PRINT           reduce using rule 20 (control_structures -> control_structures_while .)
    STRING          reduce using rule 20 (control_structures -> control_structures_while .)
    VAR             reduce using rule 20 (control_structures -> control_structures_while .)
    FINAL           reduce using rule 20 (control_structures -> control_structures_while .)
    ID              reduce using rule 20 (control_structures -> control_structures_while .)
    VOID            reduce using rule 20 (control_structures -> control_structures_while .)
    LIST            reduce using rule 20 (control_structures -> control_structures_while .)
    DYNAMIC         reduce using rule 20 (control_structures -> control_structures_while .)
    MAP             reduce using rule 20 (control_structures -> control_structures_while .)
    WHILE           reduce using rule 20 (control_structures -> control_structures_while .)
    INT             reduce using rule 20 (control_structures -> control_structures_while .)
    DOUBLE          reduce using rule 20 (control_structures -> control_structures_while .)
    BOOL            reduce using rule 20 (control_structures -> control_structures_while .)
    IF              reduce using rule 20 (control_structures -> control_structures_while .)
    FOR             reduce using rule 20 (control_structures -> control_structures_while .)
    $end            reduce using rule 20 (control_structures -> control_structures_while .)
    RBRACKET        reduce using rule 20 (control_structures -> control_structures_while .)


state 27

<<<<<<< HEAD
    (31) function -> type . ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> type . ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (124) function -> type . ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (37) variable_definition -> type . ID ASSIGN expression SEMICOLON

    ID              shift and go to state 53
=======
    (93) list_definition -> LIST . LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (91) type -> LIST .

    LESS            shift and go to state 51
    ID              reduce using rule 91 (type -> LIST .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 28

    (32) function -> VOID . ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (34) function -> VOID . ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> VOID . ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> VOID . ID LPAREN parameter_list RPAREN LBRACKET RBRACKET

    ID              shift and go to state 54


state 29

<<<<<<< HEAD
    (82) list_definition -> LIST . LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (93) type -> LIST .

    LESS            shift and go to state 55
    ID              reduce using rule 93 (type -> LIST .)
=======
    (37) variable_definition -> INT . ID ASSIGN length SEMICOLON
    (38) variable_definition -> INT . ID ASSIGN NUMBER SEMICOLON
    (87) type -> INT .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 53

  ! ID              [ reduce using rule 87 (type -> INT .) ]
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 30

<<<<<<< HEAD
    (38) variable_definition -> DYNAMIC . ID ASSIGN expression SEMICOLON

    ID              shift and go to state 56
=======
    (39) variable_definition -> DOUBLE . ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> DOUBLE . ID ASSIGN simple_operations_arithmetics SEMICOLON
    (88) type -> DOUBLE .

  ! shift/reduce conflict for ID resolved as shift
    ID              shift and go to state 54

  ! ID              [ reduce using rule 88 (type -> DOUBLE .) ]
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 31

<<<<<<< HEAD
    (127) map_declaration -> MAP . LESS key_type COMMA type GREATER ID ASSIGN
=======
    (132) map_declaration -> MAP . LESS key_type COMMA type GREATER ID ASSIGN
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    LESS            shift and go to state 57


state 32

<<<<<<< HEAD
    (58) control_structures_if_else -> if_block .
    (59) control_structures_if_else -> if_block . else_if_blocks
    (60) control_structures_if_else -> if_block . else_if_blocks else_block
    (61) control_structures_if_else -> if_block . else_block
    (63) else_if_blocks -> . ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (64) else_if_blocks -> . else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (65) else_block -> . ELSE LBRACKET statement_list RBRACKET

    COMMENT_MULTI   reduce using rule 58 (control_structures_if_else -> if_block .)
    COMMENT_SINGLE  reduce using rule 58 (control_structures_if_else -> if_block .)
    SEMICOLON       reduce using rule 58 (control_structures_if_else -> if_block .)
    PRINT           reduce using rule 58 (control_structures_if_else -> if_block .)
    STRING          reduce using rule 58 (control_structures_if_else -> if_block .)
    VAR             reduce using rule 58 (control_structures_if_else -> if_block .)
    FINAL           reduce using rule 58 (control_structures_if_else -> if_block .)
    ID              reduce using rule 58 (control_structures_if_else -> if_block .)
    VOID            reduce using rule 58 (control_structures_if_else -> if_block .)
    LIST            reduce using rule 58 (control_structures_if_else -> if_block .)
    DYNAMIC         reduce using rule 58 (control_structures_if_else -> if_block .)
    MAP             reduce using rule 58 (control_structures_if_else -> if_block .)
    WHILE           reduce using rule 58 (control_structures_if_else -> if_block .)
    INT             reduce using rule 58 (control_structures_if_else -> if_block .)
    DOUBLE          reduce using rule 58 (control_structures_if_else -> if_block .)
    BOOL            reduce using rule 58 (control_structures_if_else -> if_block .)
    IF              reduce using rule 58 (control_structures_if_else -> if_block .)
    FOR             reduce using rule 58 (control_structures_if_else -> if_block .)
    $end            reduce using rule 58 (control_structures_if_else -> if_block .)
    RBRACKET        reduce using rule 58 (control_structures_if_else -> if_block .)
    ELSE            shift and go to state 60
=======
    (63) control_structures_if_else -> if_block .
    (64) control_structures_if_else -> if_block . else_if_blocks
    (65) control_structures_if_else -> if_block . else_if_blocks else_block
    (66) control_structures_if_else -> if_block . else_block
    (68) else_if_blocks -> . ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (69) else_if_blocks -> . else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (70) else_block -> . ELSE LBRACKET statement_list RBRACKET

    SEMICOLON       reduce using rule 63 (control_structures_if_else -> if_block .)
    PRINT           reduce using rule 63 (control_structures_if_else -> if_block .)
    STRING          reduce using rule 63 (control_structures_if_else -> if_block .)
    VAR             reduce using rule 63 (control_structures_if_else -> if_block .)
    FINAL           reduce using rule 63 (control_structures_if_else -> if_block .)
    ID              reduce using rule 63 (control_structures_if_else -> if_block .)
    VOID            reduce using rule 63 (control_structures_if_else -> if_block .)
    LIST            reduce using rule 63 (control_structures_if_else -> if_block .)
    DYNAMIC         reduce using rule 63 (control_structures_if_else -> if_block .)
    INT             reduce using rule 63 (control_structures_if_else -> if_block .)
    DOUBLE          reduce using rule 63 (control_structures_if_else -> if_block .)
    MAP             reduce using rule 63 (control_structures_if_else -> if_block .)
    WHILE           reduce using rule 63 (control_structures_if_else -> if_block .)
    BOOL            reduce using rule 63 (control_structures_if_else -> if_block .)
    IF              reduce using rule 63 (control_structures_if_else -> if_block .)
    FOR             reduce using rule 63 (control_structures_if_else -> if_block .)
    $end            reduce using rule 63 (control_structures_if_else -> if_block .)
    RBRACKET        reduce using rule 63 (control_structures_if_else -> if_block .)
    ELSE            shift and go to state 58
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    else_if_blocks                 shift and go to state 58
    else_block                     shift and go to state 59

state 33

<<<<<<< HEAD
    (118) control_structures_for -> for_classic .

    COMMENT_MULTI   reduce using rule 118 (control_structures_for -> for_classic .)
    COMMENT_SINGLE  reduce using rule 118 (control_structures_for -> for_classic .)
    SEMICOLON       reduce using rule 118 (control_structures_for -> for_classic .)
    PRINT           reduce using rule 118 (control_structures_for -> for_classic .)
    STRING          reduce using rule 118 (control_structures_for -> for_classic .)
    VAR             reduce using rule 118 (control_structures_for -> for_classic .)
    FINAL           reduce using rule 118 (control_structures_for -> for_classic .)
    ID              reduce using rule 118 (control_structures_for -> for_classic .)
    VOID            reduce using rule 118 (control_structures_for -> for_classic .)
    LIST            reduce using rule 118 (control_structures_for -> for_classic .)
    DYNAMIC         reduce using rule 118 (control_structures_for -> for_classic .)
    MAP             reduce using rule 118 (control_structures_for -> for_classic .)
    WHILE           reduce using rule 118 (control_structures_for -> for_classic .)
    INT             reduce using rule 118 (control_structures_for -> for_classic .)
    DOUBLE          reduce using rule 118 (control_structures_for -> for_classic .)
    BOOL            reduce using rule 118 (control_structures_for -> for_classic .)
    IF              reduce using rule 118 (control_structures_for -> for_classic .)
    FOR             reduce using rule 118 (control_structures_for -> for_classic .)
    $end            reduce using rule 118 (control_structures_for -> for_classic .)
    RBRACKET        reduce using rule 118 (control_structures_for -> for_classic .)
=======
    (123) control_structures_for -> for_classic .

    SEMICOLON       reduce using rule 123 (control_structures_for -> for_classic .)
    PRINT           reduce using rule 123 (control_structures_for -> for_classic .)
    STRING          reduce using rule 123 (control_structures_for -> for_classic .)
    VAR             reduce using rule 123 (control_structures_for -> for_classic .)
    FINAL           reduce using rule 123 (control_structures_for -> for_classic .)
    ID              reduce using rule 123 (control_structures_for -> for_classic .)
    VOID            reduce using rule 123 (control_structures_for -> for_classic .)
    LIST            reduce using rule 123 (control_structures_for -> for_classic .)
    DYNAMIC         reduce using rule 123 (control_structures_for -> for_classic .)
    INT             reduce using rule 123 (control_structures_for -> for_classic .)
    DOUBLE          reduce using rule 123 (control_structures_for -> for_classic .)
    MAP             reduce using rule 123 (control_structures_for -> for_classic .)
    WHILE           reduce using rule 123 (control_structures_for -> for_classic .)
    BOOL            reduce using rule 123 (control_structures_for -> for_classic .)
    IF              reduce using rule 123 (control_structures_for -> for_classic .)
    FOR             reduce using rule 123 (control_structures_for -> for_classic .)
    $end            reduce using rule 123 (control_structures_for -> for_classic .)
    RBRACKET        reduce using rule 123 (control_structures_for -> for_classic .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 34

<<<<<<< HEAD
    (119) control_structures_for -> for_in .

    COMMENT_MULTI   reduce using rule 119 (control_structures_for -> for_in .)
    COMMENT_SINGLE  reduce using rule 119 (control_structures_for -> for_in .)
    SEMICOLON       reduce using rule 119 (control_structures_for -> for_in .)
    PRINT           reduce using rule 119 (control_structures_for -> for_in .)
    STRING          reduce using rule 119 (control_structures_for -> for_in .)
    VAR             reduce using rule 119 (control_structures_for -> for_in .)
    FINAL           reduce using rule 119 (control_structures_for -> for_in .)
    ID              reduce using rule 119 (control_structures_for -> for_in .)
    VOID            reduce using rule 119 (control_structures_for -> for_in .)
    LIST            reduce using rule 119 (control_structures_for -> for_in .)
    DYNAMIC         reduce using rule 119 (control_structures_for -> for_in .)
    MAP             reduce using rule 119 (control_structures_for -> for_in .)
    WHILE           reduce using rule 119 (control_structures_for -> for_in .)
    INT             reduce using rule 119 (control_structures_for -> for_in .)
    DOUBLE          reduce using rule 119 (control_structures_for -> for_in .)
    BOOL            reduce using rule 119 (control_structures_for -> for_in .)
    IF              reduce using rule 119 (control_structures_for -> for_in .)
    FOR             reduce using rule 119 (control_structures_for -> for_in .)
    $end            reduce using rule 119 (control_structures_for -> for_in .)
    RBRACKET        reduce using rule 119 (control_structures_for -> for_in .)
=======
    (124) control_structures_for -> for_in .

    SEMICOLON       reduce using rule 124 (control_structures_for -> for_in .)
    PRINT           reduce using rule 124 (control_structures_for -> for_in .)
    STRING          reduce using rule 124 (control_structures_for -> for_in .)
    VAR             reduce using rule 124 (control_structures_for -> for_in .)
    FINAL           reduce using rule 124 (control_structures_for -> for_in .)
    ID              reduce using rule 124 (control_structures_for -> for_in .)
    VOID            reduce using rule 124 (control_structures_for -> for_in .)
    LIST            reduce using rule 124 (control_structures_for -> for_in .)
    DYNAMIC         reduce using rule 124 (control_structures_for -> for_in .)
    INT             reduce using rule 124 (control_structures_for -> for_in .)
    DOUBLE          reduce using rule 124 (control_structures_for -> for_in .)
    MAP             reduce using rule 124 (control_structures_for -> for_in .)
    WHILE           reduce using rule 124 (control_structures_for -> for_in .)
    BOOL            reduce using rule 124 (control_structures_for -> for_in .)
    IF              reduce using rule 124 (control_structures_for -> for_in .)
    FOR             reduce using rule 124 (control_structures_for -> for_in .)
    $end            reduce using rule 124 (control_structures_for -> for_in .)
    RBRACKET        reduce using rule 124 (control_structures_for -> for_in .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 35

<<<<<<< HEAD
    (120) control_structures_for -> for_each .

    COMMENT_MULTI   reduce using rule 120 (control_structures_for -> for_each .)
    COMMENT_SINGLE  reduce using rule 120 (control_structures_for -> for_each .)
    SEMICOLON       reduce using rule 120 (control_structures_for -> for_each .)
    PRINT           reduce using rule 120 (control_structures_for -> for_each .)
    STRING          reduce using rule 120 (control_structures_for -> for_each .)
    VAR             reduce using rule 120 (control_structures_for -> for_each .)
    FINAL           reduce using rule 120 (control_structures_for -> for_each .)
    ID              reduce using rule 120 (control_structures_for -> for_each .)
    VOID            reduce using rule 120 (control_structures_for -> for_each .)
    LIST            reduce using rule 120 (control_structures_for -> for_each .)
    DYNAMIC         reduce using rule 120 (control_structures_for -> for_each .)
    MAP             reduce using rule 120 (control_structures_for -> for_each .)
    WHILE           reduce using rule 120 (control_structures_for -> for_each .)
    INT             reduce using rule 120 (control_structures_for -> for_each .)
    DOUBLE          reduce using rule 120 (control_structures_for -> for_each .)
    BOOL            reduce using rule 120 (control_structures_for -> for_each .)
    IF              reduce using rule 120 (control_structures_for -> for_each .)
    FOR             reduce using rule 120 (control_structures_for -> for_each .)
    $end            reduce using rule 120 (control_structures_for -> for_each .)
    RBRACKET        reduce using rule 120 (control_structures_for -> for_each .)
=======
    (125) control_structures_for -> for_each .

    SEMICOLON       reduce using rule 125 (control_structures_for -> for_each .)
    PRINT           reduce using rule 125 (control_structures_for -> for_each .)
    STRING          reduce using rule 125 (control_structures_for -> for_each .)
    VAR             reduce using rule 125 (control_structures_for -> for_each .)
    FINAL           reduce using rule 125 (control_structures_for -> for_each .)
    ID              reduce using rule 125 (control_structures_for -> for_each .)
    VOID            reduce using rule 125 (control_structures_for -> for_each .)
    LIST            reduce using rule 125 (control_structures_for -> for_each .)
    DYNAMIC         reduce using rule 125 (control_structures_for -> for_each .)
    INT             reduce using rule 125 (control_structures_for -> for_each .)
    DOUBLE          reduce using rule 125 (control_structures_for -> for_each .)
    MAP             reduce using rule 125 (control_structures_for -> for_each .)
    WHILE           reduce using rule 125 (control_structures_for -> for_each .)
    BOOL            reduce using rule 125 (control_structures_for -> for_each .)
    IF              reduce using rule 125 (control_structures_for -> for_each .)
    FOR             reduce using rule 125 (control_structures_for -> for_each .)
    $end            reduce using rule 125 (control_structures_for -> for_each .)
    RBRACKET        reduce using rule 125 (control_structures_for -> for_each .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 36

<<<<<<< HEAD
    (125) control_structures_while -> WHILE . LPAREN conditions LBRACKET statement_list RBRACKET
=======
    (130) control_structures_while -> WHILE . LPAREN conditions LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 59


state 37

    (90) type -> BOOL .

    ID              reduce using rule 90 (type -> BOOL .)
    GREATER         reduce using rule 90 (type -> BOOL .)


state 38

    (67) if_block -> IF . LPAREN conditions RPAREN LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 60


state 39

    (116) for_classic -> FOR . LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> FOR . LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> FOR . LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    LPAREN          shift and go to state 61


state 37

    (89) type -> INT .

    ID              reduce using rule 89 (type -> INT .)
    GREATER         reduce using rule 89 (type -> INT .)


state 38

    (90) type -> DOUBLE .

    ID              reduce using rule 90 (type -> DOUBLE .)
    GREATER         reduce using rule 90 (type -> DOUBLE .)


state 39

    (92) type -> BOOL .

    ID              reduce using rule 92 (type -> BOOL .)
    GREATER         reduce using rule 92 (type -> BOOL .)


state 40

    (62) if_block -> IF . LPAREN conditions RPAREN LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 62


state 41

    (111) for_classic -> FOR . LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> FOR . LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> FOR . LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 63


state 42

    (3) statement_list -> statement_list statement .

    COMMENT_MULTI   reduce using rule 3 (statement_list -> statement_list statement .)
    COMMENT_SINGLE  reduce using rule 3 (statement_list -> statement_list statement .)
    SEMICOLON       reduce using rule 3 (statement_list -> statement_list statement .)
    PRINT           reduce using rule 3 (statement_list -> statement_list statement .)
    STRING          reduce using rule 3 (statement_list -> statement_list statement .)
    VAR             reduce using rule 3 (statement_list -> statement_list statement .)
    FINAL           reduce using rule 3 (statement_list -> statement_list statement .)
    ID              reduce using rule 3 (statement_list -> statement_list statement .)
    VOID            reduce using rule 3 (statement_list -> statement_list statement .)
    LIST            reduce using rule 3 (statement_list -> statement_list statement .)
    DYNAMIC         reduce using rule 3 (statement_list -> statement_list statement .)
    MAP             reduce using rule 3 (statement_list -> statement_list statement .)
    WHILE           reduce using rule 3 (statement_list -> statement_list statement .)
    INT             reduce using rule 3 (statement_list -> statement_list statement .)
    DOUBLE          reduce using rule 3 (statement_list -> statement_list statement .)
    BOOL            reduce using rule 3 (statement_list -> statement_list statement .)
    IF              reduce using rule 3 (statement_list -> statement_list statement .)
    FOR             reduce using rule 3 (statement_list -> statement_list statement .)
    $end            reduce using rule 3 (statement_list -> statement_list statement .)
    RBRACKET        reduce using rule 3 (statement_list -> statement_list statement .)


<<<<<<< HEAD
=======
state 41

    (41) print -> PRINT LPAREN . RPAREN SEMICOLON
    (42) print -> PRINT LPAREN . simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> PRINT LPAREN . value RPAREN SEMICOLON
    (44) print -> PRINT LPAREN . expression RPAREN SEMICOLON
    (45) print -> PRINT LPAREN . length RPAREN SEMICOLON
    (52) simple_operations_arithmetics -> . list_numbers simple_operators_arithmetics list_numbers
    (53) simple_operations_arithmetics -> . list_numbers simple_operators_arithmetics list_numbers simple_operators_arithmetics simple_operations_arithmetics
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (54) expression -> . expression PLUS expression
    (55) expression -> . expression MINUS expression
    (56) expression -> . expression TIMES expression
    (57) expression -> . expression DIVIDE expression
    (58) expression -> . expression AND expression
    (59) expression -> . expression OR expression
    (60) expression -> . value comparator value
    (61) expression -> . value PLUS value
    (62) expression -> . value
    (24) length -> . call_list DOT LENGTH
    (25) length -> . TEXT DOT LENGTH
    (46) list_numbers -> . NUMBER
    (47) list_numbers -> . NDOUBLE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression
    (92) call_list -> . LSBRACKET value_list RSBRACKET

    RPAREN          shift and go to state 62
    NUMBER          shift and go to state 68
    NDOUBLE         shift and go to state 69
    TEXT            shift and go to state 70
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
    LSBRACKET       shift and go to state 76

    simple_operations_arithmetics  shift and go to state 63
    value                          shift and go to state 64
    expression                     shift and go to state 65
    length                         shift and go to state 66
    list_numbers                   shift and go to state 67
    interpolated_string            shift and go to state 72
    call_list                      shift and go to state 75

state 42

    (22) data_input -> STRING ID . ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    ASSIGN          shift and go to state 77


>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
state 43

    (40) print -> PRINT LPAREN . RPAREN SEMICOLON
    (41) print -> PRINT LPAREN . print_options RPAREN SEMICOLON
    (42) print_options -> . interpolated_string
    (43) print_options -> . expression
    (44) print_options -> . length
    (45) print_options -> . call_function
    (85) interpolated_string -> . string_part
    (86) interpolated_string -> . string_part PLUS interpolated_string
    (46) expression -> . operations
    (56) expression -> . conditions
    (57) expression -> . value
    (27) length -> . call_list DOT LENGTH
    (28) length -> . TEXT DOT LENGTH
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (87) string_part -> . TEXT
    (88) string_part -> . TEXT PLUS value
    (47) operations -> . operation
    (48) operations -> . operation operand operations
    (66) conditions -> . condition
    (67) conditions -> . condition AND conditions
    (68) conditions -> . condition OR conditions
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE
    (81) call_list -> . LSBRACKET value_list RSBRACKET
    (49) operation -> . operand operator operand
    (69) condition -> . value comparator value
    (70) condition -> . NOT condition
    (50) operand -> . NUMBER
    (51) operand -> . DOUBLE

<<<<<<< HEAD
    RPAREN          shift and go to state 64
    TEXT            shift and go to state 75
    ID              shift and go to state 76
    NUMBER          shift and go to state 80
    NDOUBLE         shift and go to state 81
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83
    LSBRACKET       shift and go to state 84
    NOT             shift and go to state 85
    DOUBLE          shift and go to state 86
=======
    ID              shift and go to state 78
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    print_options                  shift and go to state 65
    interpolated_string            shift and go to state 66
    expression                     shift and go to state 67
    length                         shift and go to state 68
    call_function                  shift and go to state 69
    string_part                    shift and go to state 70
    operations                     shift and go to state 71
    conditions                     shift and go to state 72
    value                          shift and go to state 73
    call_list                      shift and go to state 74
    operation                      shift and go to state 77
    operand                        shift and go to state 78
    condition                      shift and go to state 79

state 44

<<<<<<< HEAD
    (25) data_input -> STRING ID . ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    ASSIGN          shift and go to state 87


state 45

    (26) data_input -> STRING QUESTION . ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    ID              shift and go to state 88
=======
    (128) constructor -> ID LPAREN . constructor_parenthesis_content RPAREN SEMICOLON
    (20) call_function -> ID LPAREN . argument_list RPAREN
    (21) call_function -> ID LPAREN . RPAREN
    (126) constructor_parenthesis_content -> . THIS DOT ID
    (127) constructor_parenthesis_content -> . THIS DOT ID COMMA constructor_parenthesis_content
    (26) argument_list -> . expression
    (27) argument_list -> . argument_list COMMA expression
    (54) expression -> . expression PLUS expression
    (55) expression -> . expression MINUS expression
    (56) expression -> . expression TIMES expression
    (57) expression -> . expression DIVIDE expression
    (58) expression -> . expression AND expression
    (59) expression -> . expression OR expression
    (60) expression -> . value comparator value
    (61) expression -> . value PLUS value
    (62) expression -> . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    RPAREN          shift and go to state 80
    THIS            shift and go to state 82
    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    constructor_parenthesis_content shift and go to state 79
    argument_list                  shift and go to state 81
    expression                     shift and go to state 83
    value                          shift and go to state 84
    interpolated_string            shift and go to state 72

state 45

    (105) set -> VAR ID . ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> VAR ID . ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (36) variable_definition -> VAR ID . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 88
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 46

<<<<<<< HEAD
    (123) constructor -> ID LPAREN . constructor_parenthesis_content RPAREN SEMICOLON
    (23) call_function -> ID LPAREN . argument_list RPAREN
    (24) call_function -> ID LPAREN . RPAREN
    (121) constructor_parenthesis_content -> . THIS DOT ID
    (122) constructor_parenthesis_content -> . THIS DOT ID COMMA constructor_parenthesis_content
    (29) argument_list -> . expression
    (30) argument_list -> . argument_list COMMA expression
    (46) expression -> . operations
    (56) expression -> . conditions
    (57) expression -> . value
    (47) operations -> . operation
    (48) operations -> . operation operand operations
    (66) conditions -> . condition
    (67) conditions -> . condition AND conditions
    (68) conditions -> . condition OR conditions
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE
    (49) operation -> . operand operator operand
    (69) condition -> . value comparator value
    (70) condition -> . NOT condition
    (50) operand -> . NUMBER
    (51) operand -> . DOUBLE

    RPAREN          shift and go to state 91
    THIS            shift and go to state 93
    NUMBER          shift and go to state 80
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83
    NOT             shift and go to state 85
    DOUBLE          shift and go to state 86
=======
    (107) set -> FINAL ID . ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON

    ASSIGN          shift and go to state 89
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    constructor_parenthesis_content shift and go to state 90
    argument_list                  shift and go to state 92
    expression                     shift and go to state 94
    operations                     shift and go to state 71
    conditions                     shift and go to state 72
    value                          shift and go to state 73
    operation                      shift and go to state 77
    operand                        shift and go to state 78
    condition                      shift and go to state 79

state 47

<<<<<<< HEAD
    (21) variable_usage -> ID SEMICOLON .

    COMMENT_MULTI   reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    SEMICOLON       reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    PRINT           reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    STRING          reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    VAR             reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    FINAL           reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    ID              reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    VOID            reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    LIST            reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    DYNAMIC         reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    MAP             reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    WHILE           reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    INT             reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    DOUBLE          reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    BOOL            reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    IF              reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    FOR             reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    $end            reduce using rule 21 (variable_usage -> ID SEMICOLON .)
    RBRACKET        reduce using rule 21 (variable_usage -> ID SEMICOLON .)
=======
    (131) map -> map_declaration map_assignment .

    SEMICOLON       reduce using rule 131 (map -> map_declaration map_assignment .)
    PRINT           reduce using rule 131 (map -> map_declaration map_assignment .)
    STRING          reduce using rule 131 (map -> map_declaration map_assignment .)
    VAR             reduce using rule 131 (map -> map_declaration map_assignment .)
    FINAL           reduce using rule 131 (map -> map_declaration map_assignment .)
    ID              reduce using rule 131 (map -> map_declaration map_assignment .)
    VOID            reduce using rule 131 (map -> map_declaration map_assignment .)
    LIST            reduce using rule 131 (map -> map_declaration map_assignment .)
    DYNAMIC         reduce using rule 131 (map -> map_declaration map_assignment .)
    INT             reduce using rule 131 (map -> map_declaration map_assignment .)
    DOUBLE          reduce using rule 131 (map -> map_declaration map_assignment .)
    MAP             reduce using rule 131 (map -> map_declaration map_assignment .)
    WHILE           reduce using rule 131 (map -> map_declaration map_assignment .)
    BOOL            reduce using rule 131 (map -> map_declaration map_assignment .)
    IF              reduce using rule 131 (map -> map_declaration map_assignment .)
    FOR             reduce using rule 131 (map -> map_declaration map_assignment .)
    $end            reduce using rule 131 (map -> map_declaration map_assignment .)
    RBRACKET        reduce using rule 131 (map -> map_declaration map_assignment .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 48

<<<<<<< HEAD
    (22) variable_usage -> ID ASSIGN . value SEMICOLON
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83

    value                          shift and go to state 96

state 49

    (100) set -> VAR ID . ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> VAR ID . ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (39) variable_definition -> VAR ID . ASSIGN expression SEMICOLON
=======
    (133) map_assignment -> LBRACKET . map_contents RBRACKET
    (134) map_contents -> . map_content
    (135) map_contents -> . map_content COMMA map_contents
    (136) map_content -> . key_value COLON value
    (137) key_value -> . TEXT

    TEXT            shift and go to state 93

    map_contents                   shift and go to state 90
    map_content                    shift and go to state 91
    key_value                      shift and go to state 92

state 49

    (28) function -> type ID . LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> type ID . LPAREN RPAREN LBRACKET statement_list RBRACKET
    (129) function -> type ID . LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (34) variable_definition -> type ID . ASSIGN expression SEMICOLON

    LPAREN          shift and go to state 94
    ASSIGN          shift and go to state 95


state 50

    (29) function -> VOID ID . LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (31) function -> VOID ID . LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> VOID ID . LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> VOID ID . LPAREN parameter_list RPAREN LBRACKET RBRACKET

    LPAREN          shift and go to state 96


state 51

    (93) list_definition -> LIST LESS . type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST

    INT             shift and go to state 99
    DOUBLE          shift and go to state 100
    STRING          shift and go to state 101
    BOOL            shift and go to state 37
    LIST            shift and go to state 97

    type                           shift and go to state 98

state 52

    (35) variable_definition -> DYNAMIC ID . ASSIGN expression SEMICOLON
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    ASSIGN          shift and go to state 102


state 50

    (102) set -> FINAL ID . ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON

    ASSIGN          shift and go to state 103


state 51

    (126) map -> map_declaration map_assignment .

    COMMENT_MULTI   reduce using rule 126 (map -> map_declaration map_assignment .)
    COMMENT_SINGLE  reduce using rule 126 (map -> map_declaration map_assignment .)
    SEMICOLON       reduce using rule 126 (map -> map_declaration map_assignment .)
    PRINT           reduce using rule 126 (map -> map_declaration map_assignment .)
    STRING          reduce using rule 126 (map -> map_declaration map_assignment .)
    VAR             reduce using rule 126 (map -> map_declaration map_assignment .)
    FINAL           reduce using rule 126 (map -> map_declaration map_assignment .)
    ID              reduce using rule 126 (map -> map_declaration map_assignment .)
    VOID            reduce using rule 126 (map -> map_declaration map_assignment .)
    LIST            reduce using rule 126 (map -> map_declaration map_assignment .)
    DYNAMIC         reduce using rule 126 (map -> map_declaration map_assignment .)
    MAP             reduce using rule 126 (map -> map_declaration map_assignment .)
    WHILE           reduce using rule 126 (map -> map_declaration map_assignment .)
    INT             reduce using rule 126 (map -> map_declaration map_assignment .)
    DOUBLE          reduce using rule 126 (map -> map_declaration map_assignment .)
    BOOL            reduce using rule 126 (map -> map_declaration map_assignment .)
    IF              reduce using rule 126 (map -> map_declaration map_assignment .)
    FOR             reduce using rule 126 (map -> map_declaration map_assignment .)
    $end            reduce using rule 126 (map -> map_declaration map_assignment .)
    RBRACKET        reduce using rule 126 (map -> map_declaration map_assignment .)


state 52

    (128) map_assignment -> LBRACKET . map_contents RBRACKET
    (129) map_contents -> . map_content
    (130) map_contents -> . map_content COMMA map_contents
    (131) map_content -> . key_value COLON value
    (132) key_value -> . TEXT

    TEXT            shift and go to state 103

    map_contents                   shift and go to state 100
    map_content                    shift and go to state 101
    key_value                      shift and go to state 102

state 53

    (31) function -> type ID . LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> type ID . LPAREN RPAREN LBRACKET statement_list RBRACKET
    (124) function -> type ID . LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (37) variable_definition -> type ID . ASSIGN expression SEMICOLON

    LPAREN          shift and go to state 104
    ASSIGN          shift and go to state 105


state 54

<<<<<<< HEAD
    (32) function -> VOID ID . LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (34) function -> VOID ID . LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> VOID ID . LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> VOID ID . LPAREN parameter_list RPAREN LBRACKET RBRACKET

    LPAREN          shift and go to state 106
=======
    (39) variable_definition -> DOUBLE ID . ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> DOUBLE ID . ASSIGN simple_operations_arithmetics SEMICOLON

    ASSIGN          shift and go to state 104
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 55

<<<<<<< HEAD
    (82) list_definition -> LIST LESS . type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST

    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    STRING          shift and go to state 109
    BOOL            shift and go to state 39
    LIST            shift and go to state 107

    type                           shift and go to state 108

state 56

    (38) variable_definition -> DYNAMIC ID . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 110


state 57

    (127) map_declaration -> MAP LESS . key_type COMMA type GREATER ID ASSIGN
    (133) key_type -> . STRING

    STRING          shift and go to state 112
=======
    (132) map_declaration -> MAP LESS . key_type COMMA type GREATER ID ASSIGN
    (138) key_type -> . STRING

    STRING          shift and go to state 106

    key_type                       shift and go to state 105

state 56

    (64) control_structures_if_else -> if_block else_if_blocks .
    (65) control_structures_if_else -> if_block else_if_blocks . else_block
    (69) else_if_blocks -> else_if_blocks . ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (70) else_block -> . ELSE LBRACKET statement_list RBRACKET

    SEMICOLON       reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    PRINT           reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    STRING          reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    VAR             reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    FINAL           reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    ID              reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    VOID            reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    LIST            reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    DYNAMIC         reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    INT             reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    DOUBLE          reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    MAP             reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    WHILE           reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    BOOL            reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    IF              reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    FOR             reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    $end            reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    RBRACKET        reduce using rule 64 (control_structures_if_else -> if_block else_if_blocks .)
    ELSE            shift and go to state 108

    else_block                     shift and go to state 107

state 57

    (66) control_structures_if_else -> if_block else_block .

    SEMICOLON       reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    PRINT           reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    STRING          reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    VAR             reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    FINAL           reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    ID              reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    VOID            reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    LIST            reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    DYNAMIC         reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    INT             reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    DOUBLE          reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    MAP             reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    WHILE           reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    BOOL            reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    IF              reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    FOR             reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    $end            reduce using rule 66 (control_structures_if_else -> if_block else_block .)
    RBRACKET        reduce using rule 66 (control_structures_if_else -> if_block else_block .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    key_type                       shift and go to state 111

state 58

<<<<<<< HEAD
    (59) control_structures_if_else -> if_block else_if_blocks .
    (60) control_structures_if_else -> if_block else_if_blocks . else_block
    (64) else_if_blocks -> else_if_blocks . ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (65) else_block -> . ELSE LBRACKET statement_list RBRACKET

    COMMENT_MULTI   reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    COMMENT_SINGLE  reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    SEMICOLON       reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    PRINT           reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    STRING          reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    VAR             reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    FINAL           reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    ID              reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    VOID            reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    LIST            reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    DYNAMIC         reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    MAP             reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    WHILE           reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    INT             reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    DOUBLE          reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    BOOL            reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    IF              reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    FOR             reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    $end            reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    RBRACKET        reduce using rule 59 (control_structures_if_else -> if_block else_if_blocks .)
    ELSE            shift and go to state 114
=======
    (68) else_if_blocks -> ELSE . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (70) else_block -> ELSE . LBRACKET statement_list RBRACKET

    IF              shift and go to state 109
    LBRACKET        shift and go to state 110
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    else_block                     shift and go to state 113

state 59

<<<<<<< HEAD
    (61) control_structures_if_else -> if_block else_block .

    COMMENT_MULTI   reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    COMMENT_SINGLE  reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    SEMICOLON       reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    PRINT           reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    STRING          reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    VAR             reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    FINAL           reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    ID              reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    VOID            reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    LIST            reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    DYNAMIC         reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    MAP             reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    WHILE           reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    INT             reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    DOUBLE          reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    BOOL            reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    IF              reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    FOR             reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    $end            reduce using rule 61 (control_structures_if_else -> if_block else_block .)
    RBRACKET        reduce using rule 61 (control_structures_if_else -> if_block else_block .)


state 60

    (63) else_if_blocks -> ELSE . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (65) else_block -> ELSE . LBRACKET statement_list RBRACKET

    IF              shift and go to state 115
    LBRACKET        shift and go to state 116


state 61

    (125) control_structures_while -> WHILE LPAREN . conditions LBRACKET statement_list RBRACKET
    (66) conditions -> . condition
    (67) conditions -> . condition AND conditions
    (68) conditions -> . condition OR conditions
    (69) condition -> . value comparator value
    (70) condition -> . NOT condition
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NOT             shift and go to state 85
    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83

    conditions                     shift and go to state 117
    condition                      shift and go to state 79
    value                          shift and go to state 118

state 62

    (62) if_block -> IF LPAREN . conditions RPAREN LBRACKET statement_list RBRACKET
    (66) conditions -> . condition
    (67) conditions -> . condition AND conditions
    (68) conditions -> . condition OR conditions
    (69) condition -> . value comparator value
    (70) condition -> . NOT condition
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NOT             shift and go to state 85
    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83
=======
    (130) control_structures_while -> WHILE LPAREN . conditions LBRACKET statement_list RBRACKET
    (71) conditions -> . condition
    (72) conditions -> . conditions AND conditions
    (73) conditions -> . conditions OR conditions
    (74) condition -> . value comparator value
    (75) condition -> . NOT condition
    (76) condition -> . LPAREN conditions RPAREN
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 115
    LPAREN          shift and go to state 111
    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    conditions                     shift and go to state 112
    condition                      shift and go to state 113
    value                          shift and go to state 114
    interpolated_string            shift and go to state 72

state 60

    (67) if_block -> IF LPAREN . conditions RPAREN LBRACKET statement_list RBRACKET
    (71) conditions -> . condition
    (72) conditions -> . conditions AND conditions
    (73) conditions -> . conditions OR conditions
    (74) condition -> . value comparator value
    (75) condition -> . NOT condition
    (76) condition -> . LPAREN conditions RPAREN
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 115
    LPAREN          shift and go to state 111
    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    conditions                     shift and go to state 116
    condition                      shift and go to state 113
    value                          shift and go to state 114
    interpolated_string            shift and go to state 72

state 61

    (116) for_classic -> FOR LPAREN . for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> FOR LPAREN . for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> FOR LPAREN . for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (115) for_classic_parenthesis_content -> . for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON for_classic_changes
    (117) for_in_parenthesis_content -> . FINAL ID IN ID
    (121) for_each_parenthesis_content -> . FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID
    (108) for_classic_initialization -> . INT ID ASSIGN NUMBER
    (109) for_classic_initialization -> . DOUBLE ID ASSIGN NDOUBLE

    FINAL           shift and go to state 121
    INT             shift and go to state 122
    DOUBLE          shift and go to state 123

    for_classic_parenthesis_content shift and go to state 117
    for_in_parenthesis_content     shift and go to state 118
    for_each_parenthesis_content   shift and go to state 119
    for_classic_initialization     shift and go to state 120

state 62

    (41) print -> PRINT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 124
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    conditions                     shift and go to state 119
    condition                      shift and go to state 79
    value                          shift and go to state 118

state 63

<<<<<<< HEAD
    (111) for_classic -> FOR LPAREN . for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> FOR LPAREN . for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> FOR LPAREN . for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (110) for_classic_parenthesis_content -> . for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON for_classic_changes
    (112) for_in_parenthesis_content -> . FINAL ID IN ID
    (116) for_each_parenthesis_content -> . FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID
    (103) for_classic_initialization -> . INT ID ASSIGN NUMBER
    (104) for_classic_initialization -> . DOUBLE ID ASSIGN NDOUBLE

    FINAL           shift and go to state 124
    INT             shift and go to state 125
    DOUBLE          shift and go to state 126

    for_classic_parenthesis_content shift and go to state 120
    for_in_parenthesis_content     shift and go to state 121
    for_each_parenthesis_content   shift and go to state 122
    for_classic_initialization     shift and go to state 123

state 64

    (40) print -> PRINT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 127
=======
    (42) print -> PRINT LPAREN simple_operations_arithmetics . RPAREN SEMICOLON

    RPAREN          shift and go to state 125


state 64

    (43) print -> PRINT LPAREN value . RPAREN SEMICOLON
    (60) expression -> value . comparator value
    (61) expression -> value . PLUS value
    (62) expression -> value .
    (77) comparator -> . GREATER
    (78) comparator -> . LESS
    (79) comparator -> . EQUALS
    (80) comparator -> . GREATER_EQUAL
    (81) comparator -> . LESS_EQUAL
    (82) comparator -> . NOT_EQUALS

  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
    RPAREN          shift and go to state 126
    PLUS            shift and go to state 128
    MINUS           reduce using rule 62 (expression -> value .)
    TIMES           reduce using rule 62 (expression -> value .)
    DIVIDE          reduce using rule 62 (expression -> value .)
    AND             reduce using rule 62 (expression -> value .)
    OR              reduce using rule 62 (expression -> value .)
    GREATER         shift and go to state 129
    LESS            shift and go to state 130
    EQUALS          shift and go to state 131
    GREATER_EQUAL   shift and go to state 132
    LESS_EQUAL      shift and go to state 133
    NOT_EQUALS      shift and go to state 134
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

  ! RPAREN          [ reduce using rule 62 (expression -> value .) ]
  ! PLUS            [ reduce using rule 62 (expression -> value .) ]

    comparator                     shift and go to state 127

state 65

<<<<<<< HEAD
    (41) print -> PRINT LPAREN print_options . RPAREN SEMICOLON

    RPAREN          shift and go to state 128
=======
    (44) print -> PRINT LPAREN expression . RPAREN SEMICOLON
    (54) expression -> expression . PLUS expression
    (55) expression -> expression . MINUS expression
    (56) expression -> expression . TIMES expression
    (57) expression -> expression . DIVIDE expression
    (58) expression -> expression . AND expression
    (59) expression -> expression . OR expression

    RPAREN          shift and go to state 135
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    AND             shift and go to state 140
    OR              shift and go to state 141
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 66

<<<<<<< HEAD
    (42) print_options -> interpolated_string .

    RPAREN          reduce using rule 42 (print_options -> interpolated_string .)
=======
    (45) print -> PRINT LPAREN length . RPAREN SEMICOLON

    RPAREN          shift and go to state 142
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 67

<<<<<<< HEAD
    (43) print_options -> expression .

    RPAREN          reduce using rule 43 (print_options -> expression .)
=======
    (52) simple_operations_arithmetics -> list_numbers . simple_operators_arithmetics list_numbers
    (53) simple_operations_arithmetics -> list_numbers . simple_operators_arithmetics list_numbers simple_operators_arithmetics simple_operations_arithmetics
    (48) simple_operators_arithmetics -> . MINUS
    (49) simple_operators_arithmetics -> . PLUS
    (50) simple_operators_arithmetics -> . DIVIDE
    (51) simple_operators_arithmetics -> . TIMES

    MINUS           shift and go to state 144
    PLUS            shift and go to state 145
    DIVIDE          shift and go to state 146
    TIMES           shift and go to state 147
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    simple_operators_arithmetics   shift and go to state 143

state 68

<<<<<<< HEAD
    (44) print_options -> length .

    RPAREN          reduce using rule 44 (print_options -> length .)
=======
    (96) value -> NUMBER .
    (46) list_numbers -> NUMBER .

  ! reduce/reduce conflict for MINUS resolved using rule 46 (list_numbers -> NUMBER .)
  ! reduce/reduce conflict for PLUS resolved using rule 46 (list_numbers -> NUMBER .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 46 (list_numbers -> NUMBER .)
  ! reduce/reduce conflict for TIMES resolved using rule 46 (list_numbers -> NUMBER .)
    RPAREN          reduce using rule 96 (value -> NUMBER .)
    GREATER         reduce using rule 96 (value -> NUMBER .)
    LESS            reduce using rule 96 (value -> NUMBER .)
    EQUALS          reduce using rule 96 (value -> NUMBER .)
    GREATER_EQUAL   reduce using rule 96 (value -> NUMBER .)
    LESS_EQUAL      reduce using rule 96 (value -> NUMBER .)
    NOT_EQUALS      reduce using rule 96 (value -> NUMBER .)
    AND             reduce using rule 96 (value -> NUMBER .)
    OR              reduce using rule 96 (value -> NUMBER .)
    MINUS           reduce using rule 46 (list_numbers -> NUMBER .)
    PLUS            reduce using rule 46 (list_numbers -> NUMBER .)
    DIVIDE          reduce using rule 46 (list_numbers -> NUMBER .)
    TIMES           reduce using rule 46 (list_numbers -> NUMBER .)

  ! PLUS            [ reduce using rule 96 (value -> NUMBER .) ]
  ! MINUS           [ reduce using rule 96 (value -> NUMBER .) ]
  ! TIMES           [ reduce using rule 96 (value -> NUMBER .) ]
  ! DIVIDE          [ reduce using rule 96 (value -> NUMBER .) ]
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 69

<<<<<<< HEAD
    (45) print_options -> call_function .

    RPAREN          reduce using rule 45 (print_options -> call_function .)
=======
    (97) value -> NDOUBLE .
    (47) list_numbers -> NDOUBLE .

  ! reduce/reduce conflict for MINUS resolved using rule 47 (list_numbers -> NDOUBLE .)
  ! reduce/reduce conflict for PLUS resolved using rule 47 (list_numbers -> NDOUBLE .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 47 (list_numbers -> NDOUBLE .)
  ! reduce/reduce conflict for TIMES resolved using rule 47 (list_numbers -> NDOUBLE .)
    RPAREN          reduce using rule 97 (value -> NDOUBLE .)
    GREATER         reduce using rule 97 (value -> NDOUBLE .)
    LESS            reduce using rule 97 (value -> NDOUBLE .)
    EQUALS          reduce using rule 97 (value -> NDOUBLE .)
    GREATER_EQUAL   reduce using rule 97 (value -> NDOUBLE .)
    LESS_EQUAL      reduce using rule 97 (value -> NDOUBLE .)
    NOT_EQUALS      reduce using rule 97 (value -> NDOUBLE .)
    AND             reduce using rule 97 (value -> NDOUBLE .)
    OR              reduce using rule 97 (value -> NDOUBLE .)
    MINUS           reduce using rule 47 (list_numbers -> NDOUBLE .)
    PLUS            reduce using rule 47 (list_numbers -> NDOUBLE .)
    DIVIDE          reduce using rule 47 (list_numbers -> NDOUBLE .)
    TIMES           reduce using rule 47 (list_numbers -> NDOUBLE .)

  ! PLUS            [ reduce using rule 97 (value -> NDOUBLE .) ]
  ! MINUS           [ reduce using rule 97 (value -> NDOUBLE .) ]
  ! TIMES           [ reduce using rule 97 (value -> NDOUBLE .) ]
  ! DIVIDE          [ reduce using rule 97 (value -> NDOUBLE .) ]
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 70

<<<<<<< HEAD
    (85) interpolated_string -> string_part .
    (86) interpolated_string -> string_part . PLUS interpolated_string

    RPAREN          reduce using rule 85 (interpolated_string -> string_part .)
    PLUS            shift and go to state 129
=======
    (98) value -> TEXT .
    (25) length -> TEXT . DOT LENGTH
    (103) interpolated_string -> TEXT . PLUS ID
    (104) interpolated_string -> TEXT . PLUS expression

  ! shift/reduce conflict for PLUS resolved as shift
    RPAREN          reduce using rule 98 (value -> TEXT .)
    GREATER         reduce using rule 98 (value -> TEXT .)
    LESS            reduce using rule 98 (value -> TEXT .)
    EQUALS          reduce using rule 98 (value -> TEXT .)
    GREATER_EQUAL   reduce using rule 98 (value -> TEXT .)
    LESS_EQUAL      reduce using rule 98 (value -> TEXT .)
    NOT_EQUALS      reduce using rule 98 (value -> TEXT .)
    MINUS           reduce using rule 98 (value -> TEXT .)
    TIMES           reduce using rule 98 (value -> TEXT .)
    DIVIDE          reduce using rule 98 (value -> TEXT .)
    AND             reduce using rule 98 (value -> TEXT .)
    OR              reduce using rule 98 (value -> TEXT .)
    DOT             shift and go to state 148
    PLUS            shift and go to state 149

  ! PLUS            [ reduce using rule 98 (value -> TEXT .) ]
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 71

<<<<<<< HEAD
    (46) expression -> operations .

    RPAREN          reduce using rule 46 (expression -> operations .)
    COMMA           reduce using rule 46 (expression -> operations .)
    SEMICOLON       reduce using rule 46 (expression -> operations .)
    COMMENT_MULTI   reduce using rule 46 (expression -> operations .)
    COMMENT_SINGLE  reduce using rule 46 (expression -> operations .)
    PRINT           reduce using rule 46 (expression -> operations .)
    STRING          reduce using rule 46 (expression -> operations .)
    VAR             reduce using rule 46 (expression -> operations .)
    FINAL           reduce using rule 46 (expression -> operations .)
    ID              reduce using rule 46 (expression -> operations .)
    VOID            reduce using rule 46 (expression -> operations .)
    LIST            reduce using rule 46 (expression -> operations .)
    DYNAMIC         reduce using rule 46 (expression -> operations .)
    MAP             reduce using rule 46 (expression -> operations .)
    WHILE           reduce using rule 46 (expression -> operations .)
    INT             reduce using rule 46 (expression -> operations .)
    DOUBLE          reduce using rule 46 (expression -> operations .)
    BOOL            reduce using rule 46 (expression -> operations .)
    IF              reduce using rule 46 (expression -> operations .)
    FOR             reduce using rule 46 (expression -> operations .)
    $end            reduce using rule 46 (expression -> operations .)
    RBRACKET        reduce using rule 46 (expression -> operations .)
=======
    (99) value -> ID .

    RPAREN          reduce using rule 99 (value -> ID .)
    PLUS            reduce using rule 99 (value -> ID .)
    GREATER         reduce using rule 99 (value -> ID .)
    LESS            reduce using rule 99 (value -> ID .)
    EQUALS          reduce using rule 99 (value -> ID .)
    GREATER_EQUAL   reduce using rule 99 (value -> ID .)
    LESS_EQUAL      reduce using rule 99 (value -> ID .)
    NOT_EQUALS      reduce using rule 99 (value -> ID .)
    MINUS           reduce using rule 99 (value -> ID .)
    TIMES           reduce using rule 99 (value -> ID .)
    DIVIDE          reduce using rule 99 (value -> ID .)
    AND             reduce using rule 99 (value -> ID .)
    OR              reduce using rule 99 (value -> ID .)
    COMMA           reduce using rule 99 (value -> ID .)
    RSBRACKET       reduce using rule 99 (value -> ID .)
    SEMICOLON       reduce using rule 99 (value -> ID .)
    PRINT           reduce using rule 99 (value -> ID .)
    STRING          reduce using rule 99 (value -> ID .)
    VAR             reduce using rule 99 (value -> ID .)
    FINAL           reduce using rule 99 (value -> ID .)
    ID              reduce using rule 99 (value -> ID .)
    VOID            reduce using rule 99 (value -> ID .)
    LIST            reduce using rule 99 (value -> ID .)
    DYNAMIC         reduce using rule 99 (value -> ID .)
    INT             reduce using rule 99 (value -> ID .)
    DOUBLE          reduce using rule 99 (value -> ID .)
    MAP             reduce using rule 99 (value -> ID .)
    WHILE           reduce using rule 99 (value -> ID .)
    BOOL            reduce using rule 99 (value -> ID .)
    IF              reduce using rule 99 (value -> ID .)
    FOR             reduce using rule 99 (value -> ID .)
    $end            reduce using rule 99 (value -> ID .)
    RBRACKET        reduce using rule 99 (value -> ID .)
    LBRACKET        reduce using rule 99 (value -> ID .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 72

<<<<<<< HEAD
    (56) expression -> conditions .

    RPAREN          reduce using rule 56 (expression -> conditions .)
    COMMA           reduce using rule 56 (expression -> conditions .)
    SEMICOLON       reduce using rule 56 (expression -> conditions .)
    COMMENT_MULTI   reduce using rule 56 (expression -> conditions .)
    COMMENT_SINGLE  reduce using rule 56 (expression -> conditions .)
    PRINT           reduce using rule 56 (expression -> conditions .)
    STRING          reduce using rule 56 (expression -> conditions .)
    VAR             reduce using rule 56 (expression -> conditions .)
    FINAL           reduce using rule 56 (expression -> conditions .)
    ID              reduce using rule 56 (expression -> conditions .)
    VOID            reduce using rule 56 (expression -> conditions .)
    LIST            reduce using rule 56 (expression -> conditions .)
    DYNAMIC         reduce using rule 56 (expression -> conditions .)
    MAP             reduce using rule 56 (expression -> conditions .)
    WHILE           reduce using rule 56 (expression -> conditions .)
    INT             reduce using rule 56 (expression -> conditions .)
    DOUBLE          reduce using rule 56 (expression -> conditions .)
    BOOL            reduce using rule 56 (expression -> conditions .)
    IF              reduce using rule 56 (expression -> conditions .)
    FOR             reduce using rule 56 (expression -> conditions .)
    $end            reduce using rule 56 (expression -> conditions .)
    RBRACKET        reduce using rule 56 (expression -> conditions .)
=======
    (100) value -> interpolated_string .

    RPAREN          reduce using rule 100 (value -> interpolated_string .)
    PLUS            reduce using rule 100 (value -> interpolated_string .)
    GREATER         reduce using rule 100 (value -> interpolated_string .)
    LESS            reduce using rule 100 (value -> interpolated_string .)
    EQUALS          reduce using rule 100 (value -> interpolated_string .)
    GREATER_EQUAL   reduce using rule 100 (value -> interpolated_string .)
    LESS_EQUAL      reduce using rule 100 (value -> interpolated_string .)
    NOT_EQUALS      reduce using rule 100 (value -> interpolated_string .)
    MINUS           reduce using rule 100 (value -> interpolated_string .)
    TIMES           reduce using rule 100 (value -> interpolated_string .)
    DIVIDE          reduce using rule 100 (value -> interpolated_string .)
    AND             reduce using rule 100 (value -> interpolated_string .)
    OR              reduce using rule 100 (value -> interpolated_string .)
    COMMA           reduce using rule 100 (value -> interpolated_string .)
    RSBRACKET       reduce using rule 100 (value -> interpolated_string .)
    SEMICOLON       reduce using rule 100 (value -> interpolated_string .)
    PRINT           reduce using rule 100 (value -> interpolated_string .)
    STRING          reduce using rule 100 (value -> interpolated_string .)
    VAR             reduce using rule 100 (value -> interpolated_string .)
    FINAL           reduce using rule 100 (value -> interpolated_string .)
    ID              reduce using rule 100 (value -> interpolated_string .)
    VOID            reduce using rule 100 (value -> interpolated_string .)
    LIST            reduce using rule 100 (value -> interpolated_string .)
    DYNAMIC         reduce using rule 100 (value -> interpolated_string .)
    INT             reduce using rule 100 (value -> interpolated_string .)
    DOUBLE          reduce using rule 100 (value -> interpolated_string .)
    MAP             reduce using rule 100 (value -> interpolated_string .)
    WHILE           reduce using rule 100 (value -> interpolated_string .)
    BOOL            reduce using rule 100 (value -> interpolated_string .)
    IF              reduce using rule 100 (value -> interpolated_string .)
    FOR             reduce using rule 100 (value -> interpolated_string .)
    $end            reduce using rule 100 (value -> interpolated_string .)
    RBRACKET        reduce using rule 100 (value -> interpolated_string .)
    LBRACKET        reduce using rule 100 (value -> interpolated_string .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 73

<<<<<<< HEAD
    (57) expression -> value .
    (69) condition -> value . comparator value
    (71) comparator -> . GREATER
    (72) comparator -> . LESS
    (73) comparator -> . EQUALS
    (74) comparator -> . GREATER_EQUAL
    (75) comparator -> . LESS_EQUAL
    (76) comparator -> . NOT_EQUALS

    RPAREN          reduce using rule 57 (expression -> value .)
    COMMA           reduce using rule 57 (expression -> value .)
    SEMICOLON       reduce using rule 57 (expression -> value .)
    COMMENT_MULTI   reduce using rule 57 (expression -> value .)
    COMMENT_SINGLE  reduce using rule 57 (expression -> value .)
    PRINT           reduce using rule 57 (expression -> value .)
    STRING          reduce using rule 57 (expression -> value .)
    VAR             reduce using rule 57 (expression -> value .)
    FINAL           reduce using rule 57 (expression -> value .)
    ID              reduce using rule 57 (expression -> value .)
    VOID            reduce using rule 57 (expression -> value .)
    LIST            reduce using rule 57 (expression -> value .)
    DYNAMIC         reduce using rule 57 (expression -> value .)
    MAP             reduce using rule 57 (expression -> value .)
    WHILE           reduce using rule 57 (expression -> value .)
    INT             reduce using rule 57 (expression -> value .)
    DOUBLE          reduce using rule 57 (expression -> value .)
    BOOL            reduce using rule 57 (expression -> value .)
    IF              reduce using rule 57 (expression -> value .)
    FOR             reduce using rule 57 (expression -> value .)
    $end            reduce using rule 57 (expression -> value .)
    RBRACKET        reduce using rule 57 (expression -> value .)
    GREATER         shift and go to state 131
    LESS            shift and go to state 132
    EQUALS          shift and go to state 133
    GREATER_EQUAL   shift and go to state 134
    LESS_EQUAL      shift and go to state 135
    NOT_EQUALS      shift and go to state 136
=======
    (101) value -> TRUE .

    RPAREN          reduce using rule 101 (value -> TRUE .)
    PLUS            reduce using rule 101 (value -> TRUE .)
    GREATER         reduce using rule 101 (value -> TRUE .)
    LESS            reduce using rule 101 (value -> TRUE .)
    EQUALS          reduce using rule 101 (value -> TRUE .)
    GREATER_EQUAL   reduce using rule 101 (value -> TRUE .)
    LESS_EQUAL      reduce using rule 101 (value -> TRUE .)
    NOT_EQUALS      reduce using rule 101 (value -> TRUE .)
    MINUS           reduce using rule 101 (value -> TRUE .)
    TIMES           reduce using rule 101 (value -> TRUE .)
    DIVIDE          reduce using rule 101 (value -> TRUE .)
    AND             reduce using rule 101 (value -> TRUE .)
    OR              reduce using rule 101 (value -> TRUE .)
    COMMA           reduce using rule 101 (value -> TRUE .)
    RSBRACKET       reduce using rule 101 (value -> TRUE .)
    SEMICOLON       reduce using rule 101 (value -> TRUE .)
    PRINT           reduce using rule 101 (value -> TRUE .)
    STRING          reduce using rule 101 (value -> TRUE .)
    VAR             reduce using rule 101 (value -> TRUE .)
    FINAL           reduce using rule 101 (value -> TRUE .)
    ID              reduce using rule 101 (value -> TRUE .)
    VOID            reduce using rule 101 (value -> TRUE .)
    LIST            reduce using rule 101 (value -> TRUE .)
    DYNAMIC         reduce using rule 101 (value -> TRUE .)
    INT             reduce using rule 101 (value -> TRUE .)
    DOUBLE          reduce using rule 101 (value -> TRUE .)
    MAP             reduce using rule 101 (value -> TRUE .)
    WHILE           reduce using rule 101 (value -> TRUE .)
    BOOL            reduce using rule 101 (value -> TRUE .)
    IF              reduce using rule 101 (value -> TRUE .)
    FOR             reduce using rule 101 (value -> TRUE .)
    $end            reduce using rule 101 (value -> TRUE .)
    RBRACKET        reduce using rule 101 (value -> TRUE .)
    LBRACKET        reduce using rule 101 (value -> TRUE .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    comparator                     shift and go to state 130

state 74

<<<<<<< HEAD
    (27) length -> call_list . DOT LENGTH

    DOT             shift and go to state 137
=======
    (102) value -> FALSE .

    RPAREN          reduce using rule 102 (value -> FALSE .)
    PLUS            reduce using rule 102 (value -> FALSE .)
    GREATER         reduce using rule 102 (value -> FALSE .)
    LESS            reduce using rule 102 (value -> FALSE .)
    EQUALS          reduce using rule 102 (value -> FALSE .)
    GREATER_EQUAL   reduce using rule 102 (value -> FALSE .)
    LESS_EQUAL      reduce using rule 102 (value -> FALSE .)
    NOT_EQUALS      reduce using rule 102 (value -> FALSE .)
    MINUS           reduce using rule 102 (value -> FALSE .)
    TIMES           reduce using rule 102 (value -> FALSE .)
    DIVIDE          reduce using rule 102 (value -> FALSE .)
    AND             reduce using rule 102 (value -> FALSE .)
    OR              reduce using rule 102 (value -> FALSE .)
    COMMA           reduce using rule 102 (value -> FALSE .)
    RSBRACKET       reduce using rule 102 (value -> FALSE .)
    SEMICOLON       reduce using rule 102 (value -> FALSE .)
    PRINT           reduce using rule 102 (value -> FALSE .)
    STRING          reduce using rule 102 (value -> FALSE .)
    VAR             reduce using rule 102 (value -> FALSE .)
    FINAL           reduce using rule 102 (value -> FALSE .)
    ID              reduce using rule 102 (value -> FALSE .)
    VOID            reduce using rule 102 (value -> FALSE .)
    LIST            reduce using rule 102 (value -> FALSE .)
    DYNAMIC         reduce using rule 102 (value -> FALSE .)
    INT             reduce using rule 102 (value -> FALSE .)
    DOUBLE          reduce using rule 102 (value -> FALSE .)
    MAP             reduce using rule 102 (value -> FALSE .)
    WHILE           reduce using rule 102 (value -> FALSE .)
    BOOL            reduce using rule 102 (value -> FALSE .)
    IF              reduce using rule 102 (value -> FALSE .)
    FOR             reduce using rule 102 (value -> FALSE .)
    $end            reduce using rule 102 (value -> FALSE .)
    RBRACKET        reduce using rule 102 (value -> FALSE .)
    LBRACKET        reduce using rule 102 (value -> FALSE .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 75

<<<<<<< HEAD
    (28) length -> TEXT . DOT LENGTH
    (87) string_part -> TEXT .
    (88) string_part -> TEXT . PLUS value
    (96) value -> TEXT .

  ! shift/reduce conflict for PLUS resolved as shift
  ! reduce/reduce conflict for RPAREN resolved using rule 87 (string_part -> TEXT .)
    DOT             shift and go to state 138
    RPAREN          reduce using rule 87 (string_part -> TEXT .)
    PLUS            shift and go to state 139
    GREATER         reduce using rule 96 (value -> TEXT .)
    LESS            reduce using rule 96 (value -> TEXT .)
    EQUALS          reduce using rule 96 (value -> TEXT .)
    GREATER_EQUAL   reduce using rule 96 (value -> TEXT .)
    LESS_EQUAL      reduce using rule 96 (value -> TEXT .)
    NOT_EQUALS      reduce using rule 96 (value -> TEXT .)

  ! PLUS            [ reduce using rule 87 (string_part -> TEXT .) ]
  ! RPAREN          [ reduce using rule 96 (value -> TEXT .) ]
=======
    (24) length -> call_list . DOT LENGTH

    DOT             shift and go to state 150
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 76

<<<<<<< HEAD
    (23) call_function -> ID . LPAREN argument_list RPAREN
    (24) call_function -> ID . LPAREN RPAREN
    (97) value -> ID .

    LPAREN          shift and go to state 140
    GREATER         reduce using rule 97 (value -> ID .)
    LESS            reduce using rule 97 (value -> ID .)
    EQUALS          reduce using rule 97 (value -> ID .)
    GREATER_EQUAL   reduce using rule 97 (value -> ID .)
    LESS_EQUAL      reduce using rule 97 (value -> ID .)
    NOT_EQUALS      reduce using rule 97 (value -> ID .)
    RPAREN          reduce using rule 97 (value -> ID .)
=======
    (92) call_list -> LSBRACKET . value_list RSBRACKET
    (94) value_list -> . value
    (95) value_list -> . value_list COMMA value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    value_list                     shift and go to state 151
    value                          shift and go to state 152
    interpolated_string            shift and go to state 72

state 77

<<<<<<< HEAD
    (47) operations -> operation .
    (48) operations -> operation . operand operations
    (50) operand -> . NUMBER
    (51) operand -> . DOUBLE

  ! shift/reduce conflict for DOUBLE resolved as shift
    RPAREN          reduce using rule 47 (operations -> operation .)
    COMMA           reduce using rule 47 (operations -> operation .)
    SEMICOLON       reduce using rule 47 (operations -> operation .)
    COMMENT_MULTI   reduce using rule 47 (operations -> operation .)
    COMMENT_SINGLE  reduce using rule 47 (operations -> operation .)
    PRINT           reduce using rule 47 (operations -> operation .)
    STRING          reduce using rule 47 (operations -> operation .)
    VAR             reduce using rule 47 (operations -> operation .)
    FINAL           reduce using rule 47 (operations -> operation .)
    ID              reduce using rule 47 (operations -> operation .)
    VOID            reduce using rule 47 (operations -> operation .)
    LIST            reduce using rule 47 (operations -> operation .)
    DYNAMIC         reduce using rule 47 (operations -> operation .)
    MAP             reduce using rule 47 (operations -> operation .)
    WHILE           reduce using rule 47 (operations -> operation .)
    INT             reduce using rule 47 (operations -> operation .)
    BOOL            reduce using rule 47 (operations -> operation .)
    IF              reduce using rule 47 (operations -> operation .)
    FOR             reduce using rule 47 (operations -> operation .)
    $end            reduce using rule 47 (operations -> operation .)
    RBRACKET        reduce using rule 47 (operations -> operation .)
    NUMBER          shift and go to state 142
    DOUBLE          shift and go to state 86
=======
    (22) data_input -> STRING ID ASSIGN . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    STDIN           shift and go to state 153
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

  ! DOUBLE          [ reduce using rule 47 (operations -> operation .) ]

    operand                        shift and go to state 141

state 78

<<<<<<< HEAD
    (49) operation -> operand . operator operand
    (52) operator -> . PLUS
    (53) operator -> . MINUS
    (54) operator -> . TIMES
    (55) operator -> . DIVIDE
=======
    (23) data_input -> STRING QUESTION ID . ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    ASSIGN          shift and go to state 154


state 79

    (128) constructor -> ID LPAREN constructor_parenthesis_content . RPAREN SEMICOLON

    RPAREN          shift and go to state 155


state 80

    (21) call_function -> ID LPAREN RPAREN .
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    PLUS            shift and go to state 144
    MINUS           shift and go to state 145
    TIMES           shift and go to state 146
    DIVIDE          shift and go to state 147

    operator                       shift and go to state 143

state 81

    (66) conditions -> condition .
    (67) conditions -> condition . AND conditions
    (68) conditions -> condition . OR conditions

<<<<<<< HEAD
    RPAREN          reduce using rule 66 (conditions -> condition .)
    COMMA           reduce using rule 66 (conditions -> condition .)
    LBRACKET        reduce using rule 66 (conditions -> condition .)
    SEMICOLON       reduce using rule 66 (conditions -> condition .)
    COMMENT_MULTI   reduce using rule 66 (conditions -> condition .)
    COMMENT_SINGLE  reduce using rule 66 (conditions -> condition .)
    PRINT           reduce using rule 66 (conditions -> condition .)
    STRING          reduce using rule 66 (conditions -> condition .)
    VAR             reduce using rule 66 (conditions -> condition .)
    FINAL           reduce using rule 66 (conditions -> condition .)
    ID              reduce using rule 66 (conditions -> condition .)
    VOID            reduce using rule 66 (conditions -> condition .)
    LIST            reduce using rule 66 (conditions -> condition .)
    DYNAMIC         reduce using rule 66 (conditions -> condition .)
    MAP             reduce using rule 66 (conditions -> condition .)
    WHILE           reduce using rule 66 (conditions -> condition .)
    INT             reduce using rule 66 (conditions -> condition .)
    DOUBLE          reduce using rule 66 (conditions -> condition .)
    BOOL            reduce using rule 66 (conditions -> condition .)
    IF              reduce using rule 66 (conditions -> condition .)
    FOR             reduce using rule 66 (conditions -> condition .)
    $end            reduce using rule 66 (conditions -> condition .)
    RBRACKET        reduce using rule 66 (conditions -> condition .)
    AND             shift and go to state 148
    OR              shift and go to state 149


state 80

    (94) value -> NUMBER .
    (50) operand -> NUMBER .

    GREATER         reduce using rule 94 (value -> NUMBER .)
    LESS            reduce using rule 94 (value -> NUMBER .)
    EQUALS          reduce using rule 94 (value -> NUMBER .)
    GREATER_EQUAL   reduce using rule 94 (value -> NUMBER .)
    LESS_EQUAL      reduce using rule 94 (value -> NUMBER .)
    NOT_EQUALS      reduce using rule 94 (value -> NUMBER .)
    RPAREN          reduce using rule 94 (value -> NUMBER .)
    COMMA           reduce using rule 94 (value -> NUMBER .)
    SEMICOLON       reduce using rule 94 (value -> NUMBER .)
    COMMENT_MULTI   reduce using rule 94 (value -> NUMBER .)
    COMMENT_SINGLE  reduce using rule 94 (value -> NUMBER .)
    PRINT           reduce using rule 94 (value -> NUMBER .)
    STRING          reduce using rule 94 (value -> NUMBER .)
    VAR             reduce using rule 94 (value -> NUMBER .)
    FINAL           reduce using rule 94 (value -> NUMBER .)
    ID              reduce using rule 94 (value -> NUMBER .)
    VOID            reduce using rule 94 (value -> NUMBER .)
    LIST            reduce using rule 94 (value -> NUMBER .)
    DYNAMIC         reduce using rule 94 (value -> NUMBER .)
    MAP             reduce using rule 94 (value -> NUMBER .)
    WHILE           reduce using rule 94 (value -> NUMBER .)
    INT             reduce using rule 94 (value -> NUMBER .)
    DOUBLE          reduce using rule 94 (value -> NUMBER .)
    BOOL            reduce using rule 94 (value -> NUMBER .)
    IF              reduce using rule 94 (value -> NUMBER .)
    FOR             reduce using rule 94 (value -> NUMBER .)
    $end            reduce using rule 94 (value -> NUMBER .)
    RBRACKET        reduce using rule 94 (value -> NUMBER .)
    PLUS            reduce using rule 50 (operand -> NUMBER .)
    MINUS           reduce using rule 50 (operand -> NUMBER .)
    TIMES           reduce using rule 50 (operand -> NUMBER .)
    DIVIDE          reduce using rule 50 (operand -> NUMBER .)


state 81

    (95) value -> NDOUBLE .

    GREATER         reduce using rule 95 (value -> NDOUBLE .)
    LESS            reduce using rule 95 (value -> NDOUBLE .)
    EQUALS          reduce using rule 95 (value -> NDOUBLE .)
    GREATER_EQUAL   reduce using rule 95 (value -> NDOUBLE .)
    LESS_EQUAL      reduce using rule 95 (value -> NDOUBLE .)
    NOT_EQUALS      reduce using rule 95 (value -> NDOUBLE .)
    RPAREN          reduce using rule 95 (value -> NDOUBLE .)
    COMMA           reduce using rule 95 (value -> NDOUBLE .)
    SEMICOLON       reduce using rule 95 (value -> NDOUBLE .)
    RSBRACKET       reduce using rule 95 (value -> NDOUBLE .)
    AND             reduce using rule 95 (value -> NDOUBLE .)
    OR              reduce using rule 95 (value -> NDOUBLE .)
    LBRACKET        reduce using rule 95 (value -> NDOUBLE .)
    COMMENT_MULTI   reduce using rule 95 (value -> NDOUBLE .)
    COMMENT_SINGLE  reduce using rule 95 (value -> NDOUBLE .)
    PRINT           reduce using rule 95 (value -> NDOUBLE .)
    STRING          reduce using rule 95 (value -> NDOUBLE .)
    VAR             reduce using rule 95 (value -> NDOUBLE .)
    FINAL           reduce using rule 95 (value -> NDOUBLE .)
    ID              reduce using rule 95 (value -> NDOUBLE .)
    VOID            reduce using rule 95 (value -> NDOUBLE .)
    LIST            reduce using rule 95 (value -> NDOUBLE .)
    DYNAMIC         reduce using rule 95 (value -> NDOUBLE .)
    MAP             reduce using rule 95 (value -> NDOUBLE .)
    WHILE           reduce using rule 95 (value -> NDOUBLE .)
    INT             reduce using rule 95 (value -> NDOUBLE .)
    DOUBLE          reduce using rule 95 (value -> NDOUBLE .)
    BOOL            reduce using rule 95 (value -> NDOUBLE .)
    IF              reduce using rule 95 (value -> NDOUBLE .)
    FOR             reduce using rule 95 (value -> NDOUBLE .)
    $end            reduce using rule 95 (value -> NDOUBLE .)
    RBRACKET        reduce using rule 95 (value -> NDOUBLE .)
    PLUS            reduce using rule 95 (value -> NDOUBLE .)
=======
    RPAREN          shift and go to state 156
    COMMA           shift and go to state 157
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 82

<<<<<<< HEAD
    (98) value -> TRUE .

    GREATER         reduce using rule 98 (value -> TRUE .)
    LESS            reduce using rule 98 (value -> TRUE .)
    EQUALS          reduce using rule 98 (value -> TRUE .)
    GREATER_EQUAL   reduce using rule 98 (value -> TRUE .)
    LESS_EQUAL      reduce using rule 98 (value -> TRUE .)
    NOT_EQUALS      reduce using rule 98 (value -> TRUE .)
    RPAREN          reduce using rule 98 (value -> TRUE .)
    COMMA           reduce using rule 98 (value -> TRUE .)
    SEMICOLON       reduce using rule 98 (value -> TRUE .)
    RSBRACKET       reduce using rule 98 (value -> TRUE .)
    AND             reduce using rule 98 (value -> TRUE .)
    OR              reduce using rule 98 (value -> TRUE .)
    LBRACKET        reduce using rule 98 (value -> TRUE .)
    COMMENT_MULTI   reduce using rule 98 (value -> TRUE .)
    COMMENT_SINGLE  reduce using rule 98 (value -> TRUE .)
    PRINT           reduce using rule 98 (value -> TRUE .)
    STRING          reduce using rule 98 (value -> TRUE .)
    VAR             reduce using rule 98 (value -> TRUE .)
    FINAL           reduce using rule 98 (value -> TRUE .)
    ID              reduce using rule 98 (value -> TRUE .)
    VOID            reduce using rule 98 (value -> TRUE .)
    LIST            reduce using rule 98 (value -> TRUE .)
    DYNAMIC         reduce using rule 98 (value -> TRUE .)
    MAP             reduce using rule 98 (value -> TRUE .)
    WHILE           reduce using rule 98 (value -> TRUE .)
    INT             reduce using rule 98 (value -> TRUE .)
    DOUBLE          reduce using rule 98 (value -> TRUE .)
    BOOL            reduce using rule 98 (value -> TRUE .)
    IF              reduce using rule 98 (value -> TRUE .)
    FOR             reduce using rule 98 (value -> TRUE .)
    $end            reduce using rule 98 (value -> TRUE .)
    RBRACKET        reduce using rule 98 (value -> TRUE .)
    PLUS            reduce using rule 98 (value -> TRUE .)


state 83

    (99) value -> FALSE .

    GREATER         reduce using rule 99 (value -> FALSE .)
    LESS            reduce using rule 99 (value -> FALSE .)
    EQUALS          reduce using rule 99 (value -> FALSE .)
    GREATER_EQUAL   reduce using rule 99 (value -> FALSE .)
    LESS_EQUAL      reduce using rule 99 (value -> FALSE .)
    NOT_EQUALS      reduce using rule 99 (value -> FALSE .)
    RPAREN          reduce using rule 99 (value -> FALSE .)
    COMMA           reduce using rule 99 (value -> FALSE .)
    SEMICOLON       reduce using rule 99 (value -> FALSE .)
    RSBRACKET       reduce using rule 99 (value -> FALSE .)
    AND             reduce using rule 99 (value -> FALSE .)
    OR              reduce using rule 99 (value -> FALSE .)
    LBRACKET        reduce using rule 99 (value -> FALSE .)
    COMMENT_MULTI   reduce using rule 99 (value -> FALSE .)
    COMMENT_SINGLE  reduce using rule 99 (value -> FALSE .)
    PRINT           reduce using rule 99 (value -> FALSE .)
    STRING          reduce using rule 99 (value -> FALSE .)
    VAR             reduce using rule 99 (value -> FALSE .)
    FINAL           reduce using rule 99 (value -> FALSE .)
    ID              reduce using rule 99 (value -> FALSE .)
    VOID            reduce using rule 99 (value -> FALSE .)
    LIST            reduce using rule 99 (value -> FALSE .)
    DYNAMIC         reduce using rule 99 (value -> FALSE .)
    MAP             reduce using rule 99 (value -> FALSE .)
    WHILE           reduce using rule 99 (value -> FALSE .)
    INT             reduce using rule 99 (value -> FALSE .)
    DOUBLE          reduce using rule 99 (value -> FALSE .)
    BOOL            reduce using rule 99 (value -> FALSE .)
    IF              reduce using rule 99 (value -> FALSE .)
    FOR             reduce using rule 99 (value -> FALSE .)
    $end            reduce using rule 99 (value -> FALSE .)
    RBRACKET        reduce using rule 99 (value -> FALSE .)
    PLUS            reduce using rule 99 (value -> FALSE .)


state 84

    (81) call_list -> LSBRACKET . value_list RSBRACKET
    (83) value_list -> . value
    (84) value_list -> . value COMMA value_list
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83

    value_list                     shift and go to state 150
    value                          shift and go to state 151

state 85

    (70) condition -> NOT . condition
    (69) condition -> . value comparator value
    (70) condition -> . NOT condition
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NOT             shift and go to state 85
    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83
=======
    (126) constructor_parenthesis_content -> THIS . DOT ID
    (127) constructor_parenthesis_content -> THIS . DOT ID COMMA constructor_parenthesis_content

    DOT             shift and go to state 158


state 83

    (26) argument_list -> expression .
    (54) expression -> expression . PLUS expression
    (55) expression -> expression . MINUS expression
    (56) expression -> expression . TIMES expression
    (57) expression -> expression . DIVIDE expression
    (58) expression -> expression . AND expression
    (59) expression -> expression . OR expression

    RPAREN          reduce using rule 26 (argument_list -> expression .)
    COMMA           reduce using rule 26 (argument_list -> expression .)
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    AND             shift and go to state 140
    OR              shift and go to state 141


state 84

    (60) expression -> value . comparator value
    (61) expression -> value . PLUS value
    (62) expression -> value .
    (77) comparator -> . GREATER
    (78) comparator -> . LESS
    (79) comparator -> . EQUALS
    (80) comparator -> . GREATER_EQUAL
    (81) comparator -> . LESS_EQUAL
    (82) comparator -> . NOT_EQUALS

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for EQUALS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for NOT_EQUALS resolved as shift
    PLUS            shift and go to state 128
    MINUS           reduce using rule 62 (expression -> value .)
    TIMES           reduce using rule 62 (expression -> value .)
    DIVIDE          reduce using rule 62 (expression -> value .)
    AND             reduce using rule 62 (expression -> value .)
    OR              reduce using rule 62 (expression -> value .)
    RPAREN          reduce using rule 62 (expression -> value .)
    COMMA           reduce using rule 62 (expression -> value .)
    SEMICOLON       reduce using rule 62 (expression -> value .)
    RSBRACKET       reduce using rule 62 (expression -> value .)
    PRINT           reduce using rule 62 (expression -> value .)
    STRING          reduce using rule 62 (expression -> value .)
    VAR             reduce using rule 62 (expression -> value .)
    FINAL           reduce using rule 62 (expression -> value .)
    ID              reduce using rule 62 (expression -> value .)
    VOID            reduce using rule 62 (expression -> value .)
    LIST            reduce using rule 62 (expression -> value .)
    DYNAMIC         reduce using rule 62 (expression -> value .)
    INT             reduce using rule 62 (expression -> value .)
    DOUBLE          reduce using rule 62 (expression -> value .)
    MAP             reduce using rule 62 (expression -> value .)
    WHILE           reduce using rule 62 (expression -> value .)
    BOOL            reduce using rule 62 (expression -> value .)
    IF              reduce using rule 62 (expression -> value .)
    FOR             reduce using rule 62 (expression -> value .)
    $end            reduce using rule 62 (expression -> value .)
    RBRACKET        reduce using rule 62 (expression -> value .)
    LBRACKET        reduce using rule 62 (expression -> value .)
    GREATER         shift and go to state 129
    LESS            shift and go to state 130
    EQUALS          shift and go to state 131
    GREATER_EQUAL   shift and go to state 132
    LESS_EQUAL      shift and go to state 133
    NOT_EQUALS      shift and go to state 134

  ! PLUS            [ reduce using rule 62 (expression -> value .) ]
  ! GREATER         [ reduce using rule 62 (expression -> value .) ]
  ! LESS            [ reduce using rule 62 (expression -> value .) ]
  ! EQUALS          [ reduce using rule 62 (expression -> value .) ]
  ! GREATER_EQUAL   [ reduce using rule 62 (expression -> value .) ]
  ! LESS_EQUAL      [ reduce using rule 62 (expression -> value .) ]
  ! NOT_EQUALS      [ reduce using rule 62 (expression -> value .) ]

    comparator                     shift and go to state 127

state 85

    (96) value -> NUMBER .

    PLUS            reduce using rule 96 (value -> NUMBER .)
    GREATER         reduce using rule 96 (value -> NUMBER .)
    LESS            reduce using rule 96 (value -> NUMBER .)
    EQUALS          reduce using rule 96 (value -> NUMBER .)
    GREATER_EQUAL   reduce using rule 96 (value -> NUMBER .)
    LESS_EQUAL      reduce using rule 96 (value -> NUMBER .)
    NOT_EQUALS      reduce using rule 96 (value -> NUMBER .)
    MINUS           reduce using rule 96 (value -> NUMBER .)
    TIMES           reduce using rule 96 (value -> NUMBER .)
    DIVIDE          reduce using rule 96 (value -> NUMBER .)
    AND             reduce using rule 96 (value -> NUMBER .)
    OR              reduce using rule 96 (value -> NUMBER .)
    RPAREN          reduce using rule 96 (value -> NUMBER .)
    COMMA           reduce using rule 96 (value -> NUMBER .)
    RSBRACKET       reduce using rule 96 (value -> NUMBER .)
    SEMICOLON       reduce using rule 96 (value -> NUMBER .)
    PRINT           reduce using rule 96 (value -> NUMBER .)
    STRING          reduce using rule 96 (value -> NUMBER .)
    VAR             reduce using rule 96 (value -> NUMBER .)
    FINAL           reduce using rule 96 (value -> NUMBER .)
    ID              reduce using rule 96 (value -> NUMBER .)
    VOID            reduce using rule 96 (value -> NUMBER .)
    LIST            reduce using rule 96 (value -> NUMBER .)
    DYNAMIC         reduce using rule 96 (value -> NUMBER .)
    INT             reduce using rule 96 (value -> NUMBER .)
    DOUBLE          reduce using rule 96 (value -> NUMBER .)
    MAP             reduce using rule 96 (value -> NUMBER .)
    WHILE           reduce using rule 96 (value -> NUMBER .)
    BOOL            reduce using rule 96 (value -> NUMBER .)
    IF              reduce using rule 96 (value -> NUMBER .)
    FOR             reduce using rule 96 (value -> NUMBER .)
    $end            reduce using rule 96 (value -> NUMBER .)
    RBRACKET        reduce using rule 96 (value -> NUMBER .)
    LBRACKET        reduce using rule 96 (value -> NUMBER .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    condition                      shift and go to state 152
    value                          shift and go to state 118

state 86

<<<<<<< HEAD
    (51) operand -> DOUBLE .

    PLUS            reduce using rule 51 (operand -> DOUBLE .)
    MINUS           reduce using rule 51 (operand -> DOUBLE .)
    TIMES           reduce using rule 51 (operand -> DOUBLE .)
    DIVIDE          reduce using rule 51 (operand -> DOUBLE .)
    NUMBER          reduce using rule 51 (operand -> DOUBLE .)
    DOUBLE          reduce using rule 51 (operand -> DOUBLE .)
    RPAREN          reduce using rule 51 (operand -> DOUBLE .)
    COMMA           reduce using rule 51 (operand -> DOUBLE .)
    SEMICOLON       reduce using rule 51 (operand -> DOUBLE .)
    COMMENT_MULTI   reduce using rule 51 (operand -> DOUBLE .)
    COMMENT_SINGLE  reduce using rule 51 (operand -> DOUBLE .)
    PRINT           reduce using rule 51 (operand -> DOUBLE .)
    STRING          reduce using rule 51 (operand -> DOUBLE .)
    VAR             reduce using rule 51 (operand -> DOUBLE .)
    FINAL           reduce using rule 51 (operand -> DOUBLE .)
    ID              reduce using rule 51 (operand -> DOUBLE .)
    VOID            reduce using rule 51 (operand -> DOUBLE .)
    LIST            reduce using rule 51 (operand -> DOUBLE .)
    DYNAMIC         reduce using rule 51 (operand -> DOUBLE .)
    MAP             reduce using rule 51 (operand -> DOUBLE .)
    WHILE           reduce using rule 51 (operand -> DOUBLE .)
    INT             reduce using rule 51 (operand -> DOUBLE .)
    BOOL            reduce using rule 51 (operand -> DOUBLE .)
    IF              reduce using rule 51 (operand -> DOUBLE .)
    FOR             reduce using rule 51 (operand -> DOUBLE .)
    $end            reduce using rule 51 (operand -> DOUBLE .)
    RBRACKET        reduce using rule 51 (operand -> DOUBLE .)
=======
    (97) value -> NDOUBLE .

    PLUS            reduce using rule 97 (value -> NDOUBLE .)
    GREATER         reduce using rule 97 (value -> NDOUBLE .)
    LESS            reduce using rule 97 (value -> NDOUBLE .)
    EQUALS          reduce using rule 97 (value -> NDOUBLE .)
    GREATER_EQUAL   reduce using rule 97 (value -> NDOUBLE .)
    LESS_EQUAL      reduce using rule 97 (value -> NDOUBLE .)
    NOT_EQUALS      reduce using rule 97 (value -> NDOUBLE .)
    MINUS           reduce using rule 97 (value -> NDOUBLE .)
    TIMES           reduce using rule 97 (value -> NDOUBLE .)
    DIVIDE          reduce using rule 97 (value -> NDOUBLE .)
    AND             reduce using rule 97 (value -> NDOUBLE .)
    OR              reduce using rule 97 (value -> NDOUBLE .)
    RPAREN          reduce using rule 97 (value -> NDOUBLE .)
    COMMA           reduce using rule 97 (value -> NDOUBLE .)
    RSBRACKET       reduce using rule 97 (value -> NDOUBLE .)
    SEMICOLON       reduce using rule 97 (value -> NDOUBLE .)
    PRINT           reduce using rule 97 (value -> NDOUBLE .)
    STRING          reduce using rule 97 (value -> NDOUBLE .)
    VAR             reduce using rule 97 (value -> NDOUBLE .)
    FINAL           reduce using rule 97 (value -> NDOUBLE .)
    ID              reduce using rule 97 (value -> NDOUBLE .)
    VOID            reduce using rule 97 (value -> NDOUBLE .)
    LIST            reduce using rule 97 (value -> NDOUBLE .)
    DYNAMIC         reduce using rule 97 (value -> NDOUBLE .)
    INT             reduce using rule 97 (value -> NDOUBLE .)
    DOUBLE          reduce using rule 97 (value -> NDOUBLE .)
    MAP             reduce using rule 97 (value -> NDOUBLE .)
    WHILE           reduce using rule 97 (value -> NDOUBLE .)
    BOOL            reduce using rule 97 (value -> NDOUBLE .)
    IF              reduce using rule 97 (value -> NDOUBLE .)
    FOR             reduce using rule 97 (value -> NDOUBLE .)
    $end            reduce using rule 97 (value -> NDOUBLE .)
    RBRACKET        reduce using rule 97 (value -> NDOUBLE .)
    LBRACKET        reduce using rule 97 (value -> NDOUBLE .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 87

<<<<<<< HEAD
    (25) data_input -> STRING ID ASSIGN . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    STDIN           shift and go to state 153
=======
    (98) value -> TEXT .
    (103) interpolated_string -> TEXT . PLUS ID
    (104) interpolated_string -> TEXT . PLUS expression

  ! shift/reduce conflict for PLUS resolved as shift
    GREATER         reduce using rule 98 (value -> TEXT .)
    LESS            reduce using rule 98 (value -> TEXT .)
    EQUALS          reduce using rule 98 (value -> TEXT .)
    GREATER_EQUAL   reduce using rule 98 (value -> TEXT .)
    LESS_EQUAL      reduce using rule 98 (value -> TEXT .)
    NOT_EQUALS      reduce using rule 98 (value -> TEXT .)
    MINUS           reduce using rule 98 (value -> TEXT .)
    TIMES           reduce using rule 98 (value -> TEXT .)
    DIVIDE          reduce using rule 98 (value -> TEXT .)
    AND             reduce using rule 98 (value -> TEXT .)
    OR              reduce using rule 98 (value -> TEXT .)
    RPAREN          reduce using rule 98 (value -> TEXT .)
    COMMA           reduce using rule 98 (value -> TEXT .)
    RSBRACKET       reduce using rule 98 (value -> TEXT .)
    SEMICOLON       reduce using rule 98 (value -> TEXT .)
    PRINT           reduce using rule 98 (value -> TEXT .)
    STRING          reduce using rule 98 (value -> TEXT .)
    VAR             reduce using rule 98 (value -> TEXT .)
    FINAL           reduce using rule 98 (value -> TEXT .)
    ID              reduce using rule 98 (value -> TEXT .)
    VOID            reduce using rule 98 (value -> TEXT .)
    LIST            reduce using rule 98 (value -> TEXT .)
    DYNAMIC         reduce using rule 98 (value -> TEXT .)
    INT             reduce using rule 98 (value -> TEXT .)
    DOUBLE          reduce using rule 98 (value -> TEXT .)
    MAP             reduce using rule 98 (value -> TEXT .)
    WHILE           reduce using rule 98 (value -> TEXT .)
    BOOL            reduce using rule 98 (value -> TEXT .)
    IF              reduce using rule 98 (value -> TEXT .)
    FOR             reduce using rule 98 (value -> TEXT .)
    $end            reduce using rule 98 (value -> TEXT .)
    RBRACKET        reduce using rule 98 (value -> TEXT .)
    LBRACKET        reduce using rule 98 (value -> TEXT .)
    PLUS            shift and go to state 149

  ! PLUS            [ reduce using rule 98 (value -> TEXT .) ]
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 88

<<<<<<< HEAD
    (26) data_input -> STRING QUESTION ID . ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    ASSIGN          shift and go to state 154
=======
    (105) set -> VAR ID ASSIGN . LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> VAR ID ASSIGN . LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (36) variable_definition -> VAR ID ASSIGN . expression SEMICOLON
    (54) expression -> . expression PLUS expression
    (55) expression -> . expression MINUS expression
    (56) expression -> . expression TIMES expression
    (57) expression -> . expression DIVIDE expression
    (58) expression -> . expression AND expression
    (59) expression -> . expression OR expression
    (60) expression -> . value comparator value
    (61) expression -> . value PLUS value
    (62) expression -> . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    LBRACKET        shift and go to state 159
    LESS            shift and go to state 160
    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    expression                     shift and go to state 161
    value                          shift and go to state 84
    interpolated_string            shift and go to state 72

state 89

<<<<<<< HEAD
    (97) value -> ID .

    GREATER         reduce using rule 97 (value -> ID .)
    LESS            reduce using rule 97 (value -> ID .)
    EQUALS          reduce using rule 97 (value -> ID .)
    GREATER_EQUAL   reduce using rule 97 (value -> ID .)
    LESS_EQUAL      reduce using rule 97 (value -> ID .)
    NOT_EQUALS      reduce using rule 97 (value -> ID .)
    RPAREN          reduce using rule 97 (value -> ID .)
    COMMA           reduce using rule 97 (value -> ID .)
    SEMICOLON       reduce using rule 97 (value -> ID .)
    RSBRACKET       reduce using rule 97 (value -> ID .)
    AND             reduce using rule 97 (value -> ID .)
    OR              reduce using rule 97 (value -> ID .)
    LBRACKET        reduce using rule 97 (value -> ID .)
    COMMENT_MULTI   reduce using rule 97 (value -> ID .)
    COMMENT_SINGLE  reduce using rule 97 (value -> ID .)
    PRINT           reduce using rule 97 (value -> ID .)
    STRING          reduce using rule 97 (value -> ID .)
    VAR             reduce using rule 97 (value -> ID .)
    FINAL           reduce using rule 97 (value -> ID .)
    ID              reduce using rule 97 (value -> ID .)
    VOID            reduce using rule 97 (value -> ID .)
    LIST            reduce using rule 97 (value -> ID .)
    DYNAMIC         reduce using rule 97 (value -> ID .)
    MAP             reduce using rule 97 (value -> ID .)
    WHILE           reduce using rule 97 (value -> ID .)
    INT             reduce using rule 97 (value -> ID .)
    DOUBLE          reduce using rule 97 (value -> ID .)
    BOOL            reduce using rule 97 (value -> ID .)
    IF              reduce using rule 97 (value -> ID .)
    FOR             reduce using rule 97 (value -> ID .)
    $end            reduce using rule 97 (value -> ID .)
    RBRACKET        reduce using rule 97 (value -> ID .)
    PLUS            reduce using rule 97 (value -> ID .)
=======
    (107) set -> FINAL ID ASSIGN . CONST LBRACKET value_list RBRACKET SEMICOLON

    CONST           shift and go to state 162
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 90

<<<<<<< HEAD
    (123) constructor -> ID LPAREN constructor_parenthesis_content . RPAREN SEMICOLON

    RPAREN          shift and go to state 155
=======
    (133) map_assignment -> LBRACKET map_contents . RBRACKET

    RBRACKET        shift and go to state 163
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 91

<<<<<<< HEAD
    (24) call_function -> ID LPAREN RPAREN .

    COMMENT_MULTI   reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    COMMENT_SINGLE  reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    SEMICOLON       reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    PRINT           reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    STRING          reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    VAR             reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    FINAL           reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    ID              reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    VOID            reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    LIST            reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    DYNAMIC         reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    MAP             reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    WHILE           reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    INT             reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    DOUBLE          reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    BOOL            reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    IF              reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    FOR             reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    $end            reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    RPAREN          reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
    RBRACKET        reduce using rule 24 (call_function -> ID LPAREN RPAREN .)
=======
    (134) map_contents -> map_content .
    (135) map_contents -> map_content . COMMA map_contents

    RBRACKET        reduce using rule 134 (map_contents -> map_content .)
    COMMA           shift and go to state 164
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 92

<<<<<<< HEAD
    (23) call_function -> ID LPAREN argument_list . RPAREN
    (30) argument_list -> argument_list . COMMA expression

    RPAREN          shift and go to state 156
    COMMA           shift and go to state 157


state 93

    (121) constructor_parenthesis_content -> THIS . DOT ID
    (122) constructor_parenthesis_content -> THIS . DOT ID COMMA constructor_parenthesis_content

    DOT             shift and go to state 158


state 94

    (29) argument_list -> expression .

    RPAREN          reduce using rule 29 (argument_list -> expression .)
    COMMA           reduce using rule 29 (argument_list -> expression .)


state 95

    (96) value -> TEXT .

    GREATER         reduce using rule 96 (value -> TEXT .)
    LESS            reduce using rule 96 (value -> TEXT .)
    EQUALS          reduce using rule 96 (value -> TEXT .)
    GREATER_EQUAL   reduce using rule 96 (value -> TEXT .)
    LESS_EQUAL      reduce using rule 96 (value -> TEXT .)
    NOT_EQUALS      reduce using rule 96 (value -> TEXT .)
    RPAREN          reduce using rule 96 (value -> TEXT .)
    COMMA           reduce using rule 96 (value -> TEXT .)
    SEMICOLON       reduce using rule 96 (value -> TEXT .)
    RSBRACKET       reduce using rule 96 (value -> TEXT .)
    AND             reduce using rule 96 (value -> TEXT .)
    OR              reduce using rule 96 (value -> TEXT .)
    LBRACKET        reduce using rule 96 (value -> TEXT .)
    COMMENT_MULTI   reduce using rule 96 (value -> TEXT .)
    COMMENT_SINGLE  reduce using rule 96 (value -> TEXT .)
    PRINT           reduce using rule 96 (value -> TEXT .)
    STRING          reduce using rule 96 (value -> TEXT .)
    VAR             reduce using rule 96 (value -> TEXT .)
    FINAL           reduce using rule 96 (value -> TEXT .)
    ID              reduce using rule 96 (value -> TEXT .)
    VOID            reduce using rule 96 (value -> TEXT .)
    LIST            reduce using rule 96 (value -> TEXT .)
    DYNAMIC         reduce using rule 96 (value -> TEXT .)
    MAP             reduce using rule 96 (value -> TEXT .)
    WHILE           reduce using rule 96 (value -> TEXT .)
    INT             reduce using rule 96 (value -> TEXT .)
    DOUBLE          reduce using rule 96 (value -> TEXT .)
    BOOL            reduce using rule 96 (value -> TEXT .)
    IF              reduce using rule 96 (value -> TEXT .)
    FOR             reduce using rule 96 (value -> TEXT .)
    $end            reduce using rule 96 (value -> TEXT .)
    RBRACKET        reduce using rule 96 (value -> TEXT .)
    PLUS            reduce using rule 96 (value -> TEXT .)


state 96

    (22) variable_usage -> ID ASSIGN value . SEMICOLON

    SEMICOLON       shift and go to state 159
=======
    (136) map_content -> key_value . COLON value

    COLON           shift and go to state 165


state 93

    (137) key_value -> TEXT .

    COLON           reduce using rule 137 (key_value -> TEXT .)


state 94

    (28) function -> type ID LPAREN . parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> type ID LPAREN . RPAREN LBRACKET statement_list RBRACKET
    (129) function -> type ID LPAREN . parameter_list RPAREN ASSIGN GREATER expression
    (83) parameter_list -> . parameter
    (84) parameter_list -> . parameter_list COMMA parameter
    (85) parameter -> . type ID
    (86) parameter -> . REQUIRED type ID
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST

    RPAREN          shift and go to state 168
    REQUIRED        shift and go to state 170
    INT             shift and go to state 99
    DOUBLE          shift and go to state 100
    STRING          shift and go to state 101
    BOOL            shift and go to state 37
    LIST            shift and go to state 97

    type                           shift and go to state 166
    parameter_list                 shift and go to state 167
    parameter                      shift and go to state 169

state 95

    (34) variable_definition -> type ID ASSIGN . expression SEMICOLON
    (54) expression -> . expression PLUS expression
    (55) expression -> . expression MINUS expression
    (56) expression -> . expression TIMES expression
    (57) expression -> . expression DIVIDE expression
    (58) expression -> . expression AND expression
    (59) expression -> . expression OR expression
    (60) expression -> . value comparator value
    (61) expression -> . value PLUS value
    (62) expression -> . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    expression                     shift and go to state 171
    value                          shift and go to state 84
    interpolated_string            shift and go to state 72

state 96

    (29) function -> VOID ID LPAREN . parameter_list RPAREN LBRACKET statement_list RBRACKET
    (31) function -> VOID ID LPAREN . RPAREN LBRACKET statement_list RBRACKET
    (32) function -> VOID ID LPAREN . RPAREN LBRACKET RBRACKET
    (33) function -> VOID ID LPAREN . parameter_list RPAREN LBRACKET RBRACKET
    (83) parameter_list -> . parameter
    (84) parameter_list -> . parameter_list COMMA parameter
    (85) parameter -> . type ID
    (86) parameter -> . REQUIRED type ID
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST

    RPAREN          shift and go to state 173
    REQUIRED        shift and go to state 170
    INT             shift and go to state 99
    DOUBLE          shift and go to state 100
    STRING          shift and go to state 101
    BOOL            shift and go to state 37
    LIST            shift and go to state 97
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    parameter_list                 shift and go to state 172
    parameter                      shift and go to state 169
    type                           shift and go to state 166

state 97

<<<<<<< HEAD
    (94) value -> NUMBER .

    SEMICOLON       reduce using rule 94 (value -> NUMBER .)
    GREATER         reduce using rule 94 (value -> NUMBER .)
    LESS            reduce using rule 94 (value -> NUMBER .)
    EQUALS          reduce using rule 94 (value -> NUMBER .)
    GREATER_EQUAL   reduce using rule 94 (value -> NUMBER .)
    LESS_EQUAL      reduce using rule 94 (value -> NUMBER .)
    NOT_EQUALS      reduce using rule 94 (value -> NUMBER .)
    COMMA           reduce using rule 94 (value -> NUMBER .)
    RSBRACKET       reduce using rule 94 (value -> NUMBER .)
    AND             reduce using rule 94 (value -> NUMBER .)
    OR              reduce using rule 94 (value -> NUMBER .)
    RPAREN          reduce using rule 94 (value -> NUMBER .)
    LBRACKET        reduce using rule 94 (value -> NUMBER .)
    COMMENT_MULTI   reduce using rule 94 (value -> NUMBER .)
    COMMENT_SINGLE  reduce using rule 94 (value -> NUMBER .)
    PRINT           reduce using rule 94 (value -> NUMBER .)
    STRING          reduce using rule 94 (value -> NUMBER .)
    VAR             reduce using rule 94 (value -> NUMBER .)
    FINAL           reduce using rule 94 (value -> NUMBER .)
    ID              reduce using rule 94 (value -> NUMBER .)
    VOID            reduce using rule 94 (value -> NUMBER .)
    LIST            reduce using rule 94 (value -> NUMBER .)
    DYNAMIC         reduce using rule 94 (value -> NUMBER .)
    MAP             reduce using rule 94 (value -> NUMBER .)
    WHILE           reduce using rule 94 (value -> NUMBER .)
    INT             reduce using rule 94 (value -> NUMBER .)
    DOUBLE          reduce using rule 94 (value -> NUMBER .)
    BOOL            reduce using rule 94 (value -> NUMBER .)
    IF              reduce using rule 94 (value -> NUMBER .)
    FOR             reduce using rule 94 (value -> NUMBER .)
    $end            reduce using rule 94 (value -> NUMBER .)
    RBRACKET        reduce using rule 94 (value -> NUMBER .)
    PLUS            reduce using rule 94 (value -> NUMBER .)
=======
    (91) type -> LIST .

    GREATER         reduce using rule 91 (type -> LIST .)
    ID              reduce using rule 91 (type -> LIST .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 98

<<<<<<< HEAD
    (100) set -> VAR ID ASSIGN . LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> VAR ID ASSIGN . LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (39) variable_definition -> VAR ID ASSIGN . expression SEMICOLON
    (46) expression -> . operations
    (56) expression -> . conditions
    (57) expression -> . value
    (47) operations -> . operation
    (48) operations -> . operation operand operations
    (66) conditions -> . condition
    (67) conditions -> . condition AND conditions
    (68) conditions -> . condition OR conditions
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE
    (49) operation -> . operand operator operand
    (69) condition -> . value comparator value
    (70) condition -> . NOT condition
    (50) operand -> . NUMBER
    (51) operand -> . DOUBLE

    LBRACKET        shift and go to state 160
    LESS            shift and go to state 161
    NUMBER          shift and go to state 80
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83
    NOT             shift and go to state 85
    DOUBLE          shift and go to state 86

    expression                     shift and go to state 162
    operations                     shift and go to state 71
    conditions                     shift and go to state 72
    value                          shift and go to state 73
    operation                      shift and go to state 77
    operand                        shift and go to state 78
    condition                      shift and go to state 79

state 99

    (102) set -> FINAL ID ASSIGN . CONST LBRACKET value_list RBRACKET SEMICOLON

    CONST           shift and go to state 163


state 100

    (128) map_assignment -> LBRACKET map_contents . RBRACKET

    RBRACKET        shift and go to state 164


state 101

    (129) map_contents -> map_content .
    (130) map_contents -> map_content . COMMA map_contents

    RBRACKET        reduce using rule 129 (map_contents -> map_content .)
    COMMA           shift and go to state 165


state 102

    (131) map_content -> key_value . COLON value

    COLON           shift and go to state 166


state 103

    (132) key_value -> TEXT .

    COLON           reduce using rule 132 (key_value -> TEXT .)
=======
    (93) list_definition -> LIST LESS type . GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON

    GREATER         shift and go to state 174


state 99

    (87) type -> INT .

    GREATER         reduce using rule 87 (type -> INT .)
    ID              reduce using rule 87 (type -> INT .)


state 100

    (88) type -> DOUBLE .

    GREATER         reduce using rule 88 (type -> DOUBLE .)
    ID              reduce using rule 88 (type -> DOUBLE .)


state 101

    (89) type -> STRING .

    GREATER         reduce using rule 89 (type -> STRING .)
    ID              reduce using rule 89 (type -> STRING .)


state 102

    (35) variable_definition -> DYNAMIC ID ASSIGN . expression SEMICOLON
    (54) expression -> . expression PLUS expression
    (55) expression -> . expression MINUS expression
    (56) expression -> . expression TIMES expression
    (57) expression -> . expression DIVIDE expression
    (58) expression -> . expression AND expression
    (59) expression -> . expression OR expression
    (60) expression -> . value comparator value
    (61) expression -> . value PLUS value
    (62) expression -> . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    expression                     shift and go to state 175
    value                          shift and go to state 84
    interpolated_string            shift and go to state 72

state 103

    (37) variable_definition -> INT ID ASSIGN . length SEMICOLON
    (38) variable_definition -> INT ID ASSIGN . NUMBER SEMICOLON
    (24) length -> . call_list DOT LENGTH
    (25) length -> . TEXT DOT LENGTH
    (92) call_list -> . LSBRACKET value_list RSBRACKET

    NUMBER          shift and go to state 177
    TEXT            shift and go to state 178
    LSBRACKET       shift and go to state 76
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    length                         shift and go to state 176
    call_list                      shift and go to state 75

state 104

<<<<<<< HEAD
    (31) function -> type ID LPAREN . parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> type ID LPAREN . RPAREN LBRACKET statement_list RBRACKET
    (124) function -> type ID LPAREN . parameter_list RPAREN ASSIGN GREATER expression
    (77) parameter_list -> . parameter
    (78) parameter_list -> . parameter_list COMMA parameter
    (79) parameter -> . type ID
    (80) parameter -> . REQUIRED type ID
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST

    RPAREN          shift and go to state 169
    REQUIRED        shift and go to state 171
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    STRING          shift and go to state 109
    BOOL            shift and go to state 39
    LIST            shift and go to state 107

    type                           shift and go to state 167
    parameter_list                 shift and go to state 168
    parameter                      shift and go to state 170

state 105

    (37) variable_definition -> type ID ASSIGN . expression SEMICOLON
    (46) expression -> . operations
    (56) expression -> . conditions
    (57) expression -> . value
    (47) operations -> . operation
    (48) operations -> . operation operand operations
    (66) conditions -> . condition
    (67) conditions -> . condition AND conditions
    (68) conditions -> . condition OR conditions
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE
    (49) operation -> . operand operator operand
    (69) condition -> . value comparator value
    (70) condition -> . NOT condition
    (50) operand -> . NUMBER
    (51) operand -> . DOUBLE

    NUMBER          shift and go to state 80
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83
    NOT             shift and go to state 85
    DOUBLE          shift and go to state 86
=======
    (39) variable_definition -> DOUBLE ID ASSIGN . NDOUBLE SEMICOLON
    (40) variable_definition -> DOUBLE ID ASSIGN . simple_operations_arithmetics SEMICOLON
    (52) simple_operations_arithmetics -> . list_numbers simple_operators_arithmetics list_numbers
    (53) simple_operations_arithmetics -> . list_numbers simple_operators_arithmetics list_numbers simple_operators_arithmetics simple_operations_arithmetics
    (46) list_numbers -> . NUMBER
    (47) list_numbers -> . NDOUBLE

    NDOUBLE         shift and go to state 179
    NUMBER          shift and go to state 181

    simple_operations_arithmetics  shift and go to state 180
    list_numbers                   shift and go to state 67

state 105

    (132) map_declaration -> MAP LESS key_type . COMMA type GREATER ID ASSIGN

    COMMA           shift and go to state 182
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    expression                     shift and go to state 172
    operations                     shift and go to state 71
    conditions                     shift and go to state 72
    value                          shift and go to state 73
    operation                      shift and go to state 77
    operand                        shift and go to state 78
    condition                      shift and go to state 79

state 106

<<<<<<< HEAD
    (32) function -> VOID ID LPAREN . parameter_list RPAREN LBRACKET statement_list RBRACKET
    (34) function -> VOID ID LPAREN . RPAREN LBRACKET statement_list RBRACKET
    (35) function -> VOID ID LPAREN . RPAREN LBRACKET RBRACKET
    (36) function -> VOID ID LPAREN . parameter_list RPAREN LBRACKET RBRACKET
    (77) parameter_list -> . parameter
    (78) parameter_list -> . parameter_list COMMA parameter
    (79) parameter -> . type ID
    (80) parameter -> . REQUIRED type ID
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST

    RPAREN          shift and go to state 174
    REQUIRED        shift and go to state 171
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    STRING          shift and go to state 109
    BOOL            shift and go to state 39
    LIST            shift and go to state 107

    parameter_list                 shift and go to state 173
    parameter                      shift and go to state 170
    type                           shift and go to state 167

state 107

    (93) type -> LIST .

    GREATER         reduce using rule 93 (type -> LIST .)
    ID              reduce using rule 93 (type -> LIST .)
=======
    (138) key_type -> STRING .

    COMMA           reduce using rule 138 (key_type -> STRING .)


state 107

    (65) control_structures_if_else -> if_block else_if_blocks else_block .

    SEMICOLON       reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    PRINT           reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    STRING          reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    VAR             reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    FINAL           reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    ID              reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    VOID            reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    LIST            reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    DYNAMIC         reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    INT             reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    DOUBLE          reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    MAP             reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    WHILE           reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    BOOL            reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    IF              reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    FOR             reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    $end            reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
    RBRACKET        reduce using rule 65 (control_structures_if_else -> if_block else_if_blocks else_block .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 108

<<<<<<< HEAD
    (82) list_definition -> LIST LESS type . GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON

    GREATER         shift and go to state 175
=======
    (69) else_if_blocks -> else_if_blocks ELSE . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (70) else_block -> ELSE . LBRACKET statement_list RBRACKET

    IF              shift and go to state 183
    LBRACKET        shift and go to state 110
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 109

<<<<<<< HEAD
    (91) type -> STRING .

    GREATER         reduce using rule 91 (type -> STRING .)
    ID              reduce using rule 91 (type -> STRING .)
=======
    (68) else_if_blocks -> ELSE IF . LPAREN conditions RPAREN LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 184
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 110

<<<<<<< HEAD
    (38) variable_definition -> DYNAMIC ID ASSIGN . expression SEMICOLON
    (46) expression -> . operations
    (56) expression -> . conditions
    (57) expression -> . value
    (47) operations -> . operation
    (48) operations -> . operation operand operations
    (66) conditions -> . condition
    (67) conditions -> . condition AND conditions
    (68) conditions -> . condition OR conditions
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE
    (49) operation -> . operand operator operand
    (69) condition -> . value comparator value
    (70) condition -> . NOT condition
    (50) operand -> . NUMBER
    (51) operand -> . DOUBLE

    NUMBER          shift and go to state 80
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83
    NOT             shift and go to state 85
    DOUBLE          shift and go to state 86

    expression                     shift and go to state 176
    operations                     shift and go to state 71
    conditions                     shift and go to state 72
    value                          shift and go to state 73
    operation                      shift and go to state 77
    operand                        shift and go to state 78
    condition                      shift and go to state 79

state 111

    (127) map_declaration -> MAP LESS key_type . COMMA type GREATER ID ASSIGN

    COMMA           shift and go to state 177


state 112

    (133) key_type -> STRING .

    COMMA           reduce using rule 133 (key_type -> STRING .)


state 113

    (60) control_structures_if_else -> if_block else_if_blocks else_block .

    COMMENT_MULTI   reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    COMMENT_SINGLE  reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    SEMICOLON       reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    PRINT           reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    STRING          reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    VAR             reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    FINAL           reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    ID              reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    VOID            reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    LIST            reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    DYNAMIC         reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    MAP             reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    WHILE           reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    INT             reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    DOUBLE          reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    BOOL            reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    IF              reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    FOR             reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    $end            reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)
    RBRACKET        reduce using rule 60 (control_structures_if_else -> if_block else_if_blocks else_block .)


state 114

    (64) else_if_blocks -> else_if_blocks ELSE . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (65) else_block -> ELSE . LBRACKET statement_list RBRACKET

    IF              shift and go to state 178
    LBRACKET        shift and go to state 116


state 115

    (63) else_if_blocks -> ELSE IF . LPAREN conditions RPAREN LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 179


state 116

    (65) else_block -> ELSE LBRACKET . statement_list RBRACKET
=======
    (70) else_block -> ELSE LBRACKET . statement_list RBRACKET
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
<<<<<<< HEAD
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
=======
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

<<<<<<< HEAD
    statement_list                 shift and go to state 180
=======
    statement_list                 shift and go to state 185
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

<<<<<<< HEAD
state 117

    (125) control_structures_while -> WHILE LPAREN conditions . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 181
=======
state 111

    (76) condition -> LPAREN . conditions RPAREN
    (71) conditions -> . condition
    (72) conditions -> . conditions AND conditions
    (73) conditions -> . conditions OR conditions
    (74) condition -> . value comparator value
    (75) condition -> . NOT condition
    (76) condition -> . LPAREN conditions RPAREN
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 115
    LPAREN          shift and go to state 111
    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    conditions                     shift and go to state 186
    condition                      shift and go to state 113
    value                          shift and go to state 114
    interpolated_string            shift and go to state 72

state 112

    (130) control_structures_while -> WHILE LPAREN conditions . LBRACKET statement_list RBRACKET
    (72) conditions -> conditions . AND conditions
    (73) conditions -> conditions . OR conditions

    LBRACKET        shift and go to state 187
    AND             shift and go to state 188
    OR              shift and go to state 189


state 113

    (71) conditions -> condition .

    LBRACKET        reduce using rule 71 (conditions -> condition .)
    AND             reduce using rule 71 (conditions -> condition .)
    OR              reduce using rule 71 (conditions -> condition .)
    RPAREN          reduce using rule 71 (conditions -> condition .)
    SEMICOLON       reduce using rule 71 (conditions -> condition .)


state 114

    (74) condition -> value . comparator value
    (77) comparator -> . GREATER
    (78) comparator -> . LESS
    (79) comparator -> . EQUALS
    (80) comparator -> . GREATER_EQUAL
    (81) comparator -> . LESS_EQUAL
    (82) comparator -> . NOT_EQUALS

    GREATER         shift and go to state 129
    LESS            shift and go to state 130
    EQUALS          shift and go to state 131
    GREATER_EQUAL   shift and go to state 132
    LESS_EQUAL      shift and go to state 133
    NOT_EQUALS      shift and go to state 134

    comparator                     shift and go to state 190

state 115

    (75) condition -> NOT . condition
    (74) condition -> . value comparator value
    (75) condition -> . NOT condition
    (76) condition -> . LPAREN conditions RPAREN
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 115
    LPAREN          shift and go to state 111
    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    condition                      shift and go to state 191
    value                          shift and go to state 114
    interpolated_string            shift and go to state 72

state 116

    (67) if_block -> IF LPAREN conditions . RPAREN LBRACKET statement_list RBRACKET
    (72) conditions -> conditions . AND conditions
    (73) conditions -> conditions . OR conditions

    RPAREN          shift and go to state 192
    AND             shift and go to state 188
    OR              shift and go to state 189


state 117

    (116) for_classic -> FOR LPAREN for_classic_parenthesis_content . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 193
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 118

<<<<<<< HEAD
    (69) condition -> value . comparator value
    (71) comparator -> . GREATER
    (72) comparator -> . LESS
    (73) comparator -> . EQUALS
    (74) comparator -> . GREATER_EQUAL
    (75) comparator -> . LESS_EQUAL
    (76) comparator -> . NOT_EQUALS

    GREATER         shift and go to state 131
    LESS            shift and go to state 132
    EQUALS          shift and go to state 133
    GREATER_EQUAL   shift and go to state 134
    LESS_EQUAL      shift and go to state 135
    NOT_EQUALS      shift and go to state 136
=======
    (118) for_in -> FOR LPAREN for_in_parenthesis_content . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 194
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    comparator                     shift and go to state 130

state 119

<<<<<<< HEAD
    (62) if_block -> IF LPAREN conditions . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 182
=======
    (122) for_each -> FOR LPAREN for_each_parenthesis_content . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 195
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 120

<<<<<<< HEAD
    (111) for_classic -> FOR LPAREN for_classic_parenthesis_content . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 183


state 121

    (113) for_in -> FOR LPAREN for_in_parenthesis_content . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 184


state 122

    (117) for_each -> FOR LPAREN for_each_parenthesis_content . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 185


state 123

    (110) for_classic_parenthesis_content -> for_classic_initialization . SEMICOLON for_classic_conditions SEMICOLON for_classic_changes

    SEMICOLON       shift and go to state 186


state 124

    (112) for_in_parenthesis_content -> FINAL . ID IN ID
    (116) for_each_parenthesis_content -> FINAL . ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID

    ID              shift and go to state 187


state 125

    (103) for_classic_initialization -> INT . ID ASSIGN NUMBER

    ID              shift and go to state 188


state 126

    (104) for_classic_initialization -> DOUBLE . ID ASSIGN NDOUBLE

    ID              shift and go to state 189


state 127

    (40) print -> PRINT LPAREN RPAREN SEMICOLON .

    COMMENT_MULTI   reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 40 (print -> PRINT LPAREN RPAREN SEMICOLON .)


state 128

    (41) print -> PRINT LPAREN print_options RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 190
=======
    (115) for_classic_parenthesis_content -> for_classic_initialization . SEMICOLON for_classic_conditions SEMICOLON for_classic_changes

    SEMICOLON       shift and go to state 196


state 121

    (117) for_in_parenthesis_content -> FINAL . ID IN ID
    (121) for_each_parenthesis_content -> FINAL . ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID

    ID              shift and go to state 197


state 122

    (108) for_classic_initialization -> INT . ID ASSIGN NUMBER

    ID              shift and go to state 198


state 123

    (109) for_classic_initialization -> DOUBLE . ID ASSIGN NDOUBLE

    ID              shift and go to state 199


state 124

    (41) print -> PRINT LPAREN RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 41 (print -> PRINT LPAREN RPAREN SEMICOLON .)


state 125

    (42) print -> PRINT LPAREN simple_operations_arithmetics RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 200


state 126

    (43) print -> PRINT LPAREN value RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 201


state 127

    (60) expression -> value comparator . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    value                          shift and go to state 202
    interpolated_string            shift and go to state 72

state 128

    (61) expression -> value PLUS . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    value                          shift and go to state 203
    interpolated_string            shift and go to state 72

state 129

<<<<<<< HEAD
    (86) interpolated_string -> string_part PLUS . interpolated_string
    (85) interpolated_string -> . string_part
    (86) interpolated_string -> . string_part PLUS interpolated_string
    (87) string_part -> . TEXT
    (88) string_part -> . TEXT PLUS value

    TEXT            shift and go to state 192
=======
    (77) comparator -> GREATER .

    NUMBER          reduce using rule 77 (comparator -> GREATER .)
    NDOUBLE         reduce using rule 77 (comparator -> GREATER .)
    TEXT            reduce using rule 77 (comparator -> GREATER .)
    ID              reduce using rule 77 (comparator -> GREATER .)
    TRUE            reduce using rule 77 (comparator -> GREATER .)
    FALSE           reduce using rule 77 (comparator -> GREATER .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    string_part                    shift and go to state 70
    interpolated_string            shift and go to state 191

state 130

<<<<<<< HEAD
    (69) condition -> value comparator . value
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83
=======
    (78) comparator -> LESS .

    NUMBER          reduce using rule 78 (comparator -> LESS .)
    NDOUBLE         reduce using rule 78 (comparator -> LESS .)
    TEXT            reduce using rule 78 (comparator -> LESS .)
    ID              reduce using rule 78 (comparator -> LESS .)
    TRUE            reduce using rule 78 (comparator -> LESS .)
    FALSE           reduce using rule 78 (comparator -> LESS .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    value                          shift and go to state 193

state 131

<<<<<<< HEAD
    (71) comparator -> GREATER .

    NUMBER          reduce using rule 71 (comparator -> GREATER .)
    NDOUBLE         reduce using rule 71 (comparator -> GREATER .)
    TEXT            reduce using rule 71 (comparator -> GREATER .)
    ID              reduce using rule 71 (comparator -> GREATER .)
    TRUE            reduce using rule 71 (comparator -> GREATER .)
    FALSE           reduce using rule 71 (comparator -> GREATER .)
=======
    (79) comparator -> EQUALS .

    NUMBER          reduce using rule 79 (comparator -> EQUALS .)
    NDOUBLE         reduce using rule 79 (comparator -> EQUALS .)
    TEXT            reduce using rule 79 (comparator -> EQUALS .)
    ID              reduce using rule 79 (comparator -> EQUALS .)
    TRUE            reduce using rule 79 (comparator -> EQUALS .)
    FALSE           reduce using rule 79 (comparator -> EQUALS .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 132

<<<<<<< HEAD
    (72) comparator -> LESS .

    NUMBER          reduce using rule 72 (comparator -> LESS .)
    NDOUBLE         reduce using rule 72 (comparator -> LESS .)
    TEXT            reduce using rule 72 (comparator -> LESS .)
    ID              reduce using rule 72 (comparator -> LESS .)
    TRUE            reduce using rule 72 (comparator -> LESS .)
    FALSE           reduce using rule 72 (comparator -> LESS .)
=======
    (80) comparator -> GREATER_EQUAL .

    NUMBER          reduce using rule 80 (comparator -> GREATER_EQUAL .)
    NDOUBLE         reduce using rule 80 (comparator -> GREATER_EQUAL .)
    TEXT            reduce using rule 80 (comparator -> GREATER_EQUAL .)
    ID              reduce using rule 80 (comparator -> GREATER_EQUAL .)
    TRUE            reduce using rule 80 (comparator -> GREATER_EQUAL .)
    FALSE           reduce using rule 80 (comparator -> GREATER_EQUAL .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 133

<<<<<<< HEAD
    (73) comparator -> EQUALS .

    NUMBER          reduce using rule 73 (comparator -> EQUALS .)
    NDOUBLE         reduce using rule 73 (comparator -> EQUALS .)
    TEXT            reduce using rule 73 (comparator -> EQUALS .)
    ID              reduce using rule 73 (comparator -> EQUALS .)
    TRUE            reduce using rule 73 (comparator -> EQUALS .)
    FALSE           reduce using rule 73 (comparator -> EQUALS .)
=======
    (81) comparator -> LESS_EQUAL .

    NUMBER          reduce using rule 81 (comparator -> LESS_EQUAL .)
    NDOUBLE         reduce using rule 81 (comparator -> LESS_EQUAL .)
    TEXT            reduce using rule 81 (comparator -> LESS_EQUAL .)
    ID              reduce using rule 81 (comparator -> LESS_EQUAL .)
    TRUE            reduce using rule 81 (comparator -> LESS_EQUAL .)
    FALSE           reduce using rule 81 (comparator -> LESS_EQUAL .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 134

<<<<<<< HEAD
    (74) comparator -> GREATER_EQUAL .

    NUMBER          reduce using rule 74 (comparator -> GREATER_EQUAL .)
    NDOUBLE         reduce using rule 74 (comparator -> GREATER_EQUAL .)
    TEXT            reduce using rule 74 (comparator -> GREATER_EQUAL .)
    ID              reduce using rule 74 (comparator -> GREATER_EQUAL .)
    TRUE            reduce using rule 74 (comparator -> GREATER_EQUAL .)
    FALSE           reduce using rule 74 (comparator -> GREATER_EQUAL .)
=======
    (82) comparator -> NOT_EQUALS .

    NUMBER          reduce using rule 82 (comparator -> NOT_EQUALS .)
    NDOUBLE         reduce using rule 82 (comparator -> NOT_EQUALS .)
    TEXT            reduce using rule 82 (comparator -> NOT_EQUALS .)
    ID              reduce using rule 82 (comparator -> NOT_EQUALS .)
    TRUE            reduce using rule 82 (comparator -> NOT_EQUALS .)
    FALSE           reduce using rule 82 (comparator -> NOT_EQUALS .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 135

<<<<<<< HEAD
    (75) comparator -> LESS_EQUAL .

    NUMBER          reduce using rule 75 (comparator -> LESS_EQUAL .)
    NDOUBLE         reduce using rule 75 (comparator -> LESS_EQUAL .)
    TEXT            reduce using rule 75 (comparator -> LESS_EQUAL .)
    ID              reduce using rule 75 (comparator -> LESS_EQUAL .)
    TRUE            reduce using rule 75 (comparator -> LESS_EQUAL .)
    FALSE           reduce using rule 75 (comparator -> LESS_EQUAL .)
=======
    (44) print -> PRINT LPAREN expression RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 204
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 136

<<<<<<< HEAD
    (76) comparator -> NOT_EQUALS .

    NUMBER          reduce using rule 76 (comparator -> NOT_EQUALS .)
    NDOUBLE         reduce using rule 76 (comparator -> NOT_EQUALS .)
    TEXT            reduce using rule 76 (comparator -> NOT_EQUALS .)
    ID              reduce using rule 76 (comparator -> NOT_EQUALS .)
    TRUE            reduce using rule 76 (comparator -> NOT_EQUALS .)
    FALSE           reduce using rule 76 (comparator -> NOT_EQUALS .)


state 137

    (27) length -> call_list DOT . LENGTH

    LENGTH          shift and go to state 194
=======
    (54) expression -> expression PLUS . expression
    (54) expression -> . expression PLUS expression
    (55) expression -> . expression MINUS expression
    (56) expression -> . expression TIMES expression
    (57) expression -> . expression DIVIDE expression
    (58) expression -> . expression AND expression
    (59) expression -> . expression OR expression
    (60) expression -> . value comparator value
    (61) expression -> . value PLUS value
    (62) expression -> . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    expression                     shift and go to state 205
    value                          shift and go to state 84
    interpolated_string            shift and go to state 72

state 137

    (55) expression -> expression MINUS . expression
    (54) expression -> . expression PLUS expression
    (55) expression -> . expression MINUS expression
    (56) expression -> . expression TIMES expression
    (57) expression -> . expression DIVIDE expression
    (58) expression -> . expression AND expression
    (59) expression -> . expression OR expression
    (60) expression -> . value comparator value
    (61) expression -> . value PLUS value
    (62) expression -> . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    expression                     shift and go to state 206
    value                          shift and go to state 84
    interpolated_string            shift and go to state 72

state 138

<<<<<<< HEAD
    (28) length -> TEXT DOT . LENGTH

    LENGTH          shift and go to state 195
=======
    (56) expression -> expression TIMES . expression
    (54) expression -> . expression PLUS expression
    (55) expression -> . expression MINUS expression
    (56) expression -> . expression TIMES expression
    (57) expression -> . expression DIVIDE expression
    (58) expression -> . expression AND expression
    (59) expression -> . expression OR expression
    (60) expression -> . value comparator value
    (61) expression -> . value PLUS value
    (62) expression -> . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    expression                     shift and go to state 207
    value                          shift and go to state 84
    interpolated_string            shift and go to state 72

state 139

<<<<<<< HEAD
    (88) string_part -> TEXT PLUS . value
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83

    value                          shift and go to state 196

state 140

    (23) call_function -> ID LPAREN . argument_list RPAREN
    (24) call_function -> ID LPAREN . RPAREN
    (29) argument_list -> . expression
    (30) argument_list -> . argument_list COMMA expression
    (46) expression -> . operations
    (56) expression -> . conditions
    (57) expression -> . value
    (47) operations -> . operation
    (48) operations -> . operation operand operations
    (66) conditions -> . condition
    (67) conditions -> . condition AND conditions
    (68) conditions -> . condition OR conditions
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE
    (49) operation -> . operand operator operand
    (69) condition -> . value comparator value
    (70) condition -> . NOT condition
    (50) operand -> . NUMBER
    (51) operand -> . DOUBLE

    RPAREN          shift and go to state 91
    NUMBER          shift and go to state 80
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83
    NOT             shift and go to state 85
    DOUBLE          shift and go to state 86

    argument_list                  shift and go to state 92
    expression                     shift and go to state 94
    operations                     shift and go to state 71
    conditions                     shift and go to state 72
    value                          shift and go to state 73
    operation                      shift and go to state 77
    operand                        shift and go to state 78
    condition                      shift and go to state 79

state 141

    (48) operations -> operation operand . operations
    (47) operations -> . operation
    (48) operations -> . operation operand operations
    (49) operation -> . operand operator operand
    (50) operand -> . NUMBER
    (51) operand -> . DOUBLE

    NUMBER          shift and go to state 142
    DOUBLE          shift and go to state 86

    operation                      shift and go to state 77
    operand                        shift and go to state 78
    operations                     shift and go to state 197

state 142

    (50) operand -> NUMBER .

    NUMBER          reduce using rule 50 (operand -> NUMBER .)
    DOUBLE          reduce using rule 50 (operand -> NUMBER .)
    PLUS            reduce using rule 50 (operand -> NUMBER .)
    MINUS           reduce using rule 50 (operand -> NUMBER .)
    TIMES           reduce using rule 50 (operand -> NUMBER .)
    DIVIDE          reduce using rule 50 (operand -> NUMBER .)
    RPAREN          reduce using rule 50 (operand -> NUMBER .)
    COMMA           reduce using rule 50 (operand -> NUMBER .)
    SEMICOLON       reduce using rule 50 (operand -> NUMBER .)
    COMMENT_MULTI   reduce using rule 50 (operand -> NUMBER .)
    COMMENT_SINGLE  reduce using rule 50 (operand -> NUMBER .)
    PRINT           reduce using rule 50 (operand -> NUMBER .)
    STRING          reduce using rule 50 (operand -> NUMBER .)
    VAR             reduce using rule 50 (operand -> NUMBER .)
    FINAL           reduce using rule 50 (operand -> NUMBER .)
    ID              reduce using rule 50 (operand -> NUMBER .)
    VOID            reduce using rule 50 (operand -> NUMBER .)
    LIST            reduce using rule 50 (operand -> NUMBER .)
    DYNAMIC         reduce using rule 50 (operand -> NUMBER .)
    MAP             reduce using rule 50 (operand -> NUMBER .)
    WHILE           reduce using rule 50 (operand -> NUMBER .)
    INT             reduce using rule 50 (operand -> NUMBER .)
    BOOL            reduce using rule 50 (operand -> NUMBER .)
    IF              reduce using rule 50 (operand -> NUMBER .)
    FOR             reduce using rule 50 (operand -> NUMBER .)
    $end            reduce using rule 50 (operand -> NUMBER .)
    RBRACKET        reduce using rule 50 (operand -> NUMBER .)
=======
    (57) expression -> expression DIVIDE . expression
    (54) expression -> . expression PLUS expression
    (55) expression -> . expression MINUS expression
    (56) expression -> . expression TIMES expression
    (57) expression -> . expression DIVIDE expression
    (58) expression -> . expression AND expression
    (59) expression -> . expression OR expression
    (60) expression -> . value comparator value
    (61) expression -> . value PLUS value
    (62) expression -> . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    expression                     shift and go to state 208
    value                          shift and go to state 84
    interpolated_string            shift and go to state 72

state 140

    (58) expression -> expression AND . expression
    (54) expression -> . expression PLUS expression
    (55) expression -> . expression MINUS expression
    (56) expression -> . expression TIMES expression
    (57) expression -> . expression DIVIDE expression
    (58) expression -> . expression AND expression
    (59) expression -> . expression OR expression
    (60) expression -> . value comparator value
    (61) expression -> . value PLUS value
    (62) expression -> . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    expression                     shift and go to state 209
    value                          shift and go to state 84
    interpolated_string            shift and go to state 72

state 141

    (59) expression -> expression OR . expression
    (54) expression -> . expression PLUS expression
    (55) expression -> . expression MINUS expression
    (56) expression -> . expression TIMES expression
    (57) expression -> . expression DIVIDE expression
    (58) expression -> . expression AND expression
    (59) expression -> . expression OR expression
    (60) expression -> . value comparator value
    (61) expression -> . value PLUS value
    (62) expression -> . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    expression                     shift and go to state 210
    value                          shift and go to state 84
    interpolated_string            shift and go to state 72

state 142

    (45) print -> PRINT LPAREN length RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 211
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 143

<<<<<<< HEAD
    (49) operation -> operand operator . operand
    (50) operand -> . NUMBER
    (51) operand -> . DOUBLE

    NUMBER          shift and go to state 142
    DOUBLE          shift and go to state 86

    operand                        shift and go to state 198

state 144

    (52) operator -> PLUS .

    NUMBER          reduce using rule 52 (operator -> PLUS .)
    DOUBLE          reduce using rule 52 (operator -> PLUS .)
=======
    (52) simple_operations_arithmetics -> list_numbers simple_operators_arithmetics . list_numbers
    (53) simple_operations_arithmetics -> list_numbers simple_operators_arithmetics . list_numbers simple_operators_arithmetics simple_operations_arithmetics
    (46) list_numbers -> . NUMBER
    (47) list_numbers -> . NDOUBLE

    NUMBER          shift and go to state 181
    NDOUBLE         shift and go to state 213

    list_numbers                   shift and go to state 212

state 144

    (48) simple_operators_arithmetics -> MINUS .

    NUMBER          reduce using rule 48 (simple_operators_arithmetics -> MINUS .)
    NDOUBLE         reduce using rule 48 (simple_operators_arithmetics -> MINUS .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 145

<<<<<<< HEAD
    (53) operator -> MINUS .

    NUMBER          reduce using rule 53 (operator -> MINUS .)
    DOUBLE          reduce using rule 53 (operator -> MINUS .)
=======
    (49) simple_operators_arithmetics -> PLUS .

    NUMBER          reduce using rule 49 (simple_operators_arithmetics -> PLUS .)
    NDOUBLE         reduce using rule 49 (simple_operators_arithmetics -> PLUS .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 146

<<<<<<< HEAD
    (54) operator -> TIMES .
=======
    (50) simple_operators_arithmetics -> DIVIDE .

    NUMBER          reduce using rule 50 (simple_operators_arithmetics -> DIVIDE .)
    NDOUBLE         reduce using rule 50 (simple_operators_arithmetics -> DIVIDE .)


state 147

    (51) simple_operators_arithmetics -> TIMES .

    NUMBER          reduce using rule 51 (simple_operators_arithmetics -> TIMES .)
    NDOUBLE         reduce using rule 51 (simple_operators_arithmetics -> TIMES .)


state 148

    (25) length -> TEXT DOT . LENGTH

    LENGTH          shift and go to state 214


state 149

    (103) interpolated_string -> TEXT PLUS . ID
    (104) interpolated_string -> TEXT PLUS . expression
    (54) expression -> . expression PLUS expression
    (55) expression -> . expression MINUS expression
    (56) expression -> . expression TIMES expression
    (57) expression -> . expression DIVIDE expression
    (58) expression -> . expression AND expression
    (59) expression -> . expression OR expression
    (60) expression -> . value comparator value
    (61) expression -> . value PLUS value
    (62) expression -> . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    ID              shift and go to state 215
    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    expression                     shift and go to state 216
    value                          shift and go to state 84
    interpolated_string            shift and go to state 72

state 150

    (24) length -> call_list DOT . LENGTH

    LENGTH          shift and go to state 217


state 151

    (92) call_list -> LSBRACKET value_list . RSBRACKET
    (95) value_list -> value_list . COMMA value

    RSBRACKET       shift and go to state 218
    COMMA           shift and go to state 219


state 152

    (94) value_list -> value .

    RSBRACKET       reduce using rule 94 (value_list -> value .)
    COMMA           reduce using rule 94 (value_list -> value .)
    RBRACKET        reduce using rule 94 (value_list -> value .)


state 153

    (22) data_input -> STRING ID ASSIGN STDIN . DOT READLINESYNC LPAREN RPAREN SEMICOLON

    DOT             shift and go to state 220


state 154

    (23) data_input -> STRING QUESTION ID ASSIGN . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    STDIN           shift and go to state 221


state 155

    (128) constructor -> ID LPAREN constructor_parenthesis_content RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 222


state 156

    (20) call_function -> ID LPAREN argument_list RPAREN .
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    NUMBER          reduce using rule 54 (operator -> TIMES .)
    DOUBLE          reduce using rule 54 (operator -> TIMES .)


<<<<<<< HEAD
state 147

    (55) operator -> DIVIDE .

    NUMBER          reduce using rule 55 (operator -> DIVIDE .)
    DOUBLE          reduce using rule 55 (operator -> DIVIDE .)


state 148

    (67) conditions -> condition AND . conditions
    (66) conditions -> . condition
    (67) conditions -> . condition AND conditions
    (68) conditions -> . condition OR conditions
    (69) condition -> . value comparator value
    (70) condition -> . NOT condition
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NOT             shift and go to state 85
    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83

    condition                      shift and go to state 79
    conditions                     shift and go to state 199
    value                          shift and go to state 118

state 149

    (68) conditions -> condition OR . conditions
    (66) conditions -> . condition
    (67) conditions -> . condition AND conditions
    (68) conditions -> . condition OR conditions
    (69) condition -> . value comparator value
    (70) condition -> . NOT condition
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NOT             shift and go to state 85
    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83

    condition                      shift and go to state 79
    conditions                     shift and go to state 200
    value                          shift and go to state 118

state 150

    (81) call_list -> LSBRACKET value_list . RSBRACKET

    RSBRACKET       shift and go to state 201


state 151

    (83) value_list -> value .
    (84) value_list -> value . COMMA value_list

    RSBRACKET       reduce using rule 83 (value_list -> value .)
    RBRACKET        reduce using rule 83 (value_list -> value .)
    COMMA           shift and go to state 202


state 152

    (70) condition -> NOT condition .

    AND             reduce using rule 70 (condition -> NOT condition .)
    OR              reduce using rule 70 (condition -> NOT condition .)
    RPAREN          reduce using rule 70 (condition -> NOT condition .)
    COMMA           reduce using rule 70 (condition -> NOT condition .)
    LBRACKET        reduce using rule 70 (condition -> NOT condition .)
    SEMICOLON       reduce using rule 70 (condition -> NOT condition .)
    COMMENT_MULTI   reduce using rule 70 (condition -> NOT condition .)
    COMMENT_SINGLE  reduce using rule 70 (condition -> NOT condition .)
    PRINT           reduce using rule 70 (condition -> NOT condition .)
    STRING          reduce using rule 70 (condition -> NOT condition .)
    VAR             reduce using rule 70 (condition -> NOT condition .)
    FINAL           reduce using rule 70 (condition -> NOT condition .)
    ID              reduce using rule 70 (condition -> NOT condition .)
    VOID            reduce using rule 70 (condition -> NOT condition .)
    LIST            reduce using rule 70 (condition -> NOT condition .)
    DYNAMIC         reduce using rule 70 (condition -> NOT condition .)
    MAP             reduce using rule 70 (condition -> NOT condition .)
    WHILE           reduce using rule 70 (condition -> NOT condition .)
    INT             reduce using rule 70 (condition -> NOT condition .)
    DOUBLE          reduce using rule 70 (condition -> NOT condition .)
    BOOL            reduce using rule 70 (condition -> NOT condition .)
    IF              reduce using rule 70 (condition -> NOT condition .)
    FOR             reduce using rule 70 (condition -> NOT condition .)
    $end            reduce using rule 70 (condition -> NOT condition .)
    RBRACKET        reduce using rule 70 (condition -> NOT condition .)


state 153

    (25) data_input -> STRING ID ASSIGN STDIN . DOT READLINESYNC LPAREN RPAREN SEMICOLON

    DOT             shift and go to state 203


state 154

    (26) data_input -> STRING QUESTION ID ASSIGN . STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON

    STDIN           shift and go to state 204


state 155

    (123) constructor -> ID LPAREN constructor_parenthesis_content RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 205


state 156

    (23) call_function -> ID LPAREN argument_list RPAREN .

    COMMENT_MULTI   reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    COMMENT_SINGLE  reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    SEMICOLON       reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    PRINT           reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    STRING          reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    VAR             reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    FINAL           reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    ID              reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    VOID            reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    LIST            reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    DYNAMIC         reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    MAP             reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    WHILE           reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    INT             reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    DOUBLE          reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    BOOL            reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    IF              reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    FOR             reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    $end            reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    RPAREN          reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)
    RBRACKET        reduce using rule 23 (call_function -> ID LPAREN argument_list RPAREN .)


state 157

    (30) argument_list -> argument_list COMMA . expression
    (46) expression -> . operations
    (56) expression -> . conditions
    (57) expression -> . value
    (47) operations -> . operation
    (48) operations -> . operation operand operations
    (66) conditions -> . condition
    (67) conditions -> . condition AND conditions
    (68) conditions -> . condition OR conditions
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE
    (49) operation -> . operand operator operand
    (69) condition -> . value comparator value
    (70) condition -> . NOT condition
    (50) operand -> . NUMBER
    (51) operand -> . DOUBLE

    NUMBER          shift and go to state 80
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83
    NOT             shift and go to state 85
    DOUBLE          shift and go to state 86

    expression                     shift and go to state 206
    operations                     shift and go to state 71
    conditions                     shift and go to state 72
    value                          shift and go to state 73
    operation                      shift and go to state 77
    operand                        shift and go to state 78
    condition                      shift and go to state 79

state 158

    (121) constructor_parenthesis_content -> THIS DOT . ID
    (122) constructor_parenthesis_content -> THIS DOT . ID COMMA constructor_parenthesis_content

    ID              shift and go to state 207


state 159

    (22) variable_usage -> ID ASSIGN value SEMICOLON .

    COMMENT_MULTI   reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    SEMICOLON       reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    PRINT           reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    STRING          reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    VAR             reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    FINAL           reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    ID              reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    VOID            reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    LIST            reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    DYNAMIC         reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    MAP             reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    WHILE           reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    INT             reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    DOUBLE          reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    BOOL            reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    IF              reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    FOR             reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    $end            reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)
    RBRACKET        reduce using rule 22 (variable_usage -> ID ASSIGN value SEMICOLON .)


state 160

    (100) set -> VAR ID ASSIGN LBRACKET . value_list RBRACKET SEMICOLON
    (83) value_list -> . value
    (84) value_list -> . value COMMA value_list
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83

    value_list                     shift and go to state 208
    value                          shift and go to state 151

state 161

    (101) set -> VAR ID ASSIGN LESS . STRING GREATER LBRACKET RBRACKET SEMICOLON

    STRING          shift and go to state 209


state 162

    (39) variable_definition -> VAR ID ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 210


state 163

    (102) set -> FINAL ID ASSIGN CONST . LBRACKET value_list RBRACKET SEMICOLON

    LBRACKET        shift and go to state 211


state 164

    (128) map_assignment -> LBRACKET map_contents RBRACKET .
=======
state 157

    (27) argument_list -> argument_list COMMA . expression
    (54) expression -> . expression PLUS expression
    (55) expression -> . expression MINUS expression
    (56) expression -> . expression TIMES expression
    (57) expression -> . expression DIVIDE expression
    (58) expression -> . expression AND expression
    (59) expression -> . expression OR expression
    (60) expression -> . value comparator value
    (61) expression -> . value PLUS value
    (62) expression -> . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    expression                     shift and go to state 223
    value                          shift and go to state 84
    interpolated_string            shift and go to state 72

state 158

    (126) constructor_parenthesis_content -> THIS DOT . ID
    (127) constructor_parenthesis_content -> THIS DOT . ID COMMA constructor_parenthesis_content
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    COMMENT_MULTI   reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    COMMENT_SINGLE  reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    SEMICOLON       reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    PRINT           reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    STRING          reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    VAR             reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    FINAL           reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    ID              reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    VOID            reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    LIST            reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    DYNAMIC         reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    MAP             reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    WHILE           reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    INT             reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    DOUBLE          reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    BOOL            reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    IF              reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    FOR             reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    $end            reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)
    RBRACKET        reduce using rule 128 (map_assignment -> LBRACKET map_contents RBRACKET .)


state 159

    (105) set -> VAR ID ASSIGN LBRACKET . value_list RBRACKET SEMICOLON
    (94) value_list -> . value
    (95) value_list -> . value_list COMMA value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    value_list                     shift and go to state 225
    value                          shift and go to state 152
    interpolated_string            shift and go to state 72

state 160

    (106) set -> VAR ID ASSIGN LESS . STRING GREATER LBRACKET RBRACKET SEMICOLON

    STRING          shift and go to state 226


state 161

    (36) variable_definition -> VAR ID ASSIGN expression . SEMICOLON
    (54) expression -> expression . PLUS expression
    (55) expression -> expression . MINUS expression
    (56) expression -> expression . TIMES expression
    (57) expression -> expression . DIVIDE expression
    (58) expression -> expression . AND expression
    (59) expression -> expression . OR expression

    SEMICOLON       shift and go to state 227
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    AND             shift and go to state 140
    OR              shift and go to state 141


state 162

    (107) set -> FINAL ID ASSIGN CONST . LBRACKET value_list RBRACKET SEMICOLON

    LBRACKET        shift and go to state 228


state 163

    (133) map_assignment -> LBRACKET map_contents RBRACKET .

    SEMICOLON       reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    PRINT           reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    STRING          reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    VAR             reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    FINAL           reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    ID              reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    VOID            reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    LIST            reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    DYNAMIC         reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    INT             reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    DOUBLE          reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    MAP             reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    WHILE           reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    BOOL            reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    IF              reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    FOR             reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    $end            reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)
    RBRACKET        reduce using rule 133 (map_assignment -> LBRACKET map_contents RBRACKET .)


state 164

    (135) map_contents -> map_content COMMA . map_contents
    (134) map_contents -> . map_content
    (135) map_contents -> . map_content COMMA map_contents
    (136) map_content -> . key_value COLON value
    (137) key_value -> . TEXT

    TEXT            shift and go to state 93

    map_content                    shift and go to state 91
    map_contents                   shift and go to state 229
    key_value                      shift and go to state 92

state 165

<<<<<<< HEAD
    (130) map_contents -> map_content COMMA . map_contents
    (129) map_contents -> . map_content
    (130) map_contents -> . map_content COMMA map_contents
    (131) map_content -> . key_value COLON value
    (132) key_value -> . TEXT

    TEXT            shift and go to state 103

    map_content                    shift and go to state 101
    map_contents                   shift and go to state 212
    key_value                      shift and go to state 102

state 166

    (131) map_content -> key_value COLON . value
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83
=======
    (136) map_content -> key_value COLON . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    value                          shift and go to state 230
    interpolated_string            shift and go to state 72

state 166

    (85) parameter -> type . ID

    ID              shift and go to state 231
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    value                          shift and go to state 213

state 167

<<<<<<< HEAD
    (79) parameter -> type . ID

    ID              shift and go to state 214
=======
    (28) function -> type ID LPAREN parameter_list . RPAREN LBRACKET statement_list RBRACKET
    (129) function -> type ID LPAREN parameter_list . RPAREN ASSIGN GREATER expression
    (84) parameter_list -> parameter_list . COMMA parameter

    RPAREN          shift and go to state 232
    COMMA           shift and go to state 233
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 168

<<<<<<< HEAD
    (31) function -> type ID LPAREN parameter_list . RPAREN LBRACKET statement_list RBRACKET
    (124) function -> type ID LPAREN parameter_list . RPAREN ASSIGN GREATER expression
    (78) parameter_list -> parameter_list . COMMA parameter

    RPAREN          shift and go to state 215
    COMMA           shift and go to state 216
=======
    (30) function -> type ID LPAREN RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 234
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 169

<<<<<<< HEAD
    (33) function -> type ID LPAREN RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 217
=======
    (83) parameter_list -> parameter .

    RPAREN          reduce using rule 83 (parameter_list -> parameter .)
    COMMA           reduce using rule 83 (parameter_list -> parameter .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 170

<<<<<<< HEAD
    (77) parameter_list -> parameter .

    RPAREN          reduce using rule 77 (parameter_list -> parameter .)
    COMMA           reduce using rule 77 (parameter_list -> parameter .)


state 171

    (80) parameter -> REQUIRED . type ID
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST

    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    STRING          shift and go to state 109
    BOOL            shift and go to state 39
    LIST            shift and go to state 107
=======
    (86) parameter -> REQUIRED . type ID
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST

    INT             shift and go to state 99
    DOUBLE          shift and go to state 100
    STRING          shift and go to state 101
    BOOL            shift and go to state 37
    LIST            shift and go to state 97

    type                           shift and go to state 235

state 171

    (34) variable_definition -> type ID ASSIGN expression . SEMICOLON
    (54) expression -> expression . PLUS expression
    (55) expression -> expression . MINUS expression
    (56) expression -> expression . TIMES expression
    (57) expression -> expression . DIVIDE expression
    (58) expression -> expression . AND expression
    (59) expression -> expression . OR expression

    SEMICOLON       shift and go to state 236
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    AND             shift and go to state 140
    OR              shift and go to state 141
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    type                           shift and go to state 218

state 172

<<<<<<< HEAD
    (37) variable_definition -> type ID ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 219
=======
    (29) function -> VOID ID LPAREN parameter_list . RPAREN LBRACKET statement_list RBRACKET
    (33) function -> VOID ID LPAREN parameter_list . RPAREN LBRACKET RBRACKET
    (84) parameter_list -> parameter_list . COMMA parameter

    RPAREN          shift and go to state 237
    COMMA           shift and go to state 233
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 173

<<<<<<< HEAD
    (32) function -> VOID ID LPAREN parameter_list . RPAREN LBRACKET statement_list RBRACKET
    (36) function -> VOID ID LPAREN parameter_list . RPAREN LBRACKET RBRACKET
    (78) parameter_list -> parameter_list . COMMA parameter

    RPAREN          shift and go to state 220
    COMMA           shift and go to state 216
=======
    (31) function -> VOID ID LPAREN RPAREN . LBRACKET statement_list RBRACKET
    (32) function -> VOID ID LPAREN RPAREN . LBRACKET RBRACKET

    LBRACKET        shift and go to state 238
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 174

<<<<<<< HEAD
    (34) function -> VOID ID LPAREN RPAREN . LBRACKET statement_list RBRACKET
    (35) function -> VOID ID LPAREN RPAREN . LBRACKET RBRACKET

    LBRACKET        shift and go to state 221
=======
    (93) list_definition -> LIST LESS type GREATER . ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON

    ID              shift and go to state 239
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 175

<<<<<<< HEAD
    (82) list_definition -> LIST LESS type GREATER . ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON

    ID              shift and go to state 222
=======
    (35) variable_definition -> DYNAMIC ID ASSIGN expression . SEMICOLON
    (54) expression -> expression . PLUS expression
    (55) expression -> expression . MINUS expression
    (56) expression -> expression . TIMES expression
    (57) expression -> expression . DIVIDE expression
    (58) expression -> expression . AND expression
    (59) expression -> expression . OR expression

    SEMICOLON       shift and go to state 240
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    AND             shift and go to state 140
    OR              shift and go to state 141
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 176

<<<<<<< HEAD
    (38) variable_definition -> DYNAMIC ID ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 223
=======
    (37) variable_definition -> INT ID ASSIGN length . SEMICOLON

    SEMICOLON       shift and go to state 241
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 177

<<<<<<< HEAD
    (127) map_declaration -> MAP LESS key_type COMMA . type GREATER ID ASSIGN
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST

    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    STRING          shift and go to state 109
    BOOL            shift and go to state 39
    LIST            shift and go to state 107

    type                           shift and go to state 224

state 178

    (64) else_if_blocks -> else_if_blocks ELSE IF . LPAREN conditions RPAREN LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 225
=======
    (38) variable_definition -> INT ID ASSIGN NUMBER . SEMICOLON

    SEMICOLON       shift and go to state 242


state 178

    (25) length -> TEXT . DOT LENGTH

    DOT             shift and go to state 148
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 179

<<<<<<< HEAD
    (63) else_if_blocks -> ELSE IF LPAREN . conditions RPAREN LBRACKET statement_list RBRACKET
    (66) conditions -> . condition
    (67) conditions -> . condition AND conditions
    (68) conditions -> . condition OR conditions
    (69) condition -> . value comparator value
    (70) condition -> . NOT condition
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NOT             shift and go to state 85
    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83

    conditions                     shift and go to state 226
    condition                      shift and go to state 79
    value                          shift and go to state 118

state 180

    (65) else_block -> ELSE LBRACKET statement_list . RBRACKET
=======
    (39) variable_definition -> DOUBLE ID ASSIGN NDOUBLE . SEMICOLON
    (47) list_numbers -> NDOUBLE .

    SEMICOLON       shift and go to state 243
    MINUS           reduce using rule 47 (list_numbers -> NDOUBLE .)
    PLUS            reduce using rule 47 (list_numbers -> NDOUBLE .)
    DIVIDE          reduce using rule 47 (list_numbers -> NDOUBLE .)
    TIMES           reduce using rule 47 (list_numbers -> NDOUBLE .)


state 180

    (40) variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics . SEMICOLON

    SEMICOLON       shift and go to state 244


state 181

    (46) list_numbers -> NUMBER .

    MINUS           reduce using rule 46 (list_numbers -> NUMBER .)
    PLUS            reduce using rule 46 (list_numbers -> NUMBER .)
    DIVIDE          reduce using rule 46 (list_numbers -> NUMBER .)
    TIMES           reduce using rule 46 (list_numbers -> NUMBER .)
    RPAREN          reduce using rule 46 (list_numbers -> NUMBER .)
    SEMICOLON       reduce using rule 46 (list_numbers -> NUMBER .)


state 182

    (132) map_declaration -> MAP LESS key_type COMMA . type GREATER ID ASSIGN
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST

    INT             shift and go to state 99
    DOUBLE          shift and go to state 100
    STRING          shift and go to state 101
    BOOL            shift and go to state 37
    LIST            shift and go to state 97

    type                           shift and go to state 245

state 183

    (69) else_if_blocks -> else_if_blocks ELSE IF . LPAREN conditions RPAREN LBRACKET statement_list RBRACKET

    LPAREN          shift and go to state 246


state 184

    (68) else_if_blocks -> ELSE IF LPAREN . conditions RPAREN LBRACKET statement_list RBRACKET
    (71) conditions -> . condition
    (72) conditions -> . conditions AND conditions
    (73) conditions -> . conditions OR conditions
    (74) condition -> . value comparator value
    (75) condition -> . NOT condition
    (76) condition -> . LPAREN conditions RPAREN
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 115
    LPAREN          shift and go to state 111
    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    conditions                     shift and go to state 247
    condition                      shift and go to state 113
    value                          shift and go to state 114
    interpolated_string            shift and go to state 72

state 185

    (70) else_block -> ELSE LBRACKET statement_list . RBRACKET
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
<<<<<<< HEAD
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 227
    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
=======
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 248
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement                      shift and go to state 42
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

<<<<<<< HEAD
state 181

    (125) control_structures_while -> WHILE LPAREN conditions LBRACKET . statement_list RBRACKET
=======
state 186

    (76) condition -> LPAREN conditions . RPAREN
    (72) conditions -> conditions . AND conditions
    (73) conditions -> conditions . OR conditions

    RPAREN          shift and go to state 249
    AND             shift and go to state 188
    OR              shift and go to state 189


state 187

    (130) control_structures_while -> WHILE LPAREN conditions LBRACKET . statement_list RBRACKET
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
<<<<<<< HEAD
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
=======
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

<<<<<<< HEAD
    statement_list                 shift and go to state 228
=======
    statement_list                 shift and go to state 250
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

<<<<<<< HEAD
state 182

    (62) if_block -> IF LPAREN conditions RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 229


state 183

    (111) for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 230


state 184

    (113) for_in -> FOR LPAREN for_in_parenthesis_content RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 231


state 185

    (117) for_each -> FOR LPAREN for_each_parenthesis_content RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 232


state 186

    (110) for_classic_parenthesis_content -> for_classic_initialization SEMICOLON . for_classic_conditions SEMICOLON for_classic_changes
    (105) for_classic_conditions -> . conditions
    (66) conditions -> . condition
    (67) conditions -> . condition AND conditions
    (68) conditions -> . condition OR conditions
    (69) condition -> . value comparator value
    (70) condition -> . NOT condition
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NOT             shift and go to state 85
    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83

    for_classic_conditions         shift and go to state 233
    conditions                     shift and go to state 234
    condition                      shift and go to state 79
    value                          shift and go to state 118

state 187

    (112) for_in_parenthesis_content -> FINAL ID . IN ID
    (116) for_each_parenthesis_content -> FINAL ID . LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID

    IN              shift and go to state 235
    LPAREN          shift and go to state 236


state 188

    (103) for_classic_initialization -> INT ID . ASSIGN NUMBER

    ASSIGN          shift and go to state 237
=======
state 188

    (72) conditions -> conditions AND . conditions
    (71) conditions -> . condition
    (72) conditions -> . conditions AND conditions
    (73) conditions -> . conditions OR conditions
    (74) condition -> . value comparator value
    (75) condition -> . NOT condition
    (76) condition -> . LPAREN conditions RPAREN
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 115
    LPAREN          shift and go to state 111
    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    conditions                     shift and go to state 251
    condition                      shift and go to state 113
    value                          shift and go to state 114
    interpolated_string            shift and go to state 72

state 189

<<<<<<< HEAD
    (104) for_classic_initialization -> DOUBLE ID . ASSIGN NDOUBLE

    ASSIGN          shift and go to state 238
=======
    (73) conditions -> conditions OR . conditions
    (71) conditions -> . condition
    (72) conditions -> . conditions AND conditions
    (73) conditions -> . conditions OR conditions
    (74) condition -> . value comparator value
    (75) condition -> . NOT condition
    (76) condition -> . LPAREN conditions RPAREN
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 115
    LPAREN          shift and go to state 111
    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    conditions                     shift and go to state 252
    condition                      shift and go to state 113
    value                          shift and go to state 114
    interpolated_string            shift and go to state 72

state 190

<<<<<<< HEAD
    (41) print -> PRINT LPAREN print_options RPAREN SEMICOLON .

    COMMENT_MULTI   reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    PRINT           reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    STRING          reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    VAR             reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    FINAL           reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    ID              reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    VOID            reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    LIST            reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    MAP             reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    WHILE           reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    INT             reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    BOOL            reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    IF              reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    FOR             reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    $end            reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 41 (print -> PRINT LPAREN print_options RPAREN SEMICOLON .)
=======
    (74) condition -> value comparator . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    value                          shift and go to state 253
    interpolated_string            shift and go to state 72

state 191

<<<<<<< HEAD
    (86) interpolated_string -> string_part PLUS interpolated_string .

    RPAREN          reduce using rule 86 (interpolated_string -> string_part PLUS interpolated_string .)
=======
    (75) condition -> NOT condition .

    LBRACKET        reduce using rule 75 (condition -> NOT condition .)
    AND             reduce using rule 75 (condition -> NOT condition .)
    OR              reduce using rule 75 (condition -> NOT condition .)
    RPAREN          reduce using rule 75 (condition -> NOT condition .)
    SEMICOLON       reduce using rule 75 (condition -> NOT condition .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 192

<<<<<<< HEAD
    (87) string_part -> TEXT .
    (88) string_part -> TEXT . PLUS value

  ! shift/reduce conflict for PLUS resolved as shift
    RPAREN          reduce using rule 87 (string_part -> TEXT .)
    PLUS            shift and go to state 139

  ! PLUS            [ reduce using rule 87 (string_part -> TEXT .) ]
=======
    (67) if_block -> IF LPAREN conditions RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 254
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 193

<<<<<<< HEAD
    (69) condition -> value comparator value .

    AND             reduce using rule 69 (condition -> value comparator value .)
    OR              reduce using rule 69 (condition -> value comparator value .)
    RPAREN          reduce using rule 69 (condition -> value comparator value .)
    COMMA           reduce using rule 69 (condition -> value comparator value .)
    LBRACKET        reduce using rule 69 (condition -> value comparator value .)
    SEMICOLON       reduce using rule 69 (condition -> value comparator value .)
    COMMENT_MULTI   reduce using rule 69 (condition -> value comparator value .)
    COMMENT_SINGLE  reduce using rule 69 (condition -> value comparator value .)
    PRINT           reduce using rule 69 (condition -> value comparator value .)
    STRING          reduce using rule 69 (condition -> value comparator value .)
    VAR             reduce using rule 69 (condition -> value comparator value .)
    FINAL           reduce using rule 69 (condition -> value comparator value .)
    ID              reduce using rule 69 (condition -> value comparator value .)
    VOID            reduce using rule 69 (condition -> value comparator value .)
    LIST            reduce using rule 69 (condition -> value comparator value .)
    DYNAMIC         reduce using rule 69 (condition -> value comparator value .)
    MAP             reduce using rule 69 (condition -> value comparator value .)
    WHILE           reduce using rule 69 (condition -> value comparator value .)
    INT             reduce using rule 69 (condition -> value comparator value .)
    DOUBLE          reduce using rule 69 (condition -> value comparator value .)
    BOOL            reduce using rule 69 (condition -> value comparator value .)
    IF              reduce using rule 69 (condition -> value comparator value .)
    FOR             reduce using rule 69 (condition -> value comparator value .)
    $end            reduce using rule 69 (condition -> value comparator value .)
    RBRACKET        reduce using rule 69 (condition -> value comparator value .)
=======
    (116) for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 255
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 194

<<<<<<< HEAD
    (27) length -> call_list DOT LENGTH .

    RPAREN          reduce using rule 27 (length -> call_list DOT LENGTH .)
=======
    (118) for_in -> FOR LPAREN for_in_parenthesis_content RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 256
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 195

<<<<<<< HEAD
    (28) length -> TEXT DOT LENGTH .

    RPAREN          reduce using rule 28 (length -> TEXT DOT LENGTH .)
=======
    (122) for_each -> FOR LPAREN for_each_parenthesis_content RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 257
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 196

<<<<<<< HEAD
    (88) string_part -> TEXT PLUS value .

    PLUS            reduce using rule 88 (string_part -> TEXT PLUS value .)
    RPAREN          reduce using rule 88 (string_part -> TEXT PLUS value .)
=======
    (115) for_classic_parenthesis_content -> for_classic_initialization SEMICOLON . for_classic_conditions SEMICOLON for_classic_changes
    (110) for_classic_conditions -> . conditions
    (71) conditions -> . condition
    (72) conditions -> . conditions AND conditions
    (73) conditions -> . conditions OR conditions
    (74) condition -> . value comparator value
    (75) condition -> . NOT condition
    (76) condition -> . LPAREN conditions RPAREN
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 115
    LPAREN          shift and go to state 111
    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    for_classic_conditions         shift and go to state 258
    conditions                     shift and go to state 259
    condition                      shift and go to state 113
    value                          shift and go to state 114
    interpolated_string            shift and go to state 72

state 197

<<<<<<< HEAD
    (48) operations -> operation operand operations .

    RPAREN          reduce using rule 48 (operations -> operation operand operations .)
    COMMA           reduce using rule 48 (operations -> operation operand operations .)
    SEMICOLON       reduce using rule 48 (operations -> operation operand operations .)
    COMMENT_MULTI   reduce using rule 48 (operations -> operation operand operations .)
    COMMENT_SINGLE  reduce using rule 48 (operations -> operation operand operations .)
    PRINT           reduce using rule 48 (operations -> operation operand operations .)
    STRING          reduce using rule 48 (operations -> operation operand operations .)
    VAR             reduce using rule 48 (operations -> operation operand operations .)
    FINAL           reduce using rule 48 (operations -> operation operand operations .)
    ID              reduce using rule 48 (operations -> operation operand operations .)
    VOID            reduce using rule 48 (operations -> operation operand operations .)
    LIST            reduce using rule 48 (operations -> operation operand operations .)
    DYNAMIC         reduce using rule 48 (operations -> operation operand operations .)
    MAP             reduce using rule 48 (operations -> operation operand operations .)
    WHILE           reduce using rule 48 (operations -> operation operand operations .)
    INT             reduce using rule 48 (operations -> operation operand operations .)
    DOUBLE          reduce using rule 48 (operations -> operation operand operations .)
    BOOL            reduce using rule 48 (operations -> operation operand operations .)
    IF              reduce using rule 48 (operations -> operation operand operations .)
    FOR             reduce using rule 48 (operations -> operation operand operations .)
    $end            reduce using rule 48 (operations -> operation operand operations .)
    RBRACKET        reduce using rule 48 (operations -> operation operand operations .)
=======
    (117) for_in_parenthesis_content -> FINAL ID . IN ID
    (121) for_each_parenthesis_content -> FINAL ID . LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID

    IN              shift and go to state 260
    LPAREN          shift and go to state 261
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 198

<<<<<<< HEAD
    (49) operation -> operand operator operand .

    NUMBER          reduce using rule 49 (operation -> operand operator operand .)
    DOUBLE          reduce using rule 49 (operation -> operand operator operand .)
    RPAREN          reduce using rule 49 (operation -> operand operator operand .)
    COMMA           reduce using rule 49 (operation -> operand operator operand .)
    SEMICOLON       reduce using rule 49 (operation -> operand operator operand .)
    COMMENT_MULTI   reduce using rule 49 (operation -> operand operator operand .)
    COMMENT_SINGLE  reduce using rule 49 (operation -> operand operator operand .)
    PRINT           reduce using rule 49 (operation -> operand operator operand .)
    STRING          reduce using rule 49 (operation -> operand operator operand .)
    VAR             reduce using rule 49 (operation -> operand operator operand .)
    FINAL           reduce using rule 49 (operation -> operand operator operand .)
    ID              reduce using rule 49 (operation -> operand operator operand .)
    VOID            reduce using rule 49 (operation -> operand operator operand .)
    LIST            reduce using rule 49 (operation -> operand operator operand .)
    DYNAMIC         reduce using rule 49 (operation -> operand operator operand .)
    MAP             reduce using rule 49 (operation -> operand operator operand .)
    WHILE           reduce using rule 49 (operation -> operand operator operand .)
    INT             reduce using rule 49 (operation -> operand operator operand .)
    BOOL            reduce using rule 49 (operation -> operand operator operand .)
    IF              reduce using rule 49 (operation -> operand operator operand .)
    FOR             reduce using rule 49 (operation -> operand operator operand .)
    $end            reduce using rule 49 (operation -> operand operator operand .)
    RBRACKET        reduce using rule 49 (operation -> operand operator operand .)
=======
    (108) for_classic_initialization -> INT ID . ASSIGN NUMBER

    ASSIGN          shift and go to state 262
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 199

<<<<<<< HEAD
    (67) conditions -> condition AND conditions .
=======
    (109) for_classic_initialization -> DOUBLE ID . ASSIGN NDOUBLE

    ASSIGN          shift and go to state 263


state 200

    (42) print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    PRINT           reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    STRING          reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    VAR             reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    FINAL           reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    ID              reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    VOID            reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    LIST            reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    INT             reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    MAP             reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    WHILE           reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    BOOL            reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    IF              reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    FOR             reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    $end            reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 42 (print -> PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON .)


state 201

    (43) print -> PRINT LPAREN value RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    PRINT           reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    STRING          reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    VAR             reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    FINAL           reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    ID              reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    VOID            reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    LIST            reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    INT             reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    MAP             reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    WHILE           reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    BOOL            reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    IF              reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    FOR             reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    $end            reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 43 (print -> PRINT LPAREN value RPAREN SEMICOLON .)


state 202

    (60) expression -> value comparator value .

    RPAREN          reduce using rule 60 (expression -> value comparator value .)
    PLUS            reduce using rule 60 (expression -> value comparator value .)
    MINUS           reduce using rule 60 (expression -> value comparator value .)
    TIMES           reduce using rule 60 (expression -> value comparator value .)
    DIVIDE          reduce using rule 60 (expression -> value comparator value .)
    AND             reduce using rule 60 (expression -> value comparator value .)
    OR              reduce using rule 60 (expression -> value comparator value .)
    COMMA           reduce using rule 60 (expression -> value comparator value .)
    SEMICOLON       reduce using rule 60 (expression -> value comparator value .)
    GREATER         reduce using rule 60 (expression -> value comparator value .)
    LESS            reduce using rule 60 (expression -> value comparator value .)
    EQUALS          reduce using rule 60 (expression -> value comparator value .)
    GREATER_EQUAL   reduce using rule 60 (expression -> value comparator value .)
    LESS_EQUAL      reduce using rule 60 (expression -> value comparator value .)
    NOT_EQUALS      reduce using rule 60 (expression -> value comparator value .)
    RSBRACKET       reduce using rule 60 (expression -> value comparator value .)
    PRINT           reduce using rule 60 (expression -> value comparator value .)
    STRING          reduce using rule 60 (expression -> value comparator value .)
    VAR             reduce using rule 60 (expression -> value comparator value .)
    FINAL           reduce using rule 60 (expression -> value comparator value .)
    ID              reduce using rule 60 (expression -> value comparator value .)
    VOID            reduce using rule 60 (expression -> value comparator value .)
    LIST            reduce using rule 60 (expression -> value comparator value .)
    DYNAMIC         reduce using rule 60 (expression -> value comparator value .)
    INT             reduce using rule 60 (expression -> value comparator value .)
    DOUBLE          reduce using rule 60 (expression -> value comparator value .)
    MAP             reduce using rule 60 (expression -> value comparator value .)
    WHILE           reduce using rule 60 (expression -> value comparator value .)
    BOOL            reduce using rule 60 (expression -> value comparator value .)
    IF              reduce using rule 60 (expression -> value comparator value .)
    FOR             reduce using rule 60 (expression -> value comparator value .)
    $end            reduce using rule 60 (expression -> value comparator value .)
    RBRACKET        reduce using rule 60 (expression -> value comparator value .)
    LBRACKET        reduce using rule 60 (expression -> value comparator value .)


state 203

    (61) expression -> value PLUS value .

    RPAREN          reduce using rule 61 (expression -> value PLUS value .)
    PLUS            reduce using rule 61 (expression -> value PLUS value .)
    MINUS           reduce using rule 61 (expression -> value PLUS value .)
    TIMES           reduce using rule 61 (expression -> value PLUS value .)
    DIVIDE          reduce using rule 61 (expression -> value PLUS value .)
    AND             reduce using rule 61 (expression -> value PLUS value .)
    OR              reduce using rule 61 (expression -> value PLUS value .)
    COMMA           reduce using rule 61 (expression -> value PLUS value .)
    SEMICOLON       reduce using rule 61 (expression -> value PLUS value .)
    GREATER         reduce using rule 61 (expression -> value PLUS value .)
    LESS            reduce using rule 61 (expression -> value PLUS value .)
    EQUALS          reduce using rule 61 (expression -> value PLUS value .)
    GREATER_EQUAL   reduce using rule 61 (expression -> value PLUS value .)
    LESS_EQUAL      reduce using rule 61 (expression -> value PLUS value .)
    NOT_EQUALS      reduce using rule 61 (expression -> value PLUS value .)
    RSBRACKET       reduce using rule 61 (expression -> value PLUS value .)
    PRINT           reduce using rule 61 (expression -> value PLUS value .)
    STRING          reduce using rule 61 (expression -> value PLUS value .)
    VAR             reduce using rule 61 (expression -> value PLUS value .)
    FINAL           reduce using rule 61 (expression -> value PLUS value .)
    ID              reduce using rule 61 (expression -> value PLUS value .)
    VOID            reduce using rule 61 (expression -> value PLUS value .)
    LIST            reduce using rule 61 (expression -> value PLUS value .)
    DYNAMIC         reduce using rule 61 (expression -> value PLUS value .)
    INT             reduce using rule 61 (expression -> value PLUS value .)
    DOUBLE          reduce using rule 61 (expression -> value PLUS value .)
    MAP             reduce using rule 61 (expression -> value PLUS value .)
    WHILE           reduce using rule 61 (expression -> value PLUS value .)
    BOOL            reduce using rule 61 (expression -> value PLUS value .)
    IF              reduce using rule 61 (expression -> value PLUS value .)
    FOR             reduce using rule 61 (expression -> value PLUS value .)
    $end            reduce using rule 61 (expression -> value PLUS value .)
    RBRACKET        reduce using rule 61 (expression -> value PLUS value .)
    LBRACKET        reduce using rule 61 (expression -> value PLUS value .)


state 204

    (44) print -> PRINT LPAREN expression RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    PRINT           reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    STRING          reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    VAR             reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FINAL           reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    ID              reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    VOID            reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LIST            reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    INT             reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    MAP             reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    WHILE           reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    BOOL            reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    IF              reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FOR             reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    $end            reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 44 (print -> PRINT LPAREN expression RPAREN SEMICOLON .)


state 205

    (54) expression -> expression PLUS expression .
    (54) expression -> expression . PLUS expression
    (55) expression -> expression . MINUS expression
    (56) expression -> expression . TIMES expression
    (57) expression -> expression . DIVIDE expression
    (58) expression -> expression . AND expression
    (59) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 54 (expression -> expression PLUS expression .)
    COMMA           reduce using rule 54 (expression -> expression PLUS expression .)
    SEMICOLON       reduce using rule 54 (expression -> expression PLUS expression .)
    GREATER         reduce using rule 54 (expression -> expression PLUS expression .)
    LESS            reduce using rule 54 (expression -> expression PLUS expression .)
    EQUALS          reduce using rule 54 (expression -> expression PLUS expression .)
    GREATER_EQUAL   reduce using rule 54 (expression -> expression PLUS expression .)
    LESS_EQUAL      reduce using rule 54 (expression -> expression PLUS expression .)
    NOT_EQUALS      reduce using rule 54 (expression -> expression PLUS expression .)
    RSBRACKET       reduce using rule 54 (expression -> expression PLUS expression .)
    PRINT           reduce using rule 54 (expression -> expression PLUS expression .)
    STRING          reduce using rule 54 (expression -> expression PLUS expression .)
    VAR             reduce using rule 54 (expression -> expression PLUS expression .)
    FINAL           reduce using rule 54 (expression -> expression PLUS expression .)
    ID              reduce using rule 54 (expression -> expression PLUS expression .)
    VOID            reduce using rule 54 (expression -> expression PLUS expression .)
    LIST            reduce using rule 54 (expression -> expression PLUS expression .)
    DYNAMIC         reduce using rule 54 (expression -> expression PLUS expression .)
    INT             reduce using rule 54 (expression -> expression PLUS expression .)
    DOUBLE          reduce using rule 54 (expression -> expression PLUS expression .)
    MAP             reduce using rule 54 (expression -> expression PLUS expression .)
    WHILE           reduce using rule 54 (expression -> expression PLUS expression .)
    BOOL            reduce using rule 54 (expression -> expression PLUS expression .)
    IF              reduce using rule 54 (expression -> expression PLUS expression .)
    FOR             reduce using rule 54 (expression -> expression PLUS expression .)
    $end            reduce using rule 54 (expression -> expression PLUS expression .)
    RBRACKET        reduce using rule 54 (expression -> expression PLUS expression .)
    LBRACKET        reduce using rule 54 (expression -> expression PLUS expression .)
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    AND             shift and go to state 140
    OR              shift and go to state 141

  ! PLUS            [ reduce using rule 54 (expression -> expression PLUS expression .) ]
  ! MINUS           [ reduce using rule 54 (expression -> expression PLUS expression .) ]
  ! TIMES           [ reduce using rule 54 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 54 (expression -> expression PLUS expression .) ]
  ! AND             [ reduce using rule 54 (expression -> expression PLUS expression .) ]
  ! OR              [ reduce using rule 54 (expression -> expression PLUS expression .) ]


state 206

    (55) expression -> expression MINUS expression .
    (54) expression -> expression . PLUS expression
    (55) expression -> expression . MINUS expression
    (56) expression -> expression . TIMES expression
    (57) expression -> expression . DIVIDE expression
    (58) expression -> expression . AND expression
    (59) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 55 (expression -> expression MINUS expression .)
    COMMA           reduce using rule 55 (expression -> expression MINUS expression .)
    SEMICOLON       reduce using rule 55 (expression -> expression MINUS expression .)
    GREATER         reduce using rule 55 (expression -> expression MINUS expression .)
    LESS            reduce using rule 55 (expression -> expression MINUS expression .)
    EQUALS          reduce using rule 55 (expression -> expression MINUS expression .)
    GREATER_EQUAL   reduce using rule 55 (expression -> expression MINUS expression .)
    LESS_EQUAL      reduce using rule 55 (expression -> expression MINUS expression .)
    NOT_EQUALS      reduce using rule 55 (expression -> expression MINUS expression .)
    RSBRACKET       reduce using rule 55 (expression -> expression MINUS expression .)
    PRINT           reduce using rule 55 (expression -> expression MINUS expression .)
    STRING          reduce using rule 55 (expression -> expression MINUS expression .)
    VAR             reduce using rule 55 (expression -> expression MINUS expression .)
    FINAL           reduce using rule 55 (expression -> expression MINUS expression .)
    ID              reduce using rule 55 (expression -> expression MINUS expression .)
    VOID            reduce using rule 55 (expression -> expression MINUS expression .)
    LIST            reduce using rule 55 (expression -> expression MINUS expression .)
    DYNAMIC         reduce using rule 55 (expression -> expression MINUS expression .)
    INT             reduce using rule 55 (expression -> expression MINUS expression .)
    DOUBLE          reduce using rule 55 (expression -> expression MINUS expression .)
    MAP             reduce using rule 55 (expression -> expression MINUS expression .)
    WHILE           reduce using rule 55 (expression -> expression MINUS expression .)
    BOOL            reduce using rule 55 (expression -> expression MINUS expression .)
    IF              reduce using rule 55 (expression -> expression MINUS expression .)
    FOR             reduce using rule 55 (expression -> expression MINUS expression .)
    $end            reduce using rule 55 (expression -> expression MINUS expression .)
    RBRACKET        reduce using rule 55 (expression -> expression MINUS expression .)
    LBRACKET        reduce using rule 55 (expression -> expression MINUS expression .)
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    AND             shift and go to state 140
    OR              shift and go to state 141

  ! PLUS            [ reduce using rule 55 (expression -> expression MINUS expression .) ]
  ! MINUS           [ reduce using rule 55 (expression -> expression MINUS expression .) ]
  ! TIMES           [ reduce using rule 55 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 55 (expression -> expression MINUS expression .) ]
  ! AND             [ reduce using rule 55 (expression -> expression MINUS expression .) ]
  ! OR              [ reduce using rule 55 (expression -> expression MINUS expression .) ]


state 207

    (56) expression -> expression TIMES expression .
    (54) expression -> expression . PLUS expression
    (55) expression -> expression . MINUS expression
    (56) expression -> expression . TIMES expression
    (57) expression -> expression . DIVIDE expression
    (58) expression -> expression . AND expression
    (59) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 56 (expression -> expression TIMES expression .)
    COMMA           reduce using rule 56 (expression -> expression TIMES expression .)
    SEMICOLON       reduce using rule 56 (expression -> expression TIMES expression .)
    GREATER         reduce using rule 56 (expression -> expression TIMES expression .)
    LESS            reduce using rule 56 (expression -> expression TIMES expression .)
    EQUALS          reduce using rule 56 (expression -> expression TIMES expression .)
    GREATER_EQUAL   reduce using rule 56 (expression -> expression TIMES expression .)
    LESS_EQUAL      reduce using rule 56 (expression -> expression TIMES expression .)
    NOT_EQUALS      reduce using rule 56 (expression -> expression TIMES expression .)
    RSBRACKET       reduce using rule 56 (expression -> expression TIMES expression .)
    PRINT           reduce using rule 56 (expression -> expression TIMES expression .)
    STRING          reduce using rule 56 (expression -> expression TIMES expression .)
    VAR             reduce using rule 56 (expression -> expression TIMES expression .)
    FINAL           reduce using rule 56 (expression -> expression TIMES expression .)
    ID              reduce using rule 56 (expression -> expression TIMES expression .)
    VOID            reduce using rule 56 (expression -> expression TIMES expression .)
    LIST            reduce using rule 56 (expression -> expression TIMES expression .)
    DYNAMIC         reduce using rule 56 (expression -> expression TIMES expression .)
    INT             reduce using rule 56 (expression -> expression TIMES expression .)
    DOUBLE          reduce using rule 56 (expression -> expression TIMES expression .)
    MAP             reduce using rule 56 (expression -> expression TIMES expression .)
    WHILE           reduce using rule 56 (expression -> expression TIMES expression .)
    BOOL            reduce using rule 56 (expression -> expression TIMES expression .)
    IF              reduce using rule 56 (expression -> expression TIMES expression .)
    FOR             reduce using rule 56 (expression -> expression TIMES expression .)
    $end            reduce using rule 56 (expression -> expression TIMES expression .)
    RBRACKET        reduce using rule 56 (expression -> expression TIMES expression .)
    LBRACKET        reduce using rule 56 (expression -> expression TIMES expression .)
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    AND             shift and go to state 140
    OR              shift and go to state 141

  ! PLUS            [ reduce using rule 56 (expression -> expression TIMES expression .) ]
  ! MINUS           [ reduce using rule 56 (expression -> expression TIMES expression .) ]
  ! TIMES           [ reduce using rule 56 (expression -> expression TIMES expression .) ]
  ! DIVIDE          [ reduce using rule 56 (expression -> expression TIMES expression .) ]
  ! AND             [ reduce using rule 56 (expression -> expression TIMES expression .) ]
  ! OR              [ reduce using rule 56 (expression -> expression TIMES expression .) ]


state 208

    (57) expression -> expression DIVIDE expression .
    (54) expression -> expression . PLUS expression
    (55) expression -> expression . MINUS expression
    (56) expression -> expression . TIMES expression
    (57) expression -> expression . DIVIDE expression
    (58) expression -> expression . AND expression
    (59) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 57 (expression -> expression DIVIDE expression .)
    COMMA           reduce using rule 57 (expression -> expression DIVIDE expression .)
    SEMICOLON       reduce using rule 57 (expression -> expression DIVIDE expression .)
    GREATER         reduce using rule 57 (expression -> expression DIVIDE expression .)
    LESS            reduce using rule 57 (expression -> expression DIVIDE expression .)
    EQUALS          reduce using rule 57 (expression -> expression DIVIDE expression .)
    GREATER_EQUAL   reduce using rule 57 (expression -> expression DIVIDE expression .)
    LESS_EQUAL      reduce using rule 57 (expression -> expression DIVIDE expression .)
    NOT_EQUALS      reduce using rule 57 (expression -> expression DIVIDE expression .)
    RSBRACKET       reduce using rule 57 (expression -> expression DIVIDE expression .)
    PRINT           reduce using rule 57 (expression -> expression DIVIDE expression .)
    STRING          reduce using rule 57 (expression -> expression DIVIDE expression .)
    VAR             reduce using rule 57 (expression -> expression DIVIDE expression .)
    FINAL           reduce using rule 57 (expression -> expression DIVIDE expression .)
    ID              reduce using rule 57 (expression -> expression DIVIDE expression .)
    VOID            reduce using rule 57 (expression -> expression DIVIDE expression .)
    LIST            reduce using rule 57 (expression -> expression DIVIDE expression .)
    DYNAMIC         reduce using rule 57 (expression -> expression DIVIDE expression .)
    INT             reduce using rule 57 (expression -> expression DIVIDE expression .)
    DOUBLE          reduce using rule 57 (expression -> expression DIVIDE expression .)
    MAP             reduce using rule 57 (expression -> expression DIVIDE expression .)
    WHILE           reduce using rule 57 (expression -> expression DIVIDE expression .)
    BOOL            reduce using rule 57 (expression -> expression DIVIDE expression .)
    IF              reduce using rule 57 (expression -> expression DIVIDE expression .)
    FOR             reduce using rule 57 (expression -> expression DIVIDE expression .)
    $end            reduce using rule 57 (expression -> expression DIVIDE expression .)
    RBRACKET        reduce using rule 57 (expression -> expression DIVIDE expression .)
    LBRACKET        reduce using rule 57 (expression -> expression DIVIDE expression .)
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    AND             shift and go to state 140
    OR              shift and go to state 141

  ! PLUS            [ reduce using rule 57 (expression -> expression DIVIDE expression .) ]
  ! MINUS           [ reduce using rule 57 (expression -> expression DIVIDE expression .) ]
  ! TIMES           [ reduce using rule 57 (expression -> expression DIVIDE expression .) ]
  ! DIVIDE          [ reduce using rule 57 (expression -> expression DIVIDE expression .) ]
  ! AND             [ reduce using rule 57 (expression -> expression DIVIDE expression .) ]
  ! OR              [ reduce using rule 57 (expression -> expression DIVIDE expression .) ]


state 209

    (58) expression -> expression AND expression .
    (54) expression -> expression . PLUS expression
    (55) expression -> expression . MINUS expression
    (56) expression -> expression . TIMES expression
    (57) expression -> expression . DIVIDE expression
    (58) expression -> expression . AND expression
    (59) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 58 (expression -> expression AND expression .)
    COMMA           reduce using rule 58 (expression -> expression AND expression .)
    SEMICOLON       reduce using rule 58 (expression -> expression AND expression .)
    GREATER         reduce using rule 58 (expression -> expression AND expression .)
    LESS            reduce using rule 58 (expression -> expression AND expression .)
    EQUALS          reduce using rule 58 (expression -> expression AND expression .)
    GREATER_EQUAL   reduce using rule 58 (expression -> expression AND expression .)
    LESS_EQUAL      reduce using rule 58 (expression -> expression AND expression .)
    NOT_EQUALS      reduce using rule 58 (expression -> expression AND expression .)
    RSBRACKET       reduce using rule 58 (expression -> expression AND expression .)
    PRINT           reduce using rule 58 (expression -> expression AND expression .)
    STRING          reduce using rule 58 (expression -> expression AND expression .)
    VAR             reduce using rule 58 (expression -> expression AND expression .)
    FINAL           reduce using rule 58 (expression -> expression AND expression .)
    ID              reduce using rule 58 (expression -> expression AND expression .)
    VOID            reduce using rule 58 (expression -> expression AND expression .)
    LIST            reduce using rule 58 (expression -> expression AND expression .)
    DYNAMIC         reduce using rule 58 (expression -> expression AND expression .)
    INT             reduce using rule 58 (expression -> expression AND expression .)
    DOUBLE          reduce using rule 58 (expression -> expression AND expression .)
    MAP             reduce using rule 58 (expression -> expression AND expression .)
    WHILE           reduce using rule 58 (expression -> expression AND expression .)
    BOOL            reduce using rule 58 (expression -> expression AND expression .)
    IF              reduce using rule 58 (expression -> expression AND expression .)
    FOR             reduce using rule 58 (expression -> expression AND expression .)
    $end            reduce using rule 58 (expression -> expression AND expression .)
    RBRACKET        reduce using rule 58 (expression -> expression AND expression .)
    LBRACKET        reduce using rule 58 (expression -> expression AND expression .)
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    AND             shift and go to state 140
    OR              shift and go to state 141

  ! PLUS            [ reduce using rule 58 (expression -> expression AND expression .) ]
  ! MINUS           [ reduce using rule 58 (expression -> expression AND expression .) ]
  ! TIMES           [ reduce using rule 58 (expression -> expression AND expression .) ]
  ! DIVIDE          [ reduce using rule 58 (expression -> expression AND expression .) ]
  ! AND             [ reduce using rule 58 (expression -> expression AND expression .) ]
  ! OR              [ reduce using rule 58 (expression -> expression AND expression .) ]


state 210

    (59) expression -> expression OR expression .
    (54) expression -> expression . PLUS expression
    (55) expression -> expression . MINUS expression
    (56) expression -> expression . TIMES expression
    (57) expression -> expression . DIVIDE expression
    (58) expression -> expression . AND expression
    (59) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 59 (expression -> expression OR expression .)
    COMMA           reduce using rule 59 (expression -> expression OR expression .)
    SEMICOLON       reduce using rule 59 (expression -> expression OR expression .)
    GREATER         reduce using rule 59 (expression -> expression OR expression .)
    LESS            reduce using rule 59 (expression -> expression OR expression .)
    EQUALS          reduce using rule 59 (expression -> expression OR expression .)
    GREATER_EQUAL   reduce using rule 59 (expression -> expression OR expression .)
    LESS_EQUAL      reduce using rule 59 (expression -> expression OR expression .)
    NOT_EQUALS      reduce using rule 59 (expression -> expression OR expression .)
    RSBRACKET       reduce using rule 59 (expression -> expression OR expression .)
    PRINT           reduce using rule 59 (expression -> expression OR expression .)
    STRING          reduce using rule 59 (expression -> expression OR expression .)
    VAR             reduce using rule 59 (expression -> expression OR expression .)
    FINAL           reduce using rule 59 (expression -> expression OR expression .)
    ID              reduce using rule 59 (expression -> expression OR expression .)
    VOID            reduce using rule 59 (expression -> expression OR expression .)
    LIST            reduce using rule 59 (expression -> expression OR expression .)
    DYNAMIC         reduce using rule 59 (expression -> expression OR expression .)
    INT             reduce using rule 59 (expression -> expression OR expression .)
    DOUBLE          reduce using rule 59 (expression -> expression OR expression .)
    MAP             reduce using rule 59 (expression -> expression OR expression .)
    WHILE           reduce using rule 59 (expression -> expression OR expression .)
    BOOL            reduce using rule 59 (expression -> expression OR expression .)
    IF              reduce using rule 59 (expression -> expression OR expression .)
    FOR             reduce using rule 59 (expression -> expression OR expression .)
    $end            reduce using rule 59 (expression -> expression OR expression .)
    RBRACKET        reduce using rule 59 (expression -> expression OR expression .)
    LBRACKET        reduce using rule 59 (expression -> expression OR expression .)
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    AND             shift and go to state 140
    OR              shift and go to state 141

  ! PLUS            [ reduce using rule 59 (expression -> expression OR expression .) ]
  ! MINUS           [ reduce using rule 59 (expression -> expression OR expression .) ]
  ! TIMES           [ reduce using rule 59 (expression -> expression OR expression .) ]
  ! DIVIDE          [ reduce using rule 59 (expression -> expression OR expression .) ]
  ! AND             [ reduce using rule 59 (expression -> expression OR expression .) ]
  ! OR              [ reduce using rule 59 (expression -> expression OR expression .) ]


state 211

    (45) print -> PRINT LPAREN length RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    PRINT           reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    STRING          reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    VAR             reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    FINAL           reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    ID              reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    VOID            reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    LIST            reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    INT             reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    MAP             reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    WHILE           reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    BOOL            reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    IF              reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    FOR             reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    $end            reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 45 (print -> PRINT LPAREN length RPAREN SEMICOLON .)


state 212

    (52) simple_operations_arithmetics -> list_numbers simple_operators_arithmetics list_numbers .
    (53) simple_operations_arithmetics -> list_numbers simple_operators_arithmetics list_numbers . simple_operators_arithmetics simple_operations_arithmetics
    (48) simple_operators_arithmetics -> . MINUS
    (49) simple_operators_arithmetics -> . PLUS
    (50) simple_operators_arithmetics -> . DIVIDE
    (51) simple_operators_arithmetics -> . TIMES

    RPAREN          reduce using rule 52 (simple_operations_arithmetics -> list_numbers simple_operators_arithmetics list_numbers .)
    SEMICOLON       reduce using rule 52 (simple_operations_arithmetics -> list_numbers simple_operators_arithmetics list_numbers .)
    MINUS           shift and go to state 144
    PLUS            shift and go to state 145
    DIVIDE          shift and go to state 146
    TIMES           shift and go to state 147

    simple_operators_arithmetics   shift and go to state 264

state 213

    (47) list_numbers -> NDOUBLE .

    MINUS           reduce using rule 47 (list_numbers -> NDOUBLE .)
    PLUS            reduce using rule 47 (list_numbers -> NDOUBLE .)
    DIVIDE          reduce using rule 47 (list_numbers -> NDOUBLE .)
    TIMES           reduce using rule 47 (list_numbers -> NDOUBLE .)
    RPAREN          reduce using rule 47 (list_numbers -> NDOUBLE .)
    SEMICOLON       reduce using rule 47 (list_numbers -> NDOUBLE .)


state 214

    (25) length -> TEXT DOT LENGTH .
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    RPAREN          reduce using rule 67 (conditions -> condition AND conditions .)
    COMMA           reduce using rule 67 (conditions -> condition AND conditions .)
    LBRACKET        reduce using rule 67 (conditions -> condition AND conditions .)
    SEMICOLON       reduce using rule 67 (conditions -> condition AND conditions .)
    COMMENT_MULTI   reduce using rule 67 (conditions -> condition AND conditions .)
    COMMENT_SINGLE  reduce using rule 67 (conditions -> condition AND conditions .)
    PRINT           reduce using rule 67 (conditions -> condition AND conditions .)
    STRING          reduce using rule 67 (conditions -> condition AND conditions .)
    VAR             reduce using rule 67 (conditions -> condition AND conditions .)
    FINAL           reduce using rule 67 (conditions -> condition AND conditions .)
    ID              reduce using rule 67 (conditions -> condition AND conditions .)
    VOID            reduce using rule 67 (conditions -> condition AND conditions .)
    LIST            reduce using rule 67 (conditions -> condition AND conditions .)
    DYNAMIC         reduce using rule 67 (conditions -> condition AND conditions .)
    MAP             reduce using rule 67 (conditions -> condition AND conditions .)
    WHILE           reduce using rule 67 (conditions -> condition AND conditions .)
    INT             reduce using rule 67 (conditions -> condition AND conditions .)
    DOUBLE          reduce using rule 67 (conditions -> condition AND conditions .)
    BOOL            reduce using rule 67 (conditions -> condition AND conditions .)
    IF              reduce using rule 67 (conditions -> condition AND conditions .)
    FOR             reduce using rule 67 (conditions -> condition AND conditions .)
    $end            reduce using rule 67 (conditions -> condition AND conditions .)
    RBRACKET        reduce using rule 67 (conditions -> condition AND conditions .)


state 215

<<<<<<< HEAD
    (68) conditions -> condition OR conditions .

    RPAREN          reduce using rule 68 (conditions -> condition OR conditions .)
    COMMA           reduce using rule 68 (conditions -> condition OR conditions .)
    LBRACKET        reduce using rule 68 (conditions -> condition OR conditions .)
    SEMICOLON       reduce using rule 68 (conditions -> condition OR conditions .)
    COMMENT_MULTI   reduce using rule 68 (conditions -> condition OR conditions .)
    COMMENT_SINGLE  reduce using rule 68 (conditions -> condition OR conditions .)
    PRINT           reduce using rule 68 (conditions -> condition OR conditions .)
    STRING          reduce using rule 68 (conditions -> condition OR conditions .)
    VAR             reduce using rule 68 (conditions -> condition OR conditions .)
    FINAL           reduce using rule 68 (conditions -> condition OR conditions .)
    ID              reduce using rule 68 (conditions -> condition OR conditions .)
    VOID            reduce using rule 68 (conditions -> condition OR conditions .)
    LIST            reduce using rule 68 (conditions -> condition OR conditions .)
    DYNAMIC         reduce using rule 68 (conditions -> condition OR conditions .)
    MAP             reduce using rule 68 (conditions -> condition OR conditions .)
    WHILE           reduce using rule 68 (conditions -> condition OR conditions .)
    INT             reduce using rule 68 (conditions -> condition OR conditions .)
    DOUBLE          reduce using rule 68 (conditions -> condition OR conditions .)
    BOOL            reduce using rule 68 (conditions -> condition OR conditions .)
    IF              reduce using rule 68 (conditions -> condition OR conditions .)
    FOR             reduce using rule 68 (conditions -> condition OR conditions .)
    $end            reduce using rule 68 (conditions -> condition OR conditions .)
    RBRACKET        reduce using rule 68 (conditions -> condition OR conditions .)
=======
    (103) interpolated_string -> TEXT PLUS ID .
    (99) value -> ID .

  ! reduce/reduce conflict for RPAREN resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for COMMA resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for LESS resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for EQUALS resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for GREATER_EQUAL resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for LESS_EQUAL resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUALS resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for RSBRACKET resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for PRINT resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for STRING resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for VAR resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for FINAL resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for ID resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for VOID resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for LIST resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for DYNAMIC resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for INT resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for DOUBLE resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for MAP resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for WHILE resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for BOOL resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for IF resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for FOR resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 99 (value -> ID .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 99 (value -> ID .)
    RPAREN          reduce using rule 99 (value -> ID .)
    PLUS            reduce using rule 99 (value -> ID .)
    MINUS           reduce using rule 99 (value -> ID .)
    TIMES           reduce using rule 99 (value -> ID .)
    DIVIDE          reduce using rule 99 (value -> ID .)
    AND             reduce using rule 99 (value -> ID .)
    OR              reduce using rule 99 (value -> ID .)
    COMMA           reduce using rule 99 (value -> ID .)
    SEMICOLON       reduce using rule 99 (value -> ID .)
    GREATER         reduce using rule 99 (value -> ID .)
    LESS            reduce using rule 99 (value -> ID .)
    EQUALS          reduce using rule 99 (value -> ID .)
    GREATER_EQUAL   reduce using rule 99 (value -> ID .)
    LESS_EQUAL      reduce using rule 99 (value -> ID .)
    NOT_EQUALS      reduce using rule 99 (value -> ID .)
    RSBRACKET       reduce using rule 99 (value -> ID .)
    PRINT           reduce using rule 99 (value -> ID .)
    STRING          reduce using rule 99 (value -> ID .)
    VAR             reduce using rule 99 (value -> ID .)
    FINAL           reduce using rule 99 (value -> ID .)
    ID              reduce using rule 99 (value -> ID .)
    VOID            reduce using rule 99 (value -> ID .)
    LIST            reduce using rule 99 (value -> ID .)
    DYNAMIC         reduce using rule 99 (value -> ID .)
    INT             reduce using rule 99 (value -> ID .)
    DOUBLE          reduce using rule 99 (value -> ID .)
    MAP             reduce using rule 99 (value -> ID .)
    WHILE           reduce using rule 99 (value -> ID .)
    BOOL            reduce using rule 99 (value -> ID .)
    IF              reduce using rule 99 (value -> ID .)
    FOR             reduce using rule 99 (value -> ID .)
    $end            reduce using rule 99 (value -> ID .)
    RBRACKET        reduce using rule 99 (value -> ID .)
    LBRACKET        reduce using rule 99 (value -> ID .)

  ! RPAREN          [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! PLUS            [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! GREATER         [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! LESS            [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! EQUALS          [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! GREATER_EQUAL   [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! LESS_EQUAL      [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! NOT_EQUALS      [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! MINUS           [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! TIMES           [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! DIVIDE          [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! AND             [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! OR              [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! COMMA           [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! RSBRACKET       [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! SEMICOLON       [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! PRINT           [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! STRING          [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! VAR             [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! FINAL           [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! ID              [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! VOID            [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! LIST            [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! DYNAMIC         [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! INT             [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! DOUBLE          [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! MAP             [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! WHILE           [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! BOOL            [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! IF              [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! FOR             [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! $end            [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! RBRACKET        [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
  ! LBRACKET        [ reduce using rule 103 (interpolated_string -> TEXT PLUS ID .) ]
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 216

<<<<<<< HEAD
    (81) call_list -> LSBRACKET value_list RSBRACKET .

    DOT             reduce using rule 81 (call_list -> LSBRACKET value_list RSBRACKET .)
=======
    (104) interpolated_string -> TEXT PLUS expression .
    (54) expression -> expression . PLUS expression
    (55) expression -> expression . MINUS expression
    (56) expression -> expression . TIMES expression
    (57) expression -> expression . DIVIDE expression
    (58) expression -> expression . AND expression
    (59) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    GREATER         reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    LESS            reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    EQUALS          reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    GREATER_EQUAL   reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    LESS_EQUAL      reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    NOT_EQUALS      reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    COMMA           reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    RSBRACKET       reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    SEMICOLON       reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    PRINT           reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    STRING          reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    VAR             reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    FINAL           reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    ID              reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    VOID            reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    LIST            reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    DYNAMIC         reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    INT             reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    DOUBLE          reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    MAP             reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    WHILE           reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    BOOL            reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    IF              reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    FOR             reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    $end            reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    RBRACKET        reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    LBRACKET        reduce using rule 104 (interpolated_string -> TEXT PLUS expression .)
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    AND             shift and go to state 140
    OR              shift and go to state 141

  ! PLUS            [ reduce using rule 104 (interpolated_string -> TEXT PLUS expression .) ]
  ! MINUS           [ reduce using rule 104 (interpolated_string -> TEXT PLUS expression .) ]
  ! TIMES           [ reduce using rule 104 (interpolated_string -> TEXT PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 104 (interpolated_string -> TEXT PLUS expression .) ]
  ! AND             [ reduce using rule 104 (interpolated_string -> TEXT PLUS expression .) ]
  ! OR              [ reduce using rule 104 (interpolated_string -> TEXT PLUS expression .) ]
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 217

    (84) value_list -> value COMMA . value_list
    (83) value_list -> . value
    (84) value_list -> . value COMMA value_list
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83

    value                          shift and go to state 151
    value_list                     shift and go to state 239

state 218

<<<<<<< HEAD
    (25) data_input -> STRING ID ASSIGN STDIN DOT . READLINESYNC LPAREN RPAREN SEMICOLON

    READLINESYNC    shift and go to state 240
=======
    (92) call_list -> LSBRACKET value_list RSBRACKET .

    DOT             reduce using rule 92 (call_list -> LSBRACKET value_list RSBRACKET .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 219

<<<<<<< HEAD
    (26) data_input -> STRING QUESTION ID ASSIGN STDIN . DOT READLINESYNC LPAREN RPAREN SEMICOLON

    DOT             shift and go to state 241

=======
    (95) value_list -> value_list COMMA . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    value                          shift and go to state 265
    interpolated_string            shift and go to state 72
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

state 220

    (123) constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .

<<<<<<< HEAD
    COMMENT_MULTI   reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    PRINT           reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    STRING          reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    VAR             reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    FINAL           reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    ID              reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    VOID            reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    LIST            reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    MAP             reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    WHILE           reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    INT             reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    BOOL            reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    IF              reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    FOR             reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    $end            reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 123 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
=======
    READLINESYNC    shift and go to state 266
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 221

    (30) argument_list -> argument_list COMMA expression .

<<<<<<< HEAD
    RPAREN          reduce using rule 30 (argument_list -> argument_list COMMA expression .)
    COMMA           reduce using rule 30 (argument_list -> argument_list COMMA expression .)
=======
    DOT             shift and go to state 267
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 222

<<<<<<< HEAD
    (121) constructor_parenthesis_content -> THIS DOT ID .
    (122) constructor_parenthesis_content -> THIS DOT ID . COMMA constructor_parenthesis_content

    RPAREN          reduce using rule 121 (constructor_parenthesis_content -> THIS DOT ID .)
    COMMA           shift and go to state 242
=======
    (128) constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    PRINT           reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    STRING          reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    VAR             reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    FINAL           reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    ID              reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    VOID            reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    LIST            reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    INT             reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    MAP             reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    WHILE           reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    BOOL            reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    IF              reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    FOR             reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    $end            reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 128 (constructor -> ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 223

<<<<<<< HEAD
    (100) set -> VAR ID ASSIGN LBRACKET value_list . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 243
=======
    (27) argument_list -> argument_list COMMA expression .
    (54) expression -> expression . PLUS expression
    (55) expression -> expression . MINUS expression
    (56) expression -> expression . TIMES expression
    (57) expression -> expression . DIVIDE expression
    (58) expression -> expression . AND expression
    (59) expression -> expression . OR expression

    RPAREN          reduce using rule 27 (argument_list -> argument_list COMMA expression .)
    COMMA           reduce using rule 27 (argument_list -> argument_list COMMA expression .)
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    AND             shift and go to state 140
    OR              shift and go to state 141
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 224

<<<<<<< HEAD
    (101) set -> VAR ID ASSIGN LESS STRING . GREATER LBRACKET RBRACKET SEMICOLON

    GREATER         shift and go to state 244
=======
    (126) constructor_parenthesis_content -> THIS DOT ID .
    (127) constructor_parenthesis_content -> THIS DOT ID . COMMA constructor_parenthesis_content

    RPAREN          reduce using rule 126 (constructor_parenthesis_content -> THIS DOT ID .)
    COMMA           shift and go to state 268
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 225

<<<<<<< HEAD
    (39) variable_definition -> VAR ID ASSIGN expression SEMICOLON .

    COMMENT_MULTI   reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    DYNAMIC         reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
    RBRACKET        reduce using rule 39 (variable_definition -> VAR ID ASSIGN expression SEMICOLON .)
=======
    (105) set -> VAR ID ASSIGN LBRACKET value_list . RBRACKET SEMICOLON
    (95) value_list -> value_list . COMMA value

    RBRACKET        shift and go to state 269
    COMMA           shift and go to state 219
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 226

<<<<<<< HEAD
    (102) set -> FINAL ID ASSIGN CONST LBRACKET . value_list RBRACKET SEMICOLON
    (83) value_list -> . value
    (84) value_list -> . value COMMA value_list
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83
=======
    (106) set -> VAR ID ASSIGN LESS STRING . GREATER LBRACKET RBRACKET SEMICOLON

    GREATER         shift and go to state 270
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    value_list                     shift and go to state 245
    value                          shift and go to state 151

state 227

    (130) map_contents -> map_content COMMA map_contents .

    RBRACKET        reduce using rule 130 (map_contents -> map_content COMMA map_contents .)


state 228

<<<<<<< HEAD
    (131) map_content -> key_value COLON value .

    COMMA           reduce using rule 131 (map_content -> key_value COLON value .)
    RBRACKET        reduce using rule 131 (map_content -> key_value COLON value .)

=======
    (107) set -> FINAL ID ASSIGN CONST LBRACKET . value_list RBRACKET SEMICOLON
    (94) value_list -> . value
    (95) value_list -> . value_list COMMA value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    value_list                     shift and go to state 271
    value                          shift and go to state 152
    interpolated_string            shift and go to state 72
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

state 229

<<<<<<< HEAD
    (79) parameter -> type ID .

    RPAREN          reduce using rule 79 (parameter -> type ID .)
    COMMA           reduce using rule 79 (parameter -> type ID .)
=======
    (135) map_contents -> map_content COMMA map_contents .

    RBRACKET        reduce using rule 135 (map_contents -> map_content COMMA map_contents .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 230

<<<<<<< HEAD
    (31) function -> type ID LPAREN parameter_list RPAREN . LBRACKET statement_list RBRACKET
    (124) function -> type ID LPAREN parameter_list RPAREN . ASSIGN GREATER expression

    LBRACKET        shift and go to state 246
    ASSIGN          shift and go to state 247
=======
    (136) map_content -> key_value COLON value .

    COMMA           reduce using rule 136 (map_content -> key_value COLON value .)
    RBRACKET        reduce using rule 136 (map_content -> key_value COLON value .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 231

<<<<<<< HEAD
    (78) parameter_list -> parameter_list COMMA . parameter
    (79) parameter -> . type ID
    (80) parameter -> . REQUIRED type ID
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST

    REQUIRED        shift and go to state 171
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    STRING          shift and go to state 109
    BOOL            shift and go to state 39
    LIST            shift and go to state 107
=======
    (85) parameter -> type ID .

    RPAREN          reduce using rule 85 (parameter -> type ID .)
    COMMA           reduce using rule 85 (parameter -> type ID .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    parameter                      shift and go to state 248
    type                           shift and go to state 167

state 232

<<<<<<< HEAD
    (33) function -> type ID LPAREN RPAREN LBRACKET . statement_list RBRACKET
=======
    (28) function -> type ID LPAREN parameter_list RPAREN . LBRACKET statement_list RBRACKET
    (129) function -> type ID LPAREN parameter_list RPAREN . ASSIGN GREATER expression

    LBRACKET        shift and go to state 272
    ASSIGN          shift and go to state 273


state 233

    (84) parameter_list -> parameter_list COMMA . parameter
    (85) parameter -> . type ID
    (86) parameter -> . REQUIRED type ID
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST

    REQUIRED        shift and go to state 170
    INT             shift and go to state 99
    DOUBLE          shift and go to state 100
    STRING          shift and go to state 101
    BOOL            shift and go to state 37
    LIST            shift and go to state 97

    parameter                      shift and go to state 274
    type                           shift and go to state 166

state 234

    (30) function -> type ID LPAREN RPAREN LBRACKET . statement_list RBRACKET
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
<<<<<<< HEAD
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
=======
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

<<<<<<< HEAD
    type                           shift and go to state 27
    statement_list                 shift and go to state 249
=======
    type                           shift and go to state 25
    statement_list                 shift and go to state 275
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

<<<<<<< HEAD
state 218

    (80) parameter -> REQUIRED type . ID

    ID              shift and go to state 250


state 219

    (37) variable_definition -> type ID ASSIGN expression SEMICOLON .

    COMMENT_MULTI   reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    DYNAMIC         reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    RBRACKET        reduce using rule 37 (variable_definition -> type ID ASSIGN expression SEMICOLON .)


state 220

    (32) function -> VOID ID LPAREN parameter_list RPAREN . LBRACKET statement_list RBRACKET
    (36) function -> VOID ID LPAREN parameter_list RPAREN . LBRACKET RBRACKET

    LBRACKET        shift and go to state 251
=======
state 235

    (86) parameter -> REQUIRED type . ID

    ID              shift and go to state 276
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 236

<<<<<<< HEAD
    (34) function -> VOID ID LPAREN RPAREN LBRACKET . statement_list RBRACKET
    (35) function -> VOID ID LPAREN RPAREN LBRACKET . RBRACKET
=======
    (34) variable_definition -> type ID ASSIGN expression SEMICOLON .

    SEMICOLON       reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    DYNAMIC         reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)
    RBRACKET        reduce using rule 34 (variable_definition -> type ID ASSIGN expression SEMICOLON .)


state 237

    (29) function -> VOID ID LPAREN parameter_list RPAREN . LBRACKET statement_list RBRACKET
    (33) function -> VOID ID LPAREN parameter_list RPAREN . LBRACKET RBRACKET

    LBRACKET        shift and go to state 277


state 238

    (31) function -> VOID ID LPAREN RPAREN LBRACKET . statement_list RBRACKET
    (32) function -> VOID ID LPAREN RPAREN LBRACKET . RBRACKET
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
<<<<<<< HEAD
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 253
    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
=======
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 279
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement_list                 shift and go to state 252
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 222

    (82) list_definition -> LIST LESS type GREATER ID . ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON

    ASSIGN          shift and go to state 254


state 223

    (38) variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .

    COMMENT_MULTI   reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    DYNAMIC         reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    RBRACKET        reduce using rule 38 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)


state 224

    (127) map_declaration -> MAP LESS key_type COMMA type . GREATER ID ASSIGN

    GREATER         shift and go to state 255


state 225

    (64) else_if_blocks -> else_if_blocks ELSE IF LPAREN . conditions RPAREN LBRACKET statement_list RBRACKET
    (66) conditions -> . condition
    (67) conditions -> . condition AND conditions
    (68) conditions -> . condition OR conditions
    (69) condition -> . value comparator value
    (70) condition -> . NOT condition
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NOT             shift and go to state 85
    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83

    conditions                     shift and go to state 256
    condition                      shift and go to state 79
    value                          shift and go to state 118

state 226

    (63) else_if_blocks -> ELSE IF LPAREN conditions . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 257


state 227

    (65) else_block -> ELSE LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 65 (else_block -> ELSE LBRACKET statement_list RBRACKET .)


state 228

    (125) control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 258
    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement                      shift and go to state 42
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 229

    (62) if_block -> IF LPAREN conditions RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement_list                 shift and go to state 259
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 230

    (111) for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement_list                 shift and go to state 260
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 231

    (113) for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

<<<<<<< HEAD
    statement_list                 shift and go to state 261
=======
    statement_list                 shift and go to state 278
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
<<<<<<< HEAD
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
=======
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35
<<<<<<< HEAD

state 232

    (117) for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement_list                 shift and go to state 262
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 233

    (110) for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions . SEMICOLON for_classic_changes

    SEMICOLON       shift and go to state 263


state 234

    (105) for_classic_conditions -> conditions .

    SEMICOLON       reduce using rule 105 (for_classic_conditions -> conditions .)


state 235

    (112) for_in_parenthesis_content -> FINAL ID IN . ID

    ID              shift and go to state 264


state 236

    (116) for_each_parenthesis_content -> FINAL ID LPAREN . for_each_parenthesis_parenthesis_content RPAREN IN ID
    (114) for_each_parenthesis_parenthesis_content -> . COLON ID
    (115) for_each_parenthesis_parenthesis_content -> . COLON ID COMMA for_each_parenthesis_parenthesis_content

    COLON           shift and go to state 266

    for_each_parenthesis_parenthesis_content shift and go to state 265

state 237

    (103) for_classic_initialization -> INT ID ASSIGN . NUMBER

    NUMBER          shift and go to state 267


state 238

    (104) for_classic_initialization -> DOUBLE ID ASSIGN . NDOUBLE

    NDOUBLE         shift and go to state 268


state 239

    (84) value_list -> value COMMA value_list .

    RSBRACKET       reduce using rule 84 (value_list -> value COMMA value_list .)
    RBRACKET        reduce using rule 84 (value_list -> value COMMA value_list .)
=======

state 239

    (93) list_definition -> LIST LESS type GREATER ID . ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON

    ASSIGN          shift and go to state 280
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 240

<<<<<<< HEAD
    (25) data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 269
=======
    (35) variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .

    SEMICOLON       reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    VAR             reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    FINAL           reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    ID              reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    VOID            reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    LIST            reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    DYNAMIC         reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    INT             reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    MAP             reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    BOOL            reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    IF              reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    $end            reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
    RBRACKET        reduce using rule 35 (variable_definition -> DYNAMIC ID ASSIGN expression SEMICOLON .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 241

<<<<<<< HEAD
    (26) data_input -> STRING QUESTION ID ASSIGN STDIN DOT . READLINESYNC LPAREN RPAREN SEMICOLON

    READLINESYNC    shift and go to state 270
=======
    (37) variable_definition -> INT ID ASSIGN length SEMICOLON .

    SEMICOLON       reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    PRINT           reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    STRING          reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    VAR             reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    FINAL           reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    ID              reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    VOID            reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    LIST            reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    DYNAMIC         reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    INT             reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    DOUBLE          reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    MAP             reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    WHILE           reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    BOOL            reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    IF              reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    FOR             reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    $end            reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
    RBRACKET        reduce using rule 37 (variable_definition -> INT ID ASSIGN length SEMICOLON .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 242

<<<<<<< HEAD
    (122) constructor_parenthesis_content -> THIS DOT ID COMMA . constructor_parenthesis_content
    (121) constructor_parenthesis_content -> . THIS DOT ID
    (122) constructor_parenthesis_content -> . THIS DOT ID COMMA constructor_parenthesis_content

    THIS            shift and go to state 93

    constructor_parenthesis_content shift and go to state 271

state 243

    (100) set -> VAR ID ASSIGN LBRACKET value_list RBRACKET . SEMICOLON
=======
    (38) variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    SEMICOLON       reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    PRINT           reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    STRING          reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    VAR             reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    FINAL           reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    ID              reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    VOID            reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    LIST            reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    DYNAMIC         reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    INT             reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    DOUBLE          reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    MAP             reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    WHILE           reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    BOOL            reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    IF              reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    FOR             reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    $end            reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)
    RBRACKET        reduce using rule 38 (variable_definition -> INT ID ASSIGN NUMBER SEMICOLON .)


<<<<<<< HEAD
state 244

    (101) set -> VAR ID ASSIGN LESS STRING GREATER . LBRACKET RBRACKET SEMICOLON

    LBRACKET        shift and go to state 273
=======
state 243

    (39) variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .

    SEMICOLON       reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    PRINT           reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    STRING          reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    VAR             reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    FINAL           reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    ID              reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    VOID            reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    LIST            reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    DYNAMIC         reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    INT             reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    DOUBLE          reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    MAP             reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    WHILE           reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    BOOL            reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    IF              reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    FOR             reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    $end            reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)
    RBRACKET        reduce using rule 39 (variable_definition -> DOUBLE ID ASSIGN NDOUBLE SEMICOLON .)


state 244

    (40) variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .

    SEMICOLON       reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    PRINT           reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    STRING          reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    VAR             reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    FINAL           reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    ID              reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    VOID            reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    LIST            reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    DYNAMIC         reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    INT             reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    DOUBLE          reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    MAP             reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    WHILE           reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    BOOL            reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    IF              reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    FOR             reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    $end            reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
    RBRACKET        reduce using rule 40 (variable_definition -> DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 245

<<<<<<< HEAD
    (102) set -> FINAL ID ASSIGN CONST LBRACKET value_list . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 274
=======
    (132) map_declaration -> MAP LESS key_type COMMA type . GREATER ID ASSIGN

    GREATER         shift and go to state 281
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 246

<<<<<<< HEAD
    (31) function -> type ID LPAREN parameter_list RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    type                           shift and go to state 27
    statement_list                 shift and go to state 275
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 247

    (124) function -> type ID LPAREN parameter_list RPAREN ASSIGN . GREATER expression

    GREATER         shift and go to state 276
=======
    (69) else_if_blocks -> else_if_blocks ELSE IF LPAREN . conditions RPAREN LBRACKET statement_list RBRACKET
    (71) conditions -> . condition
    (72) conditions -> . conditions AND conditions
    (73) conditions -> . conditions OR conditions
    (74) condition -> . value comparator value
    (75) condition -> . NOT condition
    (76) condition -> . LPAREN conditions RPAREN
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NOT             shift and go to state 115
    LPAREN          shift and go to state 111
    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    conditions                     shift and go to state 282
    condition                      shift and go to state 113
    value                          shift and go to state 114
    interpolated_string            shift and go to state 72

state 247

    (68) else_if_blocks -> ELSE IF LPAREN conditions . RPAREN LBRACKET statement_list RBRACKET
    (72) conditions -> conditions . AND conditions
    (73) conditions -> conditions . OR conditions

    RPAREN          shift and go to state 283
    AND             shift and go to state 188
    OR              shift and go to state 189
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 248

<<<<<<< HEAD
    (78) parameter_list -> parameter_list COMMA parameter .

    RPAREN          reduce using rule 78 (parameter_list -> parameter_list COMMA parameter .)
    COMMA           reduce using rule 78 (parameter_list -> parameter_list COMMA parameter .)
=======
    (70) else_block -> ELSE LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 70 (else_block -> ELSE LBRACKET statement_list RBRACKET .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 249

<<<<<<< HEAD
    (33) function -> type ID LPAREN RPAREN LBRACKET statement_list . RBRACKET
=======
    (76) condition -> LPAREN conditions RPAREN .

    LBRACKET        reduce using rule 76 (condition -> LPAREN conditions RPAREN .)
    AND             reduce using rule 76 (condition -> LPAREN conditions RPAREN .)
    OR              reduce using rule 76 (condition -> LPAREN conditions RPAREN .)
    RPAREN          reduce using rule 76 (condition -> LPAREN conditions RPAREN .)
    SEMICOLON       reduce using rule 76 (condition -> LPAREN conditions RPAREN .)


state 250

    (130) control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list . RBRACKET
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
<<<<<<< HEAD
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 277
    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
=======
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 284
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

<<<<<<< HEAD
    type                           shift and go to state 27
    statement                      shift and go to state 42
=======
    statement                      shift and go to state 40
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
<<<<<<< HEAD
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
=======
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

<<<<<<< HEAD
state 250

    (80) parameter -> REQUIRED type ID .

    RPAREN          reduce using rule 80 (parameter -> REQUIRED type ID .)
    COMMA           reduce using rule 80 (parameter -> REQUIRED type ID .)


state 251

    (32) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET . statement_list RBRACKET
    (36) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET . RBRACKET
=======
state 251

    (72) conditions -> conditions AND conditions .
    (72) conditions -> conditions . AND conditions
    (73) conditions -> conditions . OR conditions

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    LBRACKET        reduce using rule 72 (conditions -> conditions AND conditions .)
    RPAREN          reduce using rule 72 (conditions -> conditions AND conditions .)
    SEMICOLON       reduce using rule 72 (conditions -> conditions AND conditions .)
    AND             shift and go to state 188
    OR              shift and go to state 189

  ! AND             [ reduce using rule 72 (conditions -> conditions AND conditions .) ]
  ! OR              [ reduce using rule 72 (conditions -> conditions AND conditions .) ]


state 252

    (73) conditions -> conditions OR conditions .
    (72) conditions -> conditions . AND conditions
    (73) conditions -> conditions . OR conditions

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    LBRACKET        reduce using rule 73 (conditions -> conditions OR conditions .)
    RPAREN          reduce using rule 73 (conditions -> conditions OR conditions .)
    SEMICOLON       reduce using rule 73 (conditions -> conditions OR conditions .)
    AND             shift and go to state 188
    OR              shift and go to state 189

  ! AND             [ reduce using rule 73 (conditions -> conditions OR conditions .) ]
  ! OR              [ reduce using rule 73 (conditions -> conditions OR conditions .) ]


state 253

    (74) condition -> value comparator value .

    LBRACKET        reduce using rule 74 (condition -> value comparator value .)
    AND             reduce using rule 74 (condition -> value comparator value .)
    OR              reduce using rule 74 (condition -> value comparator value .)
    RPAREN          reduce using rule 74 (condition -> value comparator value .)
    SEMICOLON       reduce using rule 74 (condition -> value comparator value .)


state 254

    (67) if_block -> IF LPAREN conditions RPAREN LBRACKET . statement_list RBRACKET
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
<<<<<<< HEAD
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 279
    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
=======
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement_list                 shift and go to state 285
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 255

    (116) for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement_list                 shift and go to state 286
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 256

    (118) for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement_list                 shift and go to state 278
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 252

    (34) function -> VOID ID LPAREN RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 280
    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement                      shift and go to state 42
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 253

    (35) function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .

    COMMENT_MULTI   reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    COMMENT_SINGLE  reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    SEMICOLON       reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    PRINT           reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    STRING          reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    VAR             reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    FINAL           reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    ID              reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    VOID            reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    LIST            reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    DYNAMIC         reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    MAP             reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    WHILE           reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    INT             reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    DOUBLE          reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    BOOL            reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    IF              reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    FOR             reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    $end            reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 35 (function -> VOID ID LPAREN RPAREN LBRACKET RBRACKET .)


state 254

    (82) list_definition -> LIST LESS type GREATER ID ASSIGN . LSBRACKET value_list RSBRACKET SEMICOLON

    LSBRACKET       shift and go to state 281


state 255

    (127) map_declaration -> MAP LESS key_type COMMA type GREATER . ID ASSIGN

    ID              shift and go to state 282


state 256

    (64) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions . RPAREN LBRACKET statement_list RBRACKET

    RPAREN          shift and go to state 283


state 257

    (63) else_if_blocks -> ELSE IF LPAREN conditions RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 284


state 258

    (125) control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 125 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)


state 259

    (62) if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 285
    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement                      shift and go to state 42
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 260

    (111) for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 286
    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement                      shift and go to state 42
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 257

    (122) for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement_list                 shift and go to state 288
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 258

    (115) for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions . SEMICOLON for_classic_changes

    SEMICOLON       shift and go to state 289


state 259

    (110) for_classic_conditions -> conditions .
    (72) conditions -> conditions . AND conditions
    (73) conditions -> conditions . OR conditions

    SEMICOLON       reduce using rule 110 (for_classic_conditions -> conditions .)
    AND             shift and go to state 188
    OR              shift and go to state 189


state 260

    (117) for_in_parenthesis_content -> FINAL ID IN . ID

    ID              shift and go to state 290


state 261

<<<<<<< HEAD
    (113) for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list . RBRACKET
=======
    (121) for_each_parenthesis_content -> FINAL ID LPAREN . for_each_parenthesis_parenthesis_content RPAREN IN ID
    (119) for_each_parenthesis_parenthesis_content -> . COLON ID
    (120) for_each_parenthesis_parenthesis_content -> . COLON ID COMMA for_each_parenthesis_parenthesis_content

    COLON           shift and go to state 292

    for_each_parenthesis_parenthesis_content shift and go to state 291

state 262

    (108) for_classic_initialization -> INT ID ASSIGN . NUMBER

    NUMBER          shift and go to state 293


state 263

    (109) for_classic_initialization -> DOUBLE ID ASSIGN . NDOUBLE

    NDOUBLE         shift and go to state 294


state 264

    (53) simple_operations_arithmetics -> list_numbers simple_operators_arithmetics list_numbers simple_operators_arithmetics . simple_operations_arithmetics
    (52) simple_operations_arithmetics -> . list_numbers simple_operators_arithmetics list_numbers
    (53) simple_operations_arithmetics -> . list_numbers simple_operators_arithmetics list_numbers simple_operators_arithmetics simple_operations_arithmetics
    (46) list_numbers -> . NUMBER
    (47) list_numbers -> . NDOUBLE

    NUMBER          shift and go to state 181
    NDOUBLE         shift and go to state 213

    list_numbers                   shift and go to state 67
    simple_operations_arithmetics  shift and go to state 295

state 265

    (95) value_list -> value_list COMMA value .

    RSBRACKET       reduce using rule 95 (value_list -> value_list COMMA value .)
    COMMA           reduce using rule 95 (value_list -> value_list COMMA value .)
    RBRACKET        reduce using rule 95 (value_list -> value_list COMMA value .)


state 266

    (22) data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 296


state 267

    (23) data_input -> STRING QUESTION ID ASSIGN STDIN DOT . READLINESYNC LPAREN RPAREN SEMICOLON

    READLINESYNC    shift and go to state 297


state 268

    (127) constructor_parenthesis_content -> THIS DOT ID COMMA . constructor_parenthesis_content
    (126) constructor_parenthesis_content -> . THIS DOT ID
    (127) constructor_parenthesis_content -> . THIS DOT ID COMMA constructor_parenthesis_content

    THIS            shift and go to state 82

    constructor_parenthesis_content shift and go to state 298

state 269

    (105) set -> VAR ID ASSIGN LBRACKET value_list RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 299


state 270

    (106) set -> VAR ID ASSIGN LESS STRING GREATER . LBRACKET RBRACKET SEMICOLON

    LBRACKET        shift and go to state 300


state 271

    (107) set -> FINAL ID ASSIGN CONST LBRACKET value_list . RBRACKET SEMICOLON
    (95) value_list -> value_list . COMMA value

    RBRACKET        shift and go to state 301
    COMMA           shift and go to state 219


state 272

    (28) function -> type ID LPAREN parameter_list RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    type                           shift and go to state 25
    statement_list                 shift and go to state 302
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 273

    (129) function -> type ID LPAREN parameter_list RPAREN ASSIGN . GREATER expression

    GREATER         shift and go to state 303


state 274

    (84) parameter_list -> parameter_list COMMA parameter .

    RPAREN          reduce using rule 84 (parameter_list -> parameter_list COMMA parameter .)
    COMMA           reduce using rule 84 (parameter_list -> parameter_list COMMA parameter .)


state 275

    (30) function -> type ID LPAREN RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 304
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    type                           shift and go to state 25
    statement                      shift and go to state 40
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 276

    (86) parameter -> REQUIRED type ID .

    RPAREN          reduce using rule 86 (parameter -> REQUIRED type ID .)
    COMMA           reduce using rule 86 (parameter -> REQUIRED type ID .)


state 277

    (29) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET . statement_list RBRACKET
    (33) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET . RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 306
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement_list                 shift and go to state 305
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 278

    (31) function -> VOID ID LPAREN RPAREN LBRACKET statement_list . RBRACKET
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
<<<<<<< HEAD
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 287
    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
=======
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 307
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement                      shift and go to state 42
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 279

    (117) for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 288
    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement                      shift and go to state 42
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

<<<<<<< HEAD
state 263

    (110) for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON . for_classic_changes
    (106) for_classic_changes -> . ID comparator value
    (107) for_classic_changes -> . ID INCREMENT
    (108) for_classic_changes -> . ID DECREMENT
    (109) for_classic_changes -> . ID comparator value COMMA for_classic_changes

    ID              shift and go to state 290

    for_classic_changes            shift and go to state 289

state 264

    (112) for_in_parenthesis_content -> FINAL ID IN ID .

    RPAREN          reduce using rule 112 (for_in_parenthesis_content -> FINAL ID IN ID .)


state 265

    (116) for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content . RPAREN IN ID

    RPAREN          shift and go to state 291


state 266

    (114) for_each_parenthesis_parenthesis_content -> COLON . ID
    (115) for_each_parenthesis_parenthesis_content -> COLON . ID COMMA for_each_parenthesis_parenthesis_content

    ID              shift and go to state 292


state 267

    (103) for_classic_initialization -> INT ID ASSIGN NUMBER .

    SEMICOLON       reduce using rule 103 (for_classic_initialization -> INT ID ASSIGN NUMBER .)


state 268

    (104) for_classic_initialization -> DOUBLE ID ASSIGN NDOUBLE .

    SEMICOLON       reduce using rule 104 (for_classic_initialization -> DOUBLE ID ASSIGN NDOUBLE .)


state 269

    (25) data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 293


state 270

    (26) data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 294


state 271

    (122) constructor_parenthesis_content -> THIS DOT ID COMMA constructor_parenthesis_content .

    RPAREN          reduce using rule 122 (constructor_parenthesis_content -> THIS DOT ID COMMA constructor_parenthesis_content .)


state 272

    (100) set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .

    COMMENT_MULTI   reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    SEMICOLON       reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    PRINT           reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    STRING          reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    VAR             reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    FINAL           reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    ID              reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    VOID            reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    LIST            reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    MAP             reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    WHILE           reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    INT             reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    BOOL            reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    IF              reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    FOR             reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    $end            reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    RBRACKET        reduce using rule 100 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)


state 273

    (101) set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 295


state 274

    (102) set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 296


state 275

    (31) function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list . RBRACKET
=======
state 280

    (93) list_definition -> LIST LESS type GREATER ID ASSIGN . LSBRACKET value_list RSBRACKET SEMICOLON

    LSBRACKET       shift and go to state 308


state 281

    (132) map_declaration -> MAP LESS key_type COMMA type GREATER . ID ASSIGN

    ID              shift and go to state 309


state 282

    (69) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions . RPAREN LBRACKET statement_list RBRACKET
    (72) conditions -> conditions . AND conditions
    (73) conditions -> conditions . OR conditions

    RPAREN          shift and go to state 310
    AND             shift and go to state 188
    OR              shift and go to state 189


state 283

    (68) else_if_blocks -> ELSE IF LPAREN conditions RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 311


state 284

    (130) control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 130 (control_structures_while -> WHILE LPAREN conditions LBRACKET statement_list RBRACKET .)


state 285

    (67) if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list . RBRACKET
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
<<<<<<< HEAD
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 297
    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
=======
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 312
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

<<<<<<< HEAD
    type                           shift and go to state 27
    statement                      shift and go to state 42
=======
    statement                      shift and go to state 40
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
<<<<<<< HEAD
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 276

    (124) function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER . expression
    (46) expression -> . operations
    (56) expression -> . conditions
    (57) expression -> . value
    (47) operations -> . operation
    (48) operations -> . operation operand operations
    (66) conditions -> . condition
    (67) conditions -> . condition AND conditions
    (68) conditions -> . condition OR conditions
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE
    (49) operation -> . operand operator operand
    (69) condition -> . value comparator value
    (70) condition -> . NOT condition
    (50) operand -> . NUMBER
    (51) operand -> . DOUBLE

    NUMBER          shift and go to state 80
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83
    NOT             shift and go to state 85
    DOUBLE          shift and go to state 86

    expression                     shift and go to state 298
    operations                     shift and go to state 71
    conditions                     shift and go to state 72
    value                          shift and go to state 73
    operation                      shift and go to state 77
    operand                        shift and go to state 78
    condition                      shift and go to state 79

state 277

    (33) function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 33 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)


state 278

    (32) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 299
    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement                      shift and go to state 42
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 279

    (36) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .

    COMMENT_MULTI   reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    COMMENT_SINGLE  reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    SEMICOLON       reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    PRINT           reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    STRING          reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    VAR             reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    FINAL           reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    ID              reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    VOID            reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    LIST            reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    DYNAMIC         reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    MAP             reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    WHILE           reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    INT             reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    DOUBLE          reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    BOOL            reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    IF              reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    FOR             reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    $end            reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 36 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .)


state 280

    (34) function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 34 (function -> VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)


state 281

    (82) list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET . value_list RSBRACKET SEMICOLON
    (83) value_list -> . value
    (84) value_list -> . value COMMA value_list
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83

    value_list                     shift and go to state 300
    value                          shift and go to state 151

state 282

    (127) map_declaration -> MAP LESS key_type COMMA type GREATER ID . ASSIGN

    ASSIGN          shift and go to state 301


state 283

    (64) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 302


state 284

    (63) else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement_list                 shift and go to state 303
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
=======
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

<<<<<<< HEAD
state 285

    (62) if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .

    ELSE            reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_MULTI   reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 62 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)


state 286

    (111) for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 111 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)


state 287

    (113) for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 113 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
=======
state 286

    (116) for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 313
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement                      shift and go to state 40
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 287

    (118) for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 314
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 288

<<<<<<< HEAD
    (117) for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .
=======
    (122) for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 315
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement                      shift and go to state 40
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 289

    (115) for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON . for_classic_changes
    (111) for_classic_changes -> . ID comparator value
    (112) for_classic_changes -> . ID INCREMENT
    (113) for_classic_changes -> . ID DECREMENT
    (114) for_classic_changes -> . ID comparator value COMMA for_classic_changes

    ID              shift and go to state 317

    for_classic_changes            shift and go to state 316

state 290

    (117) for_in_parenthesis_content -> FINAL ID IN ID .

    RPAREN          reduce using rule 117 (for_in_parenthesis_content -> FINAL ID IN ID .)


state 291

    (121) for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content . RPAREN IN ID

    RPAREN          shift and go to state 318


state 292

    (119) for_each_parenthesis_parenthesis_content -> COLON . ID
    (120) for_each_parenthesis_parenthesis_content -> COLON . ID COMMA for_each_parenthesis_parenthesis_content

    ID              shift and go to state 319


state 293

    (108) for_classic_initialization -> INT ID ASSIGN NUMBER .

    SEMICOLON       reduce using rule 108 (for_classic_initialization -> INT ID ASSIGN NUMBER .)


state 294

    (109) for_classic_initialization -> DOUBLE ID ASSIGN NDOUBLE .

    SEMICOLON       reduce using rule 109 (for_classic_initialization -> DOUBLE ID ASSIGN NDOUBLE .)


state 295

    (53) simple_operations_arithmetics -> list_numbers simple_operators_arithmetics list_numbers simple_operators_arithmetics simple_operations_arithmetics .

    RPAREN          reduce using rule 53 (simple_operations_arithmetics -> list_numbers simple_operators_arithmetics list_numbers simple_operators_arithmetics simple_operations_arithmetics .)
    SEMICOLON       reduce using rule 53 (simple_operations_arithmetics -> list_numbers simple_operators_arithmetics list_numbers simple_operators_arithmetics simple_operations_arithmetics .)


state 296

    (22) data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 320


state 297

    (23) data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 321


state 298

    (127) constructor_parenthesis_content -> THIS DOT ID COMMA constructor_parenthesis_content .

    RPAREN          reduce using rule 127 (constructor_parenthesis_content -> THIS DOT ID COMMA constructor_parenthesis_content .)


state 299

    (105) set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .

    SEMICOLON       reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    PRINT           reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    STRING          reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    VAR             reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    FINAL           reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    ID              reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    VOID            reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    LIST            reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    INT             reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    MAP             reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    WHILE           reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    BOOL            reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    IF              reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    FOR             reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    $end            reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)
    RBRACKET        reduce using rule 105 (set -> VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON .)


state 300

    (106) set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 322


state 301

    (107) set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 323


state 302

    (28) function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 324
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    type                           shift and go to state 25
    statement                      shift and go to state 40
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 303

    (129) function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER . expression
    (54) expression -> . expression PLUS expression
    (55) expression -> . expression MINUS expression
    (56) expression -> . expression TIMES expression
    (57) expression -> . expression DIVIDE expression
    (58) expression -> . expression AND expression
    (59) expression -> . expression OR expression
    (60) expression -> . value comparator value
    (61) expression -> . value PLUS value
    (62) expression -> . value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    expression                     shift and go to state 325
    value                          shift and go to state 84
    interpolated_string            shift and go to state 72

state 304

    (30) function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 30 (function -> type ID LPAREN RPAREN LBRACKET statement_list RBRACKET .)


state 305

    (29) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 326
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement                      shift and go to state 40
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 306

    (33) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET .
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    COMMENT_MULTI   reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 117 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)


state 307

    (110) for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON for_classic_changes .

    RPAREN          reduce using rule 110 (for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON for_classic_changes .)


<<<<<<< HEAD
state 290

    (106) for_classic_changes -> ID . comparator value
    (107) for_classic_changes -> ID . INCREMENT
    (108) for_classic_changes -> ID . DECREMENT
    (109) for_classic_changes -> ID . comparator value COMMA for_classic_changes
    (71) comparator -> . GREATER
    (72) comparator -> . LESS
    (73) comparator -> . EQUALS
    (74) comparator -> . GREATER_EQUAL
    (75) comparator -> . LESS_EQUAL
    (76) comparator -> . NOT_EQUALS

    INCREMENT       shift and go to state 305
    DECREMENT       shift and go to state 306
    GREATER         shift and go to state 131
    LESS            shift and go to state 132
    EQUALS          shift and go to state 133
    GREATER_EQUAL   shift and go to state 134
    LESS_EQUAL      shift and go to state 135
    NOT_EQUALS      shift and go to state 136

    comparator                     shift and go to state 304

state 291

    (116) for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN . IN ID

    IN              shift and go to state 307


state 292

    (114) for_each_parenthesis_parenthesis_content -> COLON ID .
    (115) for_each_parenthesis_parenthesis_content -> COLON ID . COMMA for_each_parenthesis_parenthesis_content

    RPAREN          reduce using rule 114 (for_each_parenthesis_parenthesis_content -> COLON ID .)
    COMMA           shift and go to state 308


state 293

    (25) data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 309


state 294

    (26) data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 310


state 295

    (101) set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 311


state 296

    (102) set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .

    COMMENT_MULTI   reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    SEMICOLON       reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    PRINT           reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    STRING          reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    VAR             reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    FINAL           reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    ID              reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    VOID            reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    LIST            reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    MAP             reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    WHILE           reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    INT             reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    BOOL            reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    IF              reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    FOR             reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    $end            reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    RBRACKET        reduce using rule 102 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)


state 297

    (31) function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 31 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)


state 298

    (124) function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .

    COMMENT_MULTI   reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    COMMENT_SINGLE  reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    SEMICOLON       reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    PRINT           reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    STRING          reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    VAR             reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    FINAL           reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    ID              reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    VOID            reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    LIST            reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    DYNAMIC         reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    MAP             reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    WHILE           reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    INT             reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    DOUBLE          reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    BOOL            reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    IF              reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    FOR             reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    $end            reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    RBRACKET        reduce using rule 124 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)


state 299

    (32) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .

    COMMENT_MULTI   reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 32 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)


state 300

    (82) list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list . RSBRACKET SEMICOLON

    RSBRACKET       shift and go to state 312


state 301

    (127) map_declaration -> MAP LESS key_type COMMA type GREATER ID ASSIGN .

    LBRACKET        reduce using rule 127 (map_declaration -> MAP LESS key_type COMMA type GREATER ID ASSIGN .)


state 302

    (64) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET . statement_list RBRACKET
=======
state 308

    (93) list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET . value_list RSBRACKET SEMICOLON
    (94) value_list -> . value
    (95) value_list -> . value_list COMMA value
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    value_list                     shift and go to state 327
    value                          shift and go to state 152
    interpolated_string            shift and go to state 72

state 309

    (132) map_declaration -> MAP LESS key_type COMMA type GREATER ID . ASSIGN

    ASSIGN          shift and go to state 328


state 310

    (69) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN . LBRACKET statement_list RBRACKET

    LBRACKET        shift and go to state 329


state 311

    (68) else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET . statement_list RBRACKET
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
<<<<<<< HEAD
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
=======
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

<<<<<<< HEAD
    statement_list                 shift and go to state 313
=======
    statement_list                 shift and go to state 330
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 303

<<<<<<< HEAD
    (63) else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list . RBRACKET
=======
    (67) if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .

    ELSE            reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 67 (if_block -> IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)


state 313

    (116) for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 116 (for_classic -> FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)


state 314

    (118) for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 118 (for_in -> FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)


state 315

    (122) for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 122 (for_each -> FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET .)


state 316

    (115) for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON for_classic_changes .

    RPAREN          reduce using rule 115 (for_classic_parenthesis_content -> for_classic_initialization SEMICOLON for_classic_conditions SEMICOLON for_classic_changes .)


state 317

    (111) for_classic_changes -> ID . comparator value
    (112) for_classic_changes -> ID . INCREMENT
    (113) for_classic_changes -> ID . DECREMENT
    (114) for_classic_changes -> ID . comparator value COMMA for_classic_changes
    (77) comparator -> . GREATER
    (78) comparator -> . LESS
    (79) comparator -> . EQUALS
    (80) comparator -> . GREATER_EQUAL
    (81) comparator -> . LESS_EQUAL
    (82) comparator -> . NOT_EQUALS

    INCREMENT       shift and go to state 332
    DECREMENT       shift and go to state 333
    GREATER         shift and go to state 129
    LESS            shift and go to state 130
    EQUALS          shift and go to state 131
    GREATER_EQUAL   shift and go to state 132
    LESS_EQUAL      shift and go to state 133
    NOT_EQUALS      shift and go to state 134

    comparator                     shift and go to state 331

state 318

    (121) for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN . IN ID

    IN              shift and go to state 334


state 319

    (119) for_each_parenthesis_parenthesis_content -> COLON ID .
    (120) for_each_parenthesis_parenthesis_content -> COLON ID . COMMA for_each_parenthesis_parenthesis_content

    RPAREN          reduce using rule 119 (for_each_parenthesis_parenthesis_content -> COLON ID .)
    COMMA           shift and go to state 335


state 320

    (22) data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 336


state 321

    (23) data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 337


state 322

    (106) set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 338


state 323

    (107) set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .

    SEMICOLON       reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    PRINT           reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    STRING          reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    VAR             reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    FINAL           reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    ID              reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    VOID            reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    LIST            reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    INT             reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    MAP             reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    WHILE           reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    BOOL            reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    IF              reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    FOR             reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    $end            reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)
    RBRACKET        reduce using rule 107 (set -> FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON .)


state 324

    (28) function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 28 (function -> type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)


state 325

    (129) function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .
    (54) expression -> expression . PLUS expression
    (55) expression -> expression . MINUS expression
    (56) expression -> expression . TIMES expression
    (57) expression -> expression . DIVIDE expression
    (58) expression -> expression . AND expression
    (59) expression -> expression . OR expression

    SEMICOLON       reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    PRINT           reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    STRING          reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    VAR             reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    FINAL           reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    ID              reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    VOID            reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    LIST            reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    DYNAMIC         reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    INT             reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    DOUBLE          reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    MAP             reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    WHILE           reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    BOOL            reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    IF              reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    FOR             reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    $end            reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    RBRACKET        reduce using rule 129 (function -> type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression .)
    PLUS            shift and go to state 136
    MINUS           shift and go to state 137
    TIMES           shift and go to state 138
    DIVIDE          shift and go to state 139
    AND             shift and go to state 140
    OR              shift and go to state 141


state 326

    (29) function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .

    SEMICOLON       reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 29 (function -> VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET .)


state 327

    (93) list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list . RSBRACKET SEMICOLON
    (95) value_list -> value_list . COMMA value

    RSBRACKET       shift and go to state 339
    COMMA           shift and go to state 219


state 328

    (132) map_declaration -> MAP LESS key_type COMMA type GREATER ID ASSIGN .

    LBRACKET        reduce using rule 132 (map_declaration -> MAP LESS key_type COMMA type GREATER ID ASSIGN .)


state 329

    (69) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET . statement_list RBRACKET
    (2) statement_list -> . statement
    (3) statement_list -> . statement_list statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement_list                 shift and go to state 340
    statement                      shift and go to state 3
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 330

    (68) else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list . RBRACKET
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
<<<<<<< HEAD
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 314
    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
=======
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 341
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement                      shift and go to state 42
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

<<<<<<< HEAD
state 304

    (106) for_classic_changes -> ID comparator . value
    (109) for_classic_changes -> ID comparator . value COMMA for_classic_changes
    (94) value -> . NUMBER
    (95) value -> . NDOUBLE
    (96) value -> . TEXT
    (97) value -> . ID
    (98) value -> . TRUE
    (99) value -> . FALSE

    NUMBER          shift and go to state 97
    NDOUBLE         shift and go to state 81
    TEXT            shift and go to state 95
    ID              shift and go to state 89
    TRUE            shift and go to state 82
    FALSE           shift and go to state 83

    value                          shift and go to state 315

state 305

    (107) for_classic_changes -> ID INCREMENT .

    RPAREN          reduce using rule 107 (for_classic_changes -> ID INCREMENT .)


state 306

    (108) for_classic_changes -> ID DECREMENT .

    RPAREN          reduce using rule 108 (for_classic_changes -> ID DECREMENT .)


state 307

    (116) for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN . ID

    ID              shift and go to state 316


state 308

    (115) for_each_parenthesis_parenthesis_content -> COLON ID COMMA . for_each_parenthesis_parenthesis_content
    (114) for_each_parenthesis_parenthesis_content -> . COLON ID
    (115) for_each_parenthesis_parenthesis_content -> . COLON ID COMMA for_each_parenthesis_parenthesis_content

    COLON           shift and go to state 266

    for_each_parenthesis_parenthesis_content shift and go to state 317

state 309

    (25) data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .

    COMMENT_MULTI   reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 25 (data_input -> STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)


state 310

    (26) data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 318


state 311

    (101) set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .

    COMMENT_MULTI   reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    SEMICOLON       reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    PRINT           reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    STRING          reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    VAR             reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    FINAL           reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    ID              reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    VOID            reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    LIST            reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    MAP             reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    WHILE           reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    INT             reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    BOOL            reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    IF              reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    FOR             reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    $end            reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    RBRACKET        reduce using rule 101 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)


state 312

    (82) list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 319


state 313

    (64) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . COMMENT_MULTI
    (16) statement -> . COMMENT_SINGLE
    (17) statement -> . SEMICOLON
    (40) print -> . PRINT LPAREN RPAREN SEMICOLON
    (41) print -> . PRINT LPAREN print_options RPAREN SEMICOLON
    (25) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (26) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (100) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (101) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (102) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (126) map -> . map_declaration map_assignment
    (123) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (18) control_structures -> . control_structures_if_else
    (19) control_structures -> . control_structures_for
    (20) control_structures -> . control_structures_while
    (31) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (33) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (34) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (35) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (36) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (124) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (82) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (37) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (38) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (39) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (21) variable_usage -> . ID SEMICOLON
    (22) variable_usage -> . ID ASSIGN value SEMICOLON
    (23) call_function -> . ID LPAREN argument_list RPAREN
    (24) call_function -> . ID LPAREN RPAREN
    (127) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (58) control_structures_if_else -> . if_block
    (59) control_structures_if_else -> . if_block else_if_blocks
    (60) control_structures_if_else -> . if_block else_if_blocks else_block
    (61) control_structures_if_else -> . if_block else_block
    (118) control_structures_for -> . for_classic
    (119) control_structures_for -> . for_in
    (120) control_structures_for -> . for_each
    (125) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (89) type -> . INT
    (90) type -> . DOUBLE
    (91) type -> . STRING
    (92) type -> . BOOL
    (93) type -> . LIST
    (62) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (111) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (113) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (117) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 320
    COMMENT_MULTI   shift and go to state 15
    COMMENT_SINGLE  shift and go to state 16
    SEMICOLON       shift and go to state 17
    PRINT           shift and go to state 18
    STRING          shift and go to state 19
    VAR             shift and go to state 21
    FINAL           shift and go to state 22
    ID              shift and go to state 20
    VOID            shift and go to state 28
    LIST            shift and go to state 29
    DYNAMIC         shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    INT             shift and go to state 37
    DOUBLE          shift and go to state 38
    BOOL            shift and go to state 39
    IF              shift and go to state 40
    FOR             shift and go to state 41

    statement                      shift and go to state 42
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 23
    control_structures_if_else     shift and go to state 24
    control_structures_for         shift and go to state 25
    control_structures_while       shift and go to state 26
    type                           shift and go to state 27
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35
=======
state 331

    (111) for_classic_changes -> ID comparator . value
    (114) for_classic_changes -> ID comparator . value COMMA for_classic_changes
    (96) value -> . NUMBER
    (97) value -> . NDOUBLE
    (98) value -> . TEXT
    (99) value -> . ID
    (100) value -> . interpolated_string
    (101) value -> . TRUE
    (102) value -> . FALSE
    (103) interpolated_string -> . TEXT PLUS ID
    (104) interpolated_string -> . TEXT PLUS expression

    NUMBER          shift and go to state 85
    NDOUBLE         shift and go to state 86
    TEXT            shift and go to state 87
    ID              shift and go to state 71
    TRUE            shift and go to state 73
    FALSE           shift and go to state 74

    value                          shift and go to state 342
    interpolated_string            shift and go to state 72
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

state 332

<<<<<<< HEAD
    (63) else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .

    ELSE            reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_MULTI   reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 63 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
=======
    (112) for_classic_changes -> ID INCREMENT .

    RPAREN          reduce using rule 112 (for_classic_changes -> ID INCREMENT .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 333

<<<<<<< HEAD
    (106) for_classic_changes -> ID comparator value .
    (109) for_classic_changes -> ID comparator value . COMMA for_classic_changes

    RPAREN          reduce using rule 106 (for_classic_changes -> ID comparator value .)
    COMMA           shift and go to state 321
=======
    (113) for_classic_changes -> ID DECREMENT .

    RPAREN          reduce using rule 113 (for_classic_changes -> ID DECREMENT .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 334

<<<<<<< HEAD
    (116) for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID .

    RPAREN          reduce using rule 116 (for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID .)
=======
    (121) for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN . ID

    ID              shift and go to state 343
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 335

<<<<<<< HEAD
    (115) for_each_parenthesis_parenthesis_content -> COLON ID COMMA for_each_parenthesis_parenthesis_content .

    RPAREN          reduce using rule 115 (for_each_parenthesis_parenthesis_content -> COLON ID COMMA for_each_parenthesis_parenthesis_content .)

=======
    (120) for_each_parenthesis_parenthesis_content -> COLON ID COMMA . for_each_parenthesis_parenthesis_content
    (119) for_each_parenthesis_parenthesis_content -> . COLON ID
    (120) for_each_parenthesis_parenthesis_content -> . COLON ID COMMA for_each_parenthesis_parenthesis_content

    COLON           shift and go to state 292

    for_each_parenthesis_parenthesis_content shift and go to state 344
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

state 336

    (26) data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .

    COMMENT_MULTI   reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 26 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)


state 337

    (82) list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .

<<<<<<< HEAD
    COMMENT_MULTI   reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    COMMENT_SINGLE  reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    SEMICOLON       reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    PRINT           reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    STRING          reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    VAR             reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    FINAL           reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    ID              reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    VOID            reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    LIST            reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    MAP             reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    WHILE           reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    INT             reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    BOOL            reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    IF              reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    FOR             reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    $end            reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    RBRACKET        reduce using rule 82 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
=======
    SEMICOLON       shift and go to state 345
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 338

<<<<<<< HEAD
    (64) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .

    ELSE            reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_MULTI   reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    COMMENT_SINGLE  reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 64 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
=======
    (106) set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .

    SEMICOLON       reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    PRINT           reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    STRING          reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    VAR             reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    FINAL           reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    ID              reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    VOID            reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    LIST            reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    INT             reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    MAP             reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    WHILE           reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    BOOL            reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    IF              reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    FOR             reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    $end            reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
    RBRACKET        reduce using rule 106 (set -> VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4


state 339

<<<<<<< HEAD
    (109) for_classic_changes -> ID comparator value COMMA . for_classic_changes
    (106) for_classic_changes -> . ID comparator value
    (107) for_classic_changes -> . ID INCREMENT
    (108) for_classic_changes -> . ID DECREMENT
    (109) for_classic_changes -> . ID comparator value COMMA for_classic_changes

    ID              shift and go to state 290
=======
    (93) list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 346
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

    for_classic_changes            shift and go to state 322

state 340

<<<<<<< HEAD
    (109) for_classic_changes -> ID comparator value COMMA for_classic_changes .

    RPAREN          reduce using rule 109 (for_classic_changes -> ID comparator value COMMA for_classic_changes .)
=======
    (69) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list . RBRACKET
    (3) statement_list -> statement_list . statement
    (4) statement -> . print
    (5) statement -> . data_input
    (6) statement -> . set
    (7) statement -> . map
    (8) statement -> . constructor
    (9) statement -> . control_structures
    (10) statement -> . function
    (11) statement -> . list_definition
    (12) statement -> . variable_definition
    (13) statement -> . variable_usage
    (14) statement -> . call_function
    (15) statement -> . SEMICOLON
    (41) print -> . PRINT LPAREN RPAREN SEMICOLON
    (42) print -> . PRINT LPAREN simple_operations_arithmetics RPAREN SEMICOLON
    (43) print -> . PRINT LPAREN value RPAREN SEMICOLON
    (44) print -> . PRINT LPAREN expression RPAREN SEMICOLON
    (45) print -> . PRINT LPAREN length RPAREN SEMICOLON
    (22) data_input -> . STRING ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (23) data_input -> . STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON
    (105) set -> . VAR ID ASSIGN LBRACKET value_list RBRACKET SEMICOLON
    (106) set -> . VAR ID ASSIGN LESS STRING GREATER LBRACKET RBRACKET SEMICOLON
    (107) set -> . FINAL ID ASSIGN CONST LBRACKET value_list RBRACKET SEMICOLON
    (131) map -> . map_declaration map_assignment
    (128) constructor -> . ID LPAREN constructor_parenthesis_content RPAREN SEMICOLON
    (16) control_structures -> . control_structures_if_else
    (17) control_structures -> . control_structures_for
    (18) control_structures -> . control_structures_while
    (28) function -> . type ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (29) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET statement_list RBRACKET
    (30) function -> . type ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (31) function -> . VOID ID LPAREN RPAREN LBRACKET statement_list RBRACKET
    (32) function -> . VOID ID LPAREN RPAREN LBRACKET RBRACKET
    (33) function -> . VOID ID LPAREN parameter_list RPAREN LBRACKET RBRACKET
    (129) function -> . type ID LPAREN parameter_list RPAREN ASSIGN GREATER expression
    (93) list_definition -> . LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON
    (34) variable_definition -> . type ID ASSIGN expression SEMICOLON
    (35) variable_definition -> . DYNAMIC ID ASSIGN expression SEMICOLON
    (36) variable_definition -> . VAR ID ASSIGN expression SEMICOLON
    (37) variable_definition -> . INT ID ASSIGN length SEMICOLON
    (38) variable_definition -> . INT ID ASSIGN NUMBER SEMICOLON
    (39) variable_definition -> . DOUBLE ID ASSIGN NDOUBLE SEMICOLON
    (40) variable_definition -> . DOUBLE ID ASSIGN simple_operations_arithmetics SEMICOLON
    (19) variable_usage -> . ID
    (20) call_function -> . ID LPAREN argument_list RPAREN
    (21) call_function -> . ID LPAREN RPAREN
    (132) map_declaration -> . MAP LESS key_type COMMA type GREATER ID ASSIGN
    (63) control_structures_if_else -> . if_block
    (64) control_structures_if_else -> . if_block else_if_blocks
    (65) control_structures_if_else -> . if_block else_if_blocks else_block
    (66) control_structures_if_else -> . if_block else_block
    (123) control_structures_for -> . for_classic
    (124) control_structures_for -> . for_in
    (125) control_structures_for -> . for_each
    (130) control_structures_while -> . WHILE LPAREN conditions LBRACKET statement_list RBRACKET
    (87) type -> . INT
    (88) type -> . DOUBLE
    (89) type -> . STRING
    (90) type -> . BOOL
    (91) type -> . LIST
    (67) if_block -> . IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET
    (116) for_classic -> . FOR LPAREN for_classic_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (118) for_in -> . FOR LPAREN for_in_parenthesis_content RPAREN LBRACKET statement_list RBRACKET
    (122) for_each -> . FOR LPAREN for_each_parenthesis_content RPAREN LBRACKET statement_list RBRACKET

    RBRACKET        shift and go to state 347
    SEMICOLON       shift and go to state 15
    PRINT           shift and go to state 16
    STRING          shift and go to state 17
    VAR             shift and go to state 19
    FINAL           shift and go to state 20
    ID              shift and go to state 18
    VOID            shift and go to state 26
    LIST            shift and go to state 27
    DYNAMIC         shift and go to state 28
    INT             shift and go to state 29
    DOUBLE          shift and go to state 30
    MAP             shift and go to state 31
    WHILE           shift and go to state 36
    BOOL            shift and go to state 37
    IF              shift and go to state 38
    FOR             shift and go to state 39

    statement                      shift and go to state 40
    print                          shift and go to state 4
    data_input                     shift and go to state 5
    set                            shift and go to state 6
    map                            shift and go to state 7
    constructor                    shift and go to state 8
    control_structures             shift and go to state 9
    function                       shift and go to state 10
    list_definition                shift and go to state 11
    variable_definition            shift and go to state 12
    variable_usage                 shift and go to state 13
    call_function                  shift and go to state 14
    map_declaration                shift and go to state 21
    control_structures_if_else     shift and go to state 22
    control_structures_for         shift and go to state 23
    control_structures_while       shift and go to state 24
    type                           shift and go to state 25
    if_block                       shift and go to state 32
    for_classic                    shift and go to state 33
    for_in                         shift and go to state 34
    for_each                       shift and go to state 35

state 341

    (68) else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .

    ELSE            reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 68 (else_if_blocks -> ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)


state 342

    (111) for_classic_changes -> ID comparator value .
    (114) for_classic_changes -> ID comparator value . COMMA for_classic_changes

    RPAREN          reduce using rule 111 (for_classic_changes -> ID comparator value .)
    COMMA           shift and go to state 348


state 343

    (121) for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID .

    RPAREN          reduce using rule 121 (for_each_parenthesis_content -> FINAL ID LPAREN for_each_parenthesis_parenthesis_content RPAREN IN ID .)


state 344

    (120) for_each_parenthesis_parenthesis_content -> COLON ID COMMA for_each_parenthesis_parenthesis_content .

    RPAREN          reduce using rule 120 (for_each_parenthesis_parenthesis_content -> COLON ID COMMA for_each_parenthesis_parenthesis_content .)


state 345

    (23) data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .

    SEMICOLON       reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    PRINT           reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    STRING          reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VAR             reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FINAL           reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    VOID            reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    LIST            reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DYNAMIC         reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    MAP             reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    $end            reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)
    RBRACKET        reduce using rule 23 (data_input -> STRING QUESTION ID ASSIGN STDIN DOT READLINESYNC LPAREN RPAREN SEMICOLON .)


state 346

    (93) list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .

    SEMICOLON       reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    PRINT           reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    STRING          reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    VAR             reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    FINAL           reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    ID              reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    VOID            reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    LIST            reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    DYNAMIC         reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    INT             reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    MAP             reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    WHILE           reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    BOOL            reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    IF              reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    FOR             reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    $end            reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)
    RBRACKET        reduce using rule 93 (list_definition -> LIST LESS type GREATER ID ASSIGN LSBRACKET value_list RSBRACKET SEMICOLON .)


state 347

    (69) else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .

    ELSE            reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    SEMICOLON       reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    PRINT           reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    STRING          reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VAR             reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FINAL           reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    ID              reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    VOID            reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    LIST            reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DYNAMIC         reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    INT             reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    DOUBLE          reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    MAP             reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    WHILE           reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    BOOL            reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    IF              reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    FOR             reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    $end            reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)
    RBRACKET        reduce using rule 69 (else_if_blocks -> else_if_blocks ELSE IF LPAREN conditions RPAREN LBRACKET statement_list RBRACKET .)


state 348

    (114) for_classic_changes -> ID comparator value COMMA . for_classic_changes
    (111) for_classic_changes -> . ID comparator value
    (112) for_classic_changes -> . ID INCREMENT
    (113) for_classic_changes -> . ID DECREMENT
    (114) for_classic_changes -> . ID comparator value COMMA for_classic_changes

    ID              shift and go to state 317

    for_classic_changes            shift and go to state 349

state 349

    (114) for_classic_changes -> ID comparator value COMMA for_classic_changes .

    RPAREN          reduce using rule 114 (for_classic_changes -> ID comparator value COMMA for_classic_changes .)
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4

WARNING: 
WARNING: Conflicts:
WARNING: 
<<<<<<< HEAD
WARNING: shift/reduce conflict for ID in state 19 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 75 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 77 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 192 resolved as shift
WARNING: reduce/reduce conflict in state 75 resolved using rule (string_part -> TEXT)
WARNING: rejected rule (value -> TEXT) in state 75
=======
WARNING: shift/reduce conflict for ID in state 17 resolved as shift
WARNING: shift/reduce conflict for ID in state 29 resolved as shift
WARNING: shift/reduce conflict for ID in state 30 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 64 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 64 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 70 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 84 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 84 resolved as shift
WARNING: shift/reduce conflict for LESS in state 84 resolved as shift
WARNING: shift/reduce conflict for EQUALS in state 84 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 84 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 84 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUALS in state 84 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 87 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 205 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 205 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 205 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 205 resolved as shift
WARNING: shift/reduce conflict for AND in state 205 resolved as shift
WARNING: shift/reduce conflict for OR in state 205 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 206 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 206 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 206 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 206 resolved as shift
WARNING: shift/reduce conflict for AND in state 206 resolved as shift
WARNING: shift/reduce conflict for OR in state 206 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 207 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 207 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 207 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 207 resolved as shift
WARNING: shift/reduce conflict for AND in state 207 resolved as shift
WARNING: shift/reduce conflict for OR in state 207 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 208 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 208 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 208 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 208 resolved as shift
WARNING: shift/reduce conflict for AND in state 208 resolved as shift
WARNING: shift/reduce conflict for OR in state 208 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 209 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 209 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 209 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 209 resolved as shift
WARNING: shift/reduce conflict for AND in state 209 resolved as shift
WARNING: shift/reduce conflict for OR in state 209 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 210 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 210 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 210 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 210 resolved as shift
WARNING: shift/reduce conflict for AND in state 210 resolved as shift
WARNING: shift/reduce conflict for OR in state 210 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 216 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 216 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 216 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 216 resolved as shift
WARNING: shift/reduce conflict for AND in state 216 resolved as shift
WARNING: shift/reduce conflict for OR in state 216 resolved as shift
WARNING: shift/reduce conflict for AND in state 251 resolved as shift
WARNING: shift/reduce conflict for OR in state 251 resolved as shift
WARNING: shift/reduce conflict for AND in state 252 resolved as shift
WARNING: shift/reduce conflict for OR in state 252 resolved as shift
WARNING: reduce/reduce conflict in state 68 resolved using rule (list_numbers -> NUMBER)
WARNING: rejected rule (value -> NUMBER) in state 68
WARNING: reduce/reduce conflict in state 69 resolved using rule (list_numbers -> NDOUBLE)
WARNING: rejected rule (value -> NDOUBLE) in state 69
WARNING: reduce/reduce conflict in state 215 resolved using rule (value -> ID)
WARNING: rejected rule (interpolated_string -> TEXT PLUS ID) in state 215
WARNING: Rule (interpolated_string -> TEXT PLUS ID) is never reduced
>>>>>>> cc52cebfdfb907e9d2c6b54c5deab0fbe854f1c4
